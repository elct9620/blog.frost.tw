<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>弦而時習之</title>
    <link>https://blog.frost.tw/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    
    <description>蒼時弦也的個人網誌，專注在前端、後端以及遊戲開發，大多使用 Ruby 和 Ruby on Rails 以及 Golang、JS 和 C 語言。</description>
    <pubDate>Tue, 09 Oct 2018 13:32:27 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>客製化你樹莓派上運行的 Linux</title>
      <link>https://blog.frost.tw/posts/2018/10/09/Customize-a-linux-for-your-raspberrypi/</link>
      <guid>https://blog.frost.tw/posts/2018/10/09/Customize-a-linux-for-your-raspberrypi/</guid>
      <pubDate>Tue, 09 Oct 2018 13:29:53 GMT</pubDate>
      <description>
      
        &lt;p&gt;最近因為手邊有一個工作以外的專案需要搭配硬體做一些 IoT 類型的應用，雖然之前在五倍紅寶石開發的 Tamashii 系列應用已經足以應對在這個專案上開發所需的解決方案，但是依舊缺少了一些功能。&lt;/p&gt;
&lt;p&gt;也就是我們過去並沒有考慮到的，如果裝置是交給一般使用者的狀況下，如何在透過網路的前提將裝置更新。&lt;/p&gt;
&lt;p&gt;這是很多硬體都會有的功能，但是就目前而言 Tamashii 並不支援。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>最近因為手邊有一個工作以外的專案需要搭配硬體做一些 IoT 類型的應用，雖然之前在五倍紅寶石開發的 Tamashii 系列應用已經足以應對在這個專案上開發所需的解決方案，但是依舊缺少了一些功能。</p><p>也就是我們過去並沒有考慮到的，如果裝置是交給一般使用者的狀況下，如何在透過網路的前提將裝置更新。</p><p>這是很多硬體都會有的功能，但是就目前而言 Tamashii 並不支援。</p><a id="more"></a><p>經過幾天的調查，發現有一個 Open Source 的專案似乎符合條件。</p><h1 id="Mender-的-OTA-伺服器"><a href="#Mender-的-OTA-伺服器" class="headerlink" title="Mender 的 OTA 伺服器"></a>Mender 的 OTA 伺服器</h1><p>這個開源專案叫做 <a href="https://mender.io/" target="_blank" rel="noopener">Mender</a> 是透過好幾種程式語言組合而成，功能也很簡單。在預先製作好的 Linux 發行版本中寫入 Mender 伺服器的位置，只要在伺服器上「認證」這一台裝置，未來就能夠收到來自 Mender 伺服器所提供的更新。</p><p>而更新的方式基本上就是製作一份新的 Rootfs 提供給硬體裝置下載，並且嘗試將這個新的版本加入到現有硬體中，並且嘗試是否能夠正常的運行，如果失敗的話再將舊版的 Rootfs 載入。</p><p>也因此，要能夠使用 Mender 來發布 OTA (Over the Air）更新的話，就必須要能夠製作自己的 Linux 發行版本才可以。</p><h1 id="Yocto-專案"><a href="#Yocto-專案" class="headerlink" title="Yocto 專案"></a>Yocto 專案</h1><p>想要讓所有人都知道怎麼自己編譯完整的 Linux 作業系統是很困難的，從韌體、核心（Kernel）到各種開機所需要的套件庫（Library）等等，光是編譯的步驟就非常繁複，更何況還要配合使用不同開發版或者晶片的使用者。</p><p>所以 Mender 也採許了另一套開放原始碼的解決方案，叫做 Yocto 專案。這個專案跟另一個開源專案 OpenEmbedded 已經整合在一起，或者說能夠互通使用。</p><p>在 Yocto 之中，我們透過所謂的 Layer 的疊加就能夠製作出我們所需的 Linux 系統，而有很多硬體上所需要配合的韌體，也大多會有社群貢獻，因此在大部分的情況下都不太需要擔心。</p><blockquote><p>Mender 團隊也提供付費協助處理硬體整合上的問題，也許這是主要的收入之一？</p></blockquote><p>舉例來說，我想要製作一個能在 RaspberryPi 上面執行的 Linux 環境，就需要叫做 <code>meta-respberrypi</code> 這一個 Layer 來幫助我。</p><p>他會依賴於 <code>oe-core</code> 和幾個相關的 Layer 才能夠正確編譯（因為已經有的設定不用重複撰寫）</p><p>當我加入 <code>meta-raspberry</code> 之後，我在選擇編譯的機器類型時，就能夠用像是 <code>MACHINE=raspberrypi3</code> 這樣的模式告知我希望得到能在 Raspberry Pi 3 上執行的 Linux。</p><p>最棒的是，當我們完成這個動作之後，生成的 Linux 鏡像檔案燒入到 SD 卡中就能夠正常運行。</p><blockquote><p>以前嘗試過使用 Buildroot 來製作，但是失敗率非常高。</p></blockquote><p>簡單來說 Yocto 就是一堆社群貢獻預先撰寫好的建置腳本，因此我們只需要專注在自己需要預先加入這個 Linux 環境的部分，像是 Tamashii 或者 Ruby 的運行環境。</p><h1 id="初次嘗試"><a href="#初次嘗試" class="headerlink" title="初次嘗試"></a>初次嘗試</h1><p>首先，我們需要可以運行的環境。這篇文章使用的是 CentOS 7 來進行示範，所需的相關套件可以參考 <a href="http://sunyongfeng.com/201610/programmer/yocto/Bitbake_practical_guide.html" target="_blank" rel="noopener">Yocto 官方文件</a>來配置，另外要注意的是目前較新版本是需要有 Python 3 的環境，但是 CentOS 7 還是使用 Python 2 需要自己配置。</p><h2 id="下載-Poky"><a href="#下載-Poky" class="headerlink" title="下載 Poky"></a>下載 Poky</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b sumo git://git.yoctoproject.org/poky</span><br></pre></td></tr></table></figure><p>Poky 類似於一個基礎的樣板，裡面將生成 Yocto 版本的 Linux 必要的相關檔案都放在裡面，我們可以基於這個資料夾來進行後續的設定跟配置。</p><blockquote><p>Yocto 每個版本都會有代號，目前最新的穩定版是 Sumo (2.5) 版</p></blockquote><h2 id="加入-Mender"><a href="#加入-Mender" class="headerlink" title="加入 Mender"></a>加入 Mender</h2><p>這篇文章會以 Mender 作為例子，這樣在成品階段的時候也比較好用 Mender 來體驗。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd poky</span><br><span class="line">git clone -b sumo git://github.com/mendersoftware/meta-mender</span><br></pre></td></tr></table></figure><p>如此一來，我們就可以在後續的階段使用由 Mender 所製作的 Layer 來提供 OTA 的功能。<br>不過在此之前，因為我們希望製作的是 Raspberry Pi 版本的 Linux 發行版本，所以還需要先把 Raspberry Pi 對應的 Layer 加入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone -b sumo git://git.yoctoproject.org/meta-raspberrypi</span><br><span class="line">git clone -b sumo git://git.openembedded.org/meta-openembedded</span><br></pre></td></tr></table></figure><h2 id="配置-Layer"><a href="#配置-Layer" class="headerlink" title="配置 Layer"></a>配置 Layer</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source oe-init-build-env</span><br></pre></td></tr></table></figure><p>因為 Yocto 已經提供好了各種設置，所以我們只需要透過上面的指令就能切換到對應的建置環境中。</p><blockquote><p>預設會產生一個 <code>build</code> 目錄，如果想要其他目錄的話也可以在後面指定。</p></blockquote><p>然後我們要告訴 Yocto 想要使用哪些 Layer 才能夠正常運作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bitbake-layers add-layer ../meta-mender/meta-mender-core</span><br><span class="line">bitbake-layers add-layer ../meta-openembedded/meta-oe</span><br><span class="line">bitbake-layers add-layer ../meta-raspberrypi</span><br><span class="line">bitbake-layers add-layer ../meta-mender/meta-mender-raspberrypi</span><br></pre></td></tr></table></figure><p>加入上述的 Layer 後，我們就可以產生一個能在 Raspberry Pi 上運行，以及透過 Mender 來做 OTA 更新的 Linux 發行版本。</p><p>不過礙於篇幅的關係，這次我們直接使用 Mender 提供的 Demo Layer 來加入客製化的內容。</p><blockquote><p>如果想加入自己編譯的程式、服務等等，是需要自己建立一個 Layer 來加入的，這樣也能對原有的 Layer 做擴充或者增加設定。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bitbake-layers add-layer ../meta-mender/meta-mender-demo</span><br><span class="line">bitbake-layers add-layer ../meta-mender/meta-mender-raspberrypi</span><br></pre></td></tr></table></figure><p>接下來，我們要對 <code>conf/local.conf</code> 進行設定，把伺服器位置等等設定值都加入到產生的 Linux 發行版本中，才能夠連接到正確的 Mender 伺服器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 釋出的版本，需要不同才能被辨識出來</span><br><span class="line">MENDER_ARTIFACT_NAME = &quot;release-1&quot;</span><br><span class="line"></span><br><span class="line">INHERIT += &quot;mender-full&quot;</span><br><span class="line"></span><br><span class="line"># 指定為 Raspberry Pi 3 是預設的目標</span><br><span class="line">MACHINE ?= &quot;raspberrypi3&quot;</span><br><span class="line"></span><br><span class="line"># 針對 Raspberry Pi 的額外設定</span><br><span class="line">RPI_USE_U_BOOT = &quot;1&quot;</span><br><span class="line">MENDER_PARTITION_ALIGNMENT = &quot;4194304&quot;</span><br><span class="line">MENDER_BOOT_PART_SIZE_MB = &quot;40&quot;</span><br><span class="line">IMAGE_INSTALL_append = &quot; kernel-image kernel-devicetree&quot;</span><br><span class="line">IMAGE_FSTYPES_remove += &quot; rpi-sdimg&quot;</span><br><span class="line"></span><br><span class="line"># 你的 Mender OTA 更新伺服器</span><br><span class="line">MENDER_SERVER_URL = &quot;https://ota.tamashii.io&quot;</span><br><span class="line"></span><br><span class="line">DISTRO_FEATURES_append = &quot; systemd&quot;</span><br><span class="line">VIRTUAL-RUNTIME_init_manager = &quot;systemd&quot;</span><br><span class="line">DISTRO_FEATURES_BACKFILL_CONSIDERED = &quot;sysvinit&quot;</span><br><span class="line">VIRTUAL-RUNTIME_initscripts = &quot;&quot;</span><br><span class="line"></span><br><span class="line">ARTIFACTIMG_FSTYPE = &quot;ext4&quot;</span><br><span class="line"></span><br><span class="line"># Raspberry Pi WiFi 設定（Demo 才有開啟 WiFi 功能）</span><br><span class="line">MENDER_DEMO_WIFI_SSID ?= &quot;ssid&quot;</span><br><span class="line">MENDER_DEMO_WIFI_PASSKEY ?= &quot;password&quot;</span><br></pre></td></tr></table></figure><h2 id="建置"><a href="#建置" class="headerlink" title="建置"></a>建置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitbake core-image-full-cmdline</span><br></pre></td></tr></table></figure><p>執行這個指令後，大概會要花上數小時才會完成，這段時間可以睡覺或打個遊戲。</p><blockquote><p>開發階段我會推薦使用 <code>full-cmdline</code> 的版本，因為可以直接 SSH 到機器或者接上鍵盤除錯。</p></blockquote><p>確認跑起來都沒問題之後，就可以改為使用 <code>core-image-minimal</code> 製作出刪減掉除了開啟 Linux 以及自己加入的額外功能之外，所有不必要的檔案來盡可能的縮小檔案大小。</p><h1 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h1><p>到這篇文章完成建置的段落，其實從頭到尾只花上數小時。不過目前還在測試如何讓有 C Extension 的 Ruby Gem 可以正常的被 Cross Compile 並且放進自訂的發行版本。</p><p>如果只是想單純的啟用 Ruby 的功能，直接在 <code>conf/local.conf</code> 裡面加上這行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_INSTALL_append = &quot;ruby &quot;</span><br></pre></td></tr></table></figure><p>在自訂的發行版本就可以使用 ruby 指令（目前預設是 2.5.0 版）</p><h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>這篇文章其實只是很粗略的將 Yocto 可以做的事情介紹出來，實際上深入了解 <code>bitbake</code> 這套工具以及 Layer 機制後，就會發現還有很多東西可以做。</p><p>舉例來說能透過 <code>.bbclass</code> 定義一個範本（Ex. <code>rubygem.bbclass</code>）讓其他套件（<code>Package</code>）繼承使用，而除了 Layer 之外，底下還有細分了食譜（<code>Receipe</code>）和套件（<code>Package</code>）可以做很多變的調整。</p><p>或者透過 <code>.bbappend</code> 來對原本的套件修訂，像是目前正在製作的 Tamashii Linux 就是利用這種方法讓 Ruby Gem 的 Cross Compile 得以實現。</p><p>如果之後已經有成熟的 Tamashii Linux 案例，會在分享該如何在 Yocto 上面客製化以 Ruby 為基底的 IoT 裝置嵌入是系統。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/10/09/Customize-a-linux-for-your-raspberrypi/#disqus_thread</comments>
    </item>
    
    <item>
      <title>轉職工程師：要學什麼才好？</title>
      <link>https://blog.frost.tw/posts/2018/10/02/Become-a-programmer-how-to-start/</link>
      <guid>https://blog.frost.tw/posts/2018/10/02/Become-a-programmer-how-to-start/</guid>
      <pubDate>Tue, 02 Oct 2018 15:26:53 GMT</pubDate>
      <description>
      
        &lt;p&gt;上一篇文章&lt;a href=&quot;https://blog.frost.tw/posts/2018/09/25/Become-a-programmer-lose-at-the-starting-line/&quot;&gt;輸在起跑點&lt;/a&gt;已經稍微討論過心態上的問題，所以馬上就是要怎麼開始的問題。&lt;/p&gt;
&lt;p&gt;大部分的人不論之前有沒有經驗，一定會冒出「要學什麼語言？」「某某語言很熱門是不是應該去學？」之類的問題。&lt;/p&gt;
&lt;p&gt;很多時候，我認為這不是真正的問題。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>上一篇文章<a href="https://blog.frost.tw/posts/2018/09/25/Become-a-programmer-lose-at-the-starting-line/">輸在起跑點</a>已經稍微討論過心態上的問題，所以馬上就是要怎麼開始的問題。</p><p>大部分的人不論之前有沒有經驗，一定會冒出「要學什麼語言？」「某某語言很熱門是不是應該去學？」之類的問題。</p><p>很多時候，我認為這不是真正的問題。</p><a id="more"></a><h2 id="要快又要好"><a href="#要快又要好" class="headerlink" title="要快又要好"></a>要快又要好</h2><p>現在很多電腦補習班、或是一些線上課程的廣告，其實會誤導大家「三個月轉職」這種聽起來從學會寫程式到當工程是是一件很容易的事情。</p><p>認真想想，這種類型的課程到底教會了什麼？如果其他類型的工作都沒辦法這麼輕鬆，那麼為什麼寫程式就可以呢？</p><p>如果是以找工作為目的，程式相關的技能雖然重要，但是很明顯的搞錯了重點。</p><p><strong>有優秀的能力雖然很重要，但是有沒有潛力也會是另一個基準</strong></p><p>以我自身的經驗，寫程式的「入門門檻」確實很低，除非你連打字都不會。<br>但是作為一個工程師，從「入門」到「有實戰能力」到「獨當一面」就不是這麼簡單的問題。</p><p>所以要先面對現實，看你想要的是「學得快」還是「學的好」兩者幾乎無法並存</p><h2 id="寫程式的朋友"><a href="#寫程式的朋友" class="headerlink" title="寫程式的朋友"></a>寫程式的朋友</h2><p>如果不知道該學什麼，其實很簡單。如果你有一個會寫程式的朋友，學跟他一樣的。</p><p><strong>出問題有人問</strong></p><p>這是最效率的學法，飆車太快朋友會阻止你。進度太慢朋友會幫你！替代方案就是去上課，好的老師會負責擔任前面提到的朋友的任務。</p><p>如果剛出社會，以電腦補習班的學費來說覺得是一個負擔。那就選一個最近的社群活動參加吧！雖然對台北地區的人比較方便（其他縣市比較難找）但是你馬上就能找到適合的人幫助你。</p><p><strong>沒有朋友就找一個！</strong></p><p>也許你會覺得自己害羞內向不好相處，不過我想很多人都覺得自己是這樣，但是稍微試著聊天也許會發意外的合得來。</p><blockquote><p>我平常也都蠻怕跟陌生人聊天的，但是參加社群聚會總是會有人拉你去聊天，那就可以慢慢展開話題了！</p></blockquote><p>如果身邊沒有會寫程式的朋友，又對 Ruby 或者前端、React Native 之類的有興趣，可以來<a href="https://www.facebook.com/rubymokumokukai/" target="_blank" rel="noopener">默默會</a>看看，現在的狀況是一片混亂，但是想要找人問問題的話我想我們大多都有辦法跟你聊（太專業就是我們跟你學習摟！）</p><blockquote><p>不知道要找誰也可以說要來找我，不過目前我會花大概一小時教人之後才出來，有時候可能要等我一下。</p></blockquote><h2 id="補習班"><a href="#補習班" class="headerlink" title="補習班"></a>補習班</h2><p>當你決定要選擇補習班的時候，就要有心理準備。補習班基本上就是一個以「快」為目的的地方，所以上課基本上會以最有效率的方式來做教學。</p><p>在這種情況下，基礎就不一定會好。但是「學得快」這件事情本身不是一個問題，不如說我反而很推薦想要學新東西或者第一次入門的人用這種方法。</p><p><strong>如果開發新產品是每個人很有經驗的，那他一點也不新，而且可能也不賺錢</strong></p><p>如果你有一個想法想要實現，或者想要找到一份工作。這個方法是很有效的，因為你有能力「製作」一小部分的部件，這就足夠了。</p><p>就像打遊戲一樣，有人會在意<strong>第一次就玩得很好</strong>這件事情嗎？並不會，所以有些人會透過「熟練」和「分析」去讓自己更熟悉這個遊戲。</p><p>以大多數課程都是一個月到三個月左右，其實也就 32 ~ 96 個小時來看，一款遊戲破完第一輪獎盃一半都拿不到，這樣你會覺得學寫程式有這麼容易嗎？玩遊戲都沒這麼容易了！</p><p>不過選擇補習班跟打遊戲比起來，還是有好處的。那就是老師，像是我目前的公司<a href="https://5xruby.tw/" target="_blank" rel="noopener">五倍紅寶石</a>或是<a href="https://www.hexschool.com/" target="_blank" rel="noopener">六角學院</a>和 <a href="https://skilltree.my/" target="_blank" rel="noopener">SkillTree</a> 等等，應該都屬於我知道裡面風評不錯的的幾間補習班。</p><p>不過比起這些，其實我還是比較推薦去跟「上課的老師」在一些社群活動中接觸看看，才知道適不適合。</p><p>像是在五倍<a href="https://kaochenlong.com/" target="_blank" rel="noopener">龍哥</a>、<a href="https://kuro.tw/" target="_blank" rel="noopener">Kuro</a>、<a href="http://csscoke.com/" target="_blank" rel="noopener">Amos</a> 幾位講師有時候在公司就能碰到，我也有上過課都是不錯的。另外六角的話像是廖洧杰也是在前端社群很活躍的大大，另外 SkillTree 給我印象深刻的則是 <a href="https://dotblogs.com.tw/hatelove" target="_blank" rel="noopener">91 哥</a>的敏捷開發課程（雖然我聽的是研討會版本，但是收穫很多）</p><p>我會推薦去找講師交流看看，是因為即使像我「很熟悉寫程式」也不代表可以「好好教人」以擔任 Rails Girls 三次教練我的經驗，我到第三次才比較能好好引導學員，而且定的目標（作業）太不合理之類的，也會引響被教學者最後在學習上的態度。</p><p>所以也許你適合寫程式，但不一定適合「教別人學寫程式」如果能跟講師交流過，其實你很快就會知道講師適不適合教自己。</p><blockquote><p>另外補習班的成功案例看看就好，很多時候去參加課程的不一定會是新手，因為廣告看起來似乎可以學到很厲害的技能，但是實際上對某部分已經有一定基礎的人是過於簡單的，他們在課堂上的作品很容易就被拿來當廣告。至於誇大的程度，就要看各家補習班的做法了⋯⋯</p></blockquote><h2 id="看書"><a href="#看書" class="headerlink" title="看書"></a>看書</h2><p>如果想「學的好」那就無法避免的用看書的方式自學，但是這是一種非常沒有效率的學法。如果你不擅長整理、實驗這類型的技能，我還是推薦選擇直接上線上課程或者補習班，因為看書的資訊密度比課程來高的很多，所以你要會整理。</p><p>而且一個「書」的市場影響可以獲取的資源，入門通常會選擇熟悉的語言（像是中文）來讀，但是中文書技術類的市場不大，所以其實會慢慢發現「重複性高」跟「無法深入」所以自學就會遇到門檻。</p><p>這是因為這種初階入門書是大多數人比較會買的類型，太困難或者太複雜就會變成即使出書了也很難賣掉。</p><p>但是從這一大堆知識中磨練出來的歸納整理和實驗的技巧，就會變成非常扎實的技能。</p><p><strong>學程式的精髓不在學會那個語言，而是了解使用的方式</strong></p><p>舉個例子，我以前自學在看這些書的時候。我通常「不會照著書做」我會邊參考邊改出「我認為適合」的功能，然後執行看看。</p><p>如果成功了，就表示我的理解沒有問題，也學會了變化的應用。如果失敗了，就慢慢調整到接近書上的狀況，然後看看錯的地方是哪裡。</p><p>這種技巧其實某方面來說也叫做 DEBUG 常用的方式之一，至少在自學上我錯的次數應該是遠高於平均值，所以我找 BUG 的速度可能也相對快了一些吧 XD</p><blockquote><p>不過不是第一次學就要這樣做，剛開始學的時候還是先完全模仿一次之後再來改看看，加深印象跟嘗試理解。</p></blockquote><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>好像差點把後面要分段講的東西講掉一些了，不過這篇主要想跟大家說明幾個概念。</p><ol><li>學什麼比較好其實不重要，重要的是起步的時候要有人可以幫你</li><li>想要很快學好是不可能的，但是基礎是可以慢慢補回來的（下一篇會討論）</li><li>學的方法有很多種，要看適不適合自己</li><li>要記得慎選老師，有時候名師不一定是適合自己的老師</li><li>學程式其實不是在學程式</li></ol><p>很多人的「學程式的第一步」其實沒有想像中的重要，而重要的其實是在學的過程中學到的「分析」和「統整」的能力。</p><p>所以第一個語言大多不是問題，我也是從 PHP 轉到 Ruby 為主，但其實我也嘗試學過 C / C++ / C# / Golang / Lua / Java / JavaScript / TypeScript 等等（太多不列了⋯⋯）</p><p>但是我敢說我用的「熟練」的大概只有 PHP / Ruby / JavaScript 吧！不過如果要換工作，上述的語言我都有辦法寫，也有把握在一個月內慢慢調整到能夠有足夠的生產力在這個語言上。</p><p>之後也會提到學程式的幾種面向「語法」「特性」「架構」等等，我們其實都以為學會「語法」就好了，但是有考慮過「特性」跟後面的「架構」嗎？特性會限制架構的發展之類的，就會讓我們發現不同案例下總是會有「最適合」的語言，或者「看起來怎樣都很適合」的語言（通常是個坑⋯⋯）</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/10/02/Become-a-programmer-how-to-start/#disqus_thread</comments>
    </item>
    
    <item>
      <title>轉職工程師：輸在起跑點</title>
      <link>https://blog.frost.tw/posts/2018/09/25/Become-a-programmer-lose-at-the-starting-line/</link>
      <guid>https://blog.frost.tw/posts/2018/09/25/Become-a-programmer-lose-at-the-starting-line/</guid>
      <pubDate>Tue, 25 Sep 2018 15:33:23 GMT</pubDate>
      <description>
      
        &lt;p&gt;工作到現在差不多兩年多，因為公司業務的關係偶爾也會跟同事討論在學習當工程師或者寫程式上的經驗。所以打算寫一個系列的文章，跟大家分享一下我從學程式到成為一個工程師的過程，是怎麼樣的。&lt;/p&gt;
&lt;p&gt;這是第一篇，我想用「輸在起跑點」來當開始。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>工作到現在差不多兩年多，因為公司業務的關係偶爾也會跟同事討論在學習當工程師或者寫程式上的經驗。所以打算寫一個系列的文章，跟大家分享一下我從學程式到成為一個工程師的過程，是怎麼樣的。</p><p>這是第一篇，我想用「輸在起跑點」來當開始。</p><a id="more"></a><h2 id="學習總是有兩種人"><a href="#學習總是有兩種人" class="headerlink" title="學習總是有兩種人"></a>學習總是有兩種人</h2><p>不知道什麼時候開始，總會有「不要讓你的孩子輸在起跑點」上之類的言論，從我小學開始，即使是鄉下的小學校也還是會有很多人放學就得到補習班補習。</p><p>然後就這樣比別人先學了英文、比別人多會了樂器等等⋯⋯</p><p>這類人，不是起步比別人早，不然就是家裡有那個資源可以讓他去學才藝或者嘗試各式各樣的東西。以我的家庭經濟狀況，基本上明顯會是屬於「輸在起跑點」上的情況。</p><p>不過，我還有「起步早」這個優勢。我跟很多認識的社群朋友，大多都是在小學就開始接觸這類東西的。所以單純來說，如果要比較有沒有贏在起跑點這個問題上，我想以經驗來說我肯定比很多人經驗豐富很多。</p><p>不過，出社會後才想學程式會輸在起跑點嗎？</p><p><strong>一直進步跟原地踏步是不一樣的，有進步就算是一小步你也是超前的那一類人</strong></p><blockquote><p>我母親是鋼琴老師，所以我小時候是有學鋼琴的。但是我國中之後幾乎不練習（沈迷寫程式），所以我的程度基本上跟初學者差不多，這就是原地踏步。</p></blockquote><h2 id="好的老師決定你進步的速度"><a href="#好的老師決定你進步的速度" class="headerlink" title="好的老師決定你進步的速度"></a>好的老師決定你進步的速度</h2><p>這邊的「老師」不一定是指學校的老師，可能是指導你的人，或者你讀的那本書的作者，也可能是你的朋友。我在<a href="https://blog.frost.tw/posts/2018/09/10/How-to-choose-your-first-job/">怎麼選第一份工作</a>這篇文章有提到公司看待員工的方式，會影響這個員工未來的發展。</p><p>假設你出社會後才第一次學習程式，要怎麼樣才能最快速的進步？這個問題很簡單，就是不要自己埋頭的學，去找「適合」的人教你或者跟他一起學習。</p><p>有好幾種形式，這邊講幾個案例。</p><p>一種是競爭，我國中的時候成績可以進步很大一部分是靠同班幾位比較好的同學。基本上就是互相比分數，因為這種良性的競爭，就會自然地帶動成績的提升。</p><p>當初在入門的時候，有個小我一歲的網友也是這樣，我們會邊打遊戲編寫程式（做攻略網站之類的）然後再互相看對方的作品跟進度。</p><p>另一種是分享，其實也就是我們在教育體系裡面從老師那邊接受知識的形式。我最早是寫 PHP 的，其實大概有五六年都是幾乎很微小的進步（跟當時網路資源不多跟完全自學有關）開了眼界是參加了 <a href="https://2016.phpconf.tw/" target="_blank" rel="noopener">PHPConf</a>  之後，才知道有像是開發框架（Framework）之類的東西，然後才對架構這類有概念，然後才快速的進步起來。</p><p>不過研討會的缺點是為了符合「大多數人」的程度，通常會遇到深入的議題不夠或者太過困難之類的情況。像是 <a href="https://laravelconf.tw/zh-TW" target="_blank" rel="noopener">LaravelConf TW</a> 就一直在嘗試做各種變化來改善這種問題。而 <a href="https://rubyconf.tw/" target="_blank" rel="noopener">RubyConf TW</a> 則因為工程師相對少，而且不多新人選擇進入，議程上普遍就比較有深度（同時也變成門檻）不過即使在日本 <a href="https://rubykaigi.org/" target="_blank" rel="noopener">RubyKaigi</a> 也是有這樣的狀況，但是因為有其他研討會能互補反而比較沒有台灣這種一種語言靠一個研討會支撐上的問題。</p><blockquote><p>這一直是台灣各語言社群的難題，不管是難或簡單都不好挑選。而且為了穩固新手讓他們成場起來，很多時候必須犧牲掉一些深入的題目（所以我後來參加研討會都跑去聊天，如果發現自己開始這樣做，也許是你的實力到了某個水準也說不定）</p></blockquote><h2 id="快速進步的方法"><a href="#快速進步的方法" class="headerlink" title="快速進步的方法"></a>快速進步的方法</h2><p>既然主題是「輸在起跑點」我們總該討論怎麼樣補上這個差距吧？理論上來說應該是沒有辦法，但是現實面來說我個人認為是一種「意志力」上的戰鬥。</p><p>在當兵的時候，我因為大學畢業專題開發遊戲（多媒體設計學系）所以攝取了大量的可樂跟麥當勞（我個人感覺畢業的時候同學全部胖一圈）所以後來跑 3000（公尺） 的體能測驗項目，我幾乎是落後中的落後。</p><p>不過中間經過了一些體能訓練之類的，學到了兩件事情。第一個就是你身體至少要能負擔這個程度的運動，才能在時間內跑完。另外一個就是你要能讓身體可以負擔，就是要在跑到想放棄的時候告訴自己「我還可以」盡可能把自己的極限逼出來。</p><p>其實這是在不管學什麼都通用的道理：</p><ol><li>基礎很重要</li><li>堅持很重要</li></ol><p>從這兩點來看，文章一開始的「我沒有堅持練鋼琴」就是造成我現在程度差的原因（還有不少，大學因為讀多媒體也會畫畫，畢業後就很少動筆了，基礎本身就差還沒有練習，就變成退步很多）</p><p><strong>基礎讓你不容易退步，堅持讓你可以進步</strong></p><p>所以，在衝刺之前我們應該先想想「準備好了嗎？」才知道自己有沒有那個餘裕往前衝刺，尤其是學習跟我們想像的不是什麼曲線，是梯狀的（也就是要度過瓶頸）如果不堅持的話是很容易在突破前一點的地方放棄。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>會以這篇文章作為開始，是因為我認為不管做什麼之前，都要有心理建設。不管建設了多少，只要有一個簡單的概念或是認知，就能很大的改善學習的過程。</p><blockquote><p>我認為自己很愛找藉口，所以常常用比較激烈的方式學東西。像是畢業後還想把電繪技巧練好，但是一直都是用時間不夠當藉口（明明把寫程式時間貢獻出來就可以了 XD）</p></blockquote><p>總之，一個簡單的結論。</p><p>不要管是不是本科系或者什麼有的沒的，只要先問自己「想不想學」「喜不喜歡」「撐不撐得下去」就好了，大多數時候我不鼓勵別人用跟我一樣激烈的方法，大學畢業前我大多是一定程度的把人際關係那些都犧牲掉，然後用來強化程式技能。所以用「我想學」「我喜歡」「我（自己一個人）撐得下去」的方式去進步，也許畢業後我跟很多人比「起步很順利」但不一定對每個人都是好的，你可能會發現「朋友跟不上自己」的孤獨感，比起這樣也許在職場跟朋友一起進步，說不定反而是件好事。</p><p>所以，先確定自己能不能堅持走這條路，在思考適合的走法。</p><blockquote><p>我的方法簡單粗暴，就是我不繞路，遇到障礙我就是一路往前推到障礙不見。他很花時間也很費力，不過我喜歡這種方式。</p></blockquote>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/09/25/Become-a-programmer-lose-at-the-starting-line/#disqus_thread</comments>
    </item>
    
    <item>
      <title>怎麼選第一份工作？</title>
      <link>https://blog.frost.tw/posts/2018/09/10/How-to-choose-your-first-job/</link>
      <guid>https://blog.frost.tw/posts/2018/09/10/How-to-choose-your-first-job/</guid>
      <pubDate>Mon, 10 Sep 2018 01:18:58 GMT</pubDate>
      <description>
      
        &lt;p&gt;從退伍到工作差不多過了兩年，這段時間有不少經驗我想已經足夠跟大家分享。這篇算是一個前導的文章，想來跟大家分享「第一份工作」的重要性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;重點是技能成長那段，討論薪水的地方太長可以跳過喔 XD&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>從退伍到工作差不多過了兩年，這段時間有不少經驗我想已經足夠跟大家分享。這篇算是一個前導的文章，想來跟大家分享「第一份工作」的重要性。</p><blockquote><p>重點是技能成長那段，討論薪水的地方太長可以跳過喔 XD</p></blockquote><a id="more"></a><p>先不管工作的類型，或者自身的能力這些問題。已在台北工作來說，對一個外縣市的人搬到台北工作跟居住，最先要考慮的是有 30K 以上的薪資。</p><blockquote><p>我想這應該還不算難達成的目標，而這個是在台北生活的基本。</p></blockquote><h2 id="生活成本"><a href="#生活成本" class="headerlink" title="生活成本"></a>生活成本</h2><p>我搬到台北選擇房子的基準其實蠻簡單的，就是「舒適」要滿足。不要認為說可以居住就好，假設你會失眠，而且住的地方隔音很差，每天都會有不同的聲音來影響你休息。</p><p>這樣問題就顯而易見了，假設一天工作八小時。因為睡眠不足或者品質很差，讓你原本有 90% 的生產力下降到 70% 好了，這樣子工作的狀況會好嗎？</p><p>在吃的方面也是ㄧ樣，尤其是一些比較有心的房東會把房子處理好。但是對他來說商品的維持太糟糕，他會有額外的成本，所以可能會不允許煮飯。</p><p>那麼除了上班外食之外，晚餐跟早餐可能也都要在外面吃（而且還要吃到一定程度是健康的，不能餐餐都亂吃））</p><p>假設以套房（衛生考量）來看，一個月至少就是 9K （租屋） + 9K（餐費）左右的花費，這樣算下來 30K 的薪水，還沒扣掉水電跟瓦斯，還有可能要背的學貸跟電信費用，剩下的就幾本上就是應急用。</p><blockquote><p>也就是說，在考慮工作之前，要先評估過該城市的生活花費有多少。考慮生活品質是要創造正向的循環，而不是一種不斷惡化的情境給自己。</p></blockquote><h2 id="薪水成長"><a href="#薪水成長" class="headerlink" title="薪水成長"></a>薪水成長</h2><p>之前因為噗浪上有一個匿名的問卷，我就把它做成<a href="https://frost.tw/plurk-salary/" target="_blank" rel="noopener">薪水普查</a>這個頁面，用來統計上面（可解析）的薪資情報。</p><p>以上面的情況來看，比較可靠的資訊可以發現大多數都卡在 45K 就看起來比較沒有成長。</p><p>先假設我們的極限就到此為止好了，那麼要選擇怎樣的公司就顯而易見了吧？假設三年就能達到 45K 的極限，跟要花上十年才能達到極限，中間缺少的那塊就能攘你在人生規劃中做更多的事情。</p><blockquote><p>不過很可惜，我也不清楚同事調整薪水的狀況。不過第一年的調整我是蠻滿意的，第二年因為制度調整的關係我還不知道結果，不過我是蠻相信老闆們的 XD</p></blockquote><p>不過，假設薪水調整幅度「大」的公司，我想能提供的薪水上限肯定也是比較高的。</p><p>不過公司的規模不一定會讓薪資成長比較大，像是我聽過親戚在看起來蠻大的公司工作，第一次調薪竟然是幾百塊為單位的（這跟沒有一樣吧？）還有就是外商來臺灣以為人才也會相對便宜，結果初期開的薪資確實是比台灣高。但是這幾年下來因為調整不多，反而變得無法提供更高的薪資（因為有太多人需要先調高）</p><p>所以剛畢業這幾年，選擇風險高一點的新創公司，老闆願意提供高薪的機會是比較大的。</p><blockquote><p>而且有些公司會問為什麼換工作這麼頻繁，用前公司經營不善似乎是個不錯的理由（笑）</p></blockquote><h2 id="技能成長"><a href="#技能成長" class="headerlink" title="技能成長"></a>技能成長</h2><p>既然我們已經知道薪水方面該怎麼評估，再接下來我們要看，而且要看的「很注重」的就是技能成長這一塊。</p><p><strong>薪水少沒關係，公司給的環境更重要</strong></p><p>在一間公司工作，要怎麼樣讓你的技能成長？這跟公司的方針跟給予的環境有關係，如果沒有「環境」空有「福利」你是不會進步的。</p><blockquote><p>福利是什麼？下午茶算是一種，還有是會給你去上課，但是上的課是一些心靈課程？？？？</p></blockquote><p>以目前我所在的公司<a href="https://5xruby.tw" target="_blank" rel="noopener">五倍紅寶石</a>來說好了，我想我目前有的技能其實應該是可以考慮換一個工作，然後要求更高的薪水。但是我基本上除非公司沒辦法繼續養我（如果有一天我的技能已經超過公司成長的速度）不然我想我會繼續待著，因為制度和自由度上很適合我。</p><blockquote><p>不時還會有獵人頭問我，從今年開始我都是給目前工作 +30% 左右的「期望薪資」然後問問對方「現在的工作環境我很滿意，如果可以達到個水準的薪資，我再考慮放棄現在的環境」然後通常就沒下文了⋯⋯</p></blockquote><h3 id="引路人"><a href="#引路人" class="headerlink" title="引路人"></a>引路人</h3><p>以我們網路業來說，平常的工作就是網站相關的軟體工程師。我們通常會「號稱」有 Code Review （原始碼審查）或者 Pair Programming 等等機制存在，但是真正落實的機會不大，即使在五倍也沒有辦法完全落實。</p><p>原因不外乎就是成本，即使我們自己想做，客戶也不一定有時間跟經費讓我們這樣做。</p><p>但是，可以的話我們會盡力去做。尤其是針對公司的 Junior （初級工程師）做 Code Review 或者 Pair Programming 來幫助他們。</p><p>為什麼？如果你寫了十年的程式，但是從來沒有人告訴過你「其實有更好的方法」以及「用這樣的方式思考，是不是可以更俐落的解決問題」那麼你會進步嗎？除非你有一天頓悟，不然真的很難。</p><p><strong>工程師雖然面對電腦，但是人是需要互動跟交流的</strong></p><p>所以才會有像是 <a href="https://2018.rubyconf.tw/" target="_blank" rel="noopener">RubyElixirConf</a> 和<a href="https://www.facebook.com/rubymokumokukai/" target="_blank" rel="noopener">默默會</a>這類活動的存在，即使你是一個天才或者高手，你還是需要跟其他人討論和交流，去發掘自己不知道的領域和從沒有考慮過的問題。</p><blockquote><p>尤其時你越來越強，越容易忽略一些「理所當然」但是卻沒有細想過背後原理和機制的東西。</p></blockquote><p>再舉個例子，我的親戚也是工程師。但是他的公司前輩有一次問他「為什麼你要自己做，這個東西以前人做過複製貼上就好拉！」</p><p>後來我問，你做的東西問題其實很多，前輩都沒有訂正這種低級錯誤嗎？<br>「沒有，我們給客戶的產品只要 QA （品質測試）通過就可以了⋯⋯」</p><p>因為東西會動，所以品質測試就能通過。然後背後是否能夠有「最低限度」的可維護性，或者工程師的技能成長，就這樣被公司「節省」掉了！</p><p><strong>聽起來就像公司把你當做產生軟體的「工具」，而不是一個人力資源</strong></p><p>所以，你必須確定你的公司會在「能做到的範圍內」盡可能幫助你，而不是把你當做一個工具。</p><blockquote><p>重複使用不是問題，但是完全不明白自己在用什麼，就是個大問題。</p></blockquote><h3 id="自由"><a href="#自由" class="headerlink" title="自由"></a>自由</h3><p>在五倍，基本上不會強迫我們加班。而工作上，如果有餘裕的話，也可以用在一些改進自己技能的地方。</p><p>在五倍這兩年左右，其實我嘗試了不少東西。跟同事把原本的 Raspberry Pi （樹莓派）打卡機改寫，變成一套稍微簡單使用的 Ruby IoT 解決方案。</p><p>在公司內部嘗試了好幾次，做了很多改上讓 GitLab 跟 GitLab CI 可以運作起來、有 Staging 的環境可以自動化部屬最新的版本做測試。</p><p>最近也開始嘗試透過像是 Ansible 來做自動化的伺服器部署，以及使用 Vault 控管開發人員存取伺服器的權限等等。</p><p>甚至也嘗試基於 Scrum 和其他幾套敏捷開發的理論，改良出一套適合五倍通常以接案的專案管理流程，用來應對小團隊（三到五人）跟短期（一兩個月，或者半年）的開發。</p><p>中間還有不少時間讓我跟工作內容搭配，用來準備投稿國內外的研討會。雖然不多，但是一年至少也能夠在國內分享一兩次左右，運氣好還可以到日本分享。</p><p>最近同事也自發的在下班後利用公司的空間，開始互相教學一些自己會的技能，像是在美國住過的口說經驗、記憶學是怎麼用來輔助記憶東西的等等。</p><p><strong>短短兩年，你學會的技能就足以在下一次的工作上獲得更多優勢</strong></p><p>所以五倍的「技術力」很強嗎？從這樣的角度來看，即使現在不是，之後也會慢慢變強。</p><blockquote><p>當然，我們也不斷面臨人才的流失。但是我們也同時的讓更多人才被發掘和成長起來。</p></blockquote><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>我目前想到的大概是這些，其實從我接觸到的一些情況會發現一件事情。</p><p>「即使再有天份或者能力，如果在錯誤的公司，就算是天才也會變成普通人」</p><p>作為一個工程師你要考我演算法或者一些計算機科學的知識，身為一個「非本科生」我沒辦法「正確」的回答，但是我能用我的經驗跟理解去解釋。</p><p>所以很多時候，知識並不重要。對求職者來說，公司對你的「態度」很重要，他會影響你之後的職涯發展。</p><p>不過，相同的你對公司的「態度」也很重要。就像今年暑假我參與了審核實習生履歷的任務，我這樣對老闆說「像是一些頂尖的學校，如果不是特別突出的話，我會先考慮其他學校表現不錯的看看」並不是因為我是私立大學畢業有偏見，我的同事大概有一半也都是這類頂尖學校的。</p><p>我擔心的是我過去接觸過一些這些學校的學生，少數會因為有自己的「想法」所以就不接受其他人給他的「想法」</p><p>這樣要團隊合作就很難了，不過最近也遇到了同校的人也有這樣的狀況，不過在這些頂尖大學發生的情況就相對多出許多，畢竟他們更有自信，也更容易有這樣的問題。</p><p>私校的學生就剛好反過來，太沒有自信而不敢把「我不行」或者「我可以」明確的提出來，反而讓管理階層在評估要給予怎樣的工作跟適合的挑戰時，有所篇差。</p><blockquote><p>有點扯遠了，下一次的系列文就讓我來討論從我成為工程師這段時期，我的經驗和每一個階段面臨的困難和挑戰吧！</p></blockquote>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/09/10/How-to-choose-your-first-job/#disqus_thread</comments>
    </item>
    
    <item>
      <title>淺談 Ruby 的 Fiber（九）</title>
      <link>https://blog.frost.tw/posts/2018/09/05/Talk-about-ruby-s-fiber-Part-9/</link>
      <guid>https://blog.frost.tw/posts/2018/09/05/Talk-about-ruby-s-fiber-Part-9/</guid>
      <pubDate>Wed, 05 Sep 2018 01:30:34 GMT</pubDate>
      <description>
      
        &lt;p&gt;這篇文章我們會把 Broadcast （廣播）功能實作出來，如此一來我們就擁有了可以將訊息透過 Fiber 實作的伺服器廣播給其他使用者的功能。&lt;/p&gt;
&lt;p&gt;而這系列文章也就到此告一段落。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>這篇文章我們會把 Broadcast （廣播）功能實作出來，如此一來我們就擁有了可以將訊息透過 Fiber 實作的伺服器廣播給其他使用者的功能。</p><p>而這系列文章也就到此告一段落。</p><a id="more"></a><h2 id="觀察"><a href="#觀察" class="headerlink" title="觀察"></a>觀察</h2><p>要將廣播功能實作出來，我們需要哪些功能呢？</p><ul><li>非阻塞的寫入</li><li>所有連線使用者的列表</li></ul><p>其實就卻少了跟 <code>#wait_readable</code> 成對的 <code>#wait_writable</code> 這個實作。</p><h2 id="修改-Selector"><a href="#修改-Selector" class="headerlink" title="修改 Selector"></a>修改 Selector</h2><p>所以，我們要先針對 Selector 增加 <code>#wait_writable</code> 的實作。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wait_writable</span><span class="params">(io)</span></span></span><br><span class="line">  Fiber.new <span class="keyword">do</span></span><br><span class="line">    @writers[io] = Fiber.current</span><br><span class="line">    Fiber.<span class="keyword">yield</span></span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">  <span class="keyword">end</span>.resume</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>實際上跟 <code>#wait_readable</code> 幾乎沒有差異，唯一有差別的是我們將 <code>@readers</code> 改為 <code>@writers</code></p><blockquote><p>不要忘記在 <code>initialize</code> 的時候追加 <code>@writers = {}</code> 的行為。</p></blockquote><p>為了要讓在可以寫入的時候能夠將訊息發送出去，所以原本的 <code>#resume</code> 也需要增加一些修改，將 <code>IO.select</code> 增加觀察可寫入的行為。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resume</span></span></span><br><span class="line">  readable, writable = IO.select(@readers.keys, @writers.keys)</span><br><span class="line">  readable.each <span class="keyword">do</span> <span class="params">|io|</span></span><br><span class="line">    io = @readers.delete(io)</span><br><span class="line">    io.resume</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  writable.each <span class="keyword">do</span> <span class="params">|io|</span></span><br><span class="line">    io = @writers.delete(io)</span><br><span class="line">    io.resume</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>另外 <code>IO.select</code> 其實可以接收三個陣列，基本上對應 STDOUT / STDIN / STDERR 三種標準輸出。</p><h2 id="修改-Client"><a href="#修改-Client" class="headerlink" title="修改 Client"></a>修改 Client</h2><p>我們可以將原本的 <code>#show_message</code> 稍微修改，變成呼叫 Server 來做廣播的行為。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_message</span></span></span><br><span class="line">  @server.broadcast <span class="keyword">self</span>, <span class="string">"<span class="subst">#&#123;last_message&#125;</span>\n"</span> <span class="keyword">while</span> @buffer.<span class="keyword">include</span>?(<span class="string">"\n"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>這邊我們還要對 Client 增加 <code>#send</code> 方法來做寫入。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send</span><span class="params">(message)</span></span></span><br><span class="line">  result = @socket.write_nonblock(message, <span class="symbol">exception:</span> <span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">case</span> result</span><br><span class="line">  <span class="keyword">when</span> <span class="symbol">:wait_writable</span></span><br><span class="line">    @selector.wait_writable(@socket) <span class="keyword">do</span></span><br><span class="line">      send(message)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">when</span> <span class="literal">nil</span> <span class="keyword">then</span> close</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>因為相比讀取的部分其實簡單很多，所以就沒有額外的拆解。原理上大致就是先嘗試寫入，如果無法寫入的話就讓 Fiber 將他暫時暫停，等到可以寫入之後再把他做完。</p><h2 id="修改-Server"><a href="#修改-Server" class="headerlink" title="修改 Server"></a>修改 Server</h2><p>這邊就是針對 Client 所呼叫的 Broadcast 做實作。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">broadcast</span><span class="params">(sender, message)</span></span></span><br><span class="line">  @clients.each <span class="keyword">do</span> <span class="params">|client|</span></span><br><span class="line">    <span class="keyword">next</span> <span class="keyword">if</span> client == sender</span><br><span class="line">    client.send(<span class="string">"User#<span class="subst">#&#123;sender.object_id&#125;</span> &gt; <span class="subst">#&#123;message&#125;</span>"</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我們會跳過發出訊息的本人是因為在輸入時，輸入者自己就能看到訊息了，所以就不需要重複顯示。另一方面剛好可以跟收到的訊息做出一個簡單的區隔。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>經過這大約兩週的實踐，我想大家應該對於 Fiber 有一個簡單的概念。不過實際上，要使用 Fiber 其實還是有很多限制在的。</p><p>舉例來說，如果兩個行為是有相依性的，該怎麼設計 Fiber 的組成，而像這個範例不斷的產生新的 Fiber 物件，真的會比使用 Thread 還節省記憶體嗎？</p><p>這些都是一些需要探討的問題，另外在這篇文章順便對上一篇<a href="https://blog.frost.tw/posts/2018/08/21/Does-the-Fiber-have-any-benefit-for-Ruby/">使用 Fiber 能給 Ruby 帶來好處嗎？</a>做一個簡單的補充，就是 Fiber 在 Ruby 中基本上無法比 Thread 還快。但是他有著記憶體使用量非常小的優勢，所以我們可以在不要求執行速度，但是很注重記憶體使用控制的情境下使用 Fiber 來改善記憶體的使用。</p><p>之後也會繼續抽空測試關於 Fiber 的可能性，再跟大家分享和討論有哪些地方可以做應用。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/09/05/Talk-about-ruby-s-fiber-Part-9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>使用 Fiber 能給 Ruby 帶來好處嗎？</title>
      <link>https://blog.frost.tw/posts/2018/08/21/Does-the-Fiber-have-any-benefit-for-Ruby/</link>
      <guid>https://blog.frost.tw/posts/2018/08/21/Does-the-Fiber-have-any-benefit-for-Ruby/</guid>
      <pubDate>Tue, 21 Aug 2018 10:08:56 GMT</pubDate>
      <description>
      
        &lt;p&gt;關於 Fiber 的&lt;a href=&quot;https://blog.frost.tw/posts/2018/06/26/Talk-about-ruby-s-fiber-Part-1/&quot;&gt;系列文&lt;/a&gt;寫到現在也已經一個半月了，除了分享自己在使用 Fiber 的經驗之外，我也更加的熟悉 Fiber 的使用。&lt;/p&gt;
&lt;p&gt;不過，這真的是有益於現有的專案嗎？&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>關於 Fiber 的<a href="https://blog.frost.tw/posts/2018/06/26/Talk-about-ruby-s-fiber-Part-1/">系列文</a>寫到現在也已經一個半月了，除了分享自己在使用 Fiber 的經驗之外，我也更加的熟悉 Fiber 的使用。</p><p>不過，這真的是有益於現有的專案嗎？</p><a id="more"></a><p>為了確認是否有實際的效益，我就針對當初會考慮 Fiber 的其中一個原因 - 大量 HTTP 請求處理當作方向，設計了幾個測試。</p><h2 id="情境"><a href="#情境" class="headerlink" title="情境"></a>情境</h2><p>這些測試包含了這幾種情況，唯一會改變的是使用 Fiber 實作的方式，其他都是固定的。</p><ol><li>純 <a href="https://ruby-doc.org/stdlib-2.5.1/libdoc/net/http/rdoc/Net/HTTP.html" target="_blank" rel="noopener">Net::HTTP</a> 的實現</li><li>使用 Thread 將 HTTP 請求平行處理的實現</li><li>對 Net::HTTP 採取 Keep-Alive 的方式處理的實現</li></ol><p>其實還應該加入使用 Keep-Alive 在 Thread 中處理的版本，但是目前還沒有實作到那部分。</p><h2 id="測試案例"><a href="#測試案例" class="headerlink" title="測試案例"></a>測試案例</h2><p>以下會貼出好幾種不同 Fiber 實現情境下的測試案例，來讓大家參考跟比較。</p><h3 id="一、單純的非同步請求"><a href="#一、單純的非同步請求" class="headerlink" title="一、單純的非同步請求"></a>一、單純的非同步請求</h3><p>原始碼可以在這個 <a href="https://gist.github.com/elct9620/9651456ff3abf820065b1e1f98da37ff" target="_blank" rel="noopener">Gits</a> 找到，可能會跟目前的版本有一點誤差。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Warming up --------------------------------------</span><br><span class="line">               Fiber     1.000  i/100ms</span><br><span class="line">           Net::HTTP     1.000  i/100ms</span><br><span class="line">       [P] Net::HTTP     1.000  i/100ms</span><br><span class="line">Calculating -------------------------------------</span><br><span class="line">               Fiber      0.173  (± 0.0%) i/s -      1.000  in   5.787644s</span><br><span class="line">           Net::HTTP      0.173  (± 0.0%) i/s -      1.000  in   5.766318s</span><br><span class="line">       [P] Net::HTTP      0.162  (± 0.0%) i/s -      1.000  in   6.155530s</span><br><span class="line"></span><br><span class="line">Comparison:</span><br><span class="line">           Net::HTTP:        0.2 i/s</span><br><span class="line">               Fiber:        0.2 i/s - 1.00x  slower</span><br><span class="line">       [P] Net::HTTP:        0.2 i/s - 1.07x  slower</span><br><span class="line"></span><br><span class="line">Calculating -------------------------------------</span><br><span class="line">               Fiber     1.147M memsize (    55.746k retained)</span><br><span class="line">                         5.681k objects (   356.000  retained)</span><br><span class="line">                        50.000  strings (    50.000  retained)</span><br><span class="line">           Net::HTTP     2.276M memsize (     5.416k retained)</span><br><span class="line">                         1.656k objects (    50.000  retained)</span><br><span class="line">                        50.000  strings (    50.000  retained)</span><br><span class="line">       [P] Net::HTTP     5.457M memsize (     5.343k retained)</span><br><span class="line">                         1.876k objects (    51.000  retained)</span><br><span class="line">                        50.000  strings (    50.000  retained)</span><br><span class="line"></span><br><span class="line">Comparison:</span><br><span class="line">               Fiber:    1146951 allocated</span><br><span class="line">           Net::HTTP:    2276040 allocated - 1.98x more</span><br><span class="line">       [P] Net::HTTP:    5457467 allocated - 4.76x more</span><br></pre></td></tr></table></figure><p>這邊要注意的是原始碼使用的是 <code>read_nonblock(1)</code> 會造成非常大量的記憶體浪費，因為他會產生非常多破碎的字串（緩衝區）來暫存，直到處理完才釋放。<br>所以將 <code>read_nonblock(1)</code> 修改為 <code>read_nonblock(102400)</code> 之後，因為一次最大可以讀取 10K 的資料，所以通常一次性的分配就能完成操作，記憶體會和 <code>[P] Net::HTTP</code> （Thread 版）的差異達到 100 倍的差異。</p><blockquote><p>不過要注意的是，這邊只是單純的把回應的內容擷取出來，跟 <code>Net::HTTP</code> 做的事情少了很多，碰到有 Chunk（分塊）的資料，也無法正確處理。這也是記憶體使用差距極大的原因。</p></blockquote><p>而且我們可以看到，使用 Fiber 其實並沒有「比較快」</p><h3 id="二、使用-Keep-Alive-的-Fiber"><a href="#二、使用-Keep-Alive-的-Fiber" class="headerlink" title="二、使用 Keep-Alive 的 Fiber"></a>二、使用 Keep-Alive 的 Fiber</h3><p>原始碼可以在這個 <a href="https://gist.github.com/elct9620/1330b47d71a5fbbb31867989a47cff17" target="_blank" rel="noopener">Gits</a> 找到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Warming up --------------------------------------</span><br><span class="line">               Fiber     1.000  i/100ms</span><br><span class="line">           Net::HTTP     1.000  i/100ms</span><br><span class="line">       [P] Net::HTTP     1.000  i/100ms</span><br><span class="line">Calculating -------------------------------------</span><br><span class="line">               Fiber      0.152  (± 0.0%) i/s -      1.000  in   6.578475s</span><br><span class="line">           Net::HTTP      0.116  (± 0.0%) i/s -      1.000  in   8.648963s</span><br><span class="line">       [P] Net::HTTP      0.162  (± 0.0%) i/s -      1.000  in   6.175362s</span><br><span class="line"></span><br><span class="line">Comparison:</span><br><span class="line">       [P] Net::HTTP:        0.2 i/s</span><br><span class="line">               Fiber:        0.2 i/s - 1.07x  slower</span><br><span class="line">           Net::HTTP:        0.1 i/s - 1.40x  slower</span><br><span class="line"></span><br><span class="line">Calculating -------------------------------------</span><br><span class="line">               Fiber    83.919k memsize (     1.162k retained)</span><br><span class="line">                       279.000  objects (     9.000  retained)</span><br><span class="line">                        44.000  strings (     9.000  retained)</span><br><span class="line">           Net::HTTP     9.085M memsize (    12.385k retained)</span><br><span class="line">                         5.827k objects (   117.000  retained)</span><br><span class="line">                        50.000  strings (    50.000  retained)</span><br><span class="line">       [P] Net::HTTP    17.466M memsize (    11.139k retained)</span><br><span class="line">                         5.849k objects (   110.000  retained)</span><br><span class="line">                        50.000  strings (    50.000  retained)</span><br><span class="line"></span><br><span class="line">Comparison:</span><br><span class="line">               Fiber:      83919 allocated</span><br><span class="line">           Net::HTTP:    9084994 allocated - 108.26x more</span><br><span class="line">       [P] Net::HTTP:   17466200 allocated - 208.13x more</span><br></pre></td></tr></table></figure><p>這次我們將 <code>read_nonblock</code> 設定到正確數值後，可以看到記憶體的使用急遽的下降。而且在使用 Keep-Alive （連線後不馬上關閉）的機制後，節省下來的 TCP Handshake 時間讓他的速度跟 Thread 的時間更加接近，但是在實質上順利的比原本的 <code>Net::HTTP</code> 還更快。</p><h3 id="三、使用-Net-HTTP-非同步處理-Fiber"><a href="#三、使用-Net-HTTP-非同步處理-Fiber" class="headerlink" title="三、使用 Net::HTTP 非同步處理 Fiber"></a>三、使用 Net::HTTP 非同步處理 Fiber</h3><p>原始碼可以在這個 <a href="https://gist.github.com/elct9620/e2eadcb8cf431f30a1b080bdee4077a1" target="_blank" rel="noopener">Gits</a> 找到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Warming up --------------------------------------</span><br><span class="line">               Fiber     1.000  i/100ms</span><br><span class="line">           Net::HTTP     1.000  i/100ms</span><br><span class="line">       [K] Net::HTTP     1.000  i/100ms</span><br><span class="line">       [P] Net::HTTP     1.000  i/100ms</span><br><span class="line">Calculating -------------------------------------</span><br><span class="line">               Fiber      0.153  (± 0.0%) i/s -      1.000  in   6.553764s</span><br><span class="line">           Net::HTTP      0.104  (± 0.0%) i/s -      1.000  in   9.656557s</span><br><span class="line">       [K] Net::HTTP      0.109  (± 0.0%) i/s -      1.000  in   9.196089s</span><br><span class="line">       [P] Net::HTTP      0.145  (± 0.0%) i/s -      1.000  in   6.877551s</span><br><span class="line"></span><br><span class="line">Comparison:</span><br><span class="line">               Fiber:        0.2 i/s</span><br><span class="line">       [P] Net::HTTP:        0.1 i/s - 1.05x  slower</span><br><span class="line">       [K] Net::HTTP:        0.1 i/s - 1.40x  slower</span><br><span class="line">           Net::HTTP:        0.1 i/s - 1.47x  slower</span><br><span class="line"></span><br><span class="line">Calculating -------------------------------------</span><br><span class="line">               Fiber   633.129k memsize (     8.289k retained)</span><br><span class="line">                         5.040k objects (    82.000  retained)</span><br><span class="line">                        50.000  strings (    50.000  retained)</span><br><span class="line">           Net::HTTP     9.057M memsize (    11.527k retained)</span><br><span class="line">                         5.834k objects (   116.000  retained)</span><br><span class="line">                        50.000  strings (    50.000  retained)</span><br><span class="line">       [K] Net::HTTP     4.777M memsize (    11.078k retained)</span><br><span class="line">                         4.794k objects (   113.000  retained)</span><br><span class="line">                        50.000  strings (    50.000  retained)</span><br><span class="line">       [P] Net::HTTP    17.440M memsize (    11.047k retained)</span><br><span class="line">                         5.874k objects (   107.000  retained)</span><br><span class="line">                        50.000  strings (    50.000  retained)</span><br><span class="line"></span><br><span class="line">Comparison:</span><br><span class="line">               Fiber:     633129 allocated</span><br><span class="line">       [K] Net::HTTP:    4776761 allocated - 7.54x more</span><br><span class="line">           Net::HTTP:    9056946 allocated - 14.31x more</span><br><span class="line">       [P] Net::HTTP:   17440446 allocated - 27.55x more</span><br></pre></td></tr></table></figure><p>這一次的測試我也額外的補上了使用 Keep-Alive 的 Net::HTTP 實作，不過速度上的變化變得有點微妙，應該是測試還不完善造成的數據不太準確。不過我們可以觀察到記憶體的差距並沒有原本的那麼巨大，主要是因為 Net::HTTP 分配了很多物件在處理，另外因為有一部分的功能是重複的（有兩個緩衝區），也造成有多餘的記憶體被分配。</p><h3 id="四、修改-Net-HTTP-採用-Fiber-模式"><a href="#四、修改-Net-HTTP-採用-Fiber-模式" class="headerlink" title="四、修改 Net::HTTP 採用 Fiber 模式"></a>四、修改 Net::HTTP 採用 Fiber 模式</h3><p>這部分還不完整所以就沒有把程式碼放到 Gits 上了，整個實驗成功的話會製作一個新的 Ruby Gem 來提供這個功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Warming up --------------------------------------</span><br><span class="line">               Fiber     1.000  i/100ms</span><br><span class="line">           [K] Fiber     1.000  i/100ms</span><br><span class="line">            Net:HTTP     1.000  i/100ms</span><br><span class="line">       [K] Net::HTTP     1.000  i/100ms</span><br><span class="line">       [P] Net::HTTP     1.000  i/100ms</span><br><span class="line">   [P + K] Net::HTTP     1.000  i/100ms</span><br><span class="line">Calculating -------------------------------------</span><br><span class="line">               Fiber      0.320  (± 0.0%) i/s -      2.000  in   6.260364s</span><br><span class="line">           [K] Fiber      0.469  (± 0.0%) i/s -      3.000  in   6.401384s</span><br><span class="line">            Net:HTTP      0.247  (± 0.0%) i/s -      2.000  in   8.122089s</span><br><span class="line">       [K] Net::HTTP      0.314  (± 0.0%) i/s -      2.000  in   6.408347s</span><br><span class="line">       [P] Net::HTTP      0.365  (± 0.0%) i/s -      2.000  in   5.867113s</span><br><span class="line">   [P + K] Net::HTTP      0.393  (± 0.0%) i/s -      2.000  in   5.091580s</span><br><span class="line"></span><br><span class="line">Comparison:</span><br><span class="line">           [K] Fiber:        0.5 i/s</span><br><span class="line">   [P + K] Net::HTTP:        0.4 i/s - 1.19x  slower</span><br><span class="line">       [P] Net::HTTP:        0.4 i/s - 1.29x  slower</span><br><span class="line">               Fiber:        0.3 i/s - 1.47x  slower</span><br><span class="line">       [K] Net::HTTP:        0.3 i/s - 1.49x  slower</span><br><span class="line">            Net:HTTP:        0.2 i/s - 1.90x  slower</span><br><span class="line"></span><br><span class="line">Calculating -------------------------------------</span><br><span class="line">               Fiber     8.738M memsize (   148.484k retained)</span><br><span class="line">                         2.893k objects (   347.000  retained)</span><br><span class="line">                        50.000  strings (    43.000  retained)</span><br><span class="line">           [K] Fiber     4.490M memsize (    72.864k retained)</span><br><span class="line">                         1.860k objects (   147.000  retained)</span><br><span class="line">                        50.000  strings (    33.000  retained)</span><br><span class="line">            Net:HTTP     9.019M memsize (    11.607k retained)</span><br><span class="line">                         5.476k objects (   114.000  retained)</span><br><span class="line">                        50.000  strings (    50.000  retained)</span><br><span class="line">       [K] Net::HTTP     5.796M memsize (     9.899k retained)</span><br><span class="line">                         4.568k objects (   103.000  retained)</span><br><span class="line">                        50.000  strings (    50.000  retained)</span><br><span class="line">       [P] Net::HTTP    17.436M memsize (    10.764k retained)</span><br><span class="line">                         5.522k objects (   108.000  retained)</span><br><span class="line">                        50.000  strings (    50.000  retained)</span><br><span class="line">   [P + K] Net::HTTP     8.990M memsize (    10.812k retained)</span><br><span class="line">                         4.805k objects (   106.000  retained)</span><br><span class="line">                        50.000  strings (    50.000  retained)</span><br><span class="line"></span><br><span class="line">Comparison:</span><br><span class="line">           [K] Fiber:    4490290 allocated</span><br><span class="line">       [K] Net::HTTP:    5796367 allocated - 1.29x more</span><br><span class="line">               Fiber:    8737780 allocated - 1.95x more</span><br><span class="line">   [P + K] Net::HTTP:    8989723 allocated - 2.00x more</span><br><span class="line">            Net:HTTP:    9019075 allocated - 2.01x more</span><br><span class="line">       [P] Net::HTTP:   17436128 allocated - 3.88x more</span><br></pre></td></tr></table></figure><p>這次加入了更多的測試項目進來，而且可以發現就是在這個情境之下 Fiber (Keep-Alive) 版本其實相對於 Thread 版本還要快，但是在記憶體使用上幾乎就佔不到什麼優勢。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>首先要強調一件事情，這些測試數據都還是不完整的。而且條件其實不太對等，因此只能作為參考使用，並不能當作評估的依據。</p><p>不過我們也可以觀測到幾件事情，就是 Net::HTTP 在處理網路連線的部分，其實並不慢（Socket / IO 都是 C 語言實作）而當我們開始處理資料（緩衝）的時候，因為有許多檢查所以才造成的記憶體的浪費，如果沒有需要做很多處理的話，自己使用 TCPSocket 處理可能會節省非常多的記憶體使用。</p><p>而 Net::HTTP 理論上來說會比 Fiber 的版本比較慢，主要是因為 Net::BufferedIO 會在讀取 Body 的時候 Blocking 住，雖然這個過程是使用 Nonblocking 的行為，但是並無法像 Fiber 一樣在遇到 Blocking 的時候先讓其他人處理。</p><p>數字上看起來接近可能是因為網路其實都是順暢而且資料都不大的狀況下，才能有這樣的結果。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/08/21/Does-the-Fiber-have-any-benefit-for-Ruby/#disqus_thread</comments>
    </item>
    
    <item>
      <title>淺談 Ruby 的 Fiber（八）</title>
      <link>https://blog.frost.tw/posts/2018/08/14/Talk-about-ruby-s-fiber-Part-8/</link>
      <guid>https://blog.frost.tw/posts/2018/08/14/Talk-about-ruby-s-fiber-Part-8/</guid>
      <pubDate>Tue, 14 Aug 2018 12:47:48 GMT</pubDate>
      <description>
      
        &lt;p&gt;到這篇為止，我們已經完成了將 Fiber 應用在程式中的基本雛型，現在只需要將上週未完成的錯誤處理，我們就能獲得一個可以正常發送訊息到伺服器的伺服器。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>到這篇為止，我們已經完成了將 Fiber 應用在程式中的基本雛型，現在只需要將上週未完成的錯誤處理，我們就能獲得一個可以正常發送訊息到伺服器的伺服器。</p><a id="more"></a><h2 id="觀察"><a href="#觀察" class="headerlink" title="觀察"></a>觀察</h2><p>經過幾次的測試，我們會發現原本預期沒有正常運作的 <a href="mailto:`@fibers.delete" target="_blank" rel="noopener">`@fibers.delete</a>(io)<code>實際上是有在執行的，但是在使用者離開時，我們還在等待「讀取」所以就會觸發</code>end of file reached (EOFError)` 這個錯誤，也就是使用者離開的瞬間，我們可以讀取。但是讀取到的是終止的訊息。</p><p>針對這個問題，我們只需要增加 <code>rescue EOFError</code> 讓他不要產生錯誤，就可以順利解決。</p><blockquote><p>不過以邏輯上來說，我們更這種由我們掌控的機制，不應該是一種例外，所以採取 <code>exception: false</code> 的做法也許是一個不錯的選擇。</p></blockquote><h2 id="重構"><a href="#重構" class="headerlink" title="重構"></a>重構</h2><p>既然我們已經了解完整的運作原理，但是程式碼依舊還是處於混亂的狀態。因此我們最好先進行一次重構會比較適合。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Selector</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></span><br><span class="line">    @readers = &#123;&#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">wait_readable</span><span class="params">(io)</span></span></span><br><span class="line">    Fiber.new <span class="keyword">do</span></span><br><span class="line">      @readers[io] = Fiber.current</span><br><span class="line">      Fiber.<span class="keyword">yield</span></span><br><span class="line">      <span class="keyword">yield</span></span><br><span class="line">    <span class="keyword">end</span>.resume</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">resume</span></span></span><br><span class="line">    readable, = IO.select(@readers.keys)</span><br><span class="line">    readable.each <span class="keyword">do</span> <span class="params">|io|</span></span><br><span class="line">      io = @readers.delete(io)</span><br><span class="line">      io.resume</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><code>Selector</code> 的部分我們沒有做太多的修改，為了配合後面會有寫入的行為，我們先把原本的 <code>@fibers</code> 修改為 <code>@readers</code> 來對應。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(selector, server, socket)</span></span></span><br><span class="line">    @socket = socket</span><br><span class="line">    @selector = selector</span><br><span class="line">    @server = server</span><br><span class="line">    @buffer = <span class="string">''</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">listen</span></span></span><br><span class="line">    buffer = @socket.read_nonblock(<span class="number">1</span>, <span class="symbol">exception:</span> <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">case</span> buffer</span><br><span class="line">    <span class="keyword">when</span> <span class="symbol">:wait_readable</span> <span class="keyword">then</span> wait</span><br><span class="line">    <span class="keyword">when</span> <span class="literal">nil</span> <span class="keyword">then</span> close</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      @buffer &lt;&lt; buffer</span><br><span class="line">      show_message <span class="keyword">if</span> @buffer.<span class="keyword">include</span>?(<span class="string">"\n"</span>)</span><br><span class="line">      listen</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">wait</span></span></span><br><span class="line">    @selector.wait_readable(@socket) <span class="keyword">do</span></span><br><span class="line">      listen</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">show_message</span></span></span><br><span class="line">    puts last_message <span class="keyword">while</span> @buffer.<span class="keyword">include</span>?(<span class="string">"\n"</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">last_message</span></span></span><br><span class="line">    (<span class="number">_</span>, @buffer = @buffer.to_s.split(<span class="string">"\n"</span>, <span class="number">2</span>)).first</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">close</span></span></span><br><span class="line">    @server.close(<span class="keyword">self</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>這次增加了 <code>Client</code> 來針對客戶端的部分處理，當我們收到訊息時會不斷重試直到有 <code>\n</code> 符號出現，並且將它顯示出來。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span> &lt; TCPServer</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(port)</span></span></span><br><span class="line">    <span class="keyword">super</span> port</span><br><span class="line">    @selector = Selector.new</span><br><span class="line">    @clients = []</span><br><span class="line">    async_accept</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">async_accept</span></span></span><br><span class="line">    socket = accept_nonblock(<span class="symbol">exception:</span> <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">case</span> socket</span><br><span class="line">    <span class="keyword">when</span> <span class="symbol">:wait_readable</span> <span class="keyword">then</span> wait_accept</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      client = (@clients.push Client.new(@selector, <span class="keyword">self</span>, socket)).last</span><br><span class="line">      client.listen</span><br><span class="line">      async_accept</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">wait_accept</span></span></span><br><span class="line">    @selector.wait_readable(<span class="keyword">self</span>) <span class="keyword">do</span></span><br><span class="line">      async_accept</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(client)</span></span></span><br><span class="line">    @clients.delete(client)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start</span></span></span><br><span class="line">    loop <span class="keyword">do</span></span><br><span class="line">      @selector.resume</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">server = Server.new <span class="number">3000</span></span><br><span class="line">server.start</span><br></pre></td></tr></table></figure><p>最後伺服器部分跟客戶端的部分採取類似的邏輯，不過我們將大部分的行為封裝進去，統一進行處理。</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>這次比較特別的有兩個部分，第一個是伺服器的 <code>@clients</code> 陣列，會用來記錄在線上上的使用者，這會讓我們之後在實作發送聊天訊息的功能上方便不少。</p><p>另一個則是我們利用 Ruby 的 Block 特性，將產生 Fiber 的工作交給 Selector 來負責，如此一來其他部分的程式碼除了需要利用一些遞迴的特性之外，就不會看到 Fiber 也更崇義理解。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>Fiber 在思考上跟我們以往習慣的方式不太一樣，不過隨著將程式碼整理之後，實際上會發現並沒有那麼複雜，但是需要特別注意程式的執行時機點可能會被稍微的改變。</p><p>下一篇文章我們可以嘗試加入廣播訊息的機制，讓這個 TCP 聊天室完成他的實作。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/08/14/Talk-about-ruby-s-fiber-Part-8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>淺談 Ruby 的 Fiber（七）</title>
      <link>https://blog.frost.tw/posts/2018/08/07/Talk-about-ruby-s-fiber-Part-7/</link>
      <guid>https://blog.frost.tw/posts/2018/08/07/Talk-about-ruby-s-fiber-Part-7/</guid>
      <pubDate>Tue, 07 Aug 2018 11:00:21 GMT</pubDate>
      <description>
      
        &lt;p&gt;上週我們開始重構 Fiber 的結構，透過一個統一的 &lt;code&gt;Selector&lt;/code&gt; 物件來選取這個「當下」可以進行 I/O 操作的物件。&lt;/p&gt;
&lt;p&gt;不過，我們原本預期是因為使用 &lt;code&gt;rescue&lt;/code&gt; 來捕捉錯誤控制流程才讓他運行不正常，經過一週的思考後，卻發現事情跟預想的不太一樣。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>上週我們開始重構 Fiber 的結構，透過一個統一的 <code>Selector</code> 物件來選取這個「當下」可以進行 I/O 操作的物件。</p><p>不過，我們原本預期是因為使用 <code>rescue</code> 來捕捉錯誤控制流程才讓他運行不正常，經過一週的思考後，卻發現事情跟預想的不太一樣。</p><a id="more"></a><h2 id="調整"><a href="#調整" class="headerlink" title="調整"></a>調整</h2><p>我們先快速的使用 <code>exception: false</code> 的模式調整程式，會變成類似這樣的結構。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Fiber.new <span class="keyword">do</span></span><br><span class="line">  loop <span class="keyword">do</span></span><br><span class="line">    client = server.accept_nonblock(<span class="symbol">exception:</span> <span class="literal">false</span>)</span><br><span class="line">    selector.register(server) <span class="keyword">if</span> client == <span class="symbol">:wait_readable</span></span><br><span class="line">    <span class="keyword">next</span> <span class="keyword">if</span> client == <span class="symbol">:wait_readable</span></span><br><span class="line"></span><br><span class="line">    Fiber.new <span class="keyword">do</span></span><br><span class="line">      buffer <span class="params">||</span>= <span class="string">''</span></span><br><span class="line">      loop <span class="keyword">do</span></span><br><span class="line">        read = client.read_nonblock(<span class="number">1024</span>, <span class="symbol">exception:</span> <span class="literal">false</span>)</span><br><span class="line">        selector.register(client) <span class="keyword">if</span> read == <span class="symbol">:wait_readable</span></span><br><span class="line">        <span class="keyword">next</span> <span class="keyword">if</span> read == <span class="symbol">:wait_readable</span></span><br><span class="line">        buffer &lt;&lt; read</span><br><span class="line">        puts buffer <span class="keyword">if</span> buffer.<span class="keyword">include</span>?(<span class="string">"\n"</span>)</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>.resume</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>.resume</span><br></pre></td></tr></table></figure><p>然而，現實上並沒有實際的改善卡住的問題，和我們原本預測只要釐清流程就會正常的方向不太一樣。</p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>目前我們已經透過 <code>Selector</code> 物件來管理所有的 I/O 行為，現在程式碼只有一個地方能夠對 I/O 造成阻塞，那就是 <code>IO.select</code> 這個方法，會將最後一次我們紀錄「等待中」的物件傳入，等待作業系統提供可繼續 I/O 行為的通知。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resume</span></span></span><br><span class="line">    puts @fibers.keys</span><br><span class="line">    readable, = IO.select(@fibers.keys)</span><br><span class="line">    readable.each <span class="keyword">do</span> <span class="params">|io|</span></span><br><span class="line">      @fibers[io].resume</span><br><span class="line">      @fibers.delete(io)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我們嘗試將放在 <code>@fibers</code> 中的物件列出來，就會發現實際上一直都只有一個。原本預期會存在的 <code>TCPServer</code> 會在第一個使用者連上後就被移除。</p><p>而我們預期的應該要是在這一個 I/O 操作完畢後，將他移除。</p><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>我們對 <code>Selector</code> 做出一些修改，變成類似像這樣的結構。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Selector</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></span><br><span class="line">    @fibers = &#123;&#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(io)</span></span></span><br><span class="line">    @fibers[io] = Fiber.current</span><br><span class="line">    Fiber.<span class="keyword">yield</span></span><br><span class="line">    @fibers.delete(io)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">resume</span></span></span><br><span class="line">    readable, = IO.select(@fibers.keys)</span><br><span class="line">    readable.each <span class="keyword">do</span> <span class="params">|io|</span></span><br><span class="line">      @fibers[io].resume</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如此一來，所有使用者都能夠正常的連上並且寫入資料到伺服器上。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>不過，現實並沒有我們預期的那麼容易，因為我們在其中一個使用者離開後，發現 <a href="mailto:`@fibers.delete" target="_blank" rel="noopener">`@fibers.delete</a>(io)` 並沒有被執行，在下一篇文章我們要來尋找原因並且將它解決。</p><p>在這將近一個半月的文章，我們會發現使用 <code>Fiber</code> 並沒有預期中的容易，而且似乎並沒有想像中的實用，但是透過這樣的方式，也可以去思考為什麼 Ruby 中要存在 <code>Fiber</code> 以及到底是用來處理怎麼樣的特殊狀況，才會需要用到。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/08/07/Talk-about-ruby-s-fiber-Part-7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>淺談 Ruby 的 Fiber（六）</title>
      <link>https://blog.frost.tw/posts/2018/07/29/Talk-about-ruby-s-fiber-Part-6/</link>
      <guid>https://blog.frost.tw/posts/2018/07/29/Talk-about-ruby-s-fiber-Part-6/</guid>
      <pubDate>Sun, 29 Jul 2018 12:56:09 GMT</pubDate>
      <description>
      
        &lt;p&gt;經過前面幾篇文章的介紹，我們已經初步的了解 Fiber 的性質。這系列的文章目標是利用 Fiber 實現再不透過 Thread 或者 Process 的情境，來實現支援多人連線的 TCP 聊天伺服器。&lt;/p&gt;
&lt;p&gt;從這一篇開始，我們就要正式的來挑戰完整的實作了！&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>經過前面幾篇文章的介紹，我們已經初步的了解 Fiber 的性質。這系列的文章目標是利用 Fiber 實現再不透過 Thread 或者 Process 的情境，來實現支援多人連線的 TCP 聊天伺服器。</p><p>從這一篇開始，我們就要正式的來挑戰完整的實作了！</p><a id="more"></a><p>在開始之前，我們已經注意到前幾篇的程式碼已經開始有點複雜而且不好維護，所以我們要先做兩件事情來改善這個問題。</p><ol><li>釐清功能</li><li>重構</li></ol><h2 id="功能分析"><a href="#功能分析" class="headerlink" title="功能分析"></a>功能分析</h2><p>因為 Fiber 的特性，我們必須在所有遭遇到 Blocking I/O 的情境下轉為 Nonblocking I/O 來操作，也因此我們回來看一下前面幾篇需要處理 Blocking I/O 的情境。</p><ol><li>接受連線的 <code>#accept</code> 行為</li><li>讀取使用者資料的 <code>#gets</code> 行為</li></ol><p>為了能夠實現聊天室功能，我們至少還會需要再加入傳送資料給使用者的 <code>#puts</code> 行為。</p><p>而這些動作，我們都需要透過一個統一的物件來處理。</p><p>我們可以簡單的把他整理成類似像這樣的行為流程圖。</p><p><img src="https://blog.frost.tw/images/2018-07-29-talk-about-ruby-s-fiber-part-6/flowchart.png" alt="FlowchartDiagram1.png"></p><p>如果照我們原來的做法，會發現很難統一管理 Fiber 來在可以操作時執行對應的動作，所以上圖執行 <code>Fiber.yield</code> 的部分，我們會用一個物件來做統一管理，其他部分則可以先維持原樣。</p><h2 id="重構"><a href="#重構" class="headerlink" title="重構"></a>重構</h2><p>首先，我們先嘗試實現一個 <code>Selector</code> 來將可以讀取或者寫入的 I/O 物件找出來。</p><p>修改後的程式碼大致上會像這樣，我們提供了一個 <code>#register</code> 方法讓暫時無法讀取的物件被記錄下來。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'socket'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'fiber'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># :nodoc:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Selector</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></span><br><span class="line">    @fibers = &#123;&#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(io)</span></span></span><br><span class="line">    @fibers[io] = Fiber.current</span><br><span class="line">    Fiber.<span class="keyword">yield</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">resume</span></span></span><br><span class="line">    readable, = IO.select(@fibers.keys)</span><br><span class="line">    readable.each <span class="keyword">do</span> <span class="params">|io|</span></span><br><span class="line">      @fibers[io].resume</span><br><span class="line">      @fibers.delete(io)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">selector = Selector.new</span><br><span class="line">server = TCPServer.new <span class="number">3000</span></span><br><span class="line"></span><br><span class="line">loop <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">    selector.resume</span><br><span class="line"></span><br><span class="line">    client = server.accept_nonblock</span><br><span class="line">    client.puts <span class="string">'Hello World'</span></span><br><span class="line"></span><br><span class="line">    Fiber.new <span class="keyword">do</span></span><br><span class="line">      buffer <span class="params">||</span>= <span class="string">''</span></span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">        buffer &lt;&lt; client.read_nonblock(<span class="number">1024</span>)</span><br><span class="line">        puts buffer <span class="keyword">if</span> buffer.<span class="keyword">include</span>?(<span class="string">"\n"</span>)</span><br><span class="line">      <span class="keyword">rescue</span> IO::WaitReadable</span><br><span class="line">        selector.register(client)</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>.resume</span><br><span class="line">  <span class="keyword">rescue</span> IO::WaitReadable</span><br><span class="line">    sleep <span class="number">1</span></span><br><span class="line">    <span class="keyword">retry</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>不過這樣是無法正確執行的，因為 <code>IO.select</code> 行為是一個 Blocking I/O 的行為，不過我們可以將大量的 I/O 物件一次性的選取，只要有一個符合條件就可以解除。</p><p>而這段程式碼出問題的主因是，當開始後就會進入 <code>IO.select</code> 的阻塞狀態，但是伺服器的阻塞狀態並沒有被加入到其中管理，而造成無法正確運行。</p><p>因此，我們要將原本的程式碼再做出一些修正。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Fiber.new <span class="keyword">do</span></span><br><span class="line">  loop <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">      client = server.accept_nonblock</span><br><span class="line">      client.puts <span class="string">'Hello World'</span></span><br><span class="line"></span><br><span class="line">      Fiber.new <span class="keyword">do</span></span><br><span class="line">        buffer <span class="params">||</span>= <span class="string">''</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">          buffer &lt;&lt; client.read_nonblock(<span class="number">1024</span>)</span><br><span class="line">          puts buffer <span class="keyword">if</span> buffer.<span class="keyword">include</span>?(<span class="string">"\n"</span>)</span><br><span class="line">        <span class="keyword">rescue</span> IO::WaitReadable</span><br><span class="line">          selector.register(client)</span><br><span class="line">          <span class="keyword">retry</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span>.resume</span><br><span class="line">    <span class="keyword">rescue</span> IO::WaitReadable</span><br><span class="line">      selector.register(server)</span><br><span class="line">      <span class="keyword">retry</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>.resume</span><br><span class="line"></span><br><span class="line">loop <span class="keyword">do</span></span><br><span class="line">  selector.resume</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>不過修改之後，卻發現因為加入了 <code>Fiber.new</code> 給伺服器後，原本的 <code>retry</code> 和 <code>loop</code> 的角色似乎有點微妙，如果不使用 <code>loop</code> 的話，成功連線後就不會嘗試等待下一個新連線，而失敗的話不使用 <code>retry</code> 一樣也不會繼續嘗試處理新的連線，這樣整個工作分配變得有點混亂。</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>要解決這樣的問題，最為理想的狀態是在 <code>#accept_nonblock</code> 的下一行馬上使用 <code>Fiber.yield</code> 以便 <code>Fiber#resume</code> 發生時能夠繼續還未完成的動作。</p><p>在 Ruby 裡面大部分的 Nonblocking I/O 方法都提供了 <code>exception: false</code> 的選項，讓我們達成這個條件。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>雖然開始嘗試重構，但是馬上又發現程式碼變的複雜，在下一篇我們會先嘗試採取 <code>exception: false</code> 的做法調整 Fiber 繼續執行的流程，然後再做一次重構讓程式碼恢復乾淨的狀態。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/07/29/Talk-about-ruby-s-fiber-Part-6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>淺談 Ruby 的 Fiber（五）</title>
      <link>https://blog.frost.tw/posts/2018/07/24/Talk-about-ruby-s-fiber-Part-5/</link>
      <guid>https://blog.frost.tw/posts/2018/07/24/Talk-about-ruby-s-fiber-Part-5/</guid>
      <pubDate>Tue, 24 Jul 2018 12:24:31 GMT</pubDate>
      <description>
      
        &lt;p&gt;經過&lt;a href=&quot;https://blog.frost.tw/posts/2018/07/17/Talk-about-ruby-s-fiber-Part-4/&quot;&gt;上次&lt;/a&gt;的嘗試，我們已經開始對於 Fiber 的性質有一些了解，目前還需要解決已經結束的 Fiber 被呼叫，以及來不及處理的問題。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>經過<a href="https://blog.frost.tw/posts/2018/07/17/Talk-about-ruby-s-fiber-Part-4/">上次</a>的嘗試，我們已經開始對於 Fiber 的性質有一些了解，目前還需要解決已經結束的 Fiber 被呼叫，以及來不及處理的問題。</p><a id="more"></a><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>實際上在上週我們已經很明確的之到如果遇到 <code>dead fiber called (FiberError)</code> 錯誤，是表示 Fiber 已經無法再繼續執行。舉例來說，我們執行了三次 <code>Fiber.yield</code> 那麼這個 Fiber 最多只能執行四次（包含產生的那次）再多就會失敗。</p><p>而另一個問題則是我們在做 <code>#resume</code> 的時候總是在 <code>#accept_nonblock</code> 之後，所以當失敗的時候並不會優先的做 <code>#resume</code> 才重新檢查是否有人嘗試連線。</p><p>所以，我們只需要做一點小修改。</p><h2 id="嘗試"><a href="#嘗試" class="headerlink" title="嘗試"></a>嘗試</h2><p>首先，我們將 <code>fibers.each(&amp;:resume)</code> 的順序放到 <code>server.accept_nonblock</code> 之前，讓他在發生 <code>IO::WaitReadable</code></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">client = server.accept_nonblock</span><br><span class="line">client.puts <span class="string">'Hello World'</span></span><br><span class="line"></span><br><span class="line">fibers.each(&amp;<span class="symbol">:resume</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>所以會變成像這個樣子</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fibers.each(&amp;<span class="symbol">:resume</span>)</span><br><span class="line"></span><br><span class="line">client = server.accept_nonblock</span><br><span class="line">client.puts <span class="string">'Hello World'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>如此一來，我們就可以正常的讓伺服器進入等待的狀態。</p><p>不過當我們連上並且傳送一些訊息後，就會再次出現 <code>dead fiber called (FiberError)</code> 錯誤訊息，因為我們在關閉連線後並沒有把處理完畢的 Fiber` 清除掉。</p><p>所以我們還需要做下面的修改。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line">        buffer &lt;&lt; client.read_nonblock(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> buffer.<span class="keyword">include</span>?(<span class="string">"\n"</span>)</span><br><span class="line">          puts buffer</span><br><span class="line">          client.close</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>增加一行在 <code>client.close</code> 下方。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line">        buffer &lt;&lt; client.read_nonblock(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> buffer.<span class="keyword">include</span>?(<span class="string">"\n"</span>)</span><br><span class="line">          puts buffer</span><br><span class="line">          client.close</span><br><span class="line">          fibers.delete(fiber)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>到這一階段，我們大致上就算是讓 Fiber 正常運作。</p><p>不過當我們把 <code>client.close</code> 刪除，準備讓他變成聊天室的形式時，又會再次出現 <code>dead fiber called (FiberError)</code> 錯誤，因為我們並沒有繼續透過 <code>Fiber.yield</code> 讓他可以繼續執行。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>到這個階段，我們已經可以初步的使用 Fiber 並且控制運行的流程，但是繼離將簡易的 TCP 聊天室實作出來還差上一小段。下一篇開始我們會嘗試將 <code>client.close</code> 和 <code>fiber.delete(fiber)</code> 去除，並且嘗試加入一些輔助程式來讓他可以持續的接收資料。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/07/24/Talk-about-ruby-s-fiber-Part-5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>淺談 Ruby 的 Fiber（四）</title>
      <link>https://blog.frost.tw/posts/2018/07/17/Talk-about-ruby-s-fiber-Part-4/</link>
      <guid>https://blog.frost.tw/posts/2018/07/17/Talk-about-ruby-s-fiber-Part-4/</guid>
      <pubDate>Tue, 17 Jul 2018 11:17:26 GMT</pubDate>
      <description>
      
        &lt;p&gt;在上週的&lt;a href=&quot;https://blog.frost.tw/posts/2018/07/10/Talk-about-ruby-s-fiber-Part-3/&quot;&gt;文章&lt;/a&gt;我們注意到 Fiber 的使用並不是那麼容易的，因為我們需要自行管理每一個 Fiber 被恢復（&lt;code&gt;#resume&lt;/code&gt;）的時機，這週就繼續來挑戰吧！&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>在上週的<a href="https://blog.frost.tw/posts/2018/07/10/Talk-about-ruby-s-fiber-Part-3/">文章</a>我們注意到 Fiber 的使用並不是那麼容易的，因為我們需要自行管理每一個 Fiber 被恢復（<code>#resume</code>）的時機，這週就繼續來挑戰吧！</p><a id="more"></a><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>在上週我們已經知道需要將行為從原本會阻塞 I/O 的操作，轉換為非阻塞的操作。所以我們會進行以下的嘗試，來修正 Fiber 的運行。</p><ol><li>使用 <code>#accept_nonblock</code> 來取得用戶端</li><li>使用 <code>#read_nonblock</code> 來讀取使用者的資料</li></ol><h2 id="嘗試"><a href="#嘗試" class="headerlink" title="嘗試"></a>嘗試</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">server = TCPServer.new <span class="number">3000</span></span><br><span class="line"></span><br><span class="line">fibers = []</span><br><span class="line">loop <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">    client = server.accept_nonblock</span><br><span class="line">    client.puts <span class="string">'Hello World'</span></span><br><span class="line"></span><br><span class="line">    fibers.each(&amp;<span class="symbol">:resume</span>)</span><br><span class="line"></span><br><span class="line">    fiber = Fiber.new <span class="keyword">do</span></span><br><span class="line">      buffer <span class="params">||</span>= <span class="string">''</span></span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">        buffer &lt;&lt; client.read_nonblock(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> buffer.<span class="keyword">include</span>?(<span class="string">"\n"</span>)</span><br><span class="line">          puts buffer</span><br><span class="line">          client.close</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">rescue</span> IO::WaitReadable</span><br><span class="line">        puts <span class="string">'RETRY'</span></span><br><span class="line">        Fiber.<span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">retry</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    fiber.resume</span><br><span class="line">    fibers &lt;&lt; fiber</span><br><span class="line">  <span class="keyword">rescue</span> IO::WaitReadable</span><br><span class="line">    sleep <span class="number">1</span></span><br><span class="line">    <span class="keyword">retry</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我們對原本的做了一些修改，把 <code>#accept_nonblock</code> 和 <code>#read_nonblock</code> 加入到了程式碼中，在這邊我們可以利用 <code>retry</code> 關鍵字觸發重試的行為，讓我們遇到 <code>IO::WaitReadable</code> 錯誤時，可以自動地重新開始。</p><p>不過，我們還是發現了一些問題不太正常。</p><ol><li>依然要在第下一個連線開始後才會斷線</li><li>到第三次之後就不正常的斷線</li></ol><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先我們來分析一下為什麼還是無法在使用者輸入訊息後關閉連線。</p><ol><li>等待連線</li><li>重試（…）</li><li>第一個連線連上</li><li>執行 <code>fibers.each(&amp;:resume)</code> 動作</li><li>執行初次連線的 Fiber 生成和 <code>#resume</code> 動作</li><li>等待連線</li><li>重試（…）</li></ol><p>透過上面的流程，我們會發現要觸發使用者輸入訊息後斷線的行為，會因為「沒有人連上」的重試行為，一直被卡在 <code>#accept_nonblock</code> 這個狀態上（因為他會產生 <code>IO::WaitReadable</code> 錯誤）</p><p>而第二個錯誤，則是在第三次連線後，會出現 <code>dead fiber called (FiberError)</code> 這個錯誤訊息，這是因為當我們用盡 <code>Fiber.yield</code> 次數後，這個 Fiber 就無法再繼續進行 <code>#resume</code> 否則就會發生這個錯誤。</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>事實上，這兩個問題是一起發生的。假設我們先將 <code>fibers.each(&amp;:resume)</code> 放到 <code>#accept_nonblock</code> 前面，那麼很快地就會將 <code>dead fiber called</code> 這個錯誤觸發，所以我們還需要搭配在關閉連線時，將目前所屬的 Fiber 從 <code>fibers</code> 移除掉，才能夠確保程式正常運行。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>目前已經逐漸抓到一些線索，可以讓我們針對 Fiber 進行應用，基本上這次的錯誤修正後就可以獲得跟我們預期中一樣運行的 TCP Server 了。</p><p>不過，如果想要將它改寫成一個簡易的聊天室，又要怎麼做？會碰到什麼問題呢？</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/07/17/Talk-about-ruby-s-fiber-Part-4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>淺談 Ruby 的 Fiber（三）</title>
      <link>https://blog.frost.tw/posts/2018/07/10/Talk-about-ruby-s-fiber-Part-3/</link>
      <guid>https://blog.frost.tw/posts/2018/07/10/Talk-about-ruby-s-fiber-Part-3/</guid>
      <pubDate>Tue, 10 Jul 2018 13:35:01 GMT</pubDate>
      <description>
      
        &lt;p&gt;延續&lt;a href=&quot;https://blog.frost.tw/posts/2018/07/03/Talk-about-ruby-s-fiber-Part-2/&quot;&gt;上一篇&lt;/a&gt;文章的實作，我們已經有一個簡易的 Thread 版本 TCP Socket 伺服器可以運作，那麼該怎麼用 Fiber 修改呢？&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>延續<a href="https://blog.frost.tw/posts/2018/07/03/Talk-about-ruby-s-fiber-Part-2/">上一篇</a>文章的實作，我們已經有一個簡易的 Thread 版本 TCP Socket 伺服器可以運作，那麼該怎麼用 Fiber 修改呢？</p><a id="more"></a><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>在我們使用 Thread 的時候，應該要先執行哪個 Thread 中的任務會由作業系統或者語言本身底層的實作來協助我們處理，但是 Fiber 目前只能用來在不同的程式碼片段中切換，所以我們就需要自己管理應該要切換到哪一個片段。</p><p>所以我們要先定義一個情境：</p><p>當 Blocking I/O 發生的時候，會發生什麼事情？</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Server 嘗試讀取 Client 的資料</span></span><br><span class="line">resp = client.gets</span><br><span class="line"><span class="comment"># Blocking I/O 發生</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># 使用者輸入 HELLO</span></span><br><span class="line"><span class="comment"># Blocking I/O 結束</span></span><br><span class="line">puts resp</span><br><span class="line"><span class="comment"># =&gt; HELLO</span></span><br></pre></td></tr></table></figure><p>其實就是當我們嘗試做 Read（讀取）跟 Write（寫入）的時候，暫時無法操作的狀態。</p><p>Ex. 想讀取資料卻無法讀取</p><p>所以，根據上一篇文章的案例，當我們嘗試 <code>#gets</code> 卻沒有得到使用者的回應時，就應該先透過 <code>Fiber.yield</code> 把執行權限釋放出來。</p><h2 id="嘗試"><a href="#嘗試" class="headerlink" title="嘗試"></a>嘗試</h2><p>因為邏輯上跟以往我們習慣的方式不太一樣，所以我們需要進行多次的嘗試，讓 Fiber 可以像我們預期的一樣運作。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server = TCPServer.new <span class="number">3000</span></span><br><span class="line"></span><br><span class="line">fibers = []</span><br><span class="line">loop <span class="keyword">do</span></span><br><span class="line">  client = server.accept</span><br><span class="line">  client.puts <span class="string">'Hello World'</span></span><br><span class="line"></span><br><span class="line">  fibers.each(&amp;<span class="symbol">:resume</span>)</span><br><span class="line"></span><br><span class="line">  fiber = Fiber.new <span class="keyword">do</span></span><br><span class="line">    Fiber.<span class="keyword">yield</span></span><br><span class="line">    puts client.gets</span><br><span class="line">    client.close</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  fiber.resume</span><br><span class="line">  fibers &lt;&lt; fiber</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>這樣看起來好像會運作，不過當我們嘗試執行的時候，卻發現有一些奇怪的地方。</p><ol><li>輸入訊息後沒有馬上斷線</li><li>第二個人連上後才會斷線</li></ol><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>當第一個人連上後，會發生以下事情：</p><ol><li>先把 <code>fibers</code> 裡面存在的 Fiber 執行 <code>#resume</code> 一次</li><li>對這次連上的使用者產生一個 <code>Fiber</code></li><li>先執行一次（抵達第一次的 <code>Fiber.yield</code>）被暫停</li><li>將目前的 Fiber 物件儲存在 <code>fibers</code> 中</li><li>重新呼叫 <code>server.accept</code> -&gt; Blocking I/O</li></ol><p>第二個人連上後，會發生以下的事情</p><ol><li>先把 <code>fibers</code> 裡面存在的 Fiber 執行 <code>#resume</code> 一次</li><li>第一個連線的使用者執行 <code>#gets</code> 行為 -&gt; Blocking I/O</li></ol><p>到目前為止已經被 Blocking I/O 堵住兩次，還比原本沒有 Fiber 的版本更難懂，那麼問題出在哪裡呢？</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>首先，我們希望程式上遇到 Blocking I/O 時先不要卡住我們，所以我們需要將 <code>server.accept</code> 和 <code>client.gets</code> 這兩個行為調整成 Nonblocking I/O 的使用方式。</p><p>也就是當遇到 Blocking I/O 的時候我們希望直接回傳「沒有資料」之類的訊息給我們，而不是直接停住。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">loop <span class="keyword">do</span></span><br><span class="line">  puts <span class="string">'LOOPING'</span></span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">    client = server.accept_nonblock</span><br><span class="line">    <span class="comment"># 有人連上了！</span></span><br><span class="line">  <span class="keyword">rescue</span> IO::WaitReadable</span><br><span class="line">    <span class="comment"># 目前都沒有人連線！</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>以 <code>#accept_nonoblock</code> 這個用法作為例子，我們會發現，假設我們做 <code>puts &#39;LOOPING&#39;</code> 這段程式碼，如果是 <code>#accept</code> 的時候，需要有人連上才會顯示訊息，但是在 <code>#accept_nonblock</code> 的時候，則會不斷出現。</p><p>同時，我們也會得到一個叫做 <code>IO::WaitReadable</code> 的錯誤，告訴我們現在雖然讀取了，但是實際上是無法讀取任何東西的，需要等待有東西可以讀取。</p><p>透過這樣的機制，我們就可以在碰到這個錯誤時進行 <code>Fiber.yield</code> 先讓他暫停，等到我們確認他可以讀取後，再繼續執行。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>這篇文章我們發現如果使用 Thread 的話，基本上是由作業系統去管理碰到 Blocking I/O 時該怎麼做，但是如果是 Fiber 的話，我們就得完全靠 Ruby 來解決。</p><p>同時也會遇到某些情境無法使用的狀況，像是 <code>net/http</code> 這個標準函式庫，並沒有提供 Nonblocking I/O 的方法，我們就無法透過在 Blocking I/O 狀態下先讓他暫停，並且先切換到其他工作上。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/07/10/Talk-about-ruby-s-fiber-Part-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>淺談 Ruby 的 Fiber（二）</title>
      <link>https://blog.frost.tw/posts/2018/07/03/Talk-about-ruby-s-fiber-Part-2/</link>
      <guid>https://blog.frost.tw/posts/2018/07/03/Talk-about-ruby-s-fiber-Part-2/</guid>
      <pubDate>Tue, 03 Jul 2018 11:26:44 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;a href=&quot;https://blog.frost.tw/posts/2018/06/26/Talk-about-ruby-s-fiber-Part-1/&quot;&gt;第一篇&lt;/a&gt;我們已經大致上了解 Fiber 的運作原理，不過要能夠實際上的掌握跟應用，我認為是需要靠實作來熟悉的。&lt;/p&gt;
&lt;p&gt;所以，這一篇我們先來講學習 Socket 最常見的 TCP 伺服器實作吧！&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="https://blog.frost.tw/posts/2018/06/26/Talk-about-ruby-s-fiber-Part-1/">第一篇</a>我們已經大致上了解 Fiber 的運作原理，不過要能夠實際上的掌握跟應用，我認為是需要靠實作來熟悉的。</p><p>所以，這一篇我們先來講學習 Socket 最常見的 TCP 伺服器實作吧！</p><a id="more"></a><p>為了要比較 Fiber 和 Thread 版，這次我們會先用 TCPServer 來實做一個簡易的 TCP 伺服器，並且用來比較兩者的差異。</p><h2 id="TCPServer"><a href="#TCPServer" class="headerlink" title="TCPServer"></a>TCPServer</h2><p>首先，我們先用 Ruby 建立一個可以接收連線的 TCP 伺服器。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'socket'</span></span><br><span class="line"></span><br><span class="line">server = TCPServer.new <span class="number">3000</span></span><br><span class="line">loop <span class="keyword">do</span></span><br><span class="line">  client = server.accept</span><br><span class="line">  client.puts <span class="string">"HELLO WORLD"</span></span><br><span class="line">  client.close</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我們可以用 telnet 指令來做簡單的測試。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet localhost 3000</span><br></pre></td></tr></table></figure><p>目前的版本在連上之後就會馬上顯示 <code>HELLO WORLD</code> 然後關閉連線。</p><h2 id="Blocking-I-O"><a href="#Blocking-I-O" class="headerlink" title="Blocking I/O"></a>Blocking I/O</h2><p>那麼，我們希望接收來自使用者的訊息，會像這樣修改。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'socket'</span></span><br><span class="line"></span><br><span class="line">server = TCPServer.new <span class="number">3000</span></span><br><span class="line">loop <span class="keyword">do</span></span><br><span class="line">  client = server.accept</span><br><span class="line">  client.puts <span class="string">"HELLO WORLD"</span></span><br><span class="line">  puts client.gets</span><br><span class="line">  client.close</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>這個時候，如過我們用像這樣的順序進行操作，就會發現無法正常運作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 視窗一</span></span><br><span class="line">telnet localhost 3000 <span class="comment"># =&gt; 顯示 HELLO WORLD</span></span><br><span class="line"><span class="comment"># 視窗二</span></span><br><span class="line">telnet localhost 3000 <span class="comment"># =&gt; 沒有顯示</span></span><br></pre></td></tr></table></figure><p>這是因為在 <code>client.gets</code> 的時候發生了 Blocking I/O（I/O 阻塞）的情況，也就是操作因為 <code>#gets</code> 嘗試讀取，但是因為讀取不到而阻止接下來的程式執行。</p><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>在這個時候，我們可以透過幾種方式解決。</p><ol><li>Process</li><li>Thread</li><li>Fiber</li></ol><p>第一個方案因為是記憶體完全獨立的，所以我們就無法知道其他連線的用戶存在，所以一般來說不會使用。而 Thread 則是把 Process 切割後，遇到了一些情境像是 <code>sleep</code> 和 <code>Blocking I/O</code> 等情況，就會先把執行權轉交給其他 Thread 繼續執行。</p><p>所以，我們可以將程式修改成這樣。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'socket'</span></span><br><span class="line"></span><br><span class="line">server = TCPServer.new <span class="number">3000</span></span><br><span class="line">loop <span class="keyword">do</span></span><br><span class="line">  client = server.accept</span><br><span class="line">  client.puts <span class="string">"HELLO WORLD"</span></span><br><span class="line">  Thread.new <span class="keyword">do</span></span><br><span class="line">    puts client.gets</span><br><span class="line">    client.close</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如此一來，當我們碰到 Blocking I/O（<code>#gets</code>）的情況，就會先將目前佔用的 Thread 轉交給其他可以繼續執行的 Thread 身上，先執行任務。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>這篇文章簡單的介紹了 Thread 的使用方式，以及該如何避免遇到 Blocking I/O 的處理方式，下一篇就來看看透過 Fiber 的流程控制機制，是怎樣迴避這個問題的。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/07/03/Talk-about-ruby-s-fiber-Part-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>淺談 Ruby 的 Fiber（ㄧ）</title>
      <link>https://blog.frost.tw/posts/2018/06/26/Talk-about-ruby-s-fiber-Part-1/</link>
      <guid>https://blog.frost.tw/posts/2018/06/26/Talk-about-ruby-s-fiber-Part-1/</guid>
      <pubDate>Tue, 26 Jun 2018 12:29:19 GMT</pubDate>
      <description>
      
        &lt;p&gt;前陣子再研究 Ruby 從 1.9.3 就開始提供的 Fiber 該怎麼使用，不過網路上的資料大多都只是簡單的討論。那麼 Fiber 到底是什麼呢？這系列的文章會詳細的介紹 Fiber 的基本概念，還有一些可以應用的方式。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>前陣子再研究 Ruby 從 1.9.3 就開始提供的 Fiber 該怎麼使用，不過網路上的資料大多都只是簡單的討論。那麼 Fiber 到底是什麼呢？這系列的文章會詳細的介紹 Fiber 的基本概念，還有一些可以應用的方式。</p><a id="more"></a><p>原本只想一篇文章寫完，但是其實 Fiber 需要大量的改變以往習慣的思考模式，所以還是用系列文來呈現比較恰當。</p><h2 id="概觀"><a href="#概觀" class="headerlink" title="概觀"></a>概觀</h2><p>所以，Fiber 是怎樣的東西呢？從 Ruby 文件上的第一句話可以看到。</p><blockquote><p>Fibers are primitives for implementing light weight cooperative concurrency in Ruby.</p></blockquote><p>他是用來實作 Concurrency 的標準函式庫，當時看到這裡我就想到 Golang 的 Goruntine 機制，可以像這樣的去實現非同步的操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resp</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Write Later ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Respond now ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以在 Ruby 中使用 Fiber 應該也要一樣簡單才對吧！</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resp</span></span></span><br><span class="line">  Fiber.new <span class="keyword">do</span></span><br><span class="line">    <span class="comment"># Write Later ...</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># Respond now ...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>不過很可惜，這樣是不會像 Golang 一樣運作的！</p><blockquote><p>所以我每次講到 Fiber 的運作，都要跟同事說 Ruby 增加 AutoFiber (<a href="https://ruby-china.org/topics/34992" target="_blank" rel="noopener">RubyChina 介紹</a>) 是因為大家都不懂怎麼用。</p></blockquote><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>有一些文章會提到 Fiber 是一種「流程控制」的工具，主要是因為 <code>Fiber</code> 可以利用 <code>Fiber.yield</code> 和 <code>#resume</code> 來切換要繼續執行的部分。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">f1 = Fiber.new <span class="keyword">do</span></span><br><span class="line">  puts <span class="string">'A'</span></span><br><span class="line">  Fiber.<span class="keyword">yield</span></span><br><span class="line">  puts <span class="string">'B'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">f2 = Fiber.new <span class="keyword">do</span></span><br><span class="line"> puts <span class="string">'C'</span></span><br><span class="line"> Fiber.<span class="keyword">yield</span></span><br><span class="line"> puts <span class="string">'D'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">f1.resume <span class="comment"># =&gt; A</span></span><br><span class="line">f2.resume <span class="comment"># =&gt; C</span></span><br><span class="line">f1.resume <span class="comment"># =&gt; B</span></span><br><span class="line">f2.resume <span class="comment"># =&gt; D</span></span><br></pre></td></tr></table></figure><p>由上面的範例來看，我們會發現 Fiber 在 <code>Fiber.yield</code> 之後，其實就離開原本執行的 Context (Block) 然後其他人就可以繼續執行他想執行的東西。</p><blockquote><p>這邊的 Context 指的是一個方法包含起來的範圍，在 Ruby 裡面 Block 基本是是透過 <code>Proc.new</code> 實現的，而方法的本體也是。不過要注意的是 Fiber 是可以跟外部交換變數的，這也是 Golang 要用 Channel 機制來交換 Goroutine 的資料，確保類似 Thread 實現的 Race Condition 問題不會發生。</p></blockquote><h2 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h2><p>一次性的獲取這樣充滿衝擊性的資訊可能對大家有點吃力，我們稍微修改前面的範例改成類似 JavaScript 的 Generator 機制來習慣一下這樣的變化。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">f = Fiber.new <span class="keyword">do</span></span><br><span class="line"> counter = <span class="number">0</span></span><br><span class="line"> loop <span class="keyword">do</span></span><br><span class="line">  Fiber.<span class="keyword">yield</span> counter += <span class="number">1</span></span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">puts f.resume <span class="comment"># =&gt; 1</span></span><br><span class="line">puts f.resume <span class="comment"># =&gt; 2</span></span><br></pre></td></tr></table></figure><p>上面這個調整的版本我們用了一個 <code>loop</code> 當作無限迴圈，但是實際上並不會阻塞我們進行後續的操作，因為 <code>Fiber.yield</code> 可以暫時的跳出目前執行的 Context 把它暫停，而在執行 <code>#resume</code> 的時候才會繼續執行到下一個 <code>Fiber.yield</code> 被呼叫。</p><p>所以，如果想實現一個類似 Generator 的行為，可以像這樣封裝。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generator</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:counter</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></span><br><span class="line">    @counter = <span class="number">0</span></span><br><span class="line">    @fiber = Fiber.new <span class="keyword">do</span></span><br><span class="line">      loop <span class="keyword">do</span></span><br><span class="line">        Fiber.<span class="keyword">yield</span> @counter += <span class="number">1</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">next</span></span></span><br><span class="line">    @fiber.resume</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">generator = Generator.new</span><br><span class="line">puts generator.<span class="keyword">next</span></span><br><span class="line">puts generator.<span class="keyword">next</span></span><br><span class="line">puts <span class="string">"Counter: <span class="subst">#&#123;generator.counter&#125;</span>"</span></span><br></pre></td></tr></table></figure><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>透過 Fiber 這樣的特性，我們可以做到一些非同步的行為，但是又不需要依賴其他的 Ruby Gem 或者 C Extension 來實現，另一方面根據 Ruby Doc 表示，產生一個 Fiber 佔用的記憶體是 4K 左右的堆疊大小，相對於產生 Thread 都要輕量不少。</p><blockquote><p>所以從以前以 Process 之後加入 Thread 到現在的 Concurrency 機制，剛好就是三個不同記憶體使用量級，在適合的情況下使用適當的機制可以讓程式更加易讀跟好用（不過 Fiber 沒封裝好會很難讀就是了 XD）</p></blockquote><p>下一篇開始會用一些範例來示範，不然這篇文章也要跟目前能找到的資料一樣沒有講到大家最關心的實際應用。因為跟 I/O Blocking 相關的機制很搭，所以後面會介紹像是非同步的 HTTP 請求跟不用 Thread 的 TCP 伺服器等等。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/06/26/Talk-about-ruby-s-fiber-Part-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>如何在國外演講</title>
      <link>https://blog.frost.tw/posts/2018/06/19/How-do-I-prepare-a-speech/</link>
      <guid>https://blog.frost.tw/posts/2018/06/19/How-do-I-prepare-a-speech/</guid>
      <pubDate>Tue, 19 Jun 2018 11:30:45 GMT</pubDate>
      <description>
      
        &lt;p&gt;今年在 &lt;a href=&quot;https://rubykaigi.org/2018&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RubyKaigi&lt;/a&gt; 有一場 Lightning Talk 分享，在後台準備跟等待上場的時候發現一件事情。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前面的人都邊發抖邊講&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以這篇文章來分享一下我的方法跟心得。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>今年在 <a href="https://rubykaigi.org/2018" target="_blank" rel="noopener">RubyKaigi</a> 有一場 Lightning Talk 分享，在後台準備跟等待上場的時候發現一件事情。</p><p><strong>前面的人都邊發抖邊講</strong></p><p>所以這篇文章來分享一下我的方法跟心得。</p><a id="more"></a><h2 id="怕，很正常"><a href="#怕，很正常" class="headerlink" title="怕，很正常"></a>怕，很正常</h2><p>像是 RubyKaigi 你一上台，台下是大概有 1000 多人在看著你。如果你覺得這樣都不會發抖的話，我反而覺得不正常。</p><p>所以，會發抖很正常。</p><p>就我自己的經驗來說，大概是在某一年的 COSCUP 我也上台講了一場 Lightning Talk 台下也是約有將近 1000 人，我確實是在發抖的。</p><p>而前面幾次的演講，其實都是在發抖的狀態下演講。</p><blockquote><p>你不怕，反而比較不正常！</p></blockquote><h2 id="預備動作"><a href="#預備動作" class="headerlink" title="預備動作"></a>預備動作</h2><p>一般來說，上台前大家可能會一直看簡報之類的。畢竟誰都不想在台上講的差，不過開始前五分鐘的話，最好的做法應該是作預備動作。</p><p>什麼是預備動作呢？</p><p>以我自己來說，就是先閉上眼睛深呼吸幾次。然後盡量的不要去思考或回憶簡報的內容，讓自己處於一個放空的狀態。</p><p>因為上台前如果很緊張的話，其實是會覺得冷（即使冷氣沒有很冷）然後心跳慢慢的加速。</p><p>所以最重要的是先讓自己處於一個放鬆的狀態，控制心跳（覺得冷應該沒救）讓自己處於一個可以控制的狀態，上台的時候才比較不會緊張。</p><h2 id="視線的控制"><a href="#視線的控制" class="headerlink" title="視線的控制"></a>視線的控制</h2><p>上台之後，要讓演講的狀態看起來是很「厲害」的話，就肯定不能低頭看著螢幕去講。所以要練習控制視線，也就是「不時的注視台下觀眾」這點。</p><p>不過只要看到下面的人，其實難免會緊張。所以就會有一些技巧，比較常見的就是看天花板之類的，我自己的話主要會用兩種。</p><ol><li>找看看在現場認識的人</li><li>掃過最近跟最遠的人</li></ol><p>這邊的技巧其實是不要「看仔細」只要用眼角的餘光看一下就好，時機點的話基本上我都會用下面的循環。</p><ol><li>看螢幕上的簡報</li><li>抬頭看觀眾</li><li>把視線放在只能看到幾個人的位置</li><li>開始講</li></ol><h2 id="演講的內容"><a href="#演講的內容" class="headerlink" title="演講的內容"></a>演講的內容</h2><p>我認為這個就很看人，以我自己來說我是<strong>不背稿</strong>的類型，也就是我看到簡報就知道我該講什麼，好處是時間的控制跟針對現場狀況調整是比較容易的。</p><blockquote><p>不過據說很難做到，我是認為當我準備充分的時候就沒問題。</p></blockquote><p>另一種就是背稿，把要講的時間跟內容都準備好，然後在現場把他盡可能的完整還原出來。兩種方法都沒有什麼問題，不過一樣要注意就是。</p><p>簡報的註解（雙螢幕通常可以看到）不要寫完整的講稿，投影片也是。這算是做簡報的技巧，而講稿的註解以「提醒這一頁要講什麼」為主，就是幫助回憶。</p><p>如果投影片內容太多，或者註解是完整的內容。就很容易變成用念的，尤其是在緊張的時候。所以盡量用一句話表達，如果掌握得不太好或者擔心的話，就把頁面切分多一點。</p><p>舉例來說，一句話大約是 20 秒好了，準備 60 頁所以是 1,200 秒，也就約略於 20 分鐘，那麼只要準備 120 頁，即使一頁一句話，只要控制好速度也能夠很穩的演講完畢。</p><blockquote><p>以我自己的經驗 40 分鐘的演講從 30 ~ 100 頁的情況都有，看內容而定。</p></blockquote><h2 id="相信自己"><a href="#相信自己" class="headerlink" title="相信自己"></a>相信自己</h2><p>不記得有沒有跟人說過，不過這邊提一下，很適合這個情況。</p><p>「如果你都不相信自己，要怎麼讓別人相信你。」</p><p>不管是去面試或者在工作上，我認為至少要表現得有自信一點，不然呈現出沒把握的狀態時，不管客戶或者同事都會跟著覺得沒把握。</p><p>上台演講也是一樣，既然都花時間準備，講的東西也是自己花了很長一段時間累積的經驗。不管怎麼樣，在台上講的東西都會很精彩才對（不過可能很無聊）所以站到台上的瞬間，就什麼都不要管了，專注在自己的演講上。</p><blockquote><p>不過也會有看起來沒啥準備就跑上來混的拉，這個就不討論了 XD</p></blockquote><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>其實不管怎麼樣，剛開始第一次或者第二次的演講都是會非常緊張的。所以要先從一些比較小規模的活動，以 Ruby 圈來說就是 Taipei.rb 這類不定期聚會，先對 20 ~ 60 人作發表，習慣在演講途中被注視的感覺。</p><p>之後再慢慢往研討會，像是 RubyConf TW 之類的嘗試，從 100 ~ 200 人左右的開始慢慢習慣，等養成了固定的習慣之後，只要演講前的「前置動作」有做好，大多數時候表現的都不會太差。</p><p>在三年前第一次去 RubyKaigi 演講的時候，已經在台灣有大概 5 ~ 10 次上台分享的經驗。不過當時比較可惜的是第一次在國外用英文，英文的程度也勉強到可以簡單的對話而已，所以實際上並不流暢（當然也很緊張）</p><p>今年稍微習慣之後，就能用比較順暢的方式在台上做分享了。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/06/19/How-do-I-prepare-a-speech/#disqus_thread</comments>
    </item>
    
    <item>
      <title>RubyKaigi 2018 會後心得</title>
      <link>https://blog.frost.tw/posts/2018/06/12/The-RubyKaigi-2018-Experience/</link>
      <guid>https://blog.frost.tw/posts/2018/06/12/The-RubyKaigi-2018-Experience/</guid>
      <pubDate>Tue, 12 Jun 2018 13:28:36 GMT</pubDate>
      <description>
      
        &lt;p&gt;今年的 RubyKaigi 比去年提早不少，作為 Ruby 開發者最大的盛會，今年也不意外的延續去年探討 Ruby 3 的可能性跟更多 Ruby 的深度應用。也因次，不意外的讓大家都聽的似懂非懂，而且還讓我感覺一年比一年的難度更高。&lt;/p&gt;
&lt;p&gt;總之，來看看今年的 RubyKaigi 吧！&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>今年的 RubyKaigi 比去年提早不少，作為 Ruby 開發者最大的盛會，今年也不意外的延續去年探討 Ruby 3 的可能性跟更多 Ruby 的深度應用。也因次，不意外的讓大家都聽的似懂非懂，而且還讓我感覺一年比一年的難度更高。</p><p>總之，來看看今年的 RubyKaigi 吧！</p><a id="more"></a><h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><p>因為飛機的關係，我們提早一天飛到日本。雖然跟平常上班一樣時間出門，不過從機場候機到旅館，已經是晚上七八點了。所以我們就在旅館附近找間燒肉店稍微吃了一下。</p><p><img src="https://blog.frost.tw/images/the-rubykaigi-2018-experience/EE88DB6FB245BFAEC9D20ED81425CC10.jpg" alt="2018-05-29 21.05.30.jpg"></p><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><p>因為提早一天，所以今天基本上就是體驗在日本遠端工作的感覺。不過實際上其實能做的事情不多，再加上中午去吃完仙台有名的牛舌後，馬上跑去附近買衣服。因為這次的旅館剛好都沒有可以投幣洗衣，送洗的話一件大概可以買一件新衣服，因為回來的路上順路就順便買了一下。</p><p><img src="https://blog.frost.tw/images/the-rubykaigi-2018-experience/95C6311914F56CD7F7A815208649A0CA.jpg" alt="2018-05-30 13.52.02-1.jpg"></p><p>晚上則是 Pre-Party 簡單來說就是從這個時間點開始，喝酒！</p><h2 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h2><p>依照慣例，都是由 Ruby 之父 Matz 進行開場，而口譯也是跟往年一樣讓人非常想睡。</p><blockquote><p>因為讓人很想睡的原因，所以以下就盡量依照記憶紀錄一下。</p></blockquote><h2 id="Analyzing-and-Reducing-Ruby-Memory-Usage"><a href="#Analyzing-and-Reducing-Ruby-Memory-Usage" class="headerlink" title="Analyzing and Reducing Ruby Memory Usage"></a>Analyzing and Reducing Ruby Memory Usage</h2><p>算是非常實用的一場演講，裡面介紹了一些方法去分析在 Ruby 裡面跟怎麽去分析記憶體使用的方法。不過很明顯的，中間那段都睡死了，幾乎沒有印象。只有很零碎的記憶，大概需要靠看投影片或者錄影才能回憶起來了。</p><h2 id="午餐"><a href="#午餐" class="headerlink" title="午餐"></a>午餐</h2><p>其實跟京都（2016）年比起來，我覺得便當品質差了很多。但是也可能是因為京都那邊對這種精緻食品比較擅長吧，去年因為是自由覓食，附近又有商店街所以反而沒有這樣的問題。</p><p><img src="https://blog.frost.tw/images/the-rubykaigi-2018-experience/10B903ACACBB43486711ACACFEFEA2FD.jpg" alt="2018-05-31 11.52.27.jpg"></p><h2 id="TTY-Ruby-alchemist’s-secret-potion"><a href="#TTY-Ruby-alchemist’s-secret-potion" class="headerlink" title="TTY - Ruby alchemist’s secret potion"></a>TTY - Ruby alchemist’s secret potion</h2><p>如果有用過 Google 的 Fastlane 來自動化 App 的打包跟部屬的話，講者花了五年所寫的 <code>tty</code> gem 就是背後的元件之一，這個 <code>tty</code> gem 裡面有非常多不同的功能，像是顯示表格、進度條等等。</p><p>如果想要寫一些 Command Line 工具卻不知道該怎麼下手的話，可以考慮使用這系列的 Gem 來輔助。</p><blockquote><p>自己是習慣在不使用 Gem 的狀況下開發，不過有很多功能透過這套 Gem 來協助可以得到比較好的使用者體驗。</p></blockquote><h2 id="Lightning-Talk"><a href="#Lightning-Talk" class="headerlink" title="Lightning Talk"></a>Lightning Talk</h2><p>因為要準備 Lightning Talk 所以錯過了幾場，雖然今年還是沒有順利的投稿上。但是運氣不錯還是獲得了五分鐘讓我發表 <code>tamashii-bluetooth</code> 這個新的 Gem 給大家。</p><p>雖然原本想作為 2019 年的主題之一，不過趁著還沒有被忘記就趕快上台發表一下這個從 BLE (Bluetooth Low Engery) 技術所衍伸的 iBeacon / EddenStone 應用，透過 <code>tamashii-bluetooth</code> 就可以輕鬆實現像是 LINE Beacon 之類的功能。</p><h2 id="Offical-Party"><a href="#Offical-Party" class="headerlink" title="Offical Party"></a>Offical Party</h2><p>依照慣例會有 Offical Party 跟當地的特色食物跟酒，不過依舊是日本人立場強大。不過有碰到客戶公司的工程師，合作半年多這麼久第一次見面。倒是客戶對我的工作狀況蠻滿意的讓我很意外，畢竟總覺得因為一直在解 Bug 感覺進度一直都不多。</p><h2 id="Controlling-Droids™-with-mruby-amp-Go"><a href="#Controlling-Droids™-with-mruby-amp-Go" class="headerlink" title="Controlling Droids™ with mruby &amp; Go"></a>Controlling Droids™ with mruby &amp; Go</h2><p>這場原本還蠻期待看到 mruby 跟 C 語言搭配使用，不過現場聽了之後反而有點失望。單純只是利用 Golang 來處理底層的問題，至於 mruby 只是作為一個腳本語言嵌入到 Golang 裡面來實作。</p><p>不過也得到一個靈感，就是明年可以考慮把 <code>tamashii-bluetooth</code> 更加完善，然後提供一個純 C 跟 Ruby 的實作。</p><h2 id="Guild-Prototype"><a href="#Guild-Prototype" class="headerlink" title="Guild Prototype"></a>Guild Prototype</h2><p>這場在 RubyElixirConf 2018 其實也有講，不過因為作為工作人員所以無法聽到。不過因為大致上的實作在台灣朋友都跟我解釋過，所以對 Guild 已經比較有概念。</p><h2 id="mruby-can-be-more-lightweight"><a href="#mruby-can-be-more-lightweight" class="headerlink" title="mruby can be more lightweight"></a>mruby can be more lightweight</h2><p>這場比較失望，原本以為會有一些關於 mruby 優化調整或者修改的部分，不過大多還是針對 Matz 在設計 mruby 上可調整的選項上來做處理，所以實際上並沒有什麼太多的突破。</p><h2 id="Firmware-programming-with-mruby-c"><a href="#Firmware-programming-with-mruby-c" class="headerlink" title="Firmware programming with mruby/c"></a>Firmware programming with mruby/c</h2><p>這場就讓我比較驚訝，在台灣蠻有名的獺祭清酒的相關監控，就是透過這套 mruby/c 的 IoT 裝置來做監控，而且不像是 mruby 是設計給 CPU 等級的硬體，而是給 MCU 這種幾乎只有非常小的記憶體可以使用的硬體。</p><p><img src="https://blog.frost.tw/images/the-rubykaigi-2018-experience/13538EFCE8A9329EBB787B50C63CA73B.jpg" alt="2018-06-01 14.45.00.jpg"></p><h2 id="ESM-Drink-up"><a href="#ESM-Drink-up" class="headerlink" title="ESM Drink-up"></a>ESM Drink-up</h2><p>再來就是據說清酒很強的 ESM 贊助商 Party 了，這兩年都有機會去到算是運氣蠻不錯的。不過還是一樣有強大的日本人力場在，讓人不禁地覺得應該要學一下日文才行。</p><p><img src="https://blog.frost.tw/images/the-rubykaigi-2018-experience/DB871BE6142FE005F2C5170398539BBA.jpg" alt="2018-06-01 19.15.40.jpg"></p><h2 id="第三天-1"><a href="#第三天-1" class="headerlink" title="第三天"></a>第三天</h2><p>因為很想睡（一般來說第二天會特別狂歡）所以上午幾乎都在睡，下午有印象的大概就只有一場。</p><h2 id="Three-Ruby-performance-projects"><a href="#Three-Ruby-performance-projects" class="headerlink" title="Three Ruby performance projects"></a>Three Ruby performance projects</h2><p>算是去年比較震撼的一場，講者是 RedHat 的工程是 GCC 的貢獻者，所以在 Compiler 上面有非常多不同獨到的見解，不過每次也是最為燒腦的議程。每年也可以學到一些不一樣的知識，不過大多都非常難以理解，以及回到台灣後需要查詢不少資料才能搞懂。</p><h2 id="After-Party"><a href="#After-Party" class="headerlink" title="After Party"></a>After Party</h2><p>晚上的 After Party 是在一間蠻大的酒吧，原本是想早點回去，畢竟日文立場還是很強大的。後來幾位同事想要去唱日本的卡拉 OK 想想覺得可以順便練習一下日文，就跟著過去。</p><p><img src="https://blog.frost.tw/images/the-rubykaigi-2018-experience/ED4E33737BF002BDF65739EAB77D58B5.jpg" alt="2018-06-02 23.26.58.jpg"></p><h2 id="東京"><a href="#東京" class="headerlink" title="東京"></a>東京</h2><p>因為要去拜訪客戶所以還安排了到東京的行程，在地圖上感覺是往北結果是往南。到了東京才發現仙台的天氣真的超讚，在台灣可能有三十幾度的溫度下，在仙台還是只有二十幾度，非常的舒適。</p><p>比較特別的就是同事有預約到 Persona 5 的主題餐廳，以及在秋葉原終於理解夾娃娃機該怎麼夾。</p><p><img src="https://blog.frost.tw/images/the-rubykaigi-2018-experience/F87A7CB27AB13B8B604F16B071BA7CEC.jpg" alt="2018-06-03 18.35.42.jpg"></p><p><img src="https://blog.frost.tw/images/the-rubykaigi-2018-experience/5C138CFC021AA9946D6907837313D5C8.jpg =3096x5504" alt="2018-06-04 11.35.43.jpg"></p><p>最後則是去拜訪一下客戶，然後就結束這次的日本行程。</p><p>另外比較的別的是日本有不少電腦書都是動漫風格的，有漫畫的電腦書超想要的！！</p><p><img src="https://blog.frost.tw/images/the-rubykaigi-2018-experience/BEFCEC952C4A354900876931339F3EC0.jpg =3096x5504" alt="2018-06-04 14.11.51.jpg"></p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>每年參加完 RubyKaigi 之後都會覺得蠻熱血的，因為有不少新的技術跟想法被提出來。不過每年都要提早一個月，填坑都來不及了還要想辦法投稿，大概也是另一種壓力來源吧。</p><blockquote><p>希望明年投稿之前可以把要投稿的題目實作出來。</p></blockquote>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/06/12/The-RubyKaigi-2018-Experience/#disqus_thread</comments>
    </item>
    
    <item>
      <title>我的 Chrome 會說話</title>
      <link>https://blog.frost.tw/posts/2018/05/30/My-Chrome-can-speak/</link>
      <guid>https://blog.frost.tw/posts/2018/05/30/My-Chrome-can-speak/</guid>
      <pubDate>Wed, 30 May 2018 04:44:30 GMT</pubDate>
      <description>
      
        &lt;p&gt;這是很多年前的事情了，當時看到別人的 Chrome 竟然會說話，讓我震驚了很久。但是花了很多年都沒有找到要怎麼做，不過最近因為一些關係，我終於知道了他的秘密！&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>這是很多年前的事情了，當時看到別人的 Chrome 竟然會說話，讓我震驚了很久。但是花了很多年都沒有找到要怎麼做，不過最近因為一些關係，我終於知道了他的秘密！</p><a id="more"></a><p>首先，這不是鬼故事！這篇文章要討論的是 Web Speech API 這個由 Google 所提交的功能。主要就是做「語音轉文字」跟「文字轉語音」兩件事情，像是有在玩遊戲可能有用過 Discord 這種類似 Slack 的通訊軟體，裡面提供的朗讀功能應該就是透過這個 API 實作的。</p><h2 id="Web-Speech-API"><a href="#Web-Speech-API" class="headerlink" title="Web Speech API"></a>Web Speech API</h2><p>在 Web Speech API 裡面其實只有兩個功能「語音轉文字」跟「文字轉語音」兩種。文字轉語音的功能可能比較常見，我們可以在像是在一些地方看到。</p><p>像是 Google 搜尋右邊的「麥克風」圖示，就是利用 Web Speech API 所製作的功能，讓我們可以利用講話的方式直接輸入搜尋的關鍵字。</p><p><img src="https://blog.frost.tw/images/my-chrome-can-speak/screenshot.png" alt="Google 搜尋的語音框"></p><p>另外就是將文字念出來，也就是這篇文章要討論的內容。</p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>那麼，要怎麼讓 Chrome （或者 Firefox 發出聲音呢？）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="keyword">new</span> SpeechSynthesisUtterance(<span class="string">'Hello World'</span>);</span><br><span class="line"><span class="built_in">window</span>.speechSynthesis.speak(msg);</span><br></pre></td></tr></table></figure><p>首先，我們要產生出一個 <code>SpeechSynthesisUntterance</code> 物件，把要講的東西放進去。然後再透過 <code>speechSynthesis</code> 提供的 <code>speak</code> 把他唸出來。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="keyword">new</span> SpeechSynthesisUtterance(<span class="string">'世界你好！'</span>);</span><br><span class="line"><span class="built_in">window</span>.speechSynthesis.speak(msg);</span><br></pre></td></tr></table></figure><p>當然，講中文也是完全沒有問題的。</p><blockquote><p>主要是這個 API 預設會用作業系統（Ex. macOS 的 VoiceOver 功能）所以不管是哪個瀏覽器預設都會用同樣的聲音講話。</p></blockquote><h2 id="調整語音"><a href="#調整語音" class="headerlink" title="調整語音"></a>調整語音</h2><p>因為作業系統中可能會針對各種國家的語言提供語音，所以同樣是中文，我們也可以從 <code>zh-TW</code> 切換到 <code>zh-HK</code> 讓他用廣東話的方式念出來。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> voices = <span class="built_in">window</span>.speechSynthesis.getVoices();</span><br><span class="line"><span class="keyword">var</span> msg = <span class="keyword">new</span> SpeechSynthesisUtterance(<span class="string">'世界你好！'</span>);</span><br><span class="line">msg.voice = voices[<span class="number">35</span>]; <span class="comment">// 每台電腦/瀏覽器結果可能略有不同</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.speechSynthesis.speak(msg);</span><br></pre></td></tr></table></figure><blockquote><p>目前似乎只有 Safari 可以正常使用，其他瀏覽器不一定可以用。</p></blockquote><p>另外就是 <code>SynthesisUtterance</code> 還有幾個參數可以玩。</p><ul><li><code>pitch</code> - 語調 0 ~ 2 設定，越大音越高</li><li><code>volume</code> - 音量</li></ul><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>這個功能在某些應用情境，像是聊天機器人。或者類似 Discord 這種通訊軟體，算是很有用的。不過似乎很少人在討論，就算是 Google 查詢「Speech API」也還不一定會看到，不過作為一個有趣的小功能倒是值得一試。</p><blockquote><p>印象中可以選擇男聲或者女聲，但是找不到。也許是 Chrome 裡面提供的語音包才有，不過目前 Chrome (66.0) 似乎切換語音不太正常，就暫時無法測試。</p></blockquote><hr><h2 id="參考文章"><a href="#參考文章" class="headerlink" title="參考文章"></a>參考文章</h2><ul><li><a href="http://blog.zhusee.in/post/56286985943/web-speech-api-part-i-using-speech-synthesis-to-make-bro" target="_blank" rel="noopener">http://blog.zhusee.in/post/56286985943/web-speech-api-part-i-using-speech-synthesis-to-make-bro</a></li><li><a href="https://developers.google.com/web/updates/2014/01/Web-apps-that-talk-Introduction-to-the-Speech-Synthesis-API" target="_blank" rel="noopener">https://developers.google.com/web/updates/2014/01/Web-apps-that-talk-Introduction-to-the-Speech-Synthesis-API</a></li></ul>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/05/30/My-Chrome-can-speak/#disqus_thread</comments>
    </item>
    
    <item>
      <title>部署你的第一個 Ruby on Rails 網站（八）</title>
      <link>https://blog.frost.tw/posts/2018/05/28/Getting-started-deploy-your-Ruby-on-Rails-Part-8/</link>
      <guid>https://blog.frost.tw/posts/2018/05/28/Getting-started-deploy-your-Ruby-on-Rails-Part-8/</guid>
      <pubDate>Mon, 28 May 2018 06:54:19 GMT</pubDate>
      <description>
      
        &lt;p&gt;前面幾篇文章已經把所有關於 Ruby 和資料庫都設定完成，最後一個階段就是要把 Nginx 設定好，並且讓 Let’s Encrypt 可以正確的被設定，讓網站支援 SSL 功能。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>前面幾篇文章已經把所有關於 Ruby 和資料庫都設定完成，最後一個階段就是要把 Nginx 設定好，並且讓 Let’s Encrypt 可以正確的被設定，讓網站支援 SSL 功能。</p><a id="more"></a><p>在開始設定之前，因為 Let’s Encrypt 針對非 Wildcard 類型可以使用檔案驗證，也是一般情況比較多使用的方式。但是第一次的驗證需要透過 HTTP 來進行，所以我們會先設定好 Let’s Encrypt 後才繼續。</p><blockquote><p>Wildcard 需要用 DNS 驗證，這是第二代的 API 才新增的功能，過去第一代都是透過放置驗證檔案來認證。</p></blockquote><h2 id="Let’s-Encrypt-設定"><a href="#Let’s-Encrypt-設定" class="headerlink" title="Let’s Encrypt 設定"></a>Let’s Encrypt 設定</h2><p>目前最簡單的設定方式就是透過 Certbot 來驗證，可以到官網的 <a href="https://certbot.eff.org/lets-encrypt/centosrhel7-other" target="_blank" rel="noopener">CentOS 7</a> 頁面獲取安裝的指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install certbot</span><br></pre></td></tr></table></figure><blockquote><p>如果找不到 <code>certbot</code> 的套件，請先安裝 EPEL <code>yum install epel-release</code> 來獲得支援，不過在 PostgreSQL 安裝的步驟應該是已經安裝過了。</p></blockquote><blockquote><p>這邊不使用 <code>certbot-nginx</code> 版本的原因是我們自己 Compile 了 Nginx 可能會互相影響。</p></blockquote><p>接下來要對 Nginx 做設定，一般來說如果伺服器上預定要安裝多個網站，我們會在 <code>/opt/nginx/conf</code> 下面增加像是 <code>sites-enabled</code> 之類的資料夾放置。不過稍微複雜，這篇文章會以直接編輯 <code>nginx.conf</code> 的方式介紹。</p><p>我們先找到檔案中 <code>server {</code> 這一段，類似下面的地方。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name localhost;</span><br><span class="line">  </span><br><span class="line">  # ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然後加入 Let’s Encrypt 需要的設定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name localhost;</span><br><span class="line">  </span><br><span class="line">  location ~ /.well-known &#123;</span><br><span class="line">    allow all;</span><br><span class="line">    root /opt/nginx/html;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  # ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這個設定會讓遇到 <code>~/.well-known</code> 開頭的頁面，都使用 <code>/opt/nginx/html</code> 這個目錄，如此一來就能夠讓 Certbot 把驗證用的檔案放在這裡面，讓 Let’s Encrypt 可以驗證到。</p><blockquote><p>如果有使用像是 OpenID 之類的，可能會互相干擾，需要調整設定值。</p></blockquote><p>完成設定後，我們用 Certbot 執行產生 SSL 憑證的指令，將網站需要的憑證生成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo certbot certonly --webroot -w /opt/nginx/html -d example.frost.tw</span><br></pre></td></tr></table></figure><blockquote><p>記得把 <code>-d</code> 後面的設定改為自己網站的網址。</p></blockquote><p>第一次執行的話會問一些基本的問題，像是信箱之類的用來之後通知快要過期跟一些重要訊息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Saving debug log to /var/log/letsencrypt/letsencrypt.log</span><br><span class="line">Plugins selected: Authenticator webroot, Installer None</span><br><span class="line">Enter email address (used for urgent renewal and security notices) (Enter &apos;c&apos; to</span><br><span class="line">cancel):</span><br></pre></td></tr></table></figure><p>中間會有使用者條款，輸入 <code>A</code> 即可，至於要不要同意接收一些來自 EFF 組織的訊息，就看個人。</p><p>接下來如果沒有出現其他錯誤，應該會看到類似下面的訊息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">IMPORTANT NOTES:</span><br><span class="line"> - Congratulations! Your certificate and chain have been saved at:</span><br><span class="line">   /etc/letsencrypt/live/example.frost.tw/fullchain.pem</span><br><span class="line">   Your key file has been saved at:</span><br><span class="line">   /etc/letsencrypt/live/example.frost.tw/privkey.pem</span><br><span class="line">   Your cert will expire on 2018-08-26. To obtain a new or tweaked</span><br><span class="line">   version of this certificate in the future, simply run certbot</span><br><span class="line">   again. To non-interactively renew *all* of your certificates, run</span><br><span class="line">   &quot;certbot renew&quot;</span><br><span class="line"> - If you like Certbot, please consider supporting our work by:</span><br><span class="line"></span><br><span class="line">   Donating to ISRG / Let&apos;s Encrypt:   https://letsencrypt.org/donate</span><br><span class="line">   Donating to EFF:                    https://eff.org/donate-le</span><br></pre></td></tr></table></figure><h2 id="設定-Nginx"><a href="#設定-Nginx" class="headerlink" title="設定 Nginx"></a>設定 Nginx</h2><p>回到 <code>nginx.conf</code> 設定檔，因為我們只有監聽 80 埠，所以只能接受 HTTP 請求。所以現在我們要做幾個修改，讓網站隨時處於 HTTPS 的安全連線狀態。</p><ul><li>把 HTTP 轉到 HTTPS</li><li>啟用 HTTPS</li></ul><p>先在原本 <code>location ~/.well-known {</code> 區段的下面增加轉跳到 HTTPS 的設定，類似這樣。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name example.frost.tw;</span><br><span class="line">  </span><br><span class="line">  location ~ /.well-known &#123;</span><br><span class="line">    allow all;</span><br><span class="line">    root /opt/nginx/html;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return 301 https://$server_name$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>server_name</code> 要記得改成你的網域名稱，不然在做轉跳時會因為跟申請的 SSL 憑證不符合而無法正常開啟。</p></blockquote><p>然後在這個區段下方，應該會看到一段被 <code>#</code> 註解的區塊，也就是預設的 HTTPS 設定範例。<br>我們將註解取消，然後補上需要的設定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen       443 ssl;</span><br><span class="line">  server_name  example.frost.tw;</span><br><span class="line"></span><br><span class="line">  ssl on;</span><br><span class="line">  ssl_certificate      /etc/letsencrypt/live/example.frost.tw/fullchain.pem;</span><br><span class="line">  ssl_certificate_key  /etc/letsencrypt/live/example.frost.tw/privkey.pem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上是最基本的設定，有興趣的話可以參考 <a href="https://www.digitalocean.com/community/tutorials/how-to-create-a-self-signed-ssl-certificate-for-nginx-in-ubuntu-16-04" target="_blank" rel="noopener">Digital Ocean 的教學</a>裡面有一些建議的 SSL 設定可以參考。</p></blockquote><p>然後我們要指定一下 Passenger 在這個網站啟用，以及程式碼所在的位置，所以修改成類似下面這樣的設定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen       443 ssl;</span><br><span class="line">  server_name  example.frost.tw;</span><br><span class="line"></span><br><span class="line">  ssl on;</span><br><span class="line">  ssl_certificate      /etc/letsencrypt/live/example.frost.tw/fullchain.pem;</span><br><span class="line">  ssl_certificate_key  /etc/letsencrypt/live/example.frost.tw/privkey.pem;</span><br><span class="line">  </span><br><span class="line">  location ~ /.well-known &#123;</span><br><span class="line">    allow all;</span><br><span class="line">    root /opt/nginx/html;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  root /home/deploy/example.frost.tw/current/public;</span><br><span class="line">  passenger_enabled on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最後我們用 Nginx 指令來檢查一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /opt/nginx/sbin/nginx -t</span><br></pre></td></tr></table></figure><p>如果沒有發生錯誤，就可以用 <code>systemctl</code> 指令重開伺服器，並且看到正常運作的 Rails 網站摟！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart nginx</span><br></pre></td></tr></table></figure><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>這一次的系列文章就到這邊結束了，其實還有不少小細節沒辦法在文章中提到。而且這些都會隨著時間或者有更好的方法而改變，舉例來說 Linux 系統有一個 Cron Job 的功能可以定時的執行某些指令，而 Let’s Encrypt 的憑證一般來說會在三個月左右過期。</p><p>如果不希望自己每次都手動操作的話，就會利用 Cron Job 功能自動執行 <code>certbot renew</code> 任務，並且重新啟動 Nginx 將可能被更新的憑證重新讀取進去。</p><p>部署網站除了使用現有雲端服務之外，更多的時候都會採取這樣的方式來執行，因為可以控制的部分相對的多。也比較能針對專案做適合的配置，畢竟以目前 VPS 收費一個月 $5 美金的價格來說，相比 Heroku 的性價比是高上不少的。</p><p>下次有機會的話應該會試著寫一系列使用 Chef 或 Ansible 的部署教學，這系列的方式只有個位數的伺服器需要管理可能還行得通，但是當有數十台以上的時候，就不會是什麼有效率的方法，更何況要服務客戶協助他們部署的時候。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/05/28/Getting-started-deploy-your-Ruby-on-Rails-Part-8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>部署你的第一個 Ruby on Rails 網站（七）</title>
      <link>https://blog.frost.tw/posts/2018/05/20/Getting-started-deploy-your-Ruby-on-Rails-Part-7/</link>
      <guid>https://blog.frost.tw/posts/2018/05/20/Getting-started-deploy-your-Ruby-on-Rails-Part-7/</guid>
      <pubDate>Sun, 20 May 2018 14:39:15 GMT</pubDate>
      <description>
      
        &lt;p&gt;現在伺服器還沒辦法下載到 Ruby on Rails 專案的原始碼用來部署，這一篇會介紹該如何把原始碼下載回來，並且在伺服器上將相關的 Ruby Gem 都安裝好。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>現在伺服器還沒辦法下載到 Ruby on Rails 專案的原始碼用來部署，這一篇會介紹該如何把原始碼下載回來，並且在伺服器上將相關的 Ruby Gem 都安裝好。</p><a id="more"></a><h2 id="Deploy-Key"><a href="#Deploy-Key" class="headerlink" title="Deploy Key"></a>Deploy Key</h2><p>要讓 Capistrano 自動在伺服器上下載原始碼，我們必須先讓 GitHub 或者 Gitlab 這類服務允許這台伺服器下載，所以我們要先對 <code>deploy</code> 這個部署用的使用者，產生一組下載原始碼的 SSH Key 也就是所謂的 Deploy Key。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo su - deploy</span><br><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>利用 <code>ssh-keygen</code> 指令，我們可以生成一組 Private Key 和一組 Public Key 給 <code>deploy</code> 這個使用者使用，跟我們用來 SSH 到伺服器的是一樣的概念，只不過現在是要讓他當作「驗證權限」的證明，讓 GitHub 接受伺服器下載原始碼。</p><p>將生成的 <code>~/.ssh/id_rsa.pub</code> 內容，複製後貼到 GitHub 專案中 Settings &gt; Deploy Keys 裡面，用來允許這台伺服器下載。</p><p><img src="https://blog.frost.tw/images/getting-started-deploy-your-ruby-on-rails-part-7/figure.png" alt="螢幕快照 2018-05-20 下午10.08.30.png"></p><blockquote><p>GitHub 只允許同一把 Deploy Key 存在一次，所以如果想要讓多台伺服器共用的話，可以先在一台產生，其他伺服器共用。但是盡量避免使用自己電腦中的，因為 Deploy Key 只能讀取會安全許多。</p></blockquote><p>如此一來，在設定正確的狀況下，我們就可以順利的讓伺服器下載到原始碼。</p><h2 id="檢查"><a href="#檢查" class="headerlink" title="檢查"></a>檢查</h2><p>一般在部署之前，我們都會用 <code>cap staging deploy:check</code> 確認基本的操作都是正常的，也就是產生這次部署的版本、下載原始碼跟設定檔已經正確生成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cap deploy:check</span><br></pre></td></tr></table></figure><p>如果伺服器正確的話，應該是不會有錯誤訊息。不過我們嘗試透過 git 來下載原始碼，伺服器上可能是沒有 git 環境的，所以先透過 yum 安裝套件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install git</span><br></pre></td></tr></table></figure><p>如此一來，<code>cap staging deploy:check</code> 就會回報已經可以正確地產生新的資料夾，以及下載原始碼。</p><h2 id="JavaScript-Runtime"><a href="#JavaScript-Runtime" class="headerlink" title="JavaScript Runtime"></a>JavaScript Runtime</h2><p>伺服器環境預設是沒有 JavaScript 的執行環境，不然在我們執行 <code>cap staging deploy</code> 的時候，就可以順利的部署完成。</p><p>不過，因為 Assets Precompile 的關係，我們至少需要有 Node.js 的環境才行。</p><p>我們可以利用 Node.js 官方提供的<a href="https://nodejs.org/en/download/package-manager/#enterprise-linux-and-fedora" target="_blank" rel="noopener">設定程式</a>，讓 CentOS 可以支援較新版本的 Node.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Node 8 是寫這篇文章的穩定版</span><br><span class="line">curl --silent --location https://rpm.nodesource.com/setup_8.x | sudo bash -</span><br></pre></td></tr></table></figure><p>當這段設定程式執行完畢後，我們就可以利用 yum 指令更新或者安裝。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y nodejs</span><br></pre></td></tr></table></figure><blockquote><p>實際上 Node.js 的環境影響並不大，即使是舊版的 Node.js 環境也是可以正常的完成 Assets Precompile</p></blockquote><p>假設有使用 Webpack 的話，對於 Webpacker 這個 Gem 還會需要使用 Yarn 來安裝 Node.js 套件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl --silent --location https://dl.yarnpkg.com/rpm/yarn.repo | sudo tee /etc/yum.repos.d/yarn.repo</span><br><span class="line">sudo yum install yarn</span><br></pre></td></tr></table></figure><p>安裝的方法跟 Node.js 基本上是沒有太大的差異，一樣是透過官方的設定程式將 yum 可以安裝的來源增加，就可以透過 yum 安裝或者升級。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>現在我們只需要透過 <code>cap staging deploy</code> 就可以把 Ruby on Rails 專案傳到伺服器，並且將一切都安裝完畢。</p><blockquote><p>如果有出現錯誤，可能就是使用的 Gem 使用了一些 C 語言編寫的套件，需要額外的安裝一些套件才可以解決，這就考驗大家的應變能力了！</p></blockquote><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>到這篇文章為止，我們只剩下一個步驟——設定 Nginx 伺服器。雖然我們安裝好了伺服器，但是並沒有設定這個專案要怎麼被 Passenger 啟動。</p><p>下一篇是最後一篇，會講解怎麼設定 Nginx 伺服器以及套用 Let’s Encrypt 來設定 SSL 加密。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/05/20/Getting-started-deploy-your-Ruby-on-Rails-Part-7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>關於我怎麼準備人生第一次的履歷和面試</title>
      <link>https://blog.frost.tw/posts/2018/05/14/About-my-first-time-interview-and-resume/</link>
      <guid>https://blog.frost.tw/posts/2018/05/14/About-my-first-time-interview-and-resume/</guid>
      <pubDate>Sun, 13 May 2018 16:58:04 GMT</pubDate>
      <description>
      
        &lt;p&gt;最近又到了畢業的季節，今年比較不一樣的大概是我有稍微幫幾個學弟妹看了一下履歷。還有公司今年暑期實習生的履歷，我也都看了一遍。&lt;/p&gt;
&lt;p&gt;看完之後就發現，跟當初退伍前準備的情況不一樣，我們肯定搞錯重點了 XD&lt;/p&gt;
&lt;p&gt;總之，這不是一篇雞湯文，是雞精文！&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>最近又到了畢業的季節，今年比較不一樣的大概是我有稍微幫幾個學弟妹看了一下履歷。還有公司今年暑期實習生的履歷，我也都看了一遍。</p><p>看完之後就發現，跟當初退伍前準備的情況不一樣，我們肯定搞錯重點了 XD</p><p>總之，這不是一篇雞湯文，是雞精文！</p><a id="more"></a><p>文章就分兩個部分，履歷跟面試，內容基本上就是約兩到三年前剛退伍後找工作的狀況。</p><p>不過，有一點要強調的是我的狀況不太一樣，我小學就因為興趣的關係自學程式。中間的累積跟從大學才開始認真練習的情況是差很多的，不過大部分的人都不是這樣，所以也不太需要擔心。</p><h2 id="履歷篇"><a href="#履歷篇" class="headerlink" title="履歷篇"></a>履歷篇</h2><p>履歷基本上分兩種，客製化的跟制式化的。制式化的基本上不用討論，大多就是求職網站提供的，或者再聯絡到某間公司由 HR（人力資源）提供的版本。</p><p>如果是走制式化的履歷，大概就是真的要拼學歷跟經歷了。畢竟那是方便快速篩選人的方法，先從最簡單的方法篩選，就是假設名校之類的比較厲害。</p><blockquote><p>不過以我看履歷的狀況，即使是台清交來投工程師，如果作品都是作業的話，我根本分不出來誰比較好，同樣的條件下就會先以有自己作品的優先，剩下無法比較才用學歷比（高學歷的人在學習上通常會有一套方法，這可以幫助他們快速適應新環境跟工作）</p></blockquote><p>所以，到了客製化履歷的情況，基本上我自己看的順序是這樣的。</p><ul><li>作品</li><li>專長</li><li>履歷外觀</li><li>自我介紹</li></ul><p>雖然老闆們的看法似乎不太一樣，不過我會這樣看（在一間軟體公司）是有原因的。</p><p>首先是作品，我看作品（一般是放在 GitHub 上）的原因主要是要確認「程式技能」到底是怎麼樣的。如果是熟練寫程式的人，基本上都會有自己的小專案或作品，然後再深入看他使用的這個語言，寫起來是怎麼樣的。</p><p>以 Ruby on Rails 專案來當例子，一個投實習生的人知道怎麼應用 <code>before_action</code> 或者 <code>Concern</code> 之類的技巧，基本上都可以放到正職候補了（實習階段來觀察）</p><p>所以第一點就是先看程式怎麼寫，雖然是很主觀的感覺，但是當寫程式的程度每提升一個階段，寫出來的東西就會差異很大。</p><blockquote><p>這幾年來我接觸過（能寫小東西）的語言可能也有快十種，學寫程式入門學的是邏輯，怎麼讓程式動起來，學會了換語言基本上沒問題。在下一步的是學特性，每種語言都有它設計的理由跟背景，快慢之類的還算其次，但精髓在於能不能了解這個語言或框架想解決的問題跟善用它針對的問題所提供的特性。</p></blockquote><p>另外 UI/UX 的實習生履歷我也有看，畢竟我在高中也是自學了一些設計上的理論知識，受過四年多媒體科系的教育，雖然現在無法當個戰力但是基本的鑑別能力還是有的。</p><p>跟看程式作品一樣，水準蠻好看出來的，基本上只要會「排版」就算通過最低門檻。在客製化履歷上也會體現出這個程度差異，如果連放在一張 A4 紙上的東西都能對齊到歪的，真的很難繼續研究什麼叫做 UI/UX 技能，就算 PhotoShop 或是 Illustrator 用的再好也沒用，搞不好連個會用 Word 的工程師都能做得比你整齊。</p><blockquote><p>客製化履歷的風險也在這邊，排版技能直接變成第一線的死穴。尤其 UI 上沒排好美感就不會出來，而 UX 上沒排好也不會有好的體驗。</p></blockquote><p>接下來就是看專長，不過基本上都是參考為主。原因是因為可能上面會是「我會 Ruby、MySQL」之類的，或者是不知道何時流行起的「PhotoShop ★★★☆☆」這種模式，不過後者我也有幹過，但是現在絕對不是個好方案。</p><p>那麼要怎麼寫呢，當時我是問業界的前輩中間聊到後，推導出應該是像這樣。</p><p>Ruby on Rails</p><ul><li>做過五個以上正式上線的專案</li><li>參與過日本手遊伺服器專案升級</li><li>擔任三次以上 Rails Girls Taiwan 教練</li></ul><p>然後就把有辦法列一到兩個實績的技能列出來，至少大家可以快速分辨出會什麼。</p><blockquote><p>UI/UX 這方面就很難判斷，看履歷時我發現這兩個人同一組。有兩個包裝作品我都認為做得很好，而且他們兩個人都有放，所以我第一時間的疑問是「有沒有第三個人，其實是他做的」不過能跟這種高手一組，也算是一種實力吧，只是參考的點就會把其他作品比重看得比較重。</p></blockquote><p>履歷外觀跟自我介紹就不多說，履歷外觀乾淨整齊就好了。不過還是會有像前面提到的客製化到歪掉，或者明明 Word 的行高預設值明明不是這麼矮的，字卻擠成一團的那種，如果前面的評分一樣，我就會選履歷最整齊乾淨的那個⋯⋯</p><p>不然也不用客製化履歷了，關鍵時刻發揮作用給看履歷的人好印象啊！至於自我介紹，大概要到老闆說可以約面試我才會看，因為講再多還是不如面對面談一次。</p><h2 id="面試篇"><a href="#面試篇" class="headerlink" title="面試篇"></a>面試篇</h2><p>這部分我就不好講解了，因為目前的公司（五倍紅寶石）根本是被老闆問說要不要來，去聊天幾次被貓咪騙去的。其他公司大多也是去「聊天」為主，通常進去出來就是一個小時，面試的過程中到後面就會跟面試官聊起來（雖然還在面試的範圍內）</p><p>不過面試有一個基本的心理因素要滿足——要有自信。</p><p>如果你都不能相信自己的專業技能，要怎麼讓面試你的人相信你有這個能力呢？實際上，遇到你不會的問題，有時候不一定是「扣分」的，只是面試官在抓你的能力在哪裡。</p><blockquote><p>當時有一間公司是認識且厲害的前輩在那邊，去面試的第一階段是寫一份約兩到三頁的試題，一個小時過去大約是回答了五到七成左右。在面試結束時我問了答題的狀況，原來大部分的人連一半的沒辦法回答，有時候不是自己水準太低，而是公司水準太高（所以你有很多能學）保持自信是很重要的，因為你不能確定是哪個情況。</p></blockquote><p>回到面試過程，基本上就是這兩點。</p><ul><li>確認能力</li><li>檢查人品</li></ul><p>如果都已經被約面試，其實能力上來說是被公司認可了（除非沒得選）所以面試就是做兩件事情，先確認履歷跟現實是相符的。也許會出現在工程師界常聽到的白板考之類的，雖然碰過但是應該很少會問演算法之類的，而是要看思考的方式（除非你的工作很需要演算法）但是重點就只有一個，我們看到的東西是不是和實力相符。</p><blockquote><p>重申一次，如果因為沒自信而緊張，不小心忘記原本會的東西或者沒辦法用其他方式回答，就真的很吃虧了。</p></blockquote><p>最後是確認人品，簡單說就是看你的個性跟做事的方式，適不適合這間公司。這就很考驗面試者的看人能力，因為一個人到底能不能跟其他同事好好相處，或者在工作上能夠好好的調適自己內心等等，都會影響到未來工作的表現等等。</p><p>來舉幾個例子，可能會比較好懂。</p><p>有位朋友之前嘗試來應徵實習生，也通過履歷的階段來到面試階段。我跟他說「你一定可以上的，不用擔心」也跟老闆說「雖然不是那種實力很強的，但是很認真的學習，『態度』很好。」不過後來他還是決定去帶營隊，就這樣跟這個機會錯過。</p><p>另外一個是從老闆那邊聽說，客戶公司有一個員工。做了一段時間後，就光明正大的在上班時間找工作跟滑臉書，老闆過來請他不要這樣，還回嗆老闆。因為是客戶，所以我們老闆那段時間剛好還看到了那位員工寫程式的狀況，一行一個 Commit （版本管理存檔的單位）在送的，根本是湊數用。</p><p>很明顯的，這位員工在我們公司就是黑單。連老闆支援的一些社群活動，大概都不會有他出場的機會。</p><p>簡單來說，面試要有「自信」跟平常就要培養好的「態度」這個即使是短短半小時的交流，也可以透過平常的習慣被知道，想要隱藏是很難的。</p><blockquote><p>另外既然我們身處台灣，業界真的很小。大概就是換幾間公司就會遇到認識的人，你以為這間公司看起來不怎麼出名，結果搞不好現在的老闆和這間公司的老闆是好朋友也說不定。在公司的表現，很有可能會讓你在其他公司都沒辦法過關。</p></blockquote><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>履歷的重點其實就是怎樣讓你「被關注」方法不一定，畢竟每個人看的東西不太一樣。但是作品不會騙人，平常就要注意累積作品，作品多其實就是你平時有累積跟練習的證明。</p><p>至於面試，保持自信就不會吃虧。然後態度，這種東西雖然短時間可能改不了，但是可以培養跟訓練，如果態度一開始就很差，小心被黑單吧 XD</p><p>最後，關於自信我在用一個小故事總結。</p><p>以前小學剛學會寫程式的時候，卻被同學誤會說「我覺得你這個人很驕傲」<br>不過，我一直都不認同這一點。因為我是這樣認為的。</p><p>「有實力的叫自信，沒有實力的叫驕傲」</p><p>有實力就會相信自己做得到，沒有實力說自己做得到，就是驕傲跟自滿。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/05/14/About-my-first-time-interview-and-resume/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
