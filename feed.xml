<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>弦而時習之</title>
    <link>https://blog.frost.tw/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    
    <description>蒼時弦也的個人網誌，專注在前端、後端以及遊戲開發，大多使用 Ruby 和 Ruby on Rails 以及 Golang、JS 和 C 語言。</description>
    <pubDate>Tue, 31 Jul 2018 10:46:50 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>淺談 Ruby 的 Fiber（六）</title>
      <link>https://blog.frost.tw/posts/2018/07/29/Talk-about-ruby-s-fiber-Part-6/</link>
      <guid>https://blog.frost.tw/posts/2018/07/29/Talk-about-ruby-s-fiber-Part-6/</guid>
      <pubDate>Sun, 29 Jul 2018 12:56:09 GMT</pubDate>
      <description>
      
        &lt;p&gt;經過前面幾篇文章的介紹，我們已經初步的了解 Fiber 的性質。這系列的文章目標是利用 Fiber 實現再不透過 Thread 或者 Process 的情境，來實現支援多人連線的 TCP 聊天伺服器。&lt;/p&gt;
&lt;p&gt;從這一篇開始，我們就要正式的來挑戰完整的實作了！&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>經過前面幾篇文章的介紹，我們已經初步的了解 Fiber 的性質。這系列的文章目標是利用 Fiber 實現再不透過 Thread 或者 Process 的情境，來實現支援多人連線的 TCP 聊天伺服器。</p><p>從這一篇開始，我們就要正式的來挑戰完整的實作了！</p><a id="more"></a><p>在開始之前，我們已經注意到前幾篇的程式碼已經開始有點複雜而且不好維護，所以我們要先做兩件事情來改善這個問題。</p><ol><li>釐清功能</li><li>重構</li></ol><h2 id="功能分析"><a href="#功能分析" class="headerlink" title="功能分析"></a>功能分析</h2><p>因為 Fiber 的特性，我們必須在所有遭遇到 Blocking I/O 的情境下轉為 Nonblocking I/O 來操作，也因此我們回來看一下前面幾篇需要處理 Blocking I/O 的情境。</p><ol><li>接受連線的 <code>#accept</code> 行為</li><li>讀取使用者資料的 <code>#gets</code> 行為</li></ol><p>為了能夠實現聊天室功能，我們至少還會需要再加入傳送資料給使用者的 <code>#puts</code> 行為。</p><p>而這些動作，我們都需要透過一個統一的物件來處理。</p><p>我們可以簡單的把他整理成類似像這樣的行為流程圖。</p><p><img src="quiver-image-url/3C548A0F0BA914A522D2470F9E81AC74.png =1114x996" alt="FlowchartDiagram1.png"></p><p>如果照我們原來的做法，會發現很難統一管理 Fiber 來在可以操作時執行對應的動作，所以上圖執行 <code>Fiber.yield</code> 的部分，我們會用一個物件來做統一管理，其他部分則可以先維持原樣。</p><h2 id="重構"><a href="#重構" class="headerlink" title="重構"></a>重構</h2><p>首先，我們先嘗試實現一個 <code>Selector</code> 來將可以讀取或者寫入的 I/O 物件找出來。</p><p>修改後的程式碼大致上會像這樣，我們提供了一個 <code>#register</code> 方法讓暫時無法讀取的物件被記錄下來。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">require</span> <span class="string">'socket'</span></div><div class="line"><span class="keyword">require</span> <span class="string">'fiber'</span></div><div class="line"></div><div class="line"><span class="comment"># :nodoc:</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Selector</span></span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></div><div class="line">    @fibers = &#123;&#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(io)</span></span></div><div class="line">    @fibers[io] = Fiber.current</div><div class="line">    Fiber.<span class="keyword">yield</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">resume</span></span></div><div class="line">    readable, = IO.select(@fibers.keys)</div><div class="line">    readable.each <span class="keyword">do</span> <span class="params">|io|</span></div><div class="line">      @fibers[io].resume</div><div class="line">      @fibers.delete(io)</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">selector = Selector.new</div><div class="line">server = TCPServer.new <span class="number">3000</span></div><div class="line"></div><div class="line">loop <span class="keyword">do</span></div><div class="line">  <span class="keyword">begin</span></div><div class="line">    selector.resume</div><div class="line"></div><div class="line">    client = server.accept_nonblock</div><div class="line">    client.puts <span class="string">'Hello World'</span></div><div class="line"></div><div class="line">    Fiber.new <span class="keyword">do</span></div><div class="line">      buffer <span class="params">||</span>= <span class="string">''</span></div><div class="line">      <span class="keyword">begin</span></div><div class="line">        buffer &lt;&lt; client.read_nonblock(<span class="number">1024</span>)</div><div class="line">        puts buffer <span class="keyword">if</span> buffer.<span class="keyword">include</span>?(<span class="string">"\n"</span>)</div><div class="line">      <span class="keyword">rescue</span> IO::WaitReadable</div><div class="line">        selector.register(client)</div><div class="line">      <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span>.resume</div><div class="line">  <span class="keyword">rescue</span> IO::WaitReadable</div><div class="line">    sleep <span class="number">1</span></div><div class="line">    <span class="keyword">retry</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>不過這樣是無法正確執行的，因為 <code>IO.select</code> 行為是一個 Blocking I/O 的行為，不過我們可以將大量的 I/O 物件一次性的選取，只要有一個符合條件就可以解除。</p><p>而這段程式碼出問題的主因是，當開始後就會進入 <code>IO.select</code> 的阻塞狀態，但是伺服器的阻塞狀態並沒有被加入到其中管理，而造成無法正確運行。</p><p>因此，我們要將原本的程式碼再做出一些修正。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">Fiber.new <span class="keyword">do</span></div><div class="line">  loop <span class="keyword">do</span></div><div class="line">    <span class="keyword">begin</span></div><div class="line">      client = server.accept_nonblock</div><div class="line">      client.puts <span class="string">'Hello World'</span></div><div class="line"></div><div class="line">      Fiber.new <span class="keyword">do</span></div><div class="line">        buffer <span class="params">||</span>= <span class="string">''</span></div><div class="line">        <span class="keyword">begin</span></div><div class="line">          buffer &lt;&lt; client.read_nonblock(<span class="number">1024</span>)</div><div class="line">          puts buffer <span class="keyword">if</span> buffer.<span class="keyword">include</span>?(<span class="string">"\n"</span>)</div><div class="line">        <span class="keyword">rescue</span> IO::WaitReadable</div><div class="line">          selector.register(client)</div><div class="line">          <span class="keyword">retry</span></div><div class="line">        <span class="keyword">end</span></div><div class="line">      <span class="keyword">end</span>.resume</div><div class="line">    <span class="keyword">rescue</span> IO::WaitReadable</div><div class="line">      selector.register(server)</div><div class="line">      <span class="keyword">retry</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span>.resume</div><div class="line"></div><div class="line">loop <span class="keyword">do</span></div><div class="line">  selector.resume</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>不過修改之後，卻發現因為加入了 <code>Fiber.new</code> 給伺服器後，原本的 <code>retry</code> 和 <code>loop</code> 的角色似乎有點微妙，如果不使用 <code>loop</code> 的話，成功連線後就不會嘗試等待下一個新連線，而失敗的話不使用 <code>retry</code> 一樣也不會繼續嘗試處理新的連線，這樣整個工作分配變得有點混亂。</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>要解決這樣的問題，最為理想的狀態是在 <code>#accept_nonblock</code> 的下一行馬上使用 <code>Fiber.yield</code> 以便 <code>Fiber#resume</code> 發生時能夠繼續還未完成的動作。</p><p>在 Ruby 裡面大部分的 Nonblocking I/O 方法都提供了 <code>exception: false</code> 的選項，讓我們達成這個條件。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>雖然開始嘗試重構，但是馬上又發現程式碼變的複雜，在下一篇我們會先嘗試採取 <code>exception: false</code> 的做法調整 Fiber 繼續執行的流程，然後再做一次重構讓程式碼恢復乾淨的狀態。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/07/29/Talk-about-ruby-s-fiber-Part-6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>淺談 Ruby 的 Fiber（五）</title>
      <link>https://blog.frost.tw/posts/2018/07/24/Talk-about-ruby-s-fiber-Part-5/</link>
      <guid>https://blog.frost.tw/posts/2018/07/24/Talk-about-ruby-s-fiber-Part-5/</guid>
      <pubDate>Tue, 24 Jul 2018 12:24:31 GMT</pubDate>
      <description>
      
        &lt;p&gt;經過&lt;a href=&quot;https://blog.frost.tw/posts/2018/07/17/Talk-about-ruby-s-fiber-Part-4/&quot;&gt;上次&lt;/a&gt;的嘗試，我們已經開始對於 Fiber 的性質有一些了解，目前還需要解決已經結束的 Fiber 被呼叫，以及來不及處理的問題。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>經過<a href="https://blog.frost.tw/posts/2018/07/17/Talk-about-ruby-s-fiber-Part-4/">上次</a>的嘗試，我們已經開始對於 Fiber 的性質有一些了解，目前還需要解決已經結束的 Fiber 被呼叫，以及來不及處理的問題。</p><a id="more"></a><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>實際上在上週我們已經很明確的之到如果遇到 <code>dead fiber called (FiberError)</code> 錯誤，是表示 Fiber 已經無法再繼續執行。舉例來說，我們執行了三次 <code>Fiber.yield</code> 那麼這個 Fiber 最多只能執行四次（包含產生的那次）再多就會失敗。</p><p>而另一個問題則是我們在做 <code>#resume</code> 的時候總是在 <code>#accept_nonblock</code> 之後，所以當失敗的時候並不會優先的做 <code>#resume</code> 才重新檢查是否有人嘗試連線。</p><p>所以，我們只需要做一點小修改。</p><h2 id="嘗試"><a href="#嘗試" class="headerlink" title="嘗試"></a>嘗試</h2><p>首先，我們將 <code>fibers.each(&amp;:resume)</code> 的順序放到 <code>server.accept_nonblock</code> 之前，讓他在發生 <code>IO::WaitReadable</code></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">client = server.accept_nonblock</div><div class="line">client.puts <span class="string">'Hello World'</span></div><div class="line"></div><div class="line">fibers.each(&amp;<span class="symbol">:resume</span>)</div><div class="line"></div><div class="line"><span class="comment"># ...</span></div></pre></td></tr></table></figure><p>所以會變成像這個樣子</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fibers.each(&amp;<span class="symbol">:resume</span>)</div><div class="line"></div><div class="line">client = server.accept_nonblock</div><div class="line">client.puts <span class="string">'Hello World'</span></div><div class="line"></div><div class="line"><span class="comment"># ...</span></div></pre></td></tr></table></figure><p>如此一來，我們就可以正常的讓伺服器進入等待的狀態。</p><p>不過當我們連上並且傳送一些訊息後，就會再次出現 <code>dead fiber called (FiberError)</code> 錯誤訊息，因為我們在關閉連線後並沒有把處理完畢的 Fiber` 清除掉。</p><p>所以我們還需要做下面的修改。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ...</span></div><div class="line">        buffer &lt;&lt; client.read_nonblock(<span class="number">1024</span>)</div><div class="line">        <span class="keyword">if</span> buffer.<span class="keyword">include</span>?(<span class="string">"\n"</span>)</div><div class="line">          puts buffer</div><div class="line">          client.close</div><div class="line">        <span class="keyword">end</span></div><div class="line"><span class="comment"># ...</span></div></pre></td></tr></table></figure><p>增加一行在 <code>client.close</code> 下方。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ...</span></div><div class="line">        buffer &lt;&lt; client.read_nonblock(<span class="number">1024</span>)</div><div class="line">        <span class="keyword">if</span> buffer.<span class="keyword">include</span>?(<span class="string">"\n"</span>)</div><div class="line">          puts buffer</div><div class="line">          client.close</div><div class="line">          fibers.delete(fiber)</div><div class="line">        <span class="keyword">end</span></div><div class="line"><span class="comment"># ...</span></div></pre></td></tr></table></figure><p>到這一階段，我們大致上就算是讓 Fiber 正常運作。</p><p>不過當我們把 <code>client.close</code> 刪除，準備讓他變成聊天室的形式時，又會再次出現 <code>dead fiber called (FiberError)</code> 錯誤，因為我們並沒有繼續透過 <code>Fiber.yield</code> 讓他可以繼續執行。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>到這個階段，我們已經可以初步的使用 Fiber 並且控制運行的流程，但是繼離將簡易的 TCP 聊天室實作出來還差上一小段。下一篇開始我們會嘗試將 <code>client.close</code> 和 <code>fiber.delete(fiber)</code> 去除，並且嘗試加入一些輔助程式來讓他可以持續的接收資料。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/07/24/Talk-about-ruby-s-fiber-Part-5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>淺談 Ruby 的 Fiber（四）</title>
      <link>https://blog.frost.tw/posts/2018/07/17/Talk-about-ruby-s-fiber-Part-4/</link>
      <guid>https://blog.frost.tw/posts/2018/07/17/Talk-about-ruby-s-fiber-Part-4/</guid>
      <pubDate>Tue, 17 Jul 2018 11:17:26 GMT</pubDate>
      <description>
      
        &lt;p&gt;在上週的&lt;a href=&quot;https://blog.frost.tw/posts/2018/07/10/Talk-about-ruby-s-fiber-Part-3/&quot;&gt;文章&lt;/a&gt;我們注意到 Fiber 的使用並不是那麼容易的，因為我們需要自行管理每一個 Fiber 被恢復（&lt;code&gt;#resume&lt;/code&gt;）的時機，這週就繼續來挑戰吧！&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>在上週的<a href="https://blog.frost.tw/posts/2018/07/10/Talk-about-ruby-s-fiber-Part-3/">文章</a>我們注意到 Fiber 的使用並不是那麼容易的，因為我們需要自行管理每一個 Fiber 被恢復（<code>#resume</code>）的時機，這週就繼續來挑戰吧！</p><a id="more"></a><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>在上週我們已經知道需要將行為從原本會阻塞 I/O 的操作，轉換為非阻塞的操作。所以我們會進行以下的嘗試，來修正 Fiber 的運行。</p><ol><li>使用 <code>#accept_nonblock</code> 來取得用戶端</li><li>使用 <code>#read_nonblock</code> 來讀取使用者的資料</li></ol><h2 id="嘗試"><a href="#嘗試" class="headerlink" title="嘗試"></a>嘗試</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">server = TCPServer.new <span class="number">3000</span></div><div class="line"></div><div class="line">fibers = []</div><div class="line">loop <span class="keyword">do</span></div><div class="line">  <span class="keyword">begin</span></div><div class="line">    client = server.accept_nonblock</div><div class="line">    client.puts <span class="string">'Hello World'</span></div><div class="line"></div><div class="line">    fibers.each(&amp;<span class="symbol">:resume</span>)</div><div class="line"></div><div class="line">    fiber = Fiber.new <span class="keyword">do</span></div><div class="line">      buffer <span class="params">||</span>= <span class="string">''</span></div><div class="line">      <span class="keyword">begin</span></div><div class="line">        buffer &lt;&lt; client.read_nonblock(<span class="number">1024</span>)</div><div class="line">        <span class="keyword">if</span> buffer.<span class="keyword">include</span>?(<span class="string">"\n"</span>)</div><div class="line">          puts buffer</div><div class="line">          client.close</div><div class="line">        <span class="keyword">end</span></div><div class="line">      <span class="keyword">rescue</span> IO::WaitReadable</div><div class="line">        puts <span class="string">'RETRY'</span></div><div class="line">        Fiber.<span class="keyword">yield</span></div><div class="line">        <span class="keyword">retry</span></div><div class="line">      <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line"></div><div class="line">    fiber.resume</div><div class="line">    fibers &lt;&lt; fiber</div><div class="line">  <span class="keyword">rescue</span> IO::WaitReadable</div><div class="line">    sleep <span class="number">1</span></div><div class="line">    <span class="keyword">retry</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>我們對原本的做了一些修改，把 <code>#accept_nonblock</code> 和 <code>#read_nonblock</code> 加入到了程式碼中，在這邊我們可以利用 <code>retry</code> 關鍵字觸發重試的行為，讓我們遇到 <code>IO::WaitReadable</code> 錯誤時，可以自動地重新開始。</p><p>不過，我們還是發現了一些問題不太正常。</p><ol><li>依然要在第下一個連線開始後才會斷線</li><li>到第三次之後就不正常的斷線</li></ol><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先我們來分析一下為什麼還是無法在使用者輸入訊息後關閉連線。</p><ol><li>等待連線</li><li>重試（…）</li><li>第一個連線連上</li><li>執行 <code>fibers.each(&amp;:resume)</code> 動作</li><li>執行初次連線的 Fiber 生成和 <code>#resume</code> 動作</li><li>等待連線</li><li>重試（…）</li></ol><p>透過上面的流程，我們會發現要觸發使用者輸入訊息後斷線的行為，會因為「沒有人連上」的重試行為，一直被卡在 <code>#accept_nonblock</code> 這個狀態上（因為他會產生 <code>IO::WaitReadable</code> 錯誤）</p><p>而第二個錯誤，則是在第三次連線後，會出現 <code>dead fiber called (FiberError)</code> 這個錯誤訊息，這是因為當我們用盡 <code>Fiber.yield</code> 次數後，這個 Fiber 就無法再繼續進行 <code>#resume</code> 否則就會發生這個錯誤。</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>事實上，這兩個問題是一起發生的。假設我們先將 <code>fibers.each(&amp;:resume)</code> 放到 <code>#accept_nonblock</code> 前面，那麼很快地就會將 <code>dead fiber called</code> 這個錯誤觸發，所以我們還需要搭配在關閉連線時，將目前所屬的 Fiber 從 <code>fibers</code> 移除掉，才能夠確保程式正常運行。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>目前已經逐漸抓到一些線索，可以讓我們針對 Fiber 進行應用，基本上這次的錯誤修正後就可以獲得跟我們預期中一樣運行的 TCP Server 了。</p><p>不過，如果想要將它改寫成一個簡易的聊天室，又要怎麼做？會碰到什麼問題呢？</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/07/17/Talk-about-ruby-s-fiber-Part-4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>淺談 Ruby 的 Fiber（三）</title>
      <link>https://blog.frost.tw/posts/2018/07/10/Talk-about-ruby-s-fiber-Part-3/</link>
      <guid>https://blog.frost.tw/posts/2018/07/10/Talk-about-ruby-s-fiber-Part-3/</guid>
      <pubDate>Tue, 10 Jul 2018 13:35:01 GMT</pubDate>
      <description>
      
        &lt;p&gt;延續&lt;a href=&quot;https://blog.frost.tw/posts/2018/07/03/Talk-about-ruby-s-fiber-Part-2/&quot;&gt;上一篇&lt;/a&gt;文章的實作，我們已經有一個簡易的 Thread 版本 TCP Socket 伺服器可以運作，那麼該怎麼用 Fiber 修改呢？&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>延續<a href="https://blog.frost.tw/posts/2018/07/03/Talk-about-ruby-s-fiber-Part-2/">上一篇</a>文章的實作，我們已經有一個簡易的 Thread 版本 TCP Socket 伺服器可以運作，那麼該怎麼用 Fiber 修改呢？</p><a id="more"></a><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>在我們使用 Thread 的時候，應該要先執行哪個 Thread 中的任務會由作業系統或者語言本身底層的實作來協助我們處理，但是 Fiber 目前只能用來在不同的程式碼片段中切換，所以我們就需要自己管理應該要切換到哪一個片段。</p><p>所以我們要先定義一個情境：</p><p>當 Blocking I/O 發生的時候，會發生什麼事情？</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Server 嘗試讀取 Client 的資料</span></div><div class="line">resp = client.gets</div><div class="line"><span class="comment"># Blocking I/O 發生</span></div><div class="line"><span class="comment"># ...</span></div><div class="line"><span class="comment"># ...</span></div><div class="line"><span class="comment"># 使用者輸入 HELLO</span></div><div class="line"><span class="comment"># Blocking I/O 結束</span></div><div class="line">puts resp</div><div class="line"><span class="comment"># =&gt; HELLO</span></div></pre></td></tr></table></figure><p>其實就是當我們嘗試做 Read（讀取）跟 Write（寫入）的時候，暫時無法操作的狀態。</p><p>Ex. 想讀取資料卻無法讀取</p><p>所以，根據上一篇文章的案例，當我們嘗試 <code>#gets</code> 卻沒有得到使用者的回應時，就應該先透過 <code>Fiber.yield</code> 把執行權限釋放出來。</p><h2 id="嘗試"><a href="#嘗試" class="headerlink" title="嘗試"></a>嘗試</h2><p>因為邏輯上跟以往我們習慣的方式不太一樣，所以我們需要進行多次的嘗試，讓 Fiber 可以像我們預期的一樣運作。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">server = TCPServer.new <span class="number">3000</span></div><div class="line"></div><div class="line">fibers = []</div><div class="line">loop <span class="keyword">do</span></div><div class="line">  client = server.accept</div><div class="line">  client.puts <span class="string">'Hello World'</span></div><div class="line"></div><div class="line">  fibers.each(&amp;<span class="symbol">:resume</span>)</div><div class="line"></div><div class="line">  fiber = Fiber.new <span class="keyword">do</span></div><div class="line">    Fiber.<span class="keyword">yield</span></div><div class="line">    puts client.gets</div><div class="line">    client.close</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  fiber.resume</div><div class="line">  fibers &lt;&lt; fiber</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>這樣看起來好像會運作，不過當我們嘗試執行的時候，卻發現有一些奇怪的地方。</p><ol><li>輸入訊息後沒有馬上斷線</li><li>第二個人連上後才會斷線</li></ol><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>當第一個人連上後，會發生以下事情：</p><ol><li>先把 <code>fibers</code> 裡面存在的 Fiber 執行 <code>#resume</code> 一次</li><li>對這次連上的使用者產生一個 <code>Fiber</code></li><li>先執行一次（抵達第一次的 <code>Fiber.yield</code>）被暫停</li><li>將目前的 Fiber 物件儲存在 <code>fibers</code> 中</li><li>重新呼叫 <code>server.accept</code> -&gt; Blocking I/O</li></ol><p>第二個人連上後，會發生以下的事情</p><ol><li>先把 <code>fibers</code> 裡面存在的 Fiber 執行 <code>#resume</code> 一次</li><li>第一個連線的使用者執行 <code>#gets</code> 行為 -&gt; Blocking I/O</li></ol><p>到目前為止已經被 Blocking I/O 堵住兩次，還比原本沒有 Fiber 的版本更難懂，那麼問題出在哪裡呢？</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>首先，我們希望程式上遇到 Blocking I/O 時先不要卡住我們，所以我們需要將 <code>server.accept</code> 和 <code>client.gets</code> 這兩個行為調整成 Nonblocking I/O 的使用方式。</p><p>也就是當遇到 Blocking I/O 的時候我們希望直接回傳「沒有資料」之類的訊息給我們，而不是直接停住。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">loop <span class="keyword">do</span></div><div class="line">  puts <span class="string">'LOOPING'</span></div><div class="line">  <span class="keyword">begin</span></div><div class="line">    client = server.accept_nonblock</div><div class="line">    <span class="comment"># 有人連上了！</span></div><div class="line">  <span class="keyword">rescue</span> IO::WaitReadable</div><div class="line">    <span class="comment"># 目前都沒有人連線！</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>以 <code>#accept_nonoblock</code> 這個用法作為例子，我們會發現，假設我們做 <code>puts &#39;LOOPING&#39;</code> 這段程式碼，如果是 <code>#accept</code> 的時候，需要有人連上才會顯示訊息，但是在 <code>#accept_nonblock</code> 的時候，則會不斷出現。</p><p>同時，我們也會得到一個叫做 <code>IO::WaitReadable</code> 的錯誤，告訴我們現在雖然讀取了，但是實際上是無法讀取任何東西的，需要等待有東西可以讀取。</p><p>透過這樣的機制，我們就可以在碰到這個錯誤時進行 <code>Fiber.yield</code> 先讓他暫停，等到我們確認他可以讀取後，再繼續執行。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>這篇文章我們發現如果使用 Thread 的話，基本上是由作業系統去管理碰到 Blocking I/O 時該怎麼做，但是如果是 Fiber 的話，我們就得完全靠 Ruby 來解決。</p><p>同時也會遇到某些情境無法使用的狀況，像是 <code>net/http</code> 這個標準函式庫，並沒有提供 Nonblocking I/O 的方法，我們就無法透過在 Blocking I/O 狀態下先讓他暫停，並且先切換到其他工作上。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/07/10/Talk-about-ruby-s-fiber-Part-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>淺談 Ruby 的 Fiber（二）</title>
      <link>https://blog.frost.tw/posts/2018/07/03/Talk-about-ruby-s-fiber-Part-2/</link>
      <guid>https://blog.frost.tw/posts/2018/07/03/Talk-about-ruby-s-fiber-Part-2/</guid>
      <pubDate>Tue, 03 Jul 2018 11:26:44 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;a href=&quot;https://blog.frost.tw/posts/2018/06/26/Talk-about-ruby-s-fiber-Part-1/&quot;&gt;第一篇&lt;/a&gt;我們已經大致上了解 Fiber 的運作原理，不過要能夠實際上的掌握跟應用，我認為是需要靠實作來熟悉的。&lt;/p&gt;
&lt;p&gt;所以，這一篇我們先來講學習 Socket 最常見的 TCP 伺服器實作吧！&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="https://blog.frost.tw/posts/2018/06/26/Talk-about-ruby-s-fiber-Part-1/">第一篇</a>我們已經大致上了解 Fiber 的運作原理，不過要能夠實際上的掌握跟應用，我認為是需要靠實作來熟悉的。</p><p>所以，這一篇我們先來講學習 Socket 最常見的 TCP 伺服器實作吧！</p><a id="more"></a><p>為了要比較 Fiber 和 Thread 版，這次我們會先用 TCPServer 來實做一個簡易的 TCP 伺服器，並且用來比較兩者的差異。</p><h2 id="TCPServer"><a href="#TCPServer" class="headerlink" title="TCPServer"></a>TCPServer</h2><p>首先，我們先用 Ruby 建立一個可以接收連線的 TCP 伺服器。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">require</span> <span class="string">'socket'</span></div><div class="line"></div><div class="line">server = TCPServer.new <span class="number">3000</span></div><div class="line">loop <span class="keyword">do</span></div><div class="line">  client = server.accept</div><div class="line">  client.puts <span class="string">"HELLO WORLD"</span></div><div class="line">  client.close</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>我們可以用 telnet 指令來做簡單的測試。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">telnet localhost 3000</div></pre></td></tr></table></figure><p>目前的版本在連上之後就會馬上顯示 <code>HELLO WORLD</code> 然後關閉連線。</p><h2 id="Blocking-I-O"><a href="#Blocking-I-O" class="headerlink" title="Blocking I/O"></a>Blocking I/O</h2><p>那麼，我們希望接收來自使用者的訊息，會像這樣修改。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">require</span> <span class="string">'socket'</span></div><div class="line"></div><div class="line">server = TCPServer.new <span class="number">3000</span></div><div class="line">loop <span class="keyword">do</span></div><div class="line">  client = server.accept</div><div class="line">  client.puts <span class="string">"HELLO WORLD"</span></div><div class="line">  puts client.gets</div><div class="line">  client.close</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>這個時候，如過我們用像這樣的順序進行操作，就會發現無法正常運作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 視窗一</span></div><div class="line">telnet localhost 3000 <span class="comment"># =&gt; 顯示 HELLO WORLD</span></div><div class="line"><span class="comment"># 視窗二</span></div><div class="line">telnet localhost 3000 <span class="comment"># =&gt; 沒有顯示</span></div></pre></td></tr></table></figure><p>這是因為在 <code>client.gets</code> 的時候發生了 Blocking I/O（I/O 阻塞）的情況，也就是操作因為 <code>#gets</code> 嘗試讀取，但是因為讀取不到而阻止接下來的程式執行。</p><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>在這個時候，我們可以透過幾種方式解決。</p><ol><li>Process</li><li>Thread</li><li>Fiber</li></ol><p>第一個方案因為是記憶體完全獨立的，所以我們就無法知道其他連線的用戶存在，所以一般來說不會使用。而 Thread 則是把 Process 切割後，遇到了一些情境像是 <code>sleep</code> 和 <code>Blocking I/O</code> 等情況，就會先把執行權轉交給其他 Thread 繼續執行。</p><p>所以，我們可以將程式修改成這樣。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">require</span> <span class="string">'socket'</span></div><div class="line"></div><div class="line">server = TCPServer.new <span class="number">3000</span></div><div class="line">loop <span class="keyword">do</span></div><div class="line">  client = server.accept</div><div class="line">  client.puts <span class="string">"HELLO WORLD"</span></div><div class="line">  Thread.new <span class="keyword">do</span></div><div class="line">    puts client.gets</div><div class="line">    client.close</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>如此一來，當我們碰到 Blocking I/O（<code>#gets</code>）的情況，就會先將目前佔用的 Thread 轉交給其他可以繼續執行的 Thread 身上，先執行任務。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>這篇文章簡單的介紹了 Thread 的使用方式，以及該如何避免遇到 Blocking I/O 的處理方式，下一篇就來看看透過 Fiber 的流程控制機制，是怎樣迴避這個問題的。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/07/03/Talk-about-ruby-s-fiber-Part-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>淺談 Ruby 的 Fiber（ㄧ）</title>
      <link>https://blog.frost.tw/posts/2018/06/26/Talk-about-ruby-s-fiber-Part-1/</link>
      <guid>https://blog.frost.tw/posts/2018/06/26/Talk-about-ruby-s-fiber-Part-1/</guid>
      <pubDate>Tue, 26 Jun 2018 12:29:19 GMT</pubDate>
      <description>
      
        &lt;p&gt;前陣子再研究 Ruby 從 1.9.3 就開始提供的 Fiber 該怎麼使用，不過網路上的資料大多都只是簡單的討論。那麼 Fiber 到底是什麼呢？這系列的文章會詳細的介紹 Fiber 的基本概念，還有一些可以應用的方式。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>前陣子再研究 Ruby 從 1.9.3 就開始提供的 Fiber 該怎麼使用，不過網路上的資料大多都只是簡單的討論。那麼 Fiber 到底是什麼呢？這系列的文章會詳細的介紹 Fiber 的基本概念，還有一些可以應用的方式。</p><a id="more"></a><p>原本只想一篇文章寫完，但是其實 Fiber 需要大量的改變以往習慣的思考模式，所以還是用系列文來呈現比較恰當。</p><h2 id="概觀"><a href="#概觀" class="headerlink" title="概觀"></a>概觀</h2><p>所以，Fiber 是怎樣的東西呢？從 Ruby 文件上的第一句話可以看到。</p><blockquote><p>Fibers are primitives for implementing light weight cooperative concurrency in Ruby.</p></blockquote><p>他是用來實作 Concurrency 的標準函式庫，當時看到這裡我就想到 Golang 的 Goruntine 機制，可以像這樣的去實現非同步的操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">resp</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// Write Later ...</span></div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">// Respond now ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>所以在 Ruby 中使用 Fiber 應該也要一樣簡單才對吧！</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">resp</span></span></div><div class="line">  Fiber.new <span class="keyword">do</span></div><div class="line">    <span class="comment"># Write Later ...</span></div><div class="line">  <span class="keyword">end</span></div><div class="line">  </div><div class="line">  <span class="comment"># Respond now ...</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>不過很可惜，這樣是不會像 Golang 一樣運作的！</p><blockquote><p>所以我每次講到 Fiber 的運作，都要跟同事說 Ruby 增加 AutoFiber (<a href="https://ruby-china.org/topics/34992" target="_blank" rel="noopener">RubyChina 介紹</a>) 是因為大家都不懂怎麼用。</p></blockquote><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>有一些文章會提到 Fiber 是一種「流程控制」的工具，主要是因為 <code>Fiber</code> 可以利用 <code>Fiber.yield</code> 和 <code>#resume</code> 來切換要繼續執行的部分。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">f1 = Fiber.new <span class="keyword">do</span></div><div class="line">  puts <span class="string">'A'</span></div><div class="line">  Fiber.<span class="keyword">yield</span></div><div class="line">  puts <span class="string">'B'</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">f2 = Fiber.new <span class="keyword">do</span></div><div class="line"> puts <span class="string">'C'</span></div><div class="line"> Fiber.<span class="keyword">yield</span></div><div class="line"> puts <span class="string">'D'</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">f1.resume <span class="comment"># =&gt; A</span></div><div class="line">f2.resume <span class="comment"># =&gt; C</span></div><div class="line">f1.resume <span class="comment"># =&gt; B</span></div><div class="line">f2.resume <span class="comment"># =&gt; D</span></div></pre></td></tr></table></figure><p>由上面的範例來看，我們會發現 Fiber 在 <code>Fiber.yield</code> 之後，其實就離開原本執行的 Context (Block) 然後其他人就可以繼續執行他想執行的東西。</p><blockquote><p>這邊的 Context 指的是一個方法包含起來的範圍，在 Ruby 裡面 Block 基本是是透過 <code>Proc.new</code> 實現的，而方法的本體也是。不過要注意的是 Fiber 是可以跟外部交換變數的，這也是 Golang 要用 Channel 機制來交換 Goroutine 的資料，確保類似 Thread 實現的 Race Condition 問題不會發生。</p></blockquote><h2 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h2><p>一次性的獲取這樣充滿衝擊性的資訊可能對大家有點吃力，我們稍微修改前面的範例改成類似 JavaScript 的 Generator 機制來習慣一下這樣的變化。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">f = Fiber.new <span class="keyword">do</span></div><div class="line"> counter = <span class="number">0</span></div><div class="line"> loop <span class="keyword">do</span></div><div class="line">  Fiber.<span class="keyword">yield</span> counter += <span class="number">1</span></div><div class="line"> <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">puts f.resume <span class="comment"># =&gt; 1</span></div><div class="line">puts f.resume <span class="comment"># =&gt; 2</span></div></pre></td></tr></table></figure><p>上面這個調整的版本我們用了一個 <code>loop</code> 當作無限迴圈，但是實際上並不會阻塞我們進行後續的操作，因為 <code>Fiber.yield</code> 可以暫時的跳出目前執行的 Context 把它暫停，而在執行 <code>#resume</code> 的時候才會繼續執行到下一個 <code>Fiber.yield</code> 被呼叫。</p><p>所以，如果想實現一個類似 Generator 的行為，可以像這樣封裝。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generator</span></span></div><div class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:counter</span></div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></div><div class="line">    @counter = <span class="number">0</span></div><div class="line">    @fiber = Fiber.new <span class="keyword">do</span></div><div class="line">      loop <span class="keyword">do</span></div><div class="line">        Fiber.<span class="keyword">yield</span> @counter += <span class="number">1</span></div><div class="line">      <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">next</span></span></div><div class="line">    @fiber.resume</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">generator = Generator.new</div><div class="line">puts generator.<span class="keyword">next</span></div><div class="line">puts generator.<span class="keyword">next</span></div><div class="line">puts <span class="string">"Counter: <span class="subst">#&#123;generator.counter&#125;</span>"</span></div></pre></td></tr></table></figure><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>透過 Fiber 這樣的特性，我們可以做到一些非同步的行為，但是又不需要依賴其他的 Ruby Gem 或者 C Extension 來實現，另一方面根據 Ruby Doc 表示，產生一個 Fiber 佔用的記憶體是 4K 左右的堆疊大小，相對於產生 Thread 都要輕量不少。</p><blockquote><p>所以從以前以 Process 之後加入 Thread 到現在的 Concurrency 機制，剛好就是三個不同記憶體使用量級，在適合的情況下使用適當的機制可以讓程式更加易讀跟好用（不過 Fiber 沒封裝好會很難讀就是了 XD）</p></blockquote><p>下一篇開始會用一些範例來示範，不然這篇文章也要跟目前能找到的資料一樣沒有講到大家最關心的實際應用。因為跟 I/O Blocking 相關的機制很搭，所以後面會介紹像是非同步的 HTTP 請求跟不用 Thread 的 TCP 伺服器等等。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/06/26/Talk-about-ruby-s-fiber-Part-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>如何在國外演講</title>
      <link>https://blog.frost.tw/posts/2018/06/19/How-do-I-prepare-a-speech/</link>
      <guid>https://blog.frost.tw/posts/2018/06/19/How-do-I-prepare-a-speech/</guid>
      <pubDate>Tue, 19 Jun 2018 11:30:45 GMT</pubDate>
      <description>
      
        &lt;p&gt;今年在 &lt;a href=&quot;https://rubykaigi.org/2018&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RubyKaigi&lt;/a&gt; 有一場 Lightning Talk 分享，在後台準備跟等待上場的時候發現一件事情。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前面的人都邊發抖邊講&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以這篇文章來分享一下我的方法跟心得。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>今年在 <a href="https://rubykaigi.org/2018" target="_blank" rel="noopener">RubyKaigi</a> 有一場 Lightning Talk 分享，在後台準備跟等待上場的時候發現一件事情。</p><p><strong>前面的人都邊發抖邊講</strong></p><p>所以這篇文章來分享一下我的方法跟心得。</p><a id="more"></a><h2 id="怕，很正常"><a href="#怕，很正常" class="headerlink" title="怕，很正常"></a>怕，很正常</h2><p>像是 RubyKaigi 你一上台，台下是大概有 1000 多人在看著你。如果你覺得這樣都不會發抖的話，我反而覺得不正常。</p><p>所以，會發抖很正常。</p><p>就我自己的經驗來說，大概是在某一年的 COSCUP 我也上台講了一場 Lightning Talk 台下也是約有將近 1000 人，我確實是在發抖的。</p><p>而前面幾次的演講，其實都是在發抖的狀態下演講。</p><blockquote><p>你不怕，反而比較不正常！</p></blockquote><h2 id="預備動作"><a href="#預備動作" class="headerlink" title="預備動作"></a>預備動作</h2><p>一般來說，上台前大家可能會一直看簡報之類的。畢竟誰都不想在台上講的差，不過開始前五分鐘的話，最好的做法應該是作預備動作。</p><p>什麼是預備動作呢？</p><p>以我自己來說，就是先閉上眼睛深呼吸幾次。然後盡量的不要去思考或回憶簡報的內容，讓自己處於一個放空的狀態。</p><p>因為上台前如果很緊張的話，其實是會覺得冷（即使冷氣沒有很冷）然後心跳慢慢的加速。</p><p>所以最重要的是先讓自己處於一個放鬆的狀態，控制心跳（覺得冷應該沒救）讓自己處於一個可以控制的狀態，上台的時候才比較不會緊張。</p><h2 id="視線的控制"><a href="#視線的控制" class="headerlink" title="視線的控制"></a>視線的控制</h2><p>上台之後，要讓演講的狀態看起來是很「厲害」的話，就肯定不能低頭看著螢幕去講。所以要練習控制視線，也就是「不時的注視台下觀眾」這點。</p><p>不過只要看到下面的人，其實難免會緊張。所以就會有一些技巧，比較常見的就是看天花板之類的，我自己的話主要會用兩種。</p><ol><li>找看看在現場認識的人</li><li>掃過最近跟最遠的人</li></ol><p>這邊的技巧其實是不要「看仔細」只要用眼角的餘光看一下就好，時機點的話基本上我都會用下面的循環。</p><ol><li>看螢幕上的簡報</li><li>抬頭看觀眾</li><li>把視線放在只能看到幾個人的位置</li><li>開始講</li></ol><h2 id="演講的內容"><a href="#演講的內容" class="headerlink" title="演講的內容"></a>演講的內容</h2><p>我認為這個就很看人，以我自己來說我是<strong>不背稿</strong>的類型，也就是我看到簡報就知道我該講什麼，好處是時間的控制跟針對現場狀況調整是比較容易的。</p><blockquote><p>不過據說很難做到，我是認為當我準備充分的時候就沒問題。</p></blockquote><p>另一種就是背稿，把要講的時間跟內容都準備好，然後在現場把他盡可能的完整還原出來。兩種方法都沒有什麼問題，不過一樣要注意就是。</p><p>簡報的註解（雙螢幕通常可以看到）不要寫完整的講稿，投影片也是。這算是做簡報的技巧，而講稿的註解以「提醒這一頁要講什麼」為主，就是幫助回憶。</p><p>如果投影片內容太多，或者註解是完整的內容。就很容易變成用念的，尤其是在緊張的時候。所以盡量用一句話表達，如果掌握得不太好或者擔心的話，就把頁面切分多一點。</p><p>舉例來說，一句話大約是 20 秒好了，準備 60 頁所以是 1,200 秒，也就約略於 20 分鐘，那麼只要準備 120 頁，即使一頁一句話，只要控制好速度也能夠很穩的演講完畢。</p><blockquote><p>以我自己的經驗 40 分鐘的演講從 30 ~ 100 頁的情況都有，看內容而定。</p></blockquote><h2 id="相信自己"><a href="#相信自己" class="headerlink" title="相信自己"></a>相信自己</h2><p>不記得有沒有跟人說過，不過這邊提一下，很適合這個情況。</p><p>「如果你都不相信自己，要怎麼讓別人相信你。」</p><p>不管是去面試或者在工作上，我認為至少要表現得有自信一點，不然呈現出沒把握的狀態時，不管客戶或者同事都會跟著覺得沒把握。</p><p>上台演講也是一樣，既然都花時間準備，講的東西也是自己花了很長一段時間累積的經驗。不管怎麼樣，在台上講的東西都會很精彩才對（不過可能很無聊）所以站到台上的瞬間，就什麼都不要管了，專注在自己的演講上。</p><blockquote><p>不過也會有看起來沒啥準備就跑上來混的拉，這個就不討論了 XD</p></blockquote><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>其實不管怎麼樣，剛開始第一次或者第二次的演講都是會非常緊張的。所以要先從一些比較小規模的活動，以 Ruby 圈來說就是 Taipei.rb 這類不定期聚會，先對 20 ~ 60 人作發表，習慣在演講途中被注視的感覺。</p><p>之後再慢慢往研討會，像是 RubyConf TW 之類的嘗試，從 100 ~ 200 人左右的開始慢慢習慣，等養成了固定的習慣之後，只要演講前的「前置動作」有做好，大多數時候表現的都不會太差。</p><p>在三年前第一次去 RubyKaigi 演講的時候，已經在台灣有大概 5 ~ 10 次上台分享的經驗。不過當時比較可惜的是第一次在國外用英文，英文的程度也勉強到可以簡單的對話而已，所以實際上並不流暢（當然也很緊張）</p><p>今年稍微習慣之後，就能用比較順暢的方式在台上做分享了。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/06/19/How-do-I-prepare-a-speech/#disqus_thread</comments>
    </item>
    
    <item>
      <title>RubyKaigi 2018 會後心得</title>
      <link>https://blog.frost.tw/posts/2018/06/12/The-RubyKaigi-2018-Experience/</link>
      <guid>https://blog.frost.tw/posts/2018/06/12/The-RubyKaigi-2018-Experience/</guid>
      <pubDate>Tue, 12 Jun 2018 13:28:36 GMT</pubDate>
      <description>
      
        &lt;p&gt;今年的 RubyKaigi 比去年提早不少，作為 Ruby 開發者最大的盛會，今年也不意外的延續去年探討 Ruby 3 的可能性跟更多 Ruby 的深度應用。也因次，不意外的讓大家都聽的似懂非懂，而且還讓我感覺一年比一年的難度更高。&lt;/p&gt;
&lt;p&gt;總之，來看看今年的 RubyKaigi 吧！&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>今年的 RubyKaigi 比去年提早不少，作為 Ruby 開發者最大的盛會，今年也不意外的延續去年探討 Ruby 3 的可能性跟更多 Ruby 的深度應用。也因次，不意外的讓大家都聽的似懂非懂，而且還讓我感覺一年比一年的難度更高。</p><p>總之，來看看今年的 RubyKaigi 吧！</p><a id="more"></a><h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><p>因為飛機的關係，我們提早一天飛到日本。雖然跟平常上班一樣時間出門，不過從機場候機到旅館，已經是晚上七八點了。所以我們就在旅館附近找間燒肉店稍微吃了一下。</p><p><img src="https://blog.frost.tw/images/the-rubykaigi-2018-experience/EE88DB6FB245BFAEC9D20ED81425CC10.jpg" alt="2018-05-29 21.05.30.jpg"></p><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><p>因為提早一天，所以今天基本上就是體驗在日本遠端工作的感覺。不過實際上其實能做的事情不多，再加上中午去吃完仙台有名的牛舌後，馬上跑去附近買衣服。因為這次的旅館剛好都沒有可以投幣洗衣，送洗的話一件大概可以買一件新衣服，因為回來的路上順路就順便買了一下。</p><p><img src="https://blog.frost.tw/images/the-rubykaigi-2018-experience/95C6311914F56CD7F7A815208649A0CA.jpg" alt="2018-05-30 13.52.02-1.jpg"></p><p>晚上則是 Pre-Party 簡單來說就是從這個時間點開始，喝酒！</p><h2 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h2><p>依照慣例，都是由 Ruby 之父 Matz 進行開場，而口譯也是跟往年一樣讓人非常想睡。</p><blockquote><p>因為讓人很想睡的原因，所以以下就盡量依照記憶紀錄一下。</p></blockquote><h2 id="Analyzing-and-Reducing-Ruby-Memory-Usage"><a href="#Analyzing-and-Reducing-Ruby-Memory-Usage" class="headerlink" title="Analyzing and Reducing Ruby Memory Usage"></a>Analyzing and Reducing Ruby Memory Usage</h2><p>算是非常實用的一場演講，裡面介紹了一些方法去分析在 Ruby 裡面跟怎麽去分析記憶體使用的方法。不過很明顯的，中間那段都睡死了，幾乎沒有印象。只有很零碎的記憶，大概需要靠看投影片或者錄影才能回憶起來了。</p><h2 id="午餐"><a href="#午餐" class="headerlink" title="午餐"></a>午餐</h2><p>其實跟京都（2016）年比起來，我覺得便當品質差了很多。但是也可能是因為京都那邊對這種精緻食品比較擅長吧，去年因為是自由覓食，附近又有商店街所以反而沒有這樣的問題。</p><p><img src="https://blog.frost.tw/images/the-rubykaigi-2018-experience/10B903ACACBB43486711ACACFEFEA2FD.jpg" alt="2018-05-31 11.52.27.jpg"></p><h2 id="TTY-Ruby-alchemist’s-secret-potion"><a href="#TTY-Ruby-alchemist’s-secret-potion" class="headerlink" title="TTY - Ruby alchemist’s secret potion"></a>TTY - Ruby alchemist’s secret potion</h2><p>如果有用過 Google 的 Fastlane 來自動化 App 的打包跟部屬的話，講者花了五年所寫的 <code>tty</code> gem 就是背後的元件之一，這個 <code>tty</code> gem 裡面有非常多不同的功能，像是顯示表格、進度條等等。</p><p>如果想要寫一些 Command Line 工具卻不知道該怎麼下手的話，可以考慮使用這系列的 Gem 來輔助。</p><blockquote><p>自己是習慣在不使用 Gem 的狀況下開發，不過有很多功能透過這套 Gem 來協助可以得到比較好的使用者體驗。</p></blockquote><h2 id="Lightning-Talk"><a href="#Lightning-Talk" class="headerlink" title="Lightning Talk"></a>Lightning Talk</h2><p>因為要準備 Lightning Talk 所以錯過了幾場，雖然今年還是沒有順利的投稿上。但是運氣不錯還是獲得了五分鐘讓我發表 <code>tamashii-bluetooth</code> 這個新的 Gem 給大家。</p><p>雖然原本想作為 2019 年的主題之一，不過趁著還沒有被忘記就趕快上台發表一下這個從 BLE (Bluetooth Low Engery) 技術所衍伸的 iBeacon / EddenStone 應用，透過 <code>tamashii-bluetooth</code> 就可以輕鬆實現像是 LINE Beacon 之類的功能。</p><h2 id="Offical-Party"><a href="#Offical-Party" class="headerlink" title="Offical Party"></a>Offical Party</h2><p>依照慣例會有 Offical Party 跟當地的特色食物跟酒，不過依舊是日本人立場強大。不過有碰到客戶公司的工程師，合作半年多這麼久第一次見面。倒是客戶對我的工作狀況蠻滿意的讓我很意外，畢竟總覺得因為一直在解 Bug 感覺進度一直都不多。</p><h2 id="Controlling-Droids™-with-mruby-amp-Go"><a href="#Controlling-Droids™-with-mruby-amp-Go" class="headerlink" title="Controlling Droids™ with mruby &amp; Go"></a>Controlling Droids™ with mruby &amp; Go</h2><p>這場原本還蠻期待看到 mruby 跟 C 語言搭配使用，不過現場聽了之後反而有點失望。單純只是利用 Golang 來處理底層的問題，至於 mruby 只是作為一個腳本語言嵌入到 Golang 裡面來實作。</p><p>不過也得到一個靈感，就是明年可以考慮把 <code>tamashii-bluetooth</code> 更加完善，然後提供一個純 C 跟 Ruby 的實作。</p><h2 id="Guild-Prototype"><a href="#Guild-Prototype" class="headerlink" title="Guild Prototype"></a>Guild Prototype</h2><p>這場在 RubyElixirConf 2018 其實也有講，不過因為作為工作人員所以無法聽到。不過因為大致上的實作在台灣朋友都跟我解釋過，所以對 Guild 已經比較有概念。</p><h2 id="mruby-can-be-more-lightweight"><a href="#mruby-can-be-more-lightweight" class="headerlink" title="mruby can be more lightweight"></a>mruby can be more lightweight</h2><p>這場比較失望，原本以為會有一些關於 mruby 優化調整或者修改的部分，不過大多還是針對 Matz 在設計 mruby 上可調整的選項上來做處理，所以實際上並沒有什麼太多的突破。</p><h2 id="Firmware-programming-with-mruby-c"><a href="#Firmware-programming-with-mruby-c" class="headerlink" title="Firmware programming with mruby/c"></a>Firmware programming with mruby/c</h2><p>這場就讓我比較驚訝，在台灣蠻有名的獺祭清酒的相關監控，就是透過這套 mruby/c 的 IoT 裝置來做監控，而且不像是 mruby 是設計給 CPU 等級的硬體，而是給 MCU 這種幾乎只有非常小的記憶體可以使用的硬體。</p><p><img src="https://blog.frost.tw/images/the-rubykaigi-2018-experience/13538EFCE8A9329EBB787B50C63CA73B.jpg" alt="2018-06-01 14.45.00.jpg"></p><h2 id="ESM-Drink-up"><a href="#ESM-Drink-up" class="headerlink" title="ESM Drink-up"></a>ESM Drink-up</h2><p>再來就是據說清酒很強的 ESM 贊助商 Party 了，這兩年都有機會去到算是運氣蠻不錯的。不過還是一樣有強大的日本人力場在，讓人不禁地覺得應該要學一下日文才行。</p><p><img src="https://blog.frost.tw/images/the-rubykaigi-2018-experience/DB871BE6142FE005F2C5170398539BBA.jpg" alt="2018-06-01 19.15.40.jpg"></p><h2 id="第三天-1"><a href="#第三天-1" class="headerlink" title="第三天"></a>第三天</h2><p>因為很想睡（一般來說第二天會特別狂歡）所以上午幾乎都在睡，下午有印象的大概就只有一場。</p><h2 id="Three-Ruby-performance-projects"><a href="#Three-Ruby-performance-projects" class="headerlink" title="Three Ruby performance projects"></a>Three Ruby performance projects</h2><p>算是去年比較震撼的一場，講者是 RedHat 的工程是 GCC 的貢獻者，所以在 Compiler 上面有非常多不同獨到的見解，不過每次也是最為燒腦的議程。每年也可以學到一些不一樣的知識，不過大多都非常難以理解，以及回到台灣後需要查詢不少資料才能搞懂。</p><h2 id="After-Party"><a href="#After-Party" class="headerlink" title="After Party"></a>After Party</h2><p>晚上的 After Party 是在一間蠻大的酒吧，原本是想早點回去，畢竟日文立場還是很強大的。後來幾位同事想要去唱日本的卡拉 OK 想想覺得可以順便練習一下日文，就跟著過去。</p><p><img src="https://blog.frost.tw/images/the-rubykaigi-2018-experience/ED4E33737BF002BDF65739EAB77D58B5.jpg" alt="2018-06-02 23.26.58.jpg"></p><h2 id="東京"><a href="#東京" class="headerlink" title="東京"></a>東京</h2><p>因為要去拜訪客戶所以還安排了到東京的行程，在地圖上感覺是往北結果是往南。到了東京才發現仙台的天氣真的超讚，在台灣可能有三十幾度的溫度下，在仙台還是只有二十幾度，非常的舒適。</p><p>比較特別的就是同事有預約到 Persona 5 的主題餐廳，以及在秋葉原終於理解夾娃娃機該怎麼夾。</p><p><img src="https://blog.frost.tw/images/the-rubykaigi-2018-experience/F87A7CB27AB13B8B604F16B071BA7CEC.jpg" alt="2018-06-03 18.35.42.jpg"></p><p><img src="https://blog.frost.tw/images/the-rubykaigi-2018-experience/5C138CFC021AA9946D6907837313D5C8.jpg =3096x5504" alt="2018-06-04 11.35.43.jpg"></p><p>最後則是去拜訪一下客戶，然後就結束這次的日本行程。</p><p>另外比較的別的是日本有不少電腦書都是動漫風格的，有漫畫的電腦書超想要的！！</p><p><img src="https://blog.frost.tw/images/the-rubykaigi-2018-experience/BEFCEC952C4A354900876931339F3EC0.jpg =3096x5504" alt="2018-06-04 14.11.51.jpg"></p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>每年參加完 RubyKaigi 之後都會覺得蠻熱血的，因為有不少新的技術跟想法被提出來。不過每年都要提早一個月，填坑都來不及了還要想辦法投稿，大概也是另一種壓力來源吧。</p><blockquote><p>希望明年投稿之前可以把要投稿的題目實作出來。</p></blockquote>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/06/12/The-RubyKaigi-2018-Experience/#disqus_thread</comments>
    </item>
    
    <item>
      <title>我的 Chrome 會說話</title>
      <link>https://blog.frost.tw/posts/2018/05/30/My-Chrome-can-speak/</link>
      <guid>https://blog.frost.tw/posts/2018/05/30/My-Chrome-can-speak/</guid>
      <pubDate>Wed, 30 May 2018 04:44:30 GMT</pubDate>
      <description>
      
        &lt;p&gt;這是很多年前的事情了，當時看到別人的 Chrome 竟然會說話，讓我震驚了很久。但是花了很多年都沒有找到要怎麼做，不過最近因為一些關係，我終於知道了他的秘密！&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>這是很多年前的事情了，當時看到別人的 Chrome 竟然會說話，讓我震驚了很久。但是花了很多年都沒有找到要怎麼做，不過最近因為一些關係，我終於知道了他的秘密！</p><a id="more"></a><p>首先，這不是鬼故事！這篇文章要討論的是 Web Speech API 這個由 Google 所提交的功能。主要就是做「語音轉文字」跟「文字轉語音」兩件事情，像是有在玩遊戲可能有用過 Discord 這種類似 Slack 的通訊軟體，裡面提供的朗讀功能應該就是透過這個 API 實作的。</p><h2 id="Web-Speech-API"><a href="#Web-Speech-API" class="headerlink" title="Web Speech API"></a>Web Speech API</h2><p>在 Web Speech API 裡面其實只有兩個功能「語音轉文字」跟「文字轉語音」兩種。文字轉語音的功能可能比較常見，我們可以在像是在一些地方看到。</p><p>像是 Google 搜尋右邊的「麥克風」圖示，就是利用 Web Speech API 所製作的功能，讓我們可以利用講話的方式直接輸入搜尋的關鍵字。</p><p><img src="https://blog.frost.tw/images/my-chrome-can-speak/screenshot.png" alt="Google 搜尋的語音框"></p><p>另外就是將文字念出來，也就是這篇文章要討論的內容。</p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>那麼，要怎麼讓 Chrome （或者 Firefox 發出聲音呢？）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> msg = <span class="keyword">new</span> SpeechSynthesisUtterance(<span class="string">'Hello World'</span>);</div><div class="line"><span class="built_in">window</span>.speechSynthesis.speak(msg);</div></pre></td></tr></table></figure><p>首先，我們要產生出一個 <code>SpeechSynthesisUntterance</code> 物件，把要講的東西放進去。然後再透過 <code>speechSynthesis</code> 提供的 <code>speak</code> 把他唸出來。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> msg = <span class="keyword">new</span> SpeechSynthesisUtterance(<span class="string">'世界你好！'</span>);</div><div class="line"><span class="built_in">window</span>.speechSynthesis.speak(msg);</div></pre></td></tr></table></figure><p>當然，講中文也是完全沒有問題的。</p><blockquote><p>主要是這個 API 預設會用作業系統（Ex. macOS 的 VoiceOver 功能）所以不管是哪個瀏覽器預設都會用同樣的聲音講話。</p></blockquote><h2 id="調整語音"><a href="#調整語音" class="headerlink" title="調整語音"></a>調整語音</h2><p>因為作業系統中可能會針對各種國家的語言提供語音，所以同樣是中文，我們也可以從 <code>zh-TW</code> 切換到 <code>zh-HK</code> 讓他用廣東話的方式念出來。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> voices = <span class="built_in">window</span>.speechSynthesis.getVoices();</div><div class="line"><span class="keyword">var</span> msg = <span class="keyword">new</span> SpeechSynthesisUtterance(<span class="string">'世界你好！'</span>);</div><div class="line">msg.voice = voices[<span class="number">35</span>]; <span class="comment">// 每台電腦/瀏覽器結果可能略有不同</span></div><div class="line"></div><div class="line"><span class="built_in">window</span>.speechSynthesis.speak(msg);</div></pre></td></tr></table></figure><blockquote><p>目前似乎只有 Safari 可以正常使用，其他瀏覽器不一定可以用。</p></blockquote><p>另外就是 <code>SynthesisUtterance</code> 還有幾個參數可以玩。</p><ul><li><code>pitch</code> - 語調 0 ~ 2 設定，越大音越高</li><li><code>volume</code> - 音量</li></ul><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>這個功能在某些應用情境，像是聊天機器人。或者類似 Discord 這種通訊軟體，算是很有用的。不過似乎很少人在討論，就算是 Google 查詢「Speech API」也還不一定會看到，不過作為一個有趣的小功能倒是值得一試。</p><blockquote><p>印象中可以選擇男聲或者女聲，但是找不到。也許是 Chrome 裡面提供的語音包才有，不過目前 Chrome (66.0) 似乎切換語音不太正常，就暫時無法測試。</p></blockquote><hr><h2 id="參考文章"><a href="#參考文章" class="headerlink" title="參考文章"></a>參考文章</h2><ul><li><a href="http://blog.zhusee.in/post/56286985943/web-speech-api-part-i-using-speech-synthesis-to-make-bro" target="_blank" rel="noopener">http://blog.zhusee.in/post/56286985943/web-speech-api-part-i-using-speech-synthesis-to-make-bro</a></li><li><a href="https://developers.google.com/web/updates/2014/01/Web-apps-that-talk-Introduction-to-the-Speech-Synthesis-API" target="_blank" rel="noopener">https://developers.google.com/web/updates/2014/01/Web-apps-that-talk-Introduction-to-the-Speech-Synthesis-API</a></li></ul>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/05/30/My-Chrome-can-speak/#disqus_thread</comments>
    </item>
    
    <item>
      <title>部署你的第一個 Ruby on Rails 網站（八）</title>
      <link>https://blog.frost.tw/posts/2018/05/28/Getting-started-deploy-your-Ruby-on-Rails-Part-8/</link>
      <guid>https://blog.frost.tw/posts/2018/05/28/Getting-started-deploy-your-Ruby-on-Rails-Part-8/</guid>
      <pubDate>Mon, 28 May 2018 06:54:19 GMT</pubDate>
      <description>
      
        &lt;p&gt;前面幾篇文章已經把所有關於 Ruby 和資料庫都設定完成，最後一個階段就是要把 Nginx 設定好，並且讓 Let’s Encrypt 可以正確的被設定，讓網站支援 SSL 功能。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>前面幾篇文章已經把所有關於 Ruby 和資料庫都設定完成，最後一個階段就是要把 Nginx 設定好，並且讓 Let’s Encrypt 可以正確的被設定，讓網站支援 SSL 功能。</p><a id="more"></a><p>在開始設定之前，因為 Let’s Encrypt 針對非 Wildcard 類型可以使用檔案驗證，也是一般情況比較多使用的方式。但是第一次的驗證需要透過 HTTP 來進行，所以我們會先設定好 Let’s Encrypt 後才繼續。</p><blockquote><p>Wildcard 需要用 DNS 驗證，這是第二代的 API 才新增的功能，過去第一代都是透過放置驗證檔案來認證。</p></blockquote><h2 id="Let’s-Encrypt-設定"><a href="#Let’s-Encrypt-設定" class="headerlink" title="Let’s Encrypt 設定"></a>Let’s Encrypt 設定</h2><p>目前最簡單的設定方式就是透過 Certbot 來驗證，可以到官網的 <a href="https://certbot.eff.org/lets-encrypt/centosrhel7-other" target="_blank" rel="noopener">CentOS 7</a> 頁面獲取安裝的指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum install certbot</div></pre></td></tr></table></figure><blockquote><p>如果找不到 <code>certbot</code> 的套件，請先安裝 EPEL <code>yum install epel-release</code> 來獲得支援，不過在 PostgreSQL 安裝的步驟應該是已經安裝過了。</p></blockquote><blockquote><p>這邊不使用 <code>certbot-nginx</code> 版本的原因是我們自己 Compile 了 Nginx 可能會互相影響。</p></blockquote><p>接下來要對 Nginx 做設定，一般來說如果伺服器上預定要安裝多個網站，我們會在 <code>/opt/nginx/conf</code> 下面增加像是 <code>sites-enabled</code> 之類的資料夾放置。不過稍微複雜，這篇文章會以直接編輯 <code>nginx.conf</code> 的方式介紹。</p><p>我們先找到檔案中 <code>server {</code> 這一段，類似下面的地方。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">  listen 80;</div><div class="line">  server_name localhost;</div><div class="line">  </div><div class="line">  # ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然後加入 Let’s Encrypt 需要的設定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">  listen 80;</div><div class="line">  server_name localhost;</div><div class="line">  </div><div class="line">  location ~ /.well-known &#123;</div><div class="line">    allow all;</div><div class="line">    root /opt/nginx/html;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  # ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>這個設定會讓遇到 <code>~/.well-known</code> 開頭的頁面，都使用 <code>/opt/nginx/html</code> 這個目錄，如此一來就能夠讓 Certbot 把驗證用的檔案放在這裡面，讓 Let’s Encrypt 可以驗證到。</p><blockquote><p>如果有使用像是 OpenID 之類的，可能會互相干擾，需要調整設定值。</p></blockquote><p>完成設定後，我們用 Certbot 執行產生 SSL 憑證的指令，將網站需要的憑證生成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo certbot certonly --webroot -w /opt/nginx/html -d example.frost.tw</div></pre></td></tr></table></figure><blockquote><p>記得把 <code>-d</code> 後面的設定改為自己網站的網址。</p></blockquote><p>第一次執行的話會問一些基本的問題，像是信箱之類的用來之後通知快要過期跟一些重要訊息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Saving debug log to /var/log/letsencrypt/letsencrypt.log</div><div class="line">Plugins selected: Authenticator webroot, Installer None</div><div class="line">Enter email address (used for urgent renewal and security notices) (Enter &apos;c&apos; to</div><div class="line">cancel):</div></pre></td></tr></table></figure><p>中間會有使用者條款，輸入 <code>A</code> 即可，至於要不要同意接收一些來自 EFF 組織的訊息，就看個人。</p><p>接下來如果沒有出現其他錯誤，應該會看到類似下面的訊息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">IMPORTANT NOTES:</div><div class="line"> - Congratulations! Your certificate and chain have been saved at:</div><div class="line">   /etc/letsencrypt/live/example.frost.tw/fullchain.pem</div><div class="line">   Your key file has been saved at:</div><div class="line">   /etc/letsencrypt/live/example.frost.tw/privkey.pem</div><div class="line">   Your cert will expire on 2018-08-26. To obtain a new or tweaked</div><div class="line">   version of this certificate in the future, simply run certbot</div><div class="line">   again. To non-interactively renew *all* of your certificates, run</div><div class="line">   &quot;certbot renew&quot;</div><div class="line"> - If you like Certbot, please consider supporting our work by:</div><div class="line"></div><div class="line">   Donating to ISRG / Let&apos;s Encrypt:   https://letsencrypt.org/donate</div><div class="line">   Donating to EFF:                    https://eff.org/donate-le</div></pre></td></tr></table></figure><h2 id="設定-Nginx"><a href="#設定-Nginx" class="headerlink" title="設定 Nginx"></a>設定 Nginx</h2><p>回到 <code>nginx.conf</code> 設定檔，因為我們只有監聽 80 埠，所以只能接受 HTTP 請求。所以現在我們要做幾個修改，讓網站隨時處於 HTTPS 的安全連線狀態。</p><ul><li>把 HTTP 轉到 HTTPS</li><li>啟用 HTTPS</li></ul><p>先在原本 <code>location ~/.well-known {</code> 區段的下面增加轉跳到 HTTPS 的設定，類似這樣。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">  listen 80;</div><div class="line">  server_name example.frost.tw;</div><div class="line">  </div><div class="line">  location ~ /.well-known &#123;</div><div class="line">    allow all;</div><div class="line">    root /opt/nginx/html;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return 301 https://$server_name$request_uri;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p><code>server_name</code> 要記得改成你的網域名稱，不然在做轉跳時會因為跟申請的 SSL 憑證不符合而無法正常開啟。</p></blockquote><p>然後在這個區段下方，應該會看到一段被 <code>#</code> 註解的區塊，也就是預設的 HTTPS 設定範例。<br>我們將註解取消，然後補上需要的設定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">  listen       443 ssl;</div><div class="line">  server_name  example.frost.tw;</div><div class="line"></div><div class="line">  ssl on;</div><div class="line">  ssl_certificate      /etc/letsencrypt/live/example.frost.tw/fullchain.pem;</div><div class="line">  ssl_certificate_key  /etc/letsencrypt/live/example.frost.tw/privkey.pem;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>以上是最基本的設定，有興趣的話可以參考 <a href="https://www.digitalocean.com/community/tutorials/how-to-create-a-self-signed-ssl-certificate-for-nginx-in-ubuntu-16-04" target="_blank" rel="noopener">Digital Ocean 的教學</a>裡面有一些建議的 SSL 設定可以參考。</p></blockquote><p>然後我們要指定一下 Passenger 在這個網站啟用，以及程式碼所在的位置，所以修改成類似下面這樣的設定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">  listen       443 ssl;</div><div class="line">  server_name  example.frost.tw;</div><div class="line"></div><div class="line">  ssl on;</div><div class="line">  ssl_certificate      /etc/letsencrypt/live/example.frost.tw/fullchain.pem;</div><div class="line">  ssl_certificate_key  /etc/letsencrypt/live/example.frost.tw/privkey.pem;</div><div class="line">  </div><div class="line">  location ~ /.well-known &#123;</div><div class="line">    allow all;</div><div class="line">    root /opt/nginx/html;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  root /home/deploy/example.frost.tw/current/public;</div><div class="line">  passenger_enabled on;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>最後我們用 Nginx 指令來檢查一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo /opt/nginx/sbin/nginx -t</div></pre></td></tr></table></figure><p>如果沒有發生錯誤，就可以用 <code>systemctl</code> 指令重開伺服器，並且看到正常運作的 Rails 網站摟！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo systemctl restart nginx</div></pre></td></tr></table></figure><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>這一次的系列文章就到這邊結束了，其實還有不少小細節沒辦法在文章中提到。而且這些都會隨著時間或者有更好的方法而改變，舉例來說 Linux 系統有一個 Cron Job 的功能可以定時的執行某些指令，而 Let’s Encrypt 的憑證一般來說會在三個月左右過期。</p><p>如果不希望自己每次都手動操作的話，就會利用 Cron Job 功能自動執行 <code>certbot renew</code> 任務，並且重新啟動 Nginx 將可能被更新的憑證重新讀取進去。</p><p>部署網站除了使用現有雲端服務之外，更多的時候都會採取這樣的方式來執行，因為可以控制的部分相對的多。也比較能針對專案做適合的配置，畢竟以目前 VPS 收費一個月 $5 美金的價格來說，相比 Heroku 的性價比是高上不少的。</p><p>下次有機會的話應該會試著寫一系列使用 Chef 或 Ansible 的部署教學，這系列的方式只有個位數的伺服器需要管理可能還行得通，但是當有數十台以上的時候，就不會是什麼有效率的方法，更何況要服務客戶協助他們部署的時候。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/05/28/Getting-started-deploy-your-Ruby-on-Rails-Part-8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>部署你的第一個 Ruby on Rails 網站（七）</title>
      <link>https://blog.frost.tw/posts/2018/05/20/Getting-started-deploy-your-Ruby-on-Rails-Part-7/</link>
      <guid>https://blog.frost.tw/posts/2018/05/20/Getting-started-deploy-your-Ruby-on-Rails-Part-7/</guid>
      <pubDate>Sun, 20 May 2018 14:39:15 GMT</pubDate>
      <description>
      
        &lt;p&gt;現在伺服器還沒辦法下載到 Ruby on Rails 專案的原始碼用來部署，這一篇會介紹該如何把原始碼下載回來，並且在伺服器上將相關的 Ruby Gem 都安裝好。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>現在伺服器還沒辦法下載到 Ruby on Rails 專案的原始碼用來部署，這一篇會介紹該如何把原始碼下載回來，並且在伺服器上將相關的 Ruby Gem 都安裝好。</p><a id="more"></a><h2 id="Deploy-Key"><a href="#Deploy-Key" class="headerlink" title="Deploy Key"></a>Deploy Key</h2><p>要讓 Capistrano 自動在伺服器上下載原始碼，我們必須先讓 GitHub 或者 Gitlab 這類服務允許這台伺服器下載，所以我們要先對 <code>deploy</code> 這個部署用的使用者，產生一組下載原始碼的 SSH Key 也就是所謂的 Deploy Key。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo su - deploy</div><div class="line">ssh-keygen -t rsa</div></pre></td></tr></table></figure><p>利用 <code>ssh-keygen</code> 指令，我們可以生成一組 Private Key 和一組 Public Key 給 <code>deploy</code> 這個使用者使用，跟我們用來 SSH 到伺服器的是一樣的概念，只不過現在是要讓他當作「驗證權限」的證明，讓 GitHub 接受伺服器下載原始碼。</p><p>將生成的 <code>~/.ssh/id_rsa.pub</code> 內容，複製後貼到 GitHub 專案中 Settings &gt; Deploy Keys 裡面，用來允許這台伺服器下載。</p><p><img src="https://blog.frost.tw/images/getting-started-deploy-your-ruby-on-rails-part-7/figure.png" alt="螢幕快照 2018-05-20 下午10.08.30.png"></p><blockquote><p>GitHub 只允許同一把 Deploy Key 存在一次，所以如果想要讓多台伺服器共用的話，可以先在一台產生，其他伺服器共用。但是盡量避免使用自己電腦中的，因為 Deploy Key 只能讀取會安全許多。</p></blockquote><p>如此一來，在設定正確的狀況下，我們就可以順利的讓伺服器下載到原始碼。</p><h2 id="檢查"><a href="#檢查" class="headerlink" title="檢查"></a>檢查</h2><p>一般在部署之前，我們都會用 <code>cap staging deploy:check</code> 確認基本的操作都是正常的，也就是產生這次部署的版本、下載原始碼跟設定檔已經正確生成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cap deploy:check</div></pre></td></tr></table></figure><p>如果伺服器正確的話，應該是不會有錯誤訊息。不過我們嘗試透過 git 來下載原始碼，伺服器上可能是沒有 git 環境的，所以先透過 yum 安裝套件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install git</div></pre></td></tr></table></figure><p>如此一來，<code>cap staging deploy:check</code> 就會回報已經可以正確地產生新的資料夾，以及下載原始碼。</p><h2 id="JavaScript-Runtime"><a href="#JavaScript-Runtime" class="headerlink" title="JavaScript Runtime"></a>JavaScript Runtime</h2><p>伺服器環境預設是沒有 JavaScript 的執行環境，不然在我們執行 <code>cap staging deploy</code> 的時候，就可以順利的部署完成。</p><p>不過，因為 Assets Precompile 的關係，我們至少需要有 Node.js 的環境才行。</p><p>我們可以利用 Node.js 官方提供的<a href="https://nodejs.org/en/download/package-manager/#enterprise-linux-and-fedora" target="_blank" rel="noopener">設定程式</a>，讓 CentOS 可以支援較新版本的 Node.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># Node 8 是寫這篇文章的穩定版</div><div class="line">curl --silent --location https://rpm.nodesource.com/setup_8.x | sudo bash -</div></pre></td></tr></table></figure><p>當這段設定程式執行完畢後，我們就可以利用 yum 指令更新或者安裝。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum install -y nodejs</div></pre></td></tr></table></figure><blockquote><p>實際上 Node.js 的環境影響並不大，即使是舊版的 Node.js 環境也是可以正常的完成 Assets Precompile</p></blockquote><p>假設有使用 Webpack 的話，對於 Webpacker 這個 Gem 還會需要使用 Yarn 來安裝 Node.js 套件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl --silent --location https://dl.yarnpkg.com/rpm/yarn.repo | sudo tee /etc/yum.repos.d/yarn.repo</div><div class="line">sudo yum install yarn</div></pre></td></tr></table></figure><p>安裝的方法跟 Node.js 基本上是沒有太大的差異，一樣是透過官方的設定程式將 yum 可以安裝的來源增加，就可以透過 yum 安裝或者升級。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>現在我們只需要透過 <code>cap staging deploy</code> 就可以把 Ruby on Rails 專案傳到伺服器，並且將一切都安裝完畢。</p><blockquote><p>如果有出現錯誤，可能就是使用的 Gem 使用了一些 C 語言編寫的套件，需要額外的安裝一些套件才可以解決，這就考驗大家的應變能力了！</p></blockquote><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>到這篇文章為止，我們只剩下一個步驟——設定 Nginx 伺服器。雖然我們安裝好了伺服器，但是並沒有設定這個專案要怎麼被 Passenger 啟動。</p><p>下一篇是最後一篇，會講解怎麼設定 Nginx 伺服器以及套用 Let’s Encrypt 來設定 SSL 加密。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/05/20/Getting-started-deploy-your-Ruby-on-Rails-Part-7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>關於我怎麼準備人生第一次的履歷和面試</title>
      <link>https://blog.frost.tw/posts/2018/05/14/About-my-first-time-interview-and-resume/</link>
      <guid>https://blog.frost.tw/posts/2018/05/14/About-my-first-time-interview-and-resume/</guid>
      <pubDate>Sun, 13 May 2018 16:58:04 GMT</pubDate>
      <description>
      
        &lt;p&gt;最近又到了畢業的季節，今年比較不一樣的大概是我有稍微幫幾個學弟妹看了一下履歷。還有公司今年暑期實習生的履歷，我也都看了一遍。&lt;/p&gt;
&lt;p&gt;看完之後就發現，跟當初退伍前準備的情況不一樣，我們肯定搞錯重點了 XD&lt;/p&gt;
&lt;p&gt;總之，這不是一篇雞湯文，是雞精文！&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>最近又到了畢業的季節，今年比較不一樣的大概是我有稍微幫幾個學弟妹看了一下履歷。還有公司今年暑期實習生的履歷，我也都看了一遍。</p><p>看完之後就發現，跟當初退伍前準備的情況不一樣，我們肯定搞錯重點了 XD</p><p>總之，這不是一篇雞湯文，是雞精文！</p><a id="more"></a><p>文章就分兩個部分，履歷跟面試，內容基本上就是約兩到三年前剛退伍後找工作的狀況。</p><p>不過，有一點要強調的是我的狀況不太一樣，我小學就因為興趣的關係自學程式。中間的累積跟從大學才開始認真練習的情況是差很多的，不過大部分的人都不是這樣，所以也不太需要擔心。</p><h2 id="履歷篇"><a href="#履歷篇" class="headerlink" title="履歷篇"></a>履歷篇</h2><p>履歷基本上分兩種，客製化的跟制式化的。制式化的基本上不用討論，大多就是求職網站提供的，或者再聯絡到某間公司由 HR（人力資源）提供的版本。</p><p>如果是走制式化的履歷，大概就是真的要拼學歷跟經歷了。畢竟那是方便快速篩選人的方法，先從最簡單的方法篩選，就是假設名校之類的比較厲害。</p><blockquote><p>不過以我看履歷的狀況，即使是台清交來投工程師，如果作品都是作業的話，我根本分不出來誰比較好，同樣的條件下就會先以有自己作品的優先，剩下無法比較才用學歷比（高學歷的人在學習上通常會有一套方法，這可以幫助他們快速適應新環境跟工作）</p></blockquote><p>所以，到了客製化履歷的情況，基本上我自己看的順序是這樣的。</p><ul><li>作品</li><li>專長</li><li>履歷外觀</li><li>自我介紹</li></ul><p>雖然老闆們的看法似乎不太一樣，不過我會這樣看（在一間軟體公司）是有原因的。</p><p>首先是作品，我看作品（一般是放在 GitHub 上）的原因主要是要確認「程式技能」到底是怎麼樣的。如果是熟練寫程式的人，基本上都會有自己的小專案或作品，然後再深入看他使用的這個語言，寫起來是怎麼樣的。</p><p>以 Ruby on Rails 專案來當例子，一個投實習生的人知道怎麼應用 <code>before_action</code> 或者 <code>Concern</code> 之類的技巧，基本上都可以放到正職候補了（實習階段來觀察）</p><p>所以第一點就是先看程式怎麼寫，雖然是很主觀的感覺，但是當寫程式的程度每提升一個階段，寫出來的東西就會差異很大。</p><blockquote><p>這幾年來我接觸過（能寫小東西）的語言可能也有快十種，學寫程式入門學的是邏輯，怎麼讓程式動起來，學會了換語言基本上沒問題。在下一步的是學特性，每種語言都有它設計的理由跟背景，快慢之類的還算其次，但精髓在於能不能了解這個語言或框架想解決的問題跟善用它針對的問題所提供的特性。</p></blockquote><p>另外 UI/UX 的實習生履歷我也有看，畢竟我在高中也是自學了一些設計上的理論知識，受過四年多媒體科系的教育，雖然現在無法當個戰力但是基本的鑑別能力還是有的。</p><p>跟看程式作品一樣，水準蠻好看出來的，基本上只要會「排版」就算通過最低門檻。在客製化履歷上也會體現出這個程度差異，如果連放在一張 A4 紙上的東西都能對齊到歪的，真的很難繼續研究什麼叫做 UI/UX 技能，就算 PhotoShop 或是 Illustrator 用的再好也沒用，搞不好連個會用 Word 的工程師都能做得比你整齊。</p><blockquote><p>客製化履歷的風險也在這邊，排版技能直接變成第一線的死穴。尤其 UI 上沒排好美感就不會出來，而 UX 上沒排好也不會有好的體驗。</p></blockquote><p>接下來就是看專長，不過基本上都是參考為主。原因是因為可能上面會是「我會 Ruby、MySQL」之類的，或者是不知道何時流行起的「PhotoShop ★★★☆☆」這種模式，不過後者我也有幹過，但是現在絕對不是個好方案。</p><p>那麼要怎麼寫呢，當時我是問業界的前輩中間聊到後，推導出應該是像這樣。</p><p>Ruby on Rails</p><ul><li>做過五個以上正式上線的專案</li><li>參與過日本手遊伺服器專案升級</li><li>擔任三次以上 Rails Girls Taiwan 教練</li></ul><p>然後就把有辦法列一到兩個實績的技能列出來，至少大家可以快速分辨出會什麼。</p><blockquote><p>UI/UX 這方面就很難判斷，看履歷時我發現這兩個人同一組。有兩個包裝作品我都認為做得很好，而且他們兩個人都有放，所以我第一時間的疑問是「有沒有第三個人，其實是他做的」不過能跟這種高手一組，也算是一種實力吧，只是參考的點就會把其他作品比重看得比較重。</p></blockquote><p>履歷外觀跟自我介紹就不多說，履歷外觀乾淨整齊就好了。不過還是會有像前面提到的客製化到歪掉，或者明明 Word 的行高預設值明明不是這麼矮的，字卻擠成一團的那種，如果前面的評分一樣，我就會選履歷最整齊乾淨的那個⋯⋯</p><p>不然也不用客製化履歷了，關鍵時刻發揮作用給看履歷的人好印象啊！至於自我介紹，大概要到老闆說可以約面試我才會看，因為講再多還是不如面對面談一次。</p><h2 id="面試篇"><a href="#面試篇" class="headerlink" title="面試篇"></a>面試篇</h2><p>這部分我就不好講解了，因為目前的公司（五倍紅寶石）根本是被老闆問說要不要來，去聊天幾次被貓咪騙去的。其他公司大多也是去「聊天」為主，通常進去出來就是一個小時，面試的過程中到後面就會跟面試官聊起來（雖然還在面試的範圍內）</p><p>不過面試有一個基本的心理因素要滿足——要有自信。</p><p>如果你都不能相信自己的專業技能，要怎麼讓面試你的人相信你有這個能力呢？實際上，遇到你不會的問題，有時候不一定是「扣分」的，只是面試官在抓你的能力在哪裡。</p><blockquote><p>當時有一間公司是認識且厲害的前輩在那邊，去面試的第一階段是寫一份約兩到三頁的試題，一個小時過去大約是回答了五到七成左右。在面試結束時我問了答題的狀況，原來大部分的人連一半的沒辦法回答，有時候不是自己水準太低，而是公司水準太高（所以你有很多能學）保持自信是很重要的，因為你不能確定是哪個情況。</p></blockquote><p>回到面試過程，基本上就是這兩點。</p><ul><li>確認能力</li><li>檢查人品</li></ul><p>如果都已經被約面試，其實能力上來說是被公司認可了（除非沒得選）所以面試就是做兩件事情，先確認履歷跟現實是相符的。也許會出現在工程師界常聽到的白板考之類的，雖然碰過但是應該很少會問演算法之類的，而是要看思考的方式（除非你的工作很需要演算法）但是重點就只有一個，我們看到的東西是不是和實力相符。</p><blockquote><p>重申一次，如果因為沒自信而緊張，不小心忘記原本會的東西或者沒辦法用其他方式回答，就真的很吃虧了。</p></blockquote><p>最後是確認人品，簡單說就是看你的個性跟做事的方式，適不適合這間公司。這就很考驗面試者的看人能力，因為一個人到底能不能跟其他同事好好相處，或者在工作上能夠好好的調適自己內心等等，都會影響到未來工作的表現等等。</p><p>來舉幾個例子，可能會比較好懂。</p><p>有位朋友之前嘗試來應徵實習生，也通過履歷的階段來到面試階段。我跟他說「你一定可以上的，不用擔心」也跟老闆說「雖然不是那種實力很強的，但是很認真的學習，『態度』很好。」不過後來他還是決定去帶營隊，就這樣跟這個機會錯過。</p><p>另外一個是從老闆那邊聽說，客戶公司有一個員工。做了一段時間後，就光明正大的在上班時間找工作跟滑臉書，老闆過來請他不要這樣，還回嗆老闆。因為是客戶，所以我們老闆那段時間剛好還看到了那位員工寫程式的狀況，一行一個 Commit （版本管理存檔的單位）在送的，根本是湊數用。</p><p>很明顯的，這位員工在我們公司就是黑單。連老闆支援的一些社群活動，大概都不會有他出場的機會。</p><p>簡單來說，面試要有「自信」跟平常就要培養好的「態度」這個即使是短短半小時的交流，也可以透過平常的習慣被知道，想要隱藏是很難的。</p><blockquote><p>另外既然我們身處台灣，業界真的很小。大概就是換幾間公司就會遇到認識的人，你以為這間公司看起來不怎麼出名，結果搞不好現在的老闆和這間公司的老闆是好朋友也說不定。在公司的表現，很有可能會讓你在其他公司都沒辦法過關。</p></blockquote><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>履歷的重點其實就是怎樣讓你「被關注」方法不一定，畢竟每個人看的東西不太一樣。但是作品不會騙人，平常就要注意累積作品，作品多其實就是你平時有累積跟練習的證明。</p><p>至於面試，保持自信就不會吃虧。然後態度，這種東西雖然短時間可能改不了，但是可以培養跟訓練，如果態度一開始就很差，小心被黑單吧 XD</p><p>最後，關於自信我在用一個小故事總結。</p><p>以前小學剛學會寫程式的時候，卻被同學誤會說「我覺得你這個人很驕傲」<br>不過，我一直都不認同這一點。因為我是這樣認為的。</p><p>「有實力的叫自信，沒有實力的叫驕傲」</p><p>有實力就會相信自己做得到，沒有實力說自己做得到，就是驕傲跟自滿。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/05/14/About-my-first-time-interview-and-resume/#disqus_thread</comments>
    </item>
    
    <item>
      <title>部署你的第一個 Ruby on Rails 網站（六）</title>
      <link>https://blog.frost.tw/posts/2018/05/07/Getting-started-deploy-your-Ruby-on-Rails-Part-6/</link>
      <guid>https://blog.frost.tw/posts/2018/05/07/Getting-started-deploy-your-Ruby-on-Rails-Part-6/</guid>
      <pubDate>Mon, 07 May 2018 01:59:38 GMT</pubDate>
      <description>
      
        &lt;p&gt;經過前面五篇的教學，我們距離將 Ruby on Rails 部署到伺服器上越來越接近了。上一階段我們在本機段將部署的設定做完之後，這一篇文章會回到伺服器將部署所需的設定補齊，讓 Capistrano 可以正確的將程式碼部署到伺服器。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>經過前面五篇的教學，我們距離將 Ruby on Rails 部署到伺服器上越來越接近了。上一階段我們在本機段將部署的設定做完之後，這一篇文章會回到伺服器將部署所需的設定補齊，讓 Capistrano 可以正確的將程式碼部署到伺服器。</p><a id="more"></a><p>在<a href="https://blog.frost.tw/posts/2018/04/10/Getting-started-deploy-your-Ruby-on-Rails-Part-5/">上一篇</a>裡面，我們設定了部署到 Staging 的使用者為 <code>deploy</code> 所以我們要先在伺服器上增加這個使用者。</p><blockquote><p>我們會習慣開設一個沒有 <code>sudo</code> 權限和密碼的使用者，只用於部署。</p></blockquote><h2 id="新增部署用帳號"><a href="#新增部署用帳號" class="headerlink" title="新增部署用帳號"></a>新增部署用帳號</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">useradd deploy</div></pre></td></tr></table></figure><p>如果還記得我們在<a href="https://blog.frost.tw/posts/2018/04/10/Getting-started-deploy-your-Ruby-on-Rails-Part-1/">第一篇</a>裡面提到的新增使用者方法，後續的動作基本上是大同小異的。</p><blockquote><p>有些 Linux 系統不一定會在做完 <code>useradd</code> 後自動新增 <code>/home/deploy</code> 可以自己用 <code>mkdir /home/deploy</code> 後做 <code>chown -R deploy:deploy /home/deploy</code> 來手動設定。</p></blockquote><p>接下來，我們切換到 <code>deploy</code> 使用者，並且設定使用金鑰登入。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo su - deploy</div><div class="line">mkdir ~/.ssh</div><div class="line">chmod 700 ~/.ssh</div></pre></td></tr></table></figure><p>複製本機的 <code>id_rsa.pub</code> 內容，並且貼到伺服器上的 <code>~/.ssh/authorized_keys</code> 上，如果忘記步驟可以回第一篇看。</p><h2 id="安裝資料庫"><a href="#安裝資料庫" class="headerlink" title="安裝資料庫"></a>安裝資料庫</h2><p>一般情況下我們在 Ruby on Rails 專案大多採用 PostgreSQL 來做為資料庫，不過在 CentOS 上不一定會提供我們所希望的版本，所以需要先到 <a href="https://www.postgresql.org/download/linux/redhat/" target="_blank" rel="noopener">PostgreSQL 官網</a>取得對應的套件設定。</p><p><img src="quiver-image-url/947E30127205650F228B211EF7CFBE67.png =960x540" alt="螢幕快照 2018-04-22 下午9.02.44.png"></p><p>根據官網選擇所需的資料庫版本（目前大多是使用 9.5 ~ 9.7）然後取得安裝的指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 安裝 PostgreSQL 10 為例</span></div><div class="line"></div><div class="line">sudo yum install https://download.postgresql.org/pub/repos/yum/10/redhat/rhel-7-x86_64/pgdg-centos10-10-2.noarch.rpm</div><div class="line">sudo yum install postgresql10-server</div></pre></td></tr></table></figure><p>因為我們需要的是伺服器，所以就可以不安裝客戶端的部分。不過我們可能會使用一些 PostgreSQL 的 Extension 以及 Ruby 需要有 PostgreSQL 的部分原始碼來編譯，所以我們需要再額外追加另外幾個套件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum install postgresql-contrib postgresql-devel postgresql-client</div></pre></td></tr></table></figure><p>最後，將 PostgreSQL 伺服器開啟，並且設定為開機自動啟動。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo systemctl <span class="built_in">enable</span> postgresql-10</div><div class="line">sudo systemctl start postgresql-10</div></pre></td></tr></table></figure><h2 id="創建資料庫"><a href="#創建資料庫" class="headerlink" title="創建資料庫"></a>創建資料庫</h2><p>剛安裝好的狀況下，是只有 <code>postgres</code> 這個使用者可以使用的。而我們希望可以在不特別設定密碼的狀況下連上資料庫，所以我們可以透過以下的方法。</p><ul><li>建立 <code>deploy</code> 資料庫使用者</li><li>給予 <code>deploy</code> 使用者建立資料庫權限</li><li>由 <code>deploy</code> 使用者建立資料庫（等同擁有者）</li></ul><blockquote><p>其實應該是開好資料庫後指定 <code>deploy</code> 資料庫使用者為所有者，不過步驟會稍微複雜一些。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo su - postgres</div><div class="line">createuser --createdb deploy</div></pre></td></tr></table></figure><p>完成之後，我們就可以回到 <code>deploy</code> 使用者上開設資料庫。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo su - deploy</div><div class="line">createdb example_db</div></pre></td></tr></table></figure><blockquote><p><code>example_db</code> 記得替換成你的專案的名稱，像是 <code>mystore_production</code> 之類的。</p></blockquote><h2 id="準備設定檔"><a href="#準備設定檔" class="headerlink" title="準備設定檔"></a>準備設定檔</h2><p>在上一篇我們設定了 <code>config/secrets.yml</code> 為設定檔，所以我們需要先建立起來，以免在部屬的時候找不到。</p><p>舉例來說，如果我們設定了 <code>deploy_to</code> 為  <code>/home/deploy/staging</code> 的話，需要先建立好 <code>shared</code> 目錄並把檔案放進去。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo su - deploy</div><div class="line">mkdir -p /home/deploy/staging/shared/config</div></pre></td></tr></table></figure><p>然後用 Vim 編輯 <code>config/secrets.yml</code> 這個檔案，將必要的內容放進去。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attr">staging:</span></div><div class="line"><span class="attr">  secret_key_base:</span> <span class="string">SECRET_KEY_BASE</span></div></pre></td></tr></table></figure><blockquote><p><code>secret_key_base</code> 的值可以用 <code>rake secret</code> 指令產生。</p></blockquote><p>如果有使用資料庫的話，也別忘記將 <code>config/database.yml</code> 設定好放到 <code>/home/deploy/staging/shared/config</code> 目錄裡面。</p><blockquote><p>前面用的創建資料庫方法可以只寫下資料庫名稱，帳號跟密碼會自動被偵測到。</p></blockquote><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>到此為止，我們基本上已經將 Capistrano 設定完畢。下一篇我們要讓 GitHub （或是你自己的 Git 伺服器）允許我們的伺服器可以將專案下載下來，最後再將 Nginx 對應的 Passenger 設定補上，就可以完成第一次的部署了！</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/05/07/Getting-started-deploy-your-Ruby-on-Rails-Part-6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>RubyElixirConfTW 2018 會後感想</title>
      <link>https://blog.frost.tw/posts/2018/05/01/The-RubyElixirConfTW-2018-Experience/</link>
      <guid>https://blog.frost.tw/posts/2018/05/01/The-RubyElixirConfTW-2018-Experience/</guid>
      <pubDate>Mon, 30 Apr 2018 17:11:54 GMT</pubDate>
      <description>
      
        &lt;p&gt;Ruby Conference Taiwan 到今年已經是第七年了，印象中我大概是從 2013 年左右開始參加了，應該也有四五次。今年也加入了 Elixir 一起合辦，因為是&lt;a href=&quot;https://5xruby.tw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;五倍紅寶石&lt;/a&gt;的員工，所以也當了兩年的工作人員。&lt;/p&gt;
&lt;p&gt;那麼，就看看今年有什麼新鮮的事情吧！&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>Ruby Conference Taiwan 到今年已經是第七年了，印象中我大概是從 2013 年左右開始參加了，應該也有四五次。今年也加入了 Elixir 一起合辦，因為是<a href="https://5xruby.tw" target="_blank" rel="noopener">五倍紅寶石</a>的員工，所以也當了兩年的工作人員。</p><p>那麼，就看看今年有什麼新鮮的事情吧！</p><a id="more"></a><h2 id="籌備"><a href="#籌備" class="headerlink" title="籌備"></a>籌備</h2><p>因為在公司很多事情都喜歡參與一點，雖然不是主要的籌備人員不過還是默默的在籌備的群組觀察。最主要的大概還是 Ruby 研討會的贊助問題，除了相對小眾之外，這幾年很多研討會的出現，其實也瓜分了不少公司的贊助預算。而會採用 Ruby on Rails 的公司大多也是新創公司（畢竟以製作 MVP 來說基本上還是最快）所以就不容易取得贊助。</p><p>其他部分的話其實還是跟往年一樣，一個字形容「趕」各種設計物或者其他的東西，對上班族來說要準備這些其實<strong>壓力很大</strong>，不過總覺得這個坑是我自己在 SITCON 挖出來的，後來不少研討會又因為前端的技術進步，都默默的做這樣的規劃。</p><h2 id="Tamashii"><a href="#Tamashii" class="headerlink" title="Tamashii"></a>Tamashii</h2><p>當初 RubyConfTW 是跟 Python 社群借用一套利用 Raspberry Pi 的 NFC 感應打卡機，不過後來就沒有繼續維護。於是就只能自己開發，這也變成了五倍紅寶石的內部專案。不過一直到 2016 年的 RubyConfTW 都是蠻混亂的狀況，像是因為沒有 ActionCable 的客戶端只好用模擬器模擬之類的。</p><p>在 2016 年底我跟強者同事 <a href="https://lctseng.github.io/" target="_blank" rel="noopener">Henry</a> 一起開始了重寫計畫，我負責伺服端而 Henry 則是客戶端，並且在第一次測試的後就順利溝通。發展到 2018 年總算是可以穩定的在一些活動上使用，不過還有著一些硬體上的限制（鬆脫）之類的需要處理，但是整體上已經遠比 2016 年的狀況好上不少。</p><blockquote><p>後來 2017 年的兩位實習生加入這個專案，目前由我們四個人貢獻 <a href="https://tamashii.io" target="_blank" rel="noopener">Tamashii</a> 專案，主要是以容易使用為目標來設計，有興趣的話也歡迎送 Pull Request 或 Issue 給我們改進。</p></blockquote><h2 id="議程"><a href="#議程" class="headerlink" title="議程"></a>議程</h2><p>因為目前使用的錄影設備是跟<a href="https://ruydo.tw" target="_blank" rel="noopener">幕凡</a>一起利用開源的軟體搭配一些影像擷取卡土炮出來的，所以我大部分的時間都在主要的會議廳。不得不說付出了昂貴的場地費，使用張榮發國際會議中心的效果真的很好，至少作為主要會議廳的那一間，是配有專業的設備可以將所有聲音、影像都切進來，我們使用的土炮設備幾乎一半不需要就能做到相同效果。</p><p>不過議程上因為主要把精力花在錄影和關注會場的狀況，所以就沒有都完整的聽到。</p><h2 id="Ruby-after-25-years"><a href="#Ruby-after-25-years" class="headerlink" title="Ruby after 25 years"></a>Ruby after 25 years</h2><p>這麼多次的經驗後，其實大概知道 Matz 的演講大多是當年度象徵性的，今年的主題也很明確就是 Ruby 3x3 裡面的 Ruby 2.6 版。至少從出現 JIT 開始，今年有關 Ruby 的研討會大多會是討論 Ruby 2.6 為主。</p><p>不過這場幾乎沒有聽到內容（也有可能是酒喝多了），不過今年大概是拿到幾個新成就讓我比較興奮。</p><p>第一個是第一次發現跟外國人用英文交談，即使對單字不太能理解，但是說的部分已經不會嚴重卡住。<br>第二個是因為問 Matz 關於 mruby 的問題，順利的被記住而被打招呼。<br>最後一個是今年超容易跟 Matz 交談到，完全不知道為什麼 XD</p><h2 id="How-the-Rubyist-use-Blockchain"><a href="#How-the-Rubyist-use-Blockchain" class="headerlink" title="How the Rubyist use Blockchain"></a>How the Rubyist use Blockchain</h2><p>我自己的演講，因為有口譯的關係有嘗試放慢速度。另外一個點就是我認為「區塊鏈可以講的東西不多」所以也特意放慢一點，畢竟對工程師來說區塊鏈可以使用的方法就是那幾種。我們需要注意的是不要被這些東西迷惑，還有就是了解怎麼樣去創造應用。</p><p>區塊鏈本身是概念上的創新，所以我們製作應用也需要用改變概念的方式去嘗試會比較適合。</p><blockquote><p>有興趣的話可以讀看看我之前寫的<a href="https://blog.frost.tw/posts/2018/04/02/The-blockchain-I-know-about-in-2018/">在 2018 年我所知道的區塊鏈</a>基本上就是演講的內容，只是沒有後半段用 Ruby 跟 Ethereum 互動的部分。</p></blockquote><h2 id="Method-JIT-compiler-for-MRI"><a href="#Method-JIT-compiler-for-MRI" class="headerlink" title="Method JIT compiler for MRI"></a>Method JIT compiler for MRI</h2><p>這場其實也沒有聽到，不過因為剛好有對這方面比較了解的朋友有來，在會後的 Official Party 幫我稍微釐清了一些脈絡大方向。關於 Ruby 的 JIT 我是很關注的，就我自己認為 Ruby 3x3 的關鍵應該會落在 JIT 最後的表現。</p><p>大致上來說 Ruby 社群會希望「向下相容」再加上「不希望花時間在維護因為 LLVM 之類的升級造成的變動」所以才會採取「產生 C 語言程式碼」和以 Method 為單位的 JIT 來設計。</p><p>同時也有 YARV-JIT 和 RTL-JIT 兩種方案在執行，這次在 Ruby 2.6 加入的是 YARV-JIT 的版本，不過之後的發展還是不確定的。</p><h2 id="Inspecting-and-Crafting-Rails"><a href="#Inspecting-and-Crafting-Rails" class="headerlink" title="Inspecting and Crafting Rails"></a>Inspecting and Crafting Rails</h2><p>這場演講看似是在講怎麼調整 Rails 讓他運行的更快，不過其最有價值的反而是展示了怎麼應用像是 <code>ObjectSpace</code> 這類技巧，讓我們在開發 Ruby 專案遇到瓶頸的時候，可以用適合的方法去優化 Ruby 專案。</p><h2 id="Progress-report-of-“Ruby-3-Concurrency”"><a href="#Progress-report-of-“Ruby-3-Concurrency”" class="headerlink" title="Progress report of “Ruby 3 Concurrency”"></a>Progress report of “Ruby 3 Concurrency”</h2><p>這場也是我很專注的議題，關於 Ruby 中的 Concurrent 實現。之前其實有一篇文章介紹過了幾種 Concurrent 模型，不過在 Ruby 裡面其實都是不太適合的。</p><p>不過這場演講有大概交代了 Ruby 的 Concurrent 模型 Guild 的設計是受到什麼啟發，還有應用上可以透過怎樣的形式。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>今年覺得最大的收穫大概是去年在 RubyKaigi 聽得不少議程其實都沒有搞懂太多，不過經過這半年多的消化或者調整的思考方式，所以這次其實不少關於 Ruby 一些關於 C 語言的部分這次都能夠大概的理解。</p><p>大致上來說，從去年在考慮是不是要嘗試成為 Ruby 的 Commiter 這件事情，到這次的活動結束。讓我認為自己應該是適合成為 Ruby Commiter 的，雖然可能要花上好幾年才能完成，不過也許是我在追求作為自己理想中的開發者的必經之路。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/05/01/The-RubyElixirConfTW-2018-Experience/#disqus_thread</comments>
    </item>
    
    <item>
      <title>如何在 2018 年被詐騙</title>
      <link>https://blog.frost.tw/posts/2018/04/24/How-to-be-scammed-in-2018/</link>
      <guid>https://blog.frost.tw/posts/2018/04/24/How-to-be-scammed-in-2018/</guid>
      <pubDate>Tue, 24 Apr 2018 11:50:12 GMT</pubDate>
      <description>
      
        &lt;p&gt;這是關於某天晚上接到詐騙電話的分析，因為過程中太多細節的東西讓人掉入陷阱，跟同事聊過之後覺得還是寫一篇文章記錄會比較好，至少不會有人又踩到這樣的坑。&lt;/p&gt;
&lt;p&gt;這篇文章重點也很簡單，&lt;strong&gt;「不要以為你不會被騙」&lt;/strong&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>這是關於某天晚上接到詐騙電話的分析，因為過程中太多細節的東西讓人掉入陷阱，跟同事聊過之後覺得還是寫一篇文章記錄會比較好，至少不會有人又踩到這樣的坑。</p><p>這篇文章重點也很簡單，<strong>「不要以為你不會被騙」</strong></p><a id="more"></a><h2 id="先從結局開始"><a href="#先從結局開始" class="headerlink" title="先從結局開始"></a>先從結局開始</h2><p>很幸運的，繳了一點學費給詐騙集團。因為平常有管理存款的習慣，所以其實只讓對方成功了很小的金額，基本上就是這個月接近月底剩下的生活費。</p><p>雖然做了筆錄跟嘗試套對方話，但是基本上沒什麼效果就是了⋯⋯</p><h2 id="系統升級失敗"><a href="#系統升級失敗" class="headerlink" title="系統升級失敗"></a>系統升級失敗</h2><p>週末的晚上，我在電腦桌前打瞌睡醒來就接到一通電話。</p><p>「你在一月多訂的東西收到了嗎？」<br>「我是某某公司的會計，剛剛在對帳時發現了一點問題。」<br>「在一月多你從我們線上購物平台購買的商品，因為購物平台工程師升級造成的錯誤，多扣了兩次。」<br>「等一下我會幫你聯絡銀行，勁量爭取在 <strong>24:00</strong> 前取消。」</p><p>完美的起手式，但是我還是中招。主要是因為我清楚這幾點：</p><ul><li>會計有可能在這個時間點（十點）還有處理東西</li><li>系統升級失敗確實會有這種情況（身為工程師的經驗）</li></ul><p>不過，如果冷靜思考的話，其實也會有一些疑點在。</p><ul><li>銀行半夜會有人嗎？</li><li>已經過了三個多月扣款還能成功嗎？</li></ul><p>其實當時也有點懷疑，像是多扣到銀行應該會通知我（透過 APP）之類的，但是完全沒有通知，而且很剛好的是該銀行刷卡通知改成 APP 後有出包不一定會收到。</p><p>而且，對你的情報是<strong>恰到好處的含糊</strong>這時候如果能跟對方多確認一些細節，就可能不會中招。</p><blockquote><p>很剛好是上週末店家才跟我約週一送，週末就打來騙了⋯⋯<br>電話號碼也很用心，因為我記得店家是中南部的，顯示的號碼也是 07 之類的開頭。</p></blockquote><h2 id="友好的閒聊"><a href="#友好的閒聊" class="headerlink" title="友好的閒聊"></a>友好的閒聊</h2><p>前面為什麼要爭取在 24:00 之前呢，根據我找到的資訊銀行會統一在 24:00 的時候做一次統一結算，這時候要取消轉帳交易就變得很困難，所以通常會選擇<strong>接近午夜</strong>的時候行動。</p><blockquote><p>非上班時間接到都詐騙，如果真的很重要的話銀行應該會用各種方式聯絡到你，晚上不接這種最安心拉。</p></blockquote><p>前面其實有跟我詢問<strong>銀行客服</strong>電話，是假裝要真的去聯絡銀行。不過我跟他說我是用「虛擬卡」所以沒有實體卡片可以看，不過其實對方從一開始就沒打算認真問就是了。</p><p>「剛剛你說的那個『虛擬卡』是什麼？」<br>「我跟同事討論了一下，第一次聽到，可以跟我解釋一下嗎？」</p><p>然後我就稍微解釋一下，因為是中年大媽的聲音，所以我以為就是沒用過的大媽。</p><p>「喔喔，謝謝你啊！我跟同事應該會去辦來看看。」</p><p>超溫馨的有沒有，這時候防備的戒心已經開始消失了，你會心想<strong>這麼好的人應該不是詐騙吧</strong>。</p><p>接下來我就開始等銀行電話，中間其實一直有<strong>奇怪</strong>的感覺，但是都沒注意到已經踩到陷阱。</p><blockquote><p>其實我妹有聽到我講電話，但是我妹一開始是以為在跟朋友聊天。</p></blockquote><h2 id="銀行的服務"><a href="#銀行的服務" class="headerlink" title="銀行的服務"></a>銀行的服務</h2><p>大概是晚上快十一點了，只要這一波騙到他們就爽賺拉！</p><p>「請問是 X 先生嗎？我是 XX 銀行專員。」<br>「剛剛我們收到 XX 公司的通知，知道您有兩筆刷卡需要取消。」<br>「因為<strong>24:00</strong>後就會成立，我們會為了您的權益盡力在這之前完成處理。」<br>「<strong>因為購物是透過第三方公正平台，郵局來處理的，所以我們需要您的郵局帳號前四碼來確認</strong>」</p><p>這段對話蠻多的，我省略掉了一些地方。其實他是在問你「有多少帳戶」而帳戶前四或六碼基本上都是分行的代碼。</p><blockquote><p>我完全忘記<strong>郵局應該沒在管金流</strong>這件事情。</p></blockquote><p>「是 XX 分行開戶的對吧？」<br>「很可惜我們連線失敗了，<strong>您的帳戶似乎有個資保護。</strong>」<br>「是不是開戶時都有勾選呢？」<br>「要不要換其他銀行的帳戶看看？」</p><p>中間會不斷這樣的確認，而且你都會以為「應該是真的有系統連線吧！」其實他只是要盡力多套幾個帳戶出來，不過似乎數量多到一個程度就會停止（大概三個）</p><p>以我的習慣來說，有「個資保護」我當然會勾選是。所以很明顯他這樣「含糊」的說明就讓我中招，尤其是<strong>你只瞭解部分</strong>的狀況下。</p><blockquote><p>以前研究過這種晶片卡，基本上裡面確實可以存資料跟加密（Ex. 悠遊卡）但是銀行卡是怎麼運作的並不清楚，所以就被騙到。</p></blockquote><p>「那你用查詢餘額的方式看看？」<br>「點開 XX 銀行，然後查看餘額試試看。」<br>「你把時間跟餘額告訴我，這樣我才能針對這個時間點做查詢。」</p><p>這邊被我耗掉不少時間，因為以工程師的「篩選資料」來看，這個方法有點不靠譜跟精準。但是給的條件其實又「足夠調出可以人工選取的量」</p><blockquote><p>我跟他爭論很久為什麼 APP 餘額查詢沒顯示交易時間可以用手機時間，對方有點生氣（這就是疑點啊！！）</p></blockquote><p>之後基本上因為我還是覺得他檢查的方法<strong>似真似假</strong>所以卡了不少時間，因為越來越接近十二點，對方就開始出招。</p><h2 id="強制解除"><a href="#強制解除" class="headerlink" title="強制解除"></a>強制解除</h2><p>接下來對方就會裝出遇到困難的樣子，然後說要請主管幫忙。</p><blockquote><p>這其實也超可疑，銀行是什麼血汗公司嗎？半夜都在上班的？下午三點半就要關門都是假的？</p></blockquote><p>「我問一下我們技術主管看看，還有什麼方式處理。」<br>「主管因為怎樣怎樣，所以我們需要用強制解除晶片加密的方式。」</p><p>後來打 165 的時候，是被秒回說不存在這個功能。</p><p>這邊其實也有幾個疑點：</p><ul><li>前面說資料是存在晶片裡面，但是現在卻能透過轉帳解除？</li><li>全世界的銀行都是他們的，資料隨便查耶？</li></ul><p>「那你先打開手機的轉帳介面，然後到轉帳的地方輸入 822 中國信託」<br>「因為 #$&amp;*#$@#%# 所以是透過中國信託解除」<br>「帳戶就填寫身分證字號後九碼，金額就填寫 2 然後轉帳就可以了」</p><p>一樣疑點很多，其實到這邊我已經開始懷疑，但是離十二點大概才剩下二十分鐘⋯⋯</p><blockquote><p>大疑點：到底為何 A 銀行客服會教我用 B 銀行轉帳到 C 銀行去解除呢？</p></blockquote><p><strong>我超想睡</strong></p><p>其實我有問「咦，要輸入簡訊驗證碼？」</p><p>這時候對方其實有點著急，然後再催我了⋯⋯</p><p>「對，按下繼續後就會失敗！」<br>「然後錯誤代碼是不是 4507 怎樣怎樣」</p><p>這邊會先讓你「失敗」一次，所以你不會覺得奇怪。</p><p>「好了，剛剛解鎖後我們已經順利從郵局取消這兩筆刷卡。」<br>「現在我們要幫您恢復加密，因為如果沒有恢復一過 <strong>24:00 可能會被當作異常帳戶歸零餘額</strong>」<br>「現在離十二點不久，我們趕緊將帳戶恢復。」<br>「接下來我們會產生一組恢復加密的代碼，請你一樣用轉帳的方式輸入後，就可以恢復。」</p><blockquote><p>跟新手教學一樣，先示範後再來真的，很貼心對吧 XD</p></blockquote><p>「銀行一樣選 822 中國信託，帳戶就輸入 12345667」<br>「金額就輸入 11223 就可以了」</p><p>其實到這邊我開始猶豫要不到照做，但是想到「結束後我就可以躺到床上」就繼續下去了。</p><p>另外金額不會剛好等於餘額，因為剛剛已經問過餘額，所以會給一個「接近餘額」的數字，用來混淆。</p><p>這時候我又再問「又出現簡訊驗證碼了，要按嗎？」</p><p><strong>然後當然是很興奮的叫我按下去拉⋯⋯</strong></p><p>我就很順利的<strong>中招完畢</strong>了！</p><h2 id="其他帳戶還要恢復"><a href="#其他帳戶還要恢復" class="headerlink" title="其他帳戶還要恢復"></a>其他帳戶還要恢復</h2><p>接下來他就跟我說其他帳戶也要恢復，就開始要我重複前面的動作進行 SOP 流程。</p><ul><li>查餘額</li><li>轉帳</li><li>被騙</li></ul><p>不確定是對方可能來自遙遠的中國，或者我家的訊號不好。中間斷訊好幾次，來自 Whoscall 的「紅字提示」讓我稍微清醒了一點。</p><p><strong>此號碼曾被變造過，預防詐騙請撥打 165</strong></p><p>於是，我就開始假裝配合，順便給我妹手勢（因為我電腦讀卡機又讀不到，所以去跟我妹借電腦）</p><p>我：「比出 一 六 五 （使眼色」<br>妹：「？？？」<br>我：「比出 一 六 五 （使眼色」<br>妹：「？？？」</p><p>我妹到現在還以為我在跟朋友聊天，主要是因為「對方會一直提醒你不要其他人講」雖然我很淡定的開擴音很久，但是我妹也沒有發現有問題。</p><blockquote><p>所以說，遇到這種除了自己清醒之外。你的朋友或家人清醒也超重要⋯⋯</p></blockquote><p>我：「我可以掛一下電話嗎？我朋友傳訊息說有急事找我⋯⋯」<br>「這樣不好，我們要盡快幫你處理」</p><p>中間就是在找藉口，最後是跟他說我不掛電話，到我的房間先回一下朋友訊息。然後用我妹的電話直接打 165 報案。</p><p>妹：「他在叫你了⋯⋯」</p><p>對，離開太久還會把你找回來，還好我妹能幫我回答一些基本資料，讓流程繼續跑。</p><blockquote><p>可惜轉過去的帳戶沒能先讓我妹幫我登記，不然應該能搶在對方之前處理。</p></blockquote><p>之後就是一樣嘗試要轉掉郵局的錢，因為郵局主要是放我給爸媽的錢，而且爸媽幾乎也不會用，所以筆剛剛吧騙的多好幾倍，對方當然是想要馬上得手⋯⋯</p><p>運氣不錯的是剛好郵局顯示「00:00 ~ 1:30 為每日系統維護」我就用這個當藉口，請他明天跟我約時間再處理。</p><blockquote><p>中間 165 回撥我好幾次都沒成功，因為對方一直「不肯掛電話」提醒在提醒「不要跟朋友講」</p></blockquote><h2 id="筆錄"><a href="#筆錄" class="headerlink" title="筆錄"></a>筆錄</h2><p>接到電話後就馬上把剛剛的銀行帳戶那些給 165 負責的專員，並且對該帳戶做一些處理。之後就是接到附近的警察問說能不能過去做筆錄，我想這種冬東西早點處理會比較好，就在半夜走到警察局。</p><p>做完紀錄後，原本不清楚「警示帳戶」是什麼，隔天早上才知道是凍結對方帳戶。</p><p>不過警察表示「他們這種都會馬上領出，一班沒什麼效果」</p><p>後來也給我一些宣導文宣（真的是他們常處理的業務）不過我看了之後發現<strong>宣導的內容我都很注意，但是在發生的當下都因為一些小細節反而沒有注意到</strong></p><p>所以才會說「不要以為不會被騙」很多時候太信任一個陌生人，可能不是一件好事啊。</p><blockquote><p>大概是同事平常太好，活在溫馨的世界太久 XD</p></blockquote><p>進去警察局的時候，前面也有一個人在做筆錄，聽到的對話也是「被詐騙」尤其時我好一陣子都在捷運的 ATM 看到警察局貼的「警告標語」想說這一陣子沒有貼了，一鬆懈馬上中招。</p><h2 id="第二回合"><a href="#第二回合" class="headerlink" title="第二回合"></a>第二回合</h2><p>既然帳戶被凍結，我想最晚一早也會處理。至於約好的隔天晚上七點，到底會不會打來呢？到底會不會被發現，就跳過？</p><p>看起來沒被發現，所以就嘗試「演戲」配合對方。</p><p>不過，在這個階段又發現了更多<strong>詐騙集團很可惡</strong>的地方。</p><ul><li>會盡可能選接近 24:00 的時間，約七點就推托忙到九點</li><li>他們很熟悉所有銀行的流程<ul><li>我假裝登入網銀都騙不到對方，直到我去找教學截圖描述一致才能繼續</li><li>確認時間跟錯誤代碼是為了辨識使用的銀行跟是否有真實操作</li></ul></li></ul><p>簡單說，如果是假的操作馬上會被對方識破。不過對方也不是能馬上反應過來，基本上過程中勁量假裝是個「電腦白痴」一步一步操作就可以了。</p><p>而且說詞會不斷變化，像是發現我可能有「警覺」上鎖的動作就從轉帳又回到身分證字號的 SOP 先讓你「確認會失敗，很安全」才繼續。</p><p>比較可惜的就是沒有順利騙到其他的帳戶，雖然是人頭帳戶，但是多鎖一個幫對方找麻煩也是不錯。</p><blockquote><p>當你要電話跟分行位置的時候，基本上就會被發現，而且號碼都是裝成銀行的很難區分。</p></blockquote><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>後來有去找到一篇流程跟我幾乎一樣的詐騙網誌文章，不過差別在於相較 2012 年的過程，現在 2018 年的細節已經非常精細，許多地方是完全貼近真實狀況的，所以才難以防範（不過都不信就解決拉，真有問題銀行會想辦法，雖然有點對不起辛苦的行員）</p><p>至於嚴格來說到底會不會被騙這件事情，我覺得就是「不要太在意」跟「臨櫃能處理」就好了。</p><ul><li>直接去銀行櫃台處理，讓他扣再說</li><li>晚上堅持不處理轉帳</li><li><strong>轉帳就只會出現轉帳的效果</strong></li></ul><p>大概只要抓到上面幾點，應該就能防止這種類型的詐騙發生。這次的經驗就當繳學費，順便就是我有完整的參考資料，可以在下次遇到的時候認真地跟對方玩。</p><p>另外談談金融科技，我認為這類詐騙會在普及之後消失，轉變為資安類的問題。國外很多銀行都已經導入 AI 來偵測異常刷卡，像這種異常轉帳或者詐騙，應該會在之後普及金融科技慢慢消失，主要就是網路銀行電子化之後，帳單跟處理錯誤的刷卡都能透過網路進行，就比較不會有機會透過電話來處理，畢竟上網點一下就解決。</p><p>最後，希望大家不會中招。雖然我猜看到這篇文章的時候，就跟我看到 2012 年那篇文章一樣，是中招後了⋯⋯</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/04/24/How-to-be-scammed-in-2018/#disqus_thread</comments>
    </item>
    
    <item>
      <title>部署你的第一個 Ruby on Rails 網站（五）</title>
      <link>https://blog.frost.tw/posts/2018/04/15/Getting-started-deploy-your-Ruby-on-Rails-Part-5/</link>
      <guid>https://blog.frost.tw/posts/2018/04/15/Getting-started-deploy-your-Ruby-on-Rails-Part-5/</guid>
      <pubDate>Sun, 15 Apr 2018 14:04:14 GMT</pubDate>
      <description>
      
        &lt;p&gt;到&lt;a href=&quot;https://blog.frost.tw/posts/2018/04/10/Getting-started-deploy-your-Ruby-on-Rails-Part-4/&quot;&gt;第四篇&lt;/a&gt;為止，我們已經有了可以運行 Ruby on Rails 的環境，不過到底該怎麼在伺服器上跑起來呢？&lt;/p&gt;
&lt;p&gt;絕對不是&lt;strong&gt;把程式碼複製到伺服器&lt;/strong&gt;這種簡單的做法，或者說這樣的做法在更新上是很沒有效率的！&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>到<a href="https://blog.frost.tw/posts/2018/04/10/Getting-started-deploy-your-Ruby-on-Rails-Part-4/">第四篇</a>為止，我們已經有了可以運行 Ruby on Rails 的環境，不過到底該怎麼在伺服器上跑起來呢？</p><p>絕對不是<strong>把程式碼複製到伺服器</strong>這種簡單的做法，或者說這樣的做法在更新上是很沒有效率的！</p><a id="more"></a><p>在 Ruby 中，有一個非常好用的 Ruby Gem 叫做 Capistrano 可以自動地幫我們完成網站部署。運作起來其實也很簡單，就是幫我們 SSH 到伺服器上，執行相對應的指令。</p><p>這跟自己複製到伺服器上有什麼差別呢？假設我們現在要部署到四五十台的伺服器，難道要一台一台複製嗎？</p><p>有這些工具的輔助，就能夠下完指令就去泡咖啡等部署完成拉 XD</p><blockquote><p>最近打算學一下 Ansible 怎麼使用，也許下次會分享用 Ansible 部署多台 Ruby on Rails 伺服器的方法。</p></blockquote><h2 id="安裝-Capistrano"><a href="#安裝-Capistrano" class="headerlink" title="安裝 Capistrano"></a>安裝 Capistrano</h2><p>首先，先在我們的 <code>Gemfile</code> 加上</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">group <span class="symbol">:development</span> <span class="keyword">do</span></div><div class="line">  gem <span class="string">'capistrano'</span>, <span class="string">'~&gt; 3.10'</span>, <span class="symbol">require:</span> <span class="literal">false</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>因為 Capistrano 可能會因為版本升級而改變一些設定，所以大多會限制版本。另外就是這是一個擴充的指令，所以可以設定為 <code>require: false</code> 來避免在運行 Ruby on Rails 的時候將它讀取進來。</p><p>接下來，我們要執行 <code>install</code> 指令，將 Capistrano 所需的設定檔生成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bundle <span class="built_in">exec</span> <span class="built_in">cap</span> install</div></pre></td></tr></table></figure><p>當我們看到多出了 <code>Capfile</code> 和一些檔案後，就算是將 Capistrano 安裝完畢了！</p><h2 id="設定-Capistrano"><a href="#設定-Capistrano" class="headerlink" title="設定 Capistrano"></a>設定 Capistrano</h2><p>雖然安裝好了 Capistrano 但是我們還沒有針對 Capistrano 設定該如何取得原始碼、上傳到哪台伺服器上面。</p><p>首先，因為是 Ruby on Rails 專案，所以我們先在 <code>Capfile</code> 裡面做一些修改，讓 Capistrano 能夠自動幫我們針對一些 Ruby on Rails 特有的行為做處理。</p><p>下面這些是預設被註解掉的選項，我們在部署的時候會需要用到，所以都將他取消註解。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">require</span> <span class="string">"capistrano/bundler"</span></div><div class="line"><span class="keyword">require</span> <span class="string">"capistrano/rails/assets"</span></div><div class="line"><span class="keyword">require</span> <span class="string">"capistrano/rails/migrations"</span></div><div class="line"><span class="keyword">require</span> <span class="string">"capistrano/passenger"</span></div></pre></td></tr></table></figure><p>然後我們需要設定要部署的伺服器，預設 Capistrano 會區分 Production（正式）和 Staging（測試）環境，所以我們需要對這兩個環境個別設定。</p><blockquote><p>不過現實上我們可能還是很小的專案，只有一台伺服器。也是可以設定在同一台上的，這篇文章也會示範部署在同一台的方式。</p></blockquote><p>首先，我們先針對 Staging 環境做設定，打開 <code>config/deploy/staging.rb</code> 這個檔案，修改成下面這樣。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">server <span class="string">'伺服器 IP'</span>, <span class="symbol">user:</span> <span class="string">'deploy'</span>, <span class="symbol">roles:</span> <span class="string">%w&#123;app web db&#125;</span></div><div class="line">set <span class="symbol">:deploy_to</span>, <span class="string">'/home/deploy/staging'</span></div></pre></td></tr></table></figure><p>如果忘記 IP 的話可以到 Digital Ocean 找看看，因為要分別部署 Production 和 Staging 兩個網站，所以我們針對 <code>deploy_to</code> 做設定，讓他複製到不同的資料夾下面。</p><blockquote><p>一般這種我會習慣用網址當資料夾名稱，像是 <code>/home/deploy/beta.rookie.works</code> 這樣子，比較好區分。</p></blockquote><p>至於 <code>config/deploy/production.rb</code> 的設定，基本上就是複製 Staging 設定後做修改。</p><p>接下來，我們需要設定如何部署。</p><p>打開 <code>config/deploy.rb</code> 來進行設定，我們先將原始碼的位置指定給 Capistrano。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">set <span class="symbol">:application</span>, <span class="string">'deploy-example'</span></div><div class="line">set <span class="symbol">:repo_url</span>, <span class="string">'git@github.com:elct9620/deploy-example.git'</span></div></pre></td></tr></table></figure><p>最重要的是 <code>repo_url</code> 需要正確的設定，如果還不知道怎麼使用 Git 跟上傳自己的專案到 Github 的話，可以參考像是<a href="https://gitbook.tw/" target="_blank" rel="noopener">為你自己學 Git</a> 這類書籍來了解。</p><p>最後，我們要針對 Ruby on Rails 一些共用的設定檔做一些設定。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Default value for :linked_files is []</span></div><div class="line">append <span class="symbol">:linked_files</span>, <span class="string">'config/secrets.yml'</span></div><div class="line"></div><div class="line"><span class="comment"># Default value for linked_dirs is []</span></div><div class="line">append <span class="symbol">:linked_dirs</span>, <span class="string">'log'</span>, <span class="string">'tmp/pids'</span>, <span class="string">'tmp/cache'</span>, <span class="string">'tmp/sockets'</span>, <span class="string">'node_modules'</span>, <span class="string">'public/shared'</span>, <span class="string">'public/uploads'</span></div><div class="line"></div><div class="line"><span class="comment"># Default value for default_env is &#123;&#125;</span></div><div class="line">set <span class="symbol">:default_env</span>, &#123; <span class="symbol">path:</span> <span class="string">'/usr/local/ruby-2.4.3/bin:$PATH'</span> &#125;</div></pre></td></tr></table></figure><p>首先，因為 <code>config/secrets.yml</code> 會影響到 Rails 的加密機制，所以我們都會先在伺服器上放好 <code>config/secrets.yml</code> 這個檔案，並預先寫死在裡面，以免被其他人直接取得。</p><blockquote><p>像是 Github 偶爾還是能找到一些帳號密碼，像是這類敏感資訊要記得不要 Commit 到 Git 裡面。</p></blockquote><p>至於 <code>linked_dirs</code> 則是針對一些常用的資料夾，像是上傳檔案的目錄、紀錄檔等等。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>整體上來說 Capistrano 的設定還是相對簡單的，不過前面在設定伺服器的時候可能還會看到像是 <code>role</code> 之類的設定，這是在不同伺服器扮演網頁伺服器或者資料庫伺服器時，可以個別執行不同動作的設計。</p><p>下一篇文章我們會回到伺服器上的設定，將使用 Capistrano 部署到伺服器上的必要條件設定起來。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/04/15/Getting-started-deploy-your-Ruby-on-Rails-Part-5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>部署你的第一個 Ruby on Rails 網站（四）</title>
      <link>https://blog.frost.tw/posts/2018/04/10/Getting-started-deploy-your-Ruby-on-Rails-Part-4/</link>
      <guid>https://blog.frost.tw/posts/2018/04/10/Getting-started-deploy-your-Ruby-on-Rails-Part-4/</guid>
      <pubDate>Tue, 10 Apr 2018 08:54:22 GMT</pubDate>
      <description>
      
        &lt;p&gt;從&lt;a href=&quot;https://blog.frost.tw/posts/2018/03/20/Getting-started-deploy-your-Ruby-on-Rails-Part-1/&quot;&gt;第一篇&lt;/a&gt;到&lt;a href=&quot;https://blog.frost.tw/posts/2018/03/23/Getting-started-deploy-your-Ruby-on-Rails-Part-2/&quot;&gt;第二篇&lt;/a&gt;的說明，加上&lt;a href=&quot;https://blog.frost.tw/posts/2018/03/23/Getting-started-deploy-your-Ruby-on-Rails-Part-3/&quot;&gt;第三篇&lt;/a&gt;我想大家已經對編譯自己的環境稍為熟悉。&lt;/p&gt;
&lt;p&gt;為了要可以用 Passenger 作為網站伺服器，我們需要自行編譯 Nginx 讓他可以使用 Passenger 模組。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>從<a href="https://blog.frost.tw/posts/2018/03/20/Getting-started-deploy-your-Ruby-on-Rails-Part-1/">第一篇</a>到<a href="https://blog.frost.tw/posts/2018/03/23/Getting-started-deploy-your-Ruby-on-Rails-Part-2/">第二篇</a>的說明，加上<a href="https://blog.frost.tw/posts/2018/03/23/Getting-started-deploy-your-Ruby-on-Rails-Part-3/">第三篇</a>我想大家已經對編譯自己的環境稍為熟悉。</p><p>為了要可以用 Passenger 作為網站伺服器，我們需要自行編譯 Nginx 讓他可以使用 Passenger 模組。</p><a id="more"></a><p>不過因為 Passenger 已經針對這方面做好對應的處置，所以我們只需要按照 Passenger 提供的解決方案一步一步的進行編譯即可。</p><blockquote><p>Passenger 提供了從原始碼安裝跟透過 Ruby Gem 安裝兩種，為了好維護跟升級，這篇文章會採取從原始碼安裝的方式。</p></blockquote><h2 id="取得原始碼"><a href="#取得原始碼" class="headerlink" title="取得原始碼"></a>取得原始碼</h2><p>Passenger 除了開放原始碼的版本，也有企業版。從<a href="https://www.phusionpassenger.com/" target="_blank" rel="noopener">官網</a>可以找到開放原始碼版本的下載點，而且貼心的提供了像下面截圖的安裝指南。</p><p><img src="https://blog.frost.tw/images/getting-started-deploy-your-ruby-on-rails-part-4/screenshot1.jpg" alt="螢幕快照 2018-04-10 上午12.13.04.png"></p><p>因為要從原始碼安裝，所以要先選擇其他作業系統。</p><p><img src="https://blog.frost.tw/images/getting-started-deploy-your-ruby-on-rails-part-4/screenshot2.jpg" alt="螢幕快照 2018-04-10 上午12.13.30.png"></p><p>因為要和 Nginx 搭配，要記得將 <code>Standalone</code> 改為 <code>Nginx</code> 才能得到正確的安裝指南。</p><blockquote><p>不過 Standalone 模式似乎也會變編譯一個 Nginx 來運行，只是不會顯示給使用者。</p></blockquote><p>對頁面上的「Download tarball」按鈕點選右鍵複製連結，會得到類似下面的連結。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://www.phusionpassenger.com/latest_stable_tarball</div></pre></td></tr></table></figure><p>因為 Passenger 不像 Ruby 安裝完畢後會複製到某個指定的資料夾，所以我們可以參考 Homebrew 的方式，在 <code>/usr/local/passenger</code> 裡面放置檔案。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir /usr/<span class="built_in">local</span>/passenger</div><div class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/passenger</div><div class="line">wget https://www.phusionpassenger.com/latest_stable_tarball</div></pre></td></tr></table></figure><blockquote><p>這邊建議用 <code>root</code> 來進行這個動作，因為 Passenger 安裝過程會需要 <code>root</code> 權限之外，<code>/usr/local</code> 目錄要新增資料夾也是需要有 <code>root</code> 權限的。</p></blockquote><h2 id="安裝-Passenger"><a href="#安裝-Passenger" class="headerlink" title="安裝 Passenger"></a>安裝 Passenger</h2><p>首先把我們下載回來的 Passenger 解壓縮。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -zxvf latest_stable_tarball</div></pre></td></tr></table></figure><blockquote><p>用 <code>wget</code> 不知道原因並沒有自動轉成檔名，不過能夠解壓縮就就不需要太在意細節。</p></blockquote><p>解壓縮後應該會得到一個最新版的 Passenger 目錄（本文撰寫時是 5.2.3 版）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@deploy-example passenger]<span class="comment"># ls</span></div><div class="line">latest_stable_tarball  passenger-5.2.3</div></pre></td></tr></table></figure><p>接著進入 <code>passenger-5.2.3</code> 這個目錄，執行 Passenger 的安裝程式。因為 Passenger 是有使用 Ruby 的，如果上一篇文章介紹的設定沒有正確的話，可能會無法執行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/passenger/passenger-5.2.3/bin:<span class="variable">$PATH</span></div><div class="line">passenger-install-nginx-module</div></pre></td></tr></table></figure><p>依照文件，我們跟上次設定 Ruby 的時候一樣先暫時讓 Passenger 的執行檔都可以執行。安裝中途也會嘗試呼叫這個目錄的其他執行檔，所以在安裝階段先這樣設定會讓後續流暢不少。</p><blockquote><p>執行 <code>passenger-install-nginx-module</code> 會中斷好幾次，主要是 Passenger 會建議我們把一些設定改善後再繼續。</p></blockquote><p>開始後，會先出現類似下面的詢問訊息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[root@deploy-example passenger-5.2.3]<span class="comment"># passenger-install-nginx-module</span></div><div class="line">Welcome to the Phusion Passenger Nginx module installer, v5.2.3.</div><div class="line"></div><div class="line">This installer will guide you through the entire installation process. It</div><div class="line">shouldn<span class="string">'t take more than 5 minutes in total.</span></div><div class="line"></div><div class="line">Here's what you can expect from the installation process:</div><div class="line"></div><div class="line"> 1. This installer will compile and install Nginx with Passenger support.</div><div class="line"> 2. You<span class="string">'ll learn how to configure Passenger in Nginx.</span></div><div class="line"> 3. You'll learn how to deploy a Ruby on Rails application.</div><div class="line"></div><div class="line">Don<span class="string">'t worry if anything goes wrong. This installer will advise you on how to</span></div><div class="line">solve any problems.</div><div class="line"></div><div class="line">Press Enter to continue, or Ctrl-C to abort.</div></pre></td></tr></table></figure><p>因為有好幾次詢問，所以如果後面沒有特別提醒的話，請自己按 Enter 繼續執行即可。</p><p>開始後會先詢問要支援哪些語言，因為 Passenger 後來陸續增加了 Python 和 Node.js 的支援，如果需要的話，也可以用方向鍵和空白鍵選取起來。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Which languages are you interested <span class="keyword">in</span>?</div><div class="line"></div><div class="line">Use &lt;space&gt; to select.</div><div class="line">If the menu doesn<span class="string">'t display correctly, press '</span>!<span class="string">'</span></div><div class="line"></div><div class="line"> ‣ ⬢  Ruby</div><div class="line">   ⬡  Python</div><div class="line">   ⬡  Node.js</div><div class="line">   ⬡  Meteor</div></pre></td></tr></table></figure><p>下一步會檢查相依性，如果出現類似下面的訊息，就表示有缺少一些程式。按下 Enter 之後 Passenger 會給出安裝指令，我們再複製來使用即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">Checking <span class="keyword">for</span> required software...</div><div class="line"></div><div class="line"> * Checking <span class="keyword">for</span> C compiler...</div><div class="line">      Found: yes</div><div class="line">      Location: /usr/bin/cc</div><div class="line"> * Checking <span class="keyword">for</span> C++ compiler...</div><div class="line">      Found: no</div><div class="line"> * Checking <span class="keyword">for</span> A download tool like <span class="string">'wget'</span> or <span class="string">'curl'</span>...</div><div class="line">      Found: yes</div><div class="line">      Location: /usr/bin/wget</div><div class="line"> * Checking <span class="keyword">for</span> Curl development headers with SSL support...</div><div class="line">      Found: no</div><div class="line">      Error: Cannot find the `curl-config` <span class="built_in">command</span>.</div><div class="line"> * Checking <span class="keyword">for</span> OpenSSL development headers...</div><div class="line">      Found: yes</div><div class="line">      Location: /usr/include/openssl/ssl.h</div><div class="line"> * Checking <span class="keyword">for</span> Zlib development headers...</div><div class="line">      Found: yes</div><div class="line">      Location: /usr/include/zlib.h</div><div class="line"> * Checking <span class="keyword">for</span> Rake (associated with /usr/<span class="built_in">local</span>/ruby-2.4.3/bin/ruby)...</div><div class="line">      Found: yes</div><div class="line">      Location: /usr/<span class="built_in">local</span>/ruby-2.4.3/bin/ruby /usr/<span class="built_in">local</span>/ruby-2.4.3/bin/rake</div><div class="line"> * Checking <span class="keyword">for</span> OpenSSL support <span class="keyword">for</span> Ruby...</div><div class="line">      Found: yes</div><div class="line"> * Checking <span class="keyword">for</span> RubyGems...</div><div class="line">      Found: yes</div><div class="line"> * Checking <span class="keyword">for</span> Ruby development headers...</div><div class="line">      Found: yes</div><div class="line">      Location: /usr/<span class="built_in">local</span>/ruby-2.4.3/include/ruby-2.4.0/ruby.h</div><div class="line"> * Checking <span class="keyword">for</span> rack...</div><div class="line">      Found: no</div><div class="line"></div><div class="line">Some required software is not installed.</div><div class="line">But don<span class="string">'t worry, this installer will tell you how to install them.</span></div><div class="line">Press Enter to continue, or Ctrl-C to abort.</div></pre></td></tr></table></figure><p>提示的安裝指令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">--------------------------------------------</div><div class="line"></div><div class="line">Installation instructions <span class="keyword">for</span> required software</div><div class="line"></div><div class="line"> * To install C++ compiler:</div><div class="line">   Please install it with yum install gcc-c++</div><div class="line"></div><div class="line"> * To install Curl development headers with SSL support:</div><div class="line">   Please install it with yum install libcurl-devel</div><div class="line"></div><div class="line"> * To install rack:</div><div class="line">   Please make sure RubyGems is installed, <span class="keyword">then</span> run /usr/<span class="built_in">local</span>/ruby-2.4.3/bin/ruby /usr/<span class="built_in">local</span>/ruby-2.4.3/bin/gem install rack</div><div class="line"></div><div class="line">If the aforementioned instructions didn<span class="string">'t solve your problem, then please take</span></div><div class="line">a look at our documentation for troubleshooting tips:</div><div class="line"></div><div class="line">  https://www.phusionpassenger.com/library/install/nginx/</div><div class="line">  https://www.phusionpassenger.com/library/admin/nginx/troubleshooting/</div></pre></td></tr></table></figure><p>既然缺少了，那們我們就先執行對應的指令將缺少的套件安裝完成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">yum install gcc-c++ libcurl-devel</div><div class="line">gem install rack</div></pre></td></tr></table></figure><p>完成之後，我們重新執行 <code>passenger-install-nginx-module</code> 指令，前面的檢查選項就可以通過。這時候就會詢問我們要自己將 Passenger 加入 Nginx 編譯，還是讓 Passenger 幫我們自動編譯 Nginx。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">Automatically download and install Nginx?</div><div class="line"></div><div class="line">Nginx doesn<span class="string">'t support loadable modules such as some other web servers do,</span></div><div class="line">so in order to install Nginx with Passenger support, it must be recompiled.</div><div class="line"></div><div class="line">Do you want this installer to download, compile and install Nginx for you?</div><div class="line"></div><div class="line"> 1. Yes: download, compile and install Nginx for me. (recommended)</div><div class="line">    The easiest way to get started. A stock Nginx 1.12.2 with Passenger</div><div class="line">    support, but with no other additional third party modules, will be</div><div class="line">    installed for you to a directory of your choice.</div><div class="line"></div><div class="line"> 2. No: I want to customize my Nginx installation. (for advanced users)</div><div class="line">    Choose this if you want to compile Nginx with more third party modules</div><div class="line">    besides Passenger, or if you need to pass additional options to Nginx's</div><div class="line">    <span class="string">'configure'</span> script. This installer will  1) ask you <span class="keyword">for</span> the location of</div><div class="line">    the Nginx <span class="built_in">source</span> code,  2) run the <span class="string">'configure'</span> script according to your</div><div class="line">    instructions, and  3) run <span class="string">'make install'</span>.</div><div class="line"></div><div class="line">Whichever you choose, <span class="keyword">if</span> you already have an existing Nginx configuration file,</div><div class="line"><span class="keyword">then</span> it will be preserved.</div><div class="line"></div><div class="line">Enter your choice (1 or 2) or press Ctrl-C to abort: 1</div></pre></td></tr></table></figure><p>輸入 1 之後按下 Enter 就會開始把 Nginx 下載並且安裝摟！如果被詢問安裝目錄，基本上保持預設值就好，只是會跟透過 yum 安裝的位置不太一樣，所以要稍微記一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Where <span class="keyword">do</span> you want to install Nginx to?</div><div class="line"></div><div class="line">Please specify a prefix directory [/opt/nginx]:</div></pre></td></tr></table></figure><blockquote><p>要注意的是如果選用的主機規格太小 Passenger 會建議換大一點的主機，至少要有 1G 以上的記憶體比較適合。</p></blockquote><p>如果中間都沒有出錯的話，我們會看到像下面這樣的訊息，也就表示安裝成功了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Nginx with Passenger support was successfully installed.</div><div class="line"></div><div class="line">The Nginx configuration file (/opt/nginx/conf/nginx.conf)</div><div class="line">must contain the correct configuration options <span class="keyword">in</span> order <span class="keyword">for</span> Phusion Passenger</div><div class="line">to <span class="keyword">function</span> correctly.</div><div class="line"></div><div class="line">This installer has already modified the configuration file <span class="keyword">for</span> you! The</div><div class="line">following configuration snippet was inserted:</div><div class="line"></div><div class="line">  http &#123;</div><div class="line">      ...</div><div class="line">      passenger_root /usr/<span class="built_in">local</span>/passenger/passenger-5.2.3;</div><div class="line">      passenger_ruby /usr/<span class="built_in">local</span>/ruby-2.4.3/bin/ruby;</div><div class="line">      ...</div><div class="line">  &#125;</div><div class="line"></div><div class="line">After you start Nginx, you are ready to deploy any number of Ruby on Rails</div><div class="line">applications on Nginx.</div><div class="line"></div><div class="line">Press ENTER to <span class="built_in">continue</span>.</div></pre></td></tr></table></figure><h2 id="開啟-Nginx"><a href="#開啟-Nginx" class="headerlink" title="開啟 Nginx"></a>開啟 Nginx</h2><p>不過到目前為止，我們其實只是把 Passenger 和 Nginx 編譯完成，但是並沒有把 Nginx 打開。也因此，其他人是無法連上這台伺服器上的網站。</p><p>為了方便管理，我們可以使用 <code>systemd</code> 功能，透過撰寫設定檔，來使用 <code>systemctl</code> 指令觀看狀態，或者重新啟動。</p><p>在 Nginx 官網有提供一份<a href="https://www.nginx.com/resources/wiki/start/topics/examples/systemd/" target="_blank" rel="noopener">範例</a>，基本上只要修改範例上的路徑到正確的位置，我們就可以使用 <code>systemctl</code> 來控制 Nginx 的開啟跟關閉。</p><p>透過 <code>vi</code> 編輯 <code>/lib/systemd/system/nginx.service</code> 這個檔案。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /lib/systemd/system/nginx.service</div></pre></td></tr></table></figure><p>然後把下面的內容貼上，如果有修改 Nginx 的安裝路徑，要把 <code>/opt/nginx</code> 替換掉。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="section">[Unit]</span></div><div class="line"><span class="attr">Description</span>=The NGINX HTTP and reverse proxy server</div><div class="line"><span class="attr">After</span>=syslog.target network.target remote-fs.target nss-lookup.target</div><div class="line"><span class="section"></span></div><div class="line">[Service]</div><div class="line"><span class="attr">Type</span>=forking</div><div class="line"><span class="attr">PIDFile</span>=/opt/nginx/logs/nginx.pid</div><div class="line"><span class="attr">ExecStartPre</span>=/opt/nginx/sbin/nginx -t</div><div class="line"><span class="attr">ExecStart</span>=/opt/nginx/sbin/nginx</div><div class="line"><span class="attr">ExecReload</span>=/bin/kill -s HUP <span class="variable">$MAINPID</span></div><div class="line"><span class="attr">ExecStop</span>=/bin/kill -s QUIT <span class="variable">$MAINPID</span></div><div class="line"><span class="attr">PrivateTmp</span>=<span class="literal">true</span></div><div class="line"><span class="section"></span></div><div class="line">[Install]</div><div class="line"><span class="attr">WantedBy</span>=multi-user.target</div></pre></td></tr></table></figure><blockquote><p>還記得怎麼編輯嗎？按下 <code>i</code> 進入插入模式，貼上後用 <code>Esc</code> 退出，然後用 <code>:wq</code> 指令存檔離開。</p></blockquote><p>完成之後，我們就可以用 <code>systemctl</code> 指令來開啟或者關閉 Nginx 了，不過在這之前我們會希望在意外當機後重開機時，能夠自動地把 Nginx 啟動。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl <span class="built_in">enable</span> nginx</div></pre></td></tr></table></figure><p>利用 <code>enable</code> 功能，把 Nginx 設定為開機自動啟動的項目。</p><p>接下來用 <code>start</code> 指令把 Nginx 打開，並且用 <code>status</code> 指令看看是不是變成 <code>running</code> 的運行狀態。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">systemctl start nginx</div><div class="line">systemctl status nginx</div></pre></td></tr></table></figure><p>如果想檢查看看能不能連上，可以利用 <code>curl</code> 指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl localhost</div></pre></td></tr></table></figure><p>如果有 HTML 語法出現，基本上就是安裝成功了！</p><blockquote><p>如果找不到 <code>curl</code> 指令可以執行，嘗試看看自己用 <code>yum</code> 安裝吧！</p></blockquote><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>其實文章到這邊，安裝伺服器的部分就告一段落。下一階段會介紹怎麼設定 Ruby on Rails 專案，用 Capistrano 這個 Gem 幫助你把網站部署到這台伺服器。</p><p>不過，伺服器的設定其實還沒有完成，只是這些小問題會讓你在維護上不太方便。在後面的教學中，會陸續介紹跟提供解決的方案。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/04/10/Getting-started-deploy-your-Ruby-on-Rails-Part-4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>在 2018 年我所知道的區塊鏈</title>
      <link>https://blog.frost.tw/posts/2018/04/02/The-blockchain-I-know-about-in-2018/</link>
      <guid>https://blog.frost.tw/posts/2018/04/02/The-blockchain-I-know-about-in-2018/</guid>
      <pubDate>Mon, 02 Apr 2018 03:08:28 GMT</pubDate>
      <description>
      
        &lt;p&gt;上週同事突然在公司的聊天群組中討論起區塊鏈到底是不是屬於分散式系統（Distributed System）因為去年年底爆紅的關係，我也稍微了解了一下區塊鏈的運作，就被同事說會不會晚上就有文章出來了。&lt;/p&gt;
&lt;p&gt;雖然不是當天晚上就在寫，不過了解區塊鏈的運作倒是很有幫助我們冷靜下來對應這個新名詞。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>上週同事突然在公司的聊天群組中討論起區塊鏈到底是不是屬於分散式系統（Distributed System）因為去年年底爆紅的關係，我也稍微了解了一下區塊鏈的運作，就被同事說會不會晚上就有文章出來了。</p><p>雖然不是當天晚上就在寫，不過了解區塊鏈的運作倒是很有幫助我們冷靜下來對應這個新名詞。</p><a id="more"></a><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>其實最開始是跟同事有買了一些 BTC/ETH 來放著，在 2018 年底爆紅之後發現加密貨幣被當作金融商品在操作，而自己對他一點都不了解，反而沒有抓住恰當的時機，所以就開始研究他的可能性。</p><p><strong>不過我感覺，搞懂了只會讓你想趕快賣掉而已</strong></p><h2 id="新技術？"><a href="#新技術？" class="headerlink" title="新技術？"></a>新技術？</h2><p>因為不了解，所以我們會會認為他是一種全新的技術。實際上其實完全不是，都是靠「已知」的技術來實現的。也因為這樣，區塊鏈在運作起來還算是可靠的，因為有很多已知的問題都被研究過，而且使用的都是經過好幾年檢驗沒問題的技術。</p><p>所以，與其說是新技術，不如看作是一種<strong>新概念</strong>會比較恰當，在比特幣開始使用的 Proof of Work（工作證明）機制，經過長時間的驗證後，發現是一種有效的方法，所以才會被認同跟使用。</p><h2 id="區塊跟鏈"><a href="#區塊跟鏈" class="headerlink" title="區塊跟鏈"></a>區塊跟鏈</h2><p>從工程師的角度去看區塊鏈這個東西，大概會先連結到 Linked List 這種結構。實際上很明顯的，所謂的區塊鏈就是一種 Linked List 的資料結構，將一個接著一個的 Block（區塊）來練接起來。</p><p>所以，實際上一個區塊鏈很難實作嗎？其實不算困難。</p><p>要製作出簡單的區塊連結構，大概會像這樣。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Ruby</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Block</span></span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(prev, data)</span></span></div><div class="line">    @prev = prev</div><div class="line">    @data = data</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chain</span></span></div><div class="line">  GENESIS = Block.new(<span class="literal">nil</span>, <span class="string">''</span>)</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></div><div class="line">    @blocks = [GENESIS]</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(data)</span></span></div><div class="line">    @blocks.push(Block.new(@blocks.last, data))</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">chain = Chain.new</div><div class="line">chain.add(<span class="string">'Hello World'</span>)</div></pre></td></tr></table></figure><p>不過，光靠這些事不足以構成完善的區塊鏈本身。</p><h2 id="產生區塊"><a href="#產生區塊" class="headerlink" title="產生區塊"></a>產生區塊</h2><p>如果光是像前面所述的去生成新的區塊，很明顯的是沒有被驗證的。那就代表說任何人都可以隨意的去產生新的區塊，而且這並不是我們所期望的結果。</p><p>所以要放入 PoW（Proof of Work）這樣的機制在裡面，用來檢驗產生區塊是否合理。</p><p>於是，產生一個區塊的流程被拆分為幾個階段。</p><p><img src="https://blog.frost.tw/images/the-blockchain-i-know-about-in-2018/flow.png" alt="Untitled Diagram (1).png"></p><p>簡單來看，我們在原本直接產生區塊鏈的機制中，增加了一個叫做「工作證明」的動作，先讓作為礦工（節點）的角色耗費一定資源來進行運算，等到達成條件之後，再送給其他人檢查，如果結果都相同，那麼就接受這次的區塊打包，反之則拒絕讓對方重新開始。</p><h2 id="工作證明"><a href="#工作證明" class="headerlink" title="工作證明"></a>工作證明</h2><p>為了要證明工作，我們必須讓所有人都可以快速的取得相同的結果。但是證明者需要花費對應的資源才能取得結果，而其他人則需要可以用最短的時間內檢驗。</p><p>這時候加密演算法（Cryptography）剛好就可以解決這個問題。為了符合這個條件，我們需要先對區塊鏈的「區塊」本身做一些結構上的調整，這樣我們才能夠去驗證。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Block</span></span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(prev, hash, data)</span></span></div><div class="line">    @prev = prev</div><div class="line">    @parent = hash</div><div class="line">    @data = data</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>簡單來說，我們要先對區塊中的「區塊資料」先做一次加密的動作，獲得一個 Hash 值，來確保每一個區塊的資料是有一致性的。比較常見的案例，就是在下載檔案時會提供一個叫做 MD5 的 Hash 值，讓我們來驗證跟提供者提供的檔案是相同的。</p><p>基於這樣的原理，我們就可以透過這個 Hash 值來確認跟其他節點的區塊對應到的是相同的一個。</p><p>不過為了要證明工作，所以整個網路會一起提出一個問題，然後由所有參與運算的節點一起來處理。例如我們使用 MD5 來進行運算，會得到一個 32 個字元長度的字串。</p><p>那麼題目就可能會是「前三個字必須是 <code>000</code>」的題目」不過，因為原本只對資料做 Hash 是不可能改變結果的，所以我們會再加入一個叫做 <code>proof</code> 的資料欄位。</p><p>原本我們的 Hash 值可能會是 <code>md5(data)</code> 改變為 <code>md5(proof + data)</code> 這樣的計算，如此一來運算節點只需要一直修改 <code>proof</code> 的值來達到 Hash 結果為 <code>000</code> 開頭，那麼就算是完成工作證明了。</p><p>接下來提交給其他節點，他們只要執行 <code>md5(proof + data)</code> 就可以馬上驗證這個區塊是否為正確的區塊。</p><blockquote><p>出題目的情況其實就是挖礦時的難度調整，當大家都很容易算出來的時候，就會調整題目的難度，讓他更難以嘗試出來。</p></blockquote><p>像這樣透過產生隨機字串去試到成功為止這件事情，就跟「挖礦」的行為很像，這也就是為什麼我們會用「挖礦」和「礦工」來形容。</p><blockquote><p>至於像是比特幣有 51% 攻擊問題，礙於篇幅就不多做討論。</p></blockquote><h2 id="儲存問題"><a href="#儲存問題" class="headerlink" title="儲存問題"></a>儲存問題</h2><p>不過，隨著儲存的資料增長，每次更新都需要下載非常大量的交易紀錄，對一般使用者來說其實是一種負擔。所以我們再次利用密碼學的特性，將節點分成 Full Node 和 Light Node 兩種，前者會保存完整的資料，而後者則在有需要時才到網路上詢問其他節點。</p><p>以比特幣的情況來看，他採用了 Merkle Tree（默克爾樹）這個機制，我們將一個 Key-Value 儲存的資料，透過加密演算法，產生為一個 Hash 不斷合併後會得到一個最終的 Root Hash 作為參考，而這樣的機制可以讓我們在 Light Node 中只需要保存 Root Hash 就可以了。</p><p>透過這樣的機制，我們也得以在像是手機運行錢包，否則手機可能會連過往的交易資料都沒辦法完整儲存。</p><blockquote><p>Merkle Tree 的父結點會是子結點的資料相加後的 Hash 值，然後不斷合併後達到跟節點。</p></blockquote><h2 id="受限的功能"><a href="#受限的功能" class="headerlink" title="受限的功能"></a>受限的功能</h2><p>經過前面的解說，我們已經大致上的對區塊鏈的基本雛形有一個了解。簡單的來回推這些機制，其實會發現就是為了要儲存「可信且一致」的資料，所以才會有著「分散式帳本」這樣的名稱。</p><p>我們從 CAP 的定理來看，一般的資料庫大多會將 Consistence （一致性）的要求降低，來加快資料儲存的速度。但是在區塊鏈的世界，對一致性的要求是 100% 的，也讓我們在這些取捨中，失去的運算的速度。</p><p>這也是為什麼加密貨幣沒辦法做非常及時的交易，而每秒的處理量也無法達到一些金融應用的標準。</p><p>用簡單的角度去看區塊鏈，其實就是一套 NoSQL 資料庫。但是他本身有著非常好的一致性，一但資料被寫入之後就不會和其他人有所差異。</p><p>不過一個可信的區塊鏈就必須建立在下面幾種條件都建立的情況下：</p><ul><li>適當的加密演算法</li><li>足夠多的使用者（Proof of Work）</li></ul><p>這也是目前比特幣目前最大的優勢所在，因為大部分的礦工都參與這個區塊鏈，對檢查資料一致來說是非常嚴格的（不過還有 51% 攻擊問題）</p><h2 id="可能的應用"><a href="#可能的應用" class="headerlink" title="可能的應用"></a>可能的應用</h2><p>透過前面這些情報，其實我們會發現基本上在區塊鏈是基於「儲存資料」的前提下運作的。像是以太坊在區塊鏈上提供了圖靈完備的機制，我們放一段可執行的程式碼是可行的。這也構成了 DApp 和 Token（代幣）體系得以實現。</p><p>不過回到可應用的層面，因為我們都是在操作這些儲存的資料，能做的事情其實並不多。而跟這些特性相符的事情，又更少了。</p><p>適應性最高的就是加密貨幣的應用，也就是資產類型的管理和轉移。另一方面則是力用擁有圖靈完備機能的區塊鏈，在鏈上進行一些操作。</p><p>如此一來，加密貨幣的應用就顯而易見了。也因此，發展方向不外乎就是基於區塊鏈的一致性特性來輔助管理，所以才會有像是醫療、物聯網等等應用，用來追蹤資訊的變化跟脈絡。</p><p>另一方面則是強化區塊鏈本身，所以才會有側鏈、新的工作證明機制等等方法的提出，或者去開發全新的區塊鏈來改善等等。</p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>從技術的角度去觀察區塊鏈本身，其實會發現「能做的事情不多」也就是為什麼大家都在等待所謂的「殺手級應用」出現。</p><p>至於像是交易所、ICO 這類應用，只能說是在商業上的成功。至於該怎麼使用區塊鏈來改善生活，到目前為止都還沒有看到一個明確的方向。</p><p>這也是為什麼文章一開始會認為「搞懂了反而想賣掉」的原因，作為投資理財的角度，加密貨幣確實是這幾年值得一試的金融商品。但是從技術面來看，到目前為止都還沒有非常明朗的結果，也因為這樣，就代表說加密貨幣一直有資金流入，但是卻一直沒有實質上的產出。</p><p>這就跟泡沫化的跡象一樣，他很熱門但是還沒有實質的用途。</p><p>這才是大家擔心的泡沫，不過即使泡沫破了，工程師們大概還是會在這個方向上繼續努力。所以該買加密貨幣嗎？</p><p>作為研究用圖，或者期待哪一天工程師們可以找到正確得應用方案，那麼在「可接受的範圍內」買一點放著，偶爾可以拿來嘗試一些有趣的應用（Ex. 加密貓）之類的，倒是不錯。</p><blockquote><p>不過到這邊為止，我想大家應該是可以很冷靜的看待區塊鏈了吧！</p></blockquote>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/04/02/The-blockchain-I-know-about-in-2018/#disqus_thread</comments>
    </item>
    
    <item>
      <title>部署你的第一個 Ruby on Rails 網站（三）</title>
      <link>https://blog.frost.tw/posts/2018/03/27/Getting-started-deploy-your-Ruby-on-Rails-Part-3/</link>
      <guid>https://blog.frost.tw/posts/2018/03/27/Getting-started-deploy-your-Ruby-on-Rails-Part-3/</guid>
      <pubDate>Tue, 27 Mar 2018 13:30:15 GMT</pubDate>
      <description>
      
        &lt;p&gt;經過&lt;a href=&quot;https://blog.frost.tw/posts/2018/03/20/Getting-started-deploy-your-Ruby-on-Rails-Part-1/&quot;&gt;第一篇&lt;/a&gt;和&lt;a href=&quot;https://blog.frost.tw/posts/2018/03/23/Getting-started-deploy-your-Ruby-on-Rails-Part-2/&quot;&gt;第二篇&lt;/a&gt;的說明，我想大家現在應該都有辦法順利的透過 SSH 進入自己的伺服器。&lt;/p&gt;
&lt;p&gt;在第二篇的最後，我們針對 Ruby 環境預先做了準備，接下來就是安裝 Ruby 環境的時候了！&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>經過<a href="https://blog.frost.tw/posts/2018/03/20/Getting-started-deploy-your-Ruby-on-Rails-Part-1/">第一篇</a>和<a href="https://blog.frost.tw/posts/2018/03/23/Getting-started-deploy-your-Ruby-on-Rails-Part-2/">第二篇</a>的說明，我想大家現在應該都有辦法順利的透過 SSH 進入自己的伺服器。</p><p>在第二篇的最後，我們針對 Ruby 環境預先做了準備，接下來就是安裝 Ruby 環境的時候了！</p><a id="more"></a><h2 id="計畫"><a href="#計畫" class="headerlink" title="計畫"></a>計畫</h2><p>隨著專案的發展，我們通常都會需要更新 Ruby 版本。這次我們選擇使用的是 Passenger + Ruby  的解決方案，好處是可以透過設定檔指定 Ruby 版本。為了這個優點，我們可以透過自行編譯 Ruby 來管理多個版本的 Ruby。</p><p>如果覺得自行編譯麻煩的話，也可以選擇 RVM 或者 rbenv 這兩套常見的 Ruby 版本管理工具，不過在經驗上編譯 Ruby 環境其實非常的容易，所以也就不一定需要了！</p><blockquote><p>使用這種方法是需要管理的主機不多，或者是自己使用（需要放多個網站）的情況才會這樣做，當主機多的時候，採用 Chef / Ansible 這種部署工具，一台機器針對一個網站配置，更新版本時就採取直接安裝新的伺服器後轉移過去，反而會比較好管理。</p></blockquote><h2 id="編譯-Ruby"><a href="#編譯-Ruby" class="headerlink" title="編譯 Ruby"></a>編譯 Ruby</h2><p>首先，我們要確定是在自己的使用者下執行，而非 <code>root</code> 使用者。看一下輸入指令的地方是顯示類似 <code>elct9620@deploy-example</code> 而不是 <code>root@deploy-example</code> 就能夠分辨現在使用的帳號是哪一個。</p><p><code>@</code> 前面是「使用者」後面的部分叫做 Hostname（主機名稱）可以用來分辨是在哪一台伺服器上，所以在設定的時候好好取名是很重要的。</p><blockquote><p>不論是寫程式或設定伺服器，用容易理解的命名都是一個好習慣。</p></blockquote><p>這次的範例會編譯 Ruby 2.4 版本，我們要先到 Ruby 官方網站的<a href="https://www.ruby-lang.org/zh_tw/downloads/" target="_blank" rel="noopener">下載頁面</a>來取得原始碼的壓縮檔。</p><p><img src="https://blog.frost.tw/images/getting-started-deploy-your-ruby-on-rails-part-3/screenshot.jpg" alt="螢幕快照 2018-03-26 下午10.17.13.png"></p><p>如圖上顯示的一樣，目前最新的 Ruby 2.4.3 是我們想安裝的版本，所以對他點選右鍵後選擇「複製連結網址」就可以取得像是下面的下載位址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://cache.ruby-lang.org/pub/ruby/2.4/ruby-2.4.3.tar.gz</div></pre></td></tr></table></figure><p>接下來我們到伺服器上用 <code>wget</code>（WWW Get）指令來下載檔案，除了 <code>curl</code> 這個之後會介紹的指令外，是在 Linux 上很常用來下載檔案的指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget https://cache.ruby-lang.org/pub/ruby/2.4/ruby-2.4.3.tar.gz</div></pre></td></tr></table></figure><blockquote><p>如果發現沒有 <code>wget</code> 指令的話，可以利用上次介紹過的 <code>sudo yum install wget -y</code> 來安裝。</p></blockquote><p>下載完畢後，如果不確定操作是否正確，我們可以用 <code>ls</code> (List) 指令來看看現在這個目錄（資料夾）下面有沒有這個檔案。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls</div></pre></td></tr></table></figure><p>結果會類似下面這樣</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[elct9620@deploy-example ~]$ ls</div><div class="line">ruby-2.4.3.tar.gz</div></pre></td></tr></table></figure><p>既然這是一個壓縮檔，我們理所當然的要下指令對他解壓縮了！</p><p>在 Linux 中，我們通常會把檔案做成一個 <code>tar</code> 格式的檔案，然後再搭配上一個壓縮的格式（例如 Gzip 或者 Bzip2）所以才會有叫做 <code>.tar.gz</code> 或者 <code>.tgz</code> 這樣的副檔名。</p><p>而 <code>tar</code> 也是 Linux 中的一個指令，可以用來壓縮或者解壓縮檔案。下面的指令同時做了 <code>-z</code> （用 Gzip 壓縮格式）<code>-x</code>（解壓縮）<code>-v</code>（顯示檔案內容）<code>-f</code>（指定檔案）來進行解壓縮，統合起來就是「用 Gzip 格式解壓縮 <code>ruby-2.4.3.tar.gz</code> 這個檔案，並顯示內容」</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -zxvf ruby-2.4.3.tar.gz</div></pre></td></tr></table></figure><p>執行完畢後，再次用 <code>ls</code> 看一次，會發現多出了 <code>ruby-2.4.3</code> 這個資料夾。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[elct9620@deploy-example ~]$ ls</div><div class="line">ruby-2.4.3  ruby-2.4.3.tar.gz</div></pre></td></tr></table></figure><p>為了編譯 Ruby 方便下指令，我們要先用 <code>cd</code>（Change Directory）指令，切換到 <code>ruby-2.4.3</code> 這個目錄下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> ruby-2.4.3</div></pre></td></tr></table></figure><p>同時可能會發現原本輸入指令左方的 <code>~</code> 符號變成了 <code>ruby-2.4.3</code>，這是表示你目前所在的資料夾，透過這樣的方式就不怕迷失在 Linux 的資料夾中。</p><blockquote><p><code>~</code> 符號是一個代號，表示這個使用者的家目錄，一般 Linux 的使用者都會在 <code>/home</code> 資料夾下面有一個對應自己帳號的資料夾。</p></blockquote><p>預設的 Ruby 會安裝到 <code>/usr/local</code> 這個位置，但是如果我們希望能管理多個版本的 Ruby 就需要明確的指定位置。</p><p>我們可以透過執行 <code>configure</code> 這個檔案來對 Ruby 編譯時的行為做設定。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./configure --prefix=/usr/<span class="built_in">local</span>/ruby-2.4.3</div></pre></td></tr></table></figure><p>不同的軟體會有不同的設定選項，如果有興趣的話可以去研究看除了指定資料夾之外還有哪些選擇。</p><blockquote><p>如果沒有跑出任何東西，麻煩回到第二篇（有修正過指令）目前 DigitalOcean 上面的 gcc 似乎只有舊版的 4 但是一樣可以使用。</p></blockquote><p>接下來，就是編譯 Ruby 了，因為 Ruby 採用了大部分 Linux 都會有的 <code>make</code>（類似 <code>rake</code> 可以幫我們自動執行各種指令） 所以我們就不需要另外的去安裝像是 <code>CMake</code> 或者 <code>Ninja</code> 之類的編譯工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make</div></pre></td></tr></table></figure><p>這邊會比較花時間，完成之後我們可以用 <code>install</code> 動作請 <code>make</code> 幫我們放到正確的位置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make install</div></pre></td></tr></table></figure><p>不過這樣操作實際上是會發生錯誤的，因為 <code>/usr/local</code> 實際上還是所屬 <code>root</code> 我們可以用 <code>sudo</code> 指令提升權限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo make install</div></pre></td></tr></table></figure><p>如此一來就能順利的在系統中把 Ruby 安裝進去了！</p><p>可以透過手動執行 <code>ruby</code> 這個執行檔來確認 <code>ruby</code> 是正確執行的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/<span class="built_in">local</span>/ruby-2.4.3/bin/ruby -v</div></pre></td></tr></table></figure><p>如果能看到版本號，就是我們正確的安裝 Ruby 了。不過每次都要指定位置是很不方便的，我們可以透過改變 <code>PATH</code> 環境設定來簡化操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/ruby-2.4.3/bin:<span class="variable">$PATH</span></div></pre></td></tr></table></figure><p>上面的 <code>export</code> 指令表示「從此之後都套用」後面我們將 <code>/usr/local/ruby-2.4.3/bin</code> 放在原本的 <code>PATH</code> 前面，表示優先從這個目錄開始找。</p><p>如此一來就能用 <code>ruby -v</code> 直接執行 Ruby 進行操作，不過當下次登入 SSH 因為沒有執行這段指令，就會無法使用這個功能。</p><p>如果大部分的情況都會採用 Ruby 2.4.3 的話，可以在 <code>/etc/profile.d</code> 這個資料夾放一個叫做 <code>ruby.sh</code> 的檔案。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo vi /etc/profile.d/ruby.sh</div></pre></td></tr></table></figure><p>進入 Vim 後按下 <code>i</code> 進入編輯模式，輸入以下指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export PATH=/usr/local/ruby-2.4.3/bin:$PATH</div></pre></td></tr></table></figure><p>再按下 <code>:wq</code> 進行存檔，如此一下下次預設就會採用 Ruby 2.4.3 做為預設的 Ruby 執行了。</p><blockquote><p>在 <code>/etc</code> 目錄下面的變更是對整個伺服器的修改，以後不管是誰打開都會預設使用 Ruby 2.4.3 這點需要注意。</p></blockquote><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>這篇文章花了不少時間在處理編譯上，不過當掌握了編譯的方法後，不論是 Nginx 或者 PHP 還是其他的程式，都能夠用相同的方式編譯出來。</p><p>在遇到無法使用套件的情況下，會是非常有用的技巧。</p><p>下一篇會開始把 Passenger 和 Nginx 安裝起來，因為是透過 Passenger 提供的安裝工具，所以會比這一篇輕鬆很多。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/03/27/Getting-started-deploy-your-Ruby-on-Rails-Part-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>使用 Turbolinks 時 Google Analytics 並沒有正確運作</title>
      <link>https://blog.frost.tw/posts/2018/03/24/Google-Analytics-not-correct-when-using-turbolinks/</link>
      <guid>https://blog.frost.tw/posts/2018/03/24/Google-Analytics-not-correct-when-using-turbolinks/</guid>
      <pubDate>Sat, 24 Mar 2018 02:28:21 GMT</pubDate>
      <description>
      
        &lt;p&gt;最近因為在&lt;a href=&quot;https://5xruby.tw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;五倍紅寶石&lt;/a&gt;配合同事做官網的 SEO 優化，比較常見的行銷工具像是 Google Analytics 之類的就一起拿出來玩。&lt;/p&gt;
&lt;p&gt;實驗的對象首選當然是自己的網站，不過在調整的時候卻發現有一些情況有點異常。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>最近因為在<a href="https://5xruby.tw" target="_blank" rel="noopener">五倍紅寶石</a>配合同事做官網的 SEO 優化，比較常見的行銷工具像是 Google Analytics 之類的就一起拿出來玩。</p><p>實驗的對象首選當然是自己的網站，不過在調整的時候卻發現有一些情況有點異常。</p><a id="more"></a><p>當我使用 <a href="https://chrome.google.com/webstore/detail/google-analytics-debugger/jnkmfdileelhofjcijamephohjechhna?hl=zh-TW" target="_blank" rel="noopener">Google Analytics Debugger</a> 去看我的部落格（這個網站）的時候，換頁完全沒有任何事件被紀錄進去。</p><p>很明顯的，這是 Google Analytics 的 PageView 事件沒有被偵測到。而第一個應該要被檢查的，就是很多人在 Ruby on Rails 推出 Turbolinks 因為<strong>不會使用</strong>通常會搶先關掉的這個功能。</p><p>Turbolinks 本身是一個對 UX（使用者體驗）改善的套件，可以將網頁的切換變得比較平順。簡單來說，就是<strong>利用 Ajax 載入</strong>新頁面後，再替換掉改變的內容。</p><p>也就是說，實際上我們並沒有觸發真實的換頁行為。也就不會將 Google Analytics 的 JavaScript 重新讀取，自然就不存在紀錄頁面瀏覽事件（PageView）這件事情。</p><p>解決方案其實很簡單，我們只需要像處理最多人不太熟悉的 jQuery + Turbolinks 無法搭配運作的問題一樣，正確的設定頁面讀取事件即可。</p><p>也就是從普通的綁定 <code>DOMContentLoaded</code> 事件，改為</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// jQuery Version</span></div><div class="line">$(<span class="built_in">document</span>).on(<span class="string">'turbolinks:load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// Pure JavaScript Version</span></div><div class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'turbolinks:load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>因為 JavaScript 已經正確載入了，所以只需要重新把 Google Analytics 的行為重現出來。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'turbolinks:load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  ga(<span class="string">'create'</span>, <span class="string">'UA-XXXXXXX'</span>);</div><div class="line">  ga(<span class="string">'set'</span>, <span class="string">'location'</span>, location.pathname);</div><div class="line">  ga(<span class="string">'send'</span>, <span class="string">'pageview'</span>);</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>不過，假設還想加上像是 Facebook Pixel 之類的追蹤程式碼，每個都設定大概是找到頭暈。所以比較好的方式，其實是改用 Google Tag Manager 來處理。</p><p>先讓每次 Turbolinks 讀取後，都發送一個自訂事件給 Google Tag Manager 來統一觸發事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'turbolinks:load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> dataLayer !== <span class="string">"undefined"</span> &amp;&amp; dataLayer !== <span class="literal">null</span>) &#123;</div><div class="line">        dataLayer.push(&#123;</div><div class="line">            <span class="string">'event'</span>:<span class="string">'turbolinks:load'</span>,</div><div class="line">            <span class="string">'virtualUrl'</span>: event.data.url</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>接著在 Google Tag Manager 上面新增 Trigger 追蹤 <code>turbolinks:load</code>（這是自訂事件的名字）並把有需要紀錄頁面瀏覽的 Tag 加上這個 Trigger 即可。</p><p>另外現在回去看目前這個使用 Turbolinks 的網站版本，在換上去後轉換率有明顯的往下降，可能就是這個關係。</p><p><img src="https://blog.frost.tw/images/google-analytics-not-correct-when-using-turbolinks/ratio.png" alt="Google Analytics 分析資料"></p><p>最近會再關注一下轉換率有沒有提高，或者跳出率下降之類的。如果跳出率是下降，還是會蠻傷心的 XD</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/03/24/Google-Analytics-not-correct-when-using-turbolinks/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
