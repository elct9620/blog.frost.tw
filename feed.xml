<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>弦而時習之</title>
    <link>https://blog.frost.tw/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    
    <description>蒼時弦也的個人網誌，專注在前端、後端以及遊戲開發，大多使用 Ruby 和 Ruby on Rails 以及 Golang、JS 和 C 語言。</description>
    <pubDate>Tue, 30 Jul 2019 06:24:05 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>你大概沒機會遇到的 Bug - 跟 Ruby Committer 聊 Enumerator 跟 Fiber</title>
      <link>https://blog.frost.tw/posts/2019/07/30/Talk-with-the-Ruby-Committer-about-Enumerator-and-Fiber-the-bug-you-may-never-touch/</link>
      <guid>https://blog.frost.tw/posts/2019/07/30/Talk-with-the-Ruby-Committer-about-Enumerator-and-Fiber-the-bug-you-may-never-touch/</guid>
      <pubDate>Tue, 30 Jul 2019 06:11:31 GMT</pubDate>
      <description>
      
        &lt;p&gt;今年 &lt;a href=&quot;https://2019.rubyconf.tw/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;RubyConf Taiwan&lt;/a&gt; 嘗試辦了 After Hack 這個活動，也因此有機會可以跟 Ruby 語言的 Commiter 聊一些有趣的問題。&lt;/p&gt;&lt;p&gt;當天我的預定是把活動這幾天寫的 Gem 認真的補完測試，不過沒想到還剩下一個多小時就做完了，那就順便來思考一下 &lt;a href=&quot;https://tamashii.io&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Tamashii&lt;/a&gt; 專案能怎樣去改進，在今年的演講中大家應該都對 Fiber 有一個認識，而這個也許是一個不錯的選項。&lt;/p&gt;&lt;p&gt;所以就馬上去看了一下講者（Samuel）的 &lt;a href=&quot;https://github.com/socketry/async&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Async&lt;/a&gt; 這個 Gem 做了些什麼事情，因為剛講完關於 Enumerator 的演講，所以自然地看到了一段引起我興趣的說明。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Due to limitations within Ruby and the nature of this library, it is not possible to use to_enum on methods which invoke asynchronous behavior. We hope to fix this issue in the future.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;既然作者本人就在現場，而且 Issue 的內容也看不太出來發生什麼問題，那麼就直接問吧！&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>今年 <a href="https://2019.rubyconf.tw/" rel="external nofollow noopener noreferrer" target="_blank">RubyConf Taiwan</a> 嘗試辦了 After Hack 這個活動，也因此有機會可以跟 Ruby 語言的 Commiter 聊一些有趣的問題。</p><p>當天我的預定是把活動這幾天寫的 Gem 認真的補完測試，不過沒想到還剩下一個多小時就做完了，那就順便來思考一下 <a href="https://tamashii.io" rel="external nofollow noopener noreferrer" target="_blank">Tamashii</a> 專案能怎樣去改進，在今年的演講中大家應該都對 Fiber 有一個認識，而這個也許是一個不錯的選項。</p><p>所以就馬上去看了一下講者（Samuel）的 <a href="https://github.com/socketry/async" rel="external nofollow noopener noreferrer" target="_blank">Async</a> 這個 Gem 做了些什麼事情，因為剛講完關於 Enumerator 的演講，所以自然地看到了一段引起我興趣的說明。</p><blockquote><p>Due to limitations within Ruby and the nature of this library, it is not possible to use to_enum on methods which invoke asynchronous behavior. We hope to fix this issue in the future.</p></blockquote><p>既然作者本人就在現場，而且 Issue 的內容也看不太出來發生什麼問題，那麼就直接問吧！</p><a id="more"></a><h2 id="關於-Fiber"><a href="#關於-Fiber" class="headerlink" title="關於 Fiber"></a>關於 Fiber</h2><p>詳細的部分可以參考之前寫過的 <a href="https://blog.frost.tw/posts/2018/06/26/Talk-about-ruby-s-fiber-Part-1/">Fiber 簡介</a> 以下只做簡單的介紹方便跟上這篇文章的內容，另外因為這幾年很多語言都在努力的更新，雖然 Ruby 是一個相容性非常好的語言，但是還是有不少變化是隱含的。</p><blockquote><p>以文章中的 4K 堆疊為例，今年另一位講者（<a href="https://github.com/dsh0416" rel="external nofollow noopener noreferrer" target="_blank">Delton Ding</a>）在 <a href="https://twitter.com/DeltonDing/status/1155853101586214918" rel="external nofollow noopener noreferrer" target="_blank">Twitter</a> 提醒我這個特性在 2010 年和 2017 年都修改過，在 Ruby 2.5 之後的版本是不會產生，而改用指標的方式來處理。</p></blockquote><p>Fiber 機制用很簡單的方式說明，就是我們可以在單一的 Thread 下面，再做一次切割來切換執行順序。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f = Fiber.new <span class="keyword">do</span></span><br><span class="line">  <span class="comment"># A: 做某些事情</span></span><br><span class="line">  Fiber.<span class="keyword">yield</span> <span class="comment"># I/O Blocking 先跳出給其他人做事</span></span><br><span class="line">  <span class="comment"># B: 繼續做事情</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 執行 Fiber (A 區塊）</span></span><br><span class="line">f.resume</span><br><span class="line"><span class="comment"># 繼續執行（B 區塊）</span></span><br><span class="line">f.resume</span><br></pre></td></tr></table></figure><p>以前我們會需要用切分 Thread 的方式來對應 I/O Blocking 的情況，現在我們可以用一些 Non-Blocking 的操作來判斷是否有賭塞現象，進而控制執行的流程。</p><h2 id="Enumerator-中的-Fiber"><a href="#Enumerator-中的-Fiber" class="headerlink" title="Enumerator 中的 Fiber"></a>Enumerator 中的 Fiber</h2><p>今年我自己的演講主要是著重在 Enumerator 的生成與運作上，所以討論了 Ruby 能用哪些技巧去做到讓 <code>yield</code> 行為暫時不發生，以及讓某些動作能夠被「延遲（<code>#lazy</code>）」執行。</p><p>當我跟 Samuel 聊到這個 Enumerator 的 Bug 時候，我問了一句「Which ruby version this will happen?」得到的是「All versions」的解答，然後我馬上就知道這是我「沒有讀」的那一個部分，也就是關於 Enumerator 如何去迭代數值的部分。</p><blockquote><p>寫這篇文章的時候我再去看了一次 <code>enumerator.c</code> 裡面有出現 Fiber 的區段，基本上應該是有使用到 <code>#next</code> 的情況會發生，如果是一些 <code>#zip</code> 和 <code>#map</code> 的情況，因為不一定會去呼叫到 <code>#next</code> 就不會產生問題。</p></blockquote><p>那麼，到底是在哪裡產生了 Fiber 呢？</p><p><code>enumerator.c</code>（Ruby 2.6.2）裡面只有一個 <code>fiber_new</code> 我們照呼叫的順序去來追蹤，首先會看到 <code>enumerator_next</code> 這個實作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> VALUE</span><br><span class="line">enumerator_next(VALUE obj)</span><br><span class="line">&#123;</span><br><span class="line">    VALUE vs = enumerator_next_values(obj);</span><br><span class="line">    <span class="keyword">return</span> ary2sv(vs, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這邊會把 <code>enumerator_next_values</code> 回傳的數值找出第一個（如果是陣列）或者直接回傳，基本上就是把下一個元素找出來。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> VALUE</span><br><span class="line">enumerator_next_values(VALUE obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">enumerator</span> *<span class="title">e</span> = <span class="title">enumerator_ptr</span>(<span class="title">obj</span>);</span></span><br><span class="line">    VALUE vs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e-&gt;lookahead != Qundef) &#123;</span><br><span class="line">        vs = e-&gt;lookahead;</span><br><span class="line">        e-&gt;lookahead = Qundef;</span><br><span class="line">        <span class="keyword">return</span> vs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> get_next_values(obj, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然後這邊會拿當下作用的 Enumerator 來去找接下來會出現的數值，所以我們再繼續往下看到 <code>get_next_values</code> 這個方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> VALUE</span><br><span class="line">get_next_values(VALUE obj, struct enumerator *e)</span><br><span class="line">&#123;</span><br><span class="line">    VALUE curr, vs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e-&gt;stop_exc)</span><br><span class="line">      rb_exc_raise(e-&gt;stop_exc);</span><br><span class="line"></span><br><span class="line">    curr = rb_fiber_current();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!e-&gt;fib || !rb_fiber_alive_p(e-&gt;fib)) &#123;</span><br><span class="line">      next_init(obj, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vs = rb_fiber_resume(e-&gt;fib, <span class="number">1</span>, &amp;curr);</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;stop_exc) &#123;</span><br><span class="line">      e-&gt;fib = <span class="number">0</span>;</span><br><span class="line">      e-&gt;dst = Qnil;</span><br><span class="line">      e-&gt;lookahead = Qundef;</span><br><span class="line">      e-&gt;feedvalue = Qundef;</span><br><span class="line">      rb_exc_raise(e-&gt;stop_exc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到了這段，我們終於發現了 Fiber 的蹤跡，稍微來看一下發生了哪些事情。</p><ol><li>呼叫 <code>Fiber.current</code> 取得當下作用中的 Fiber</li><li><strong>如果 Enumerator 的 Fiber 不存在或者執行完畢</strong>，就做 <code>next_init</code> 這個動作</li><li>對 Enumerator 的 Fiber 呼叫 <code>#resume</code></li></ol><p>因為 <code>#resume</code> 的回傳值是 <code>Fiber.yield</code> 傳入的參數，所以我們只要再找到 Enumerator 的 Fiber 就能了解是怎樣運作的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">next_init(VALUE obj, struct enumerator *e)</span><br><span class="line">&#123;</span><br><span class="line">    VALUE curr = rb_fiber_current();</span><br><span class="line">    e-&gt;dst = curr;</span><br><span class="line">    e-&gt;fib = rb_fiber_new(next_i, obj);</span><br><span class="line">    e-&gt;lookahead = Qundef;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到 <code>next_init</code> 這段，我們會發現 Ruby 將 <code>next_i</code> 的方法當作是 Fiber 執行的區段來呼叫（就是我們 Fiber.new 給的 Block）</p><p>繼續往下追會看到 <code>next_i</code> 和 <code>next_ii</code> 兩個方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> VALUE</span><br><span class="line">next_ii(RB_BLOCK_CALL_FUNC_ARGLIST(i, obj))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">enumerator</span> *<span class="title">e</span> = <span class="title">enumerator_ptr</span>(<span class="title">obj</span>);</span></span><br><span class="line">    VALUE feedvalue = Qnil;</span><br><span class="line">    VALUE args = rb_ary_new4(argc, argv);</span><br><span class="line">    rb_fiber_yield(<span class="number">1</span>, &amp;args);</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;feedvalue != Qundef) &#123;</span><br><span class="line">        feedvalue = e-&gt;feedvalue;</span><br><span class="line">        e-&gt;feedvalue = Qundef;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> feedvalue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> VALUE</span><br><span class="line">next_i(VALUE curr, VALUE obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">enumerator</span> *<span class="title">e</span> = <span class="title">enumerator_ptr</span>(<span class="title">obj</span>);</span></span><br><span class="line">    VALUE nil = Qnil;</span><br><span class="line">    VALUE result;</span><br><span class="line"></span><br><span class="line">    result = rb_block_call(obj, id_each, <span class="number">0</span>, <span class="number">0</span>, next_ii, obj);</span><br><span class="line">    e-&gt;stop_exc = rb_exc_new2(rb_eStopIteration, <span class="string">"iteration reached an end"</span>);</span><br><span class="line">    rb_ivar_set(e-&gt;stop_exc, id_result, result);</span><br><span class="line">    <span class="keyword">return</span> rb_fiber_yield(<span class="number">1</span>, &amp;nil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看 <code>next_i</code> 這個方法，他會去呼叫我們定義的 Enumerator 的 <code>#each</code> 方法來做迭代，跟我們對 Enumerator 的理解上是一致的，而迭代的行為（給 <code>#each</code> 的 Block）就是 <code>next_ii</code> 本身。<br>繼續看到 <code>next_ii</code> 這個方法，可以理解為他就是單純的呼叫 <code>Fiber.yield</code> 而已，所以我們可以把這段轉換成下面的 Ruby 來理解。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>..<span class="number">10</span>).each <span class="keyword">do</span> <span class="params">|item|</span></span><br><span class="line">  Fiber.<span class="keyword">yield</span> item</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>也就是說，每次我們用 <code>#next</code> 的時候，Ruby 會產生一個 Fiber 然後每執行一次迭代就用 <code>Fiber.yield</code> 跳出來，直到都沒有任何元素可以被迭代後，再產生 <code>StopIteration</code> 的 Exception 同時做最後一次的 <code>Fiber.yield</code></p><p>我們可以用 Ruby簡單模擬這個行為</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frozen_string_literal: true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">require</span> <span class="string">'fiber'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># :nodoc:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FiberNext</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(items)</span></span></span><br><span class="line">    @items = items</span><br><span class="line">    @fiber = create_fiber</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">next</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">unless</span> @fiber.alive?</span><br><span class="line"></span><br><span class="line">    @fiber.resume</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  private</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">create_fiber</span></span></span><br><span class="line">    Fiber.new <span class="keyword">do</span></span><br><span class="line">      @items.each <span class="keyword">do</span> <span class="params">|item|</span></span><br><span class="line">        Fiber.<span class="keyword">yield</span> item</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      Fiber.<span class="keyword">yield</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">enum = FiberNext.new(%i[apple water flashlight])</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.times <span class="keyword">do</span></span><br><span class="line">  puts <span class="string">"Next: <span class="subst">#&#123;enum.<span class="keyword">next</span>&#125;</span>"</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>讀到這裡，不得不感嘆一下 Ruby Commiter 們用如此漂亮的方式設計了一個機能，我們都知道 Enumerator 對應的 <code>#each</code> 裡面只要給了 <code>yield</code> 基本上就是一個無法停止的狀態，他會不斷呼叫我們給的 Block 直到沒有 <code>yield</code> 再被呼叫，所以在 Ruby 裡面這算是一種「迭代」</p><p>但是想要控制迭代的進度，用步進的方式進行呢？如果採用一般的方式可能要做很多動作才能達成，此時 Fiber 這種可以暫時某個位置執行其他任務，再跳回去的機制就變得非常實用。以應用案例來說，我想這大概也是非常漂亮的一個學習參考，以我過去對 Fiber 的理解是沒辦法想到這樣的使用方式的。</p><h2 id="被少考慮的情境"><a href="#被少考慮的情境" class="headerlink" title="被少考慮的情境"></a>被少考慮的情境</h2><p>前情提要終於結束了，回到我們的主題，那個你不會遇到的 Bug 到底是什麼？</p><p>在 Samuel 對 Ruby 的 <a href="https://github.com/ruby/ruby/pull/2002#issuecomment-515749562" rel="external nofollow noopener noreferrer" target="_blank">PR</a> 中你可以看到一段使用 <code>#to_enum</code> 和 <code>Fiber</code> 的程式碼，這段是當天再向我解釋時給的一個範例。</p><p>我稍微整理一下，讓大家比較好看到問題</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">items</span><span class="params">(&amp;block)</span></span></span><br><span class="line">  <span class="keyword">yield</span> <span class="symbol">:apple</span></span><br><span class="line">  Fiber.<span class="keyword">yield</span> <span class="comment"># 我想在這跳出我的 Fiber</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="symbol">:water</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="symbol">:flashlight</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">enum = to_enum(<span class="symbol">:items</span>)</span><br><span class="line"></span><br><span class="line">f = Fiber.new <span class="keyword">do</span></span><br><span class="line">  <span class="number">3</span>.times <span class="keyword">do</span></span><br><span class="line">    puts <span class="string">"Next: <span class="subst">#&#123;enum.<span class="keyword">next</span>&#125;</span>"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">f.resume</span><br></pre></td></tr></table></figure><p>執行的結果卻是這樣的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[elct9620] Desktop % ruby fiber.rb</span><br><span class="line">Next: apple</span><br><span class="line">Next:</span><br><span class="line">Next: water</span><br></pre></td></tr></table></figure><p>照正常的迭代器運作，不應該是把 <code>:apple</code>, <code>:water</code> 和 <code>:flashlight</code> 印出來，為什麼多了一個 <code>nil</code> 的數值呢？</p><p>如果我們把 <code>Fiber.yield</code> 改成 <code>Fiber.yield :oops</code> 執行看看</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[elct962<span class="number">0</span>] Desktop % ruby fiber.rb</span><br><span class="line"><span class="symbol">Next:</span> apple</span><br><span class="line"><span class="symbol">Next:</span> oops</span><br><span class="line"><span class="symbol">Next:</span> water</span><br></pre></td></tr></table></figure><p>問題就出在 <code>Fiber.yield</code> 竟然變得跟 <code>yield</code> 一樣，這是怎麼一回事？</p><p>回想一下前面介紹 Enumerator 在做 <code>#next</code> 的時候，是不是會產生一個新的 Fiber 然後用那個 Fiber 去做事情？</p><p>我們把前面那段產生 <code>#next</code> 的 Fiber 區段找出來，然後代入 <code>#items</code> 方法，會變成怎樣呢？</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line">    Fiber.new <span class="keyword">do</span></span><br><span class="line">      <span class="comment"># <span class="doctag">@items</span>.each do |item|</span></span><br><span class="line">        items <span class="keyword">do</span> <span class="params">|item|</span></span><br><span class="line">          <span class="comment"># 第一次 =&gt; item = (yield :apple)</span></span><br><span class="line">          <span class="comment"># 第一次 =&gt; Fiber.yield :oops</span></span><br><span class="line">          <span class="comment"># 第二次 =&gt; item = (yield :water)</span></span><br><span class="line">          <span class="comment"># 第三次 =&gt; item = (yield :flashlight)</span></span><br><span class="line">          Fiber.<span class="keyword">yield</span> item</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      Fiber.<span class="keyword">yield</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>大家有沒有發現，我們在第一次到第二次迭代的時候，被偷做了一次 <code>Fiber.yield</code> 然後他就跑回去變成 <code>#resume</code> 的回傳值，然後 <code>#next</code> 行為的次數就大亂了，歸咎原因在於他在執行的時候被 Ruby 判斷為「屬於 Enumerator 的 Fiber」</p><p>所以如果我們修改成像下面這樣執行，反而就不會出問題</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">items</span><span class="params">(&amp;block)</span></span></span><br><span class="line">  <span class="keyword">yield</span> <span class="symbol">:apple</span></span><br><span class="line">  Fiber.<span class="keyword">yield</span> <span class="comment"># 我想在這跳出我的 Fiber</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="symbol">:water</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="symbol">:flashlight</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">enum = to_enum(<span class="symbol">:items</span>)</span><br><span class="line"></span><br><span class="line">f = Fiber.new <span class="keyword">do</span></span><br><span class="line">  items <span class="keyword">do</span> <span class="params">|item|</span></span><br><span class="line">    puts <span class="string">"Next: <span class="subst">#&#123;item&#125;</span>"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">f.resume</span><br><span class="line">f.resume <span class="comment"># 因為被正確 `Fiber.yield` 所以要再做一次讓他能繼續</span></span><br></pre></td></tr></table></figure><p>因為沒有使用 <code>#next</code> 所以不會產生一個 Fiber 也就不會有被判斷錯誤的問題。</p><h2 id="解決方案與-Fiber-的切換機制"><a href="#解決方案與-Fiber-的切換機制" class="headerlink" title="解決方案與 Fiber 的切換機制"></a>解決方案與 Fiber 的切換機制</h2><p>目前我們看到的 PR 算是一個暫時性的解法，Samuel 告訴我這跟目前 Fiber 的設計有關係，所以只能先處理掉這個問題（大概會是 2.7 or 2.8 之類的會好）目前 PR 上已經是另一個版本，也就是最後展示給我會動的版本。中間也還有使用像是 <code>Fiber.transfer</code> 之類的方式做切換，就能指定應該要跳回哪一個 Fiber 上。</p><p>不過 Samuel 告訴我的想法我還不太清楚他想表達的是哪一個，不過只能說目前大致上有一個解決方法可以用。</p><ol><li>Enumerator 的 Fiber 要能跟普通的 Fiber 區分開來</li><li>Fiber 要加入一些類似 Call Stack 的機制，用來判斷要跳回去的 Fiber（以解釋來說比較像是多存一個指標）</li></ol><p>最後，我們來談談目前（Ruby 2.6.2）的 Fiber 切換機制是怎樣的。</p><p>目前已知 <code>Fiber.yield</code> <code>Fiber.transfer</code> 和 <code>#resume</code> 三個方法可以做切換，那麼來看一下這三個的實作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">VALUE</span><br><span class="line">rb_fiber_resume(VALUE fibval, <span class="keyword">int</span> argc, <span class="keyword">const</span> VALUE *argv)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">rb_fiber_t</span> *fib = fiber_ptr(fibval);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fib-&gt;prev != <span class="number">0</span> || fiber_is_root_p(fib)) &#123;</span><br><span class="line">      rb_raise(rb_eFiberError, <span class="string">"double resume"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fib-&gt;transferred != <span class="number">0</span>) &#123;</span><br><span class="line">      rb_raise(rb_eFiberError, <span class="string">"cannot resume transferred Fiber"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fiber_switch(fib, argc, argv, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VALUE</span><br><span class="line">rb_fiber_yield(<span class="keyword">int</span> argc, <span class="keyword">const</span> VALUE *argv)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> fiber_switch(return_fiber(), argc, argv, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VALUE</span><br><span class="line">rb_fiber_transfer(VALUE fibval, <span class="keyword">int</span> argc, <span class="keyword">const</span> VALUE *argv)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> fiber_switch(fiber_ptr(fibval), argc, argv, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔細一看，除了 <code>#resume</code> 有做一些檢查去避免重複執行之外，基本上都是做同樣的事情。（也就是文章前面提到的在新版的 Fiber 已經採用指標切換）</p><p>而 <code>Fiber.yield</code> 和 <code>Fiber.transfer</code> 的差異幾乎是只剩下「是否能指定 Fiber」這點，這也是 Samuel 有提到可能可以用 <code>Fiber.transfer</code> 去解決 Enumerator 裡面的 Fiber 問題的原因，因為我們可以利用這樣的方式「手動指定」而不是交由 Ruby 自己判斷，那麼就能讓我們指定正確的 Fiber 去繼續執行。</p><p>至於為什麼會選到錯誤的 Fiber 執行，我們看一下 <code>fiber_siwtch</code> 和 <code>return_fiber</code> 大概就可以猜到原因。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> VALUE</span><br><span class="line">fiber_switch(<span class="keyword">rb_fiber_t</span> *fib, <span class="keyword">int</span> argc, <span class="keyword">const</span> VALUE *argv, <span class="keyword">int</span> is_resume)</span><br><span class="line">&#123;</span><br><span class="line">    VALUE value;</span><br><span class="line">    <span class="keyword">rb_context_t</span> *cont = &amp;fib-&gt;cont;</span><br><span class="line">    <span class="keyword">rb_thread_t</span> *th = GET_THREAD();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_resume) &#123;</span><br><span class="line">      fib-&gt;prev = fiber_current();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">rb_fiber_t</span>*</span><br><span class="line">return_fiber(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">rb_fiber_t</span> *fib = fiber_current();</span><br><span class="line">    <span class="keyword">rb_fiber_t</span> *prev = fib-&gt;prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!prev) &#123;</span><br><span class="line">      <span class="keyword">rb_thread_t</span> *th = GET_THREAD();</span><br><span class="line">      <span class="keyword">rb_fiber_t</span> *root_fiber = th-&gt;root_fiber;</span><br><span class="line"></span><br><span class="line">      VM_ASSERT(root_fiber != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (root_fiber == fib) &#123;</span><br><span class="line">        rb_raise(rb_eFiberError, <span class="string">"can't yield from root fiber"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">return</span> root_fiber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      fib-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>簡單說當我們呼叫 <code>#resume</code> 的時候，會把當下的 Fiber 標記成前一個 Fiber，而做 <code>Fiber.yield</code> 的時候就會因為有紀錄，就把這個 Fiber 當作前一個目標做切換。</p><p>過程大概像是這樣：</p><ol><li>Fiber.new （我們的）</li><li>#resume （我們的）</li><li>#next （產生 Enumerator 的 Fiber）</li><li>Fiber.yield =&gt; 找到的是 Enumerator 的 Fiber</li></ol><p>所以在這中間，我們的 Fiber 已經不被我們自定義的迭代方法中的 <code>Fiber.yield</code> 認識。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在 After Hack 回到家之後，才發現原來是被 Commiter 直接一對一教學了一個多小時，算是很不錯的經驗。大概也是因為克服了這類心理上的障礙，所以即使聽得蠻吃力的但還是能夠繼續嘗試，我想之後的活動大概不會有不敢用英文對話的困擾了吧！</p><p>最大的收穫大概是有 Commiter 帶你看了一部分的原始碼，還有去理解這些國外的高手是怎樣思考問題的。至少以台灣人來說算是不錯的經驗，以比例來看台灣人不多的狀況下能遇到的高手是固定的但是如果有像是研討會這類活動，我們就有機會接觸到篩選出來的高手，把握機會跟這些人交流就能很快地學到新東西跟進步，畢竟算是短時間的讓台灣的高手比例上升吧 XD</p><p>雖然會覺得能早點突破心理障礙就能更快接觸到，不過有時候很多知識還沒準備齊全（像是嘗試過 Fiber 和了解基本原理等等）也蠻難能問對問題，可以的話真的蠻需要平常多準備一些問題或者寫下來，才不會遇到機會都沒辦法問。</p><blockquote><p>不過我自己也沒有這個習慣，但是看起來還是要準備一點會比較好呢 XD</p></blockquote>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2019/07/30/Talk-with-the-Ruby-Committer-about-Enumerator-and-Fiber-the-bug-you-may-never-touch/#disqus_thread</comments>
    </item>
    
    <item>
      <title>RubyConf Taiwan 2019 會後感想、議程概覽</title>
      <link>https://blog.frost.tw/posts/2019/07/29/My-experience-after-RubyConf-Taiwan-2019/</link>
      <guid>https://blog.frost.tw/posts/2019/07/29/My-experience-after-RubyConf-Taiwan-2019/</guid>
      <pubDate>Mon, 29 Jul 2019 07:03:01 GMT</pubDate>
      <description>
      
        &lt;p&gt;跟前幾年一樣基本上就是工作人員，這幾年參加研討會也都比較沒有在仔細聽了，所以大多是邊顧邊寫點程式。&lt;/p&gt;&lt;p&gt;比較不一樣的大概是今年更累了，從週四下午場佈到 Pre Party 然後兩天的活動、Official Party 最後到今年嘗試的 After Hack 幾乎是四天左右的連續接力，每天早上醒來都要先懷疑自己是否能撐過這一天。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>跟前幾年一樣基本上就是工作人員，這幾年參加研討會也都比較沒有在仔細聽了，所以大多是邊顧邊寫點程式。</p><p>比較不一樣的大概是今年更累了，從週四下午場佈到 Pre Party 然後兩天的活動、Official Party 最後到今年嘗試的 After Hack 幾乎是四天左右的連續接力，每天早上醒來都要先懷疑自己是否能撐過這一天。</p><a id="more"></a><p>基本上就跟之前差不多，照時間來看整個活動。</p><h2 id="Pre-Party"><a href="#Pre-Party" class="headerlink" title="Pre Party"></a>Pre Party</h2><p>今年是由 <a href="https://piccollage.com/" rel="external nofollow noopener noreferrer" target="_blank">PicCollage</a> 贊助 Pre Party 的活動，去到活動場地的時候很確定以前去過幾次，但是一直沒有想起來是到哪間公司。不過以前有一次的 RubyConf Taiwan 也是在這棟大樓的某間公司辦過 Party 的樣子。</p><p>PicCollage 準備的食物真的好評，非常好吃。然後 Ruby 社群舉辦這種 Party 活動的重點是跟人交流，這場除了有抓新同事去跟 Matz 打個招呼之外，基本上就都還是講中文。蠻意外的是兩年前跟女人迷合作的聊天機器人講座來參加的人，都已經畢業變成 PicCollage 的員工，看起來我離學生時代越來越遠了⋯⋯</p><p>第一天晚上基本上算是暖身，大概就是稍微閒聊，然後跟一些認識的朋友打個招呼就這樣結束了。</p><h2 id="The-Future-of-Ruby"><a href="#The-Future-of-Ruby" class="headerlink" title="The Future of Ruby"></a>The Future of Ruby</h2><p>這場因為早上狀況蠻多的所以沒有聽到太多，尤其是 <a href="https://tamashii.io" rel="external nofollow noopener noreferrer" target="_blank">Tamashii</a> 打卡機遇到了一些狀況，雖然都是很好排除的問題，不過大概也凸顯了過去一年都沒有維護的情況，幾乎都是平常沒有使用跟調整造成的問題。</p><p>Matz 這幾年講的 Keynote 都偏向 Ruby 3 的目標跟方向，還有 Ruby Commiter 努力的成果。這次有投稿 <a href="https://2019.rubyworld-conf.org" rel="external nofollow noopener noreferrer" target="_blank">Ruby World Conference</a> 所以就看看能不能在十一月再聽一次。</p><h2 id="Rethinking-the-View-Layer-with-Components"><a href="#Rethinking-the-View-Layer-with-Components" class="headerlink" title="Rethinking the View Layer with Components"></a>Rethinking the View Layer with Components</h2><p>這場因為<a href="https://ryudo.tw/" rel="external nofollow noopener noreferrer" target="_blank">幕凡</a>在今年 <a href="https://rubykaigi.org/2019" rel="external nofollow noopener noreferrer" target="_blank">RubyKaigi</a> 有跟我提過，所以大概是有一個概念的。今年感覺都沒有很集中，但是又感覺都大概懂，很微妙的狀態。</p><p>簡單來說是在討論 Rails 在 View 層的實作，目前我們的測試都是仰賴 Feature 之類的去驗證畫面是否正常的。<br>這邊是將 View 分解成 Component（元件）的形式，將一些細碎的部分用 Ruby 來實作，有點類似 Decorator 的感覺，但更接近 React 的元件概念。</p><p>利用這種方式我們就可以針對性地對 View 做單元測試，以後端來說算是很先進的想法。</p><h2 id="Ruby-with-types"><a href="#Ruby-with-types" class="headerlink" title="Ruby with types"></a>Ruby with types</h2><p>因為我在 1001 負責錄影，所以都是聽這間的。這場主要在討論對 Ruby 增加型別支援會是怎樣子的，雖然有考慮蠻多東西的。不過我覺得整體上跟 Stripe 提出的 <a href="https://sorbet.org/" rel="external nofollow noopener noreferrer" target="_blank">Sorbet</a> 比起來讓 Ruby 的語法整個變複雜難懂很多。反而是 Sorbet 這種有點選用類型的 DSL 能保有一定程度的相容性，又可以改善一些開發上的問題。</p><blockquote><p>不過 Sorbet 的難點可能會變成在一些 IoT 類型的應用要導入需要一些 Cross Compile 的處理，有可能會變成卡住的點。但是這方面又是 IoT 應用的一個尷尬的地方，很多地方都是需要利用 C Extension 去做才能盡可能的在 Ruby 裡面做事情。</p></blockquote><h2 id="Protect-Your-Copyrighted-Ruby-Code-in-Distribution"><a href="#Protect-Your-Copyrighted-Ruby-Code-in-Distribution" class="headerlink" title="Protect Your Copyrighted Ruby Code in Distribution"></a>Protect Your Copyrighted Ruby Code in Distribution</h2><p>這場我沒怎麼跟上，反正後面就變成瑪力歐了，大致上是在講有什麼方式可以讓 Ruby 原始碼不會被直接的看到這件事情。</p><p>不過我個人是認為這算是一種一體兩面的東西吧，尤其是現在很多應用都轉到 Web 和雲端的情況下，這種套裝軟體的模式是否是合適的。</p><blockquote><p>對一些商用的 Gem 可能會有影響，不過沒有聽很詳細所以就這樣吧 XD</p></blockquote><h2 id="Scalable-Applications-with-JRuby"><a href="#Scalable-Applications-with-JRuby" class="headerlink" title="Scalable Applications with JRuby"></a>Scalable Applications with JRuby</h2><p>這場我沒在聽（印象薄弱）不過感覺有點是在介紹 JRuby 之後的一些發展吧，像是會要把 Fiber 之類的加進去支援。</p><h2 id="Road-to-white-mages"><a href="#Road-to-white-mages" class="headerlink" title="Road to white mages"></a>Road to white mages</h2><p>到這個時候我已經開始在寫新的 Gem 了，這場主要是在講怎麼 Debug 程式。其實 Ruby 在這幾年針對 Debug 的輔助增加了不少特性，用來解決一些問題的時候是真的滿重要的技巧。</p><p>比較簡單的就是現在大多數時候可以直接問 Ruby 某個 Method 是在哪裡定義的（尤其是接手專案又被魔改 Patch 的情況）</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method(<span class="symbol">:puts</span>).source_location</span><br></pre></td></tr></table></figure><p>用法大概像這樣，這場介紹不少這類技巧，我大概要之後補看影片了 XD</p><h2 id="The-Journey-to-One-Million"><a href="#The-Journey-to-One-Million" class="headerlink" title="The Journey to One Million"></a>The Journey to One Million</h2><p>聽說很精彩，因為我也沒在聽所以不太清楚發生什麼事情。不過講者 Samuel 大概是我今年講最多話的外國人了 XD</p><p>主要是在講用 Ruby Fiber 機制開發的 Web Server 能達到處理 100 萬連線的過程，這幾天仔細看 Ruby Core 的 Mailing List 才發現是 Commiter 等級的超級大大。</p><p>裡面有一段是一結束就被幕凡問，我後面跑去問了好幾個熟人也都不知道。</p><p>Fiber 我當初會有興趣是因為他跟 Goroutine 很類似，所以我就跑去研究，去年到日本員工旅遊的時候有去參加 <a href="https://asakusarb.doorkeeper.jp/" rel="external nofollow noopener noreferrer" target="_blank">Asakusa.rb</a> 活動的時候有問了一下那邊的大大，然後再經過幾個月的整理歸納出一個大概的概念，才剛好能搞懂這段問題。</p><blockquote><p>去年是寫了好幾篇關於 <a href="https://blog.frost.tw/posts/2018/06/26/Talk-about-ruby-s-fiber-Part-1/">Fiber</a> 的文章，不過現在回去看其實我的了解還是很不足的。</p></blockquote><p>其實 Fiber 有一個問題是他要做 Context Switch 而做這件事情是有代價的，這種機制（在一個 Thread 內做切換）叫做 Coroutine（協程）在 C 或是 C++ 都能實作出來，而他的特色是會把 Context 保存下來，因為要這樣才能確保切換回去的時候還是在同一個狀態下繼續執行。</p><p>而這件事情就會跟記憶體使用有關係，如果頻繁地切換就會有效能問題，也就是這樣切換的代價是否比開 Thread 還低。</p><p>像是 Context 是怎麼保存的（Ruby 有一個 context 資料結構，他可能不是整個 Ruby 保存而是以 Block 為單位之類的）還有要在什麼時機點做切換，如果我們都沒有 I/O Blocking 的狀況下，切換是否有效益等等。</p><p>簡單來說就是你使用 Fiber 跑出來的效果好不好，取決於你對 Process / Thread 這些東西的機制了解有多少，然後因為 Fiber 還很不成熟，所以你要自己做一些原本 OS 會幫你做的事情，才能讓 Fiber 跑得很快。</p><h2 id="Official-Party"><a href="#Official-Party" class="headerlink" title="Official Party"></a>Official Party</h2><p>今年感覺已經完全可以無視語言障礙，反正聽不懂就乾杯，所以可以比較順的跟外國人交流。</p><p>比較特別的大概是以前的同時有的已經是掛 Director、主管或是跑去 Google 這種看起來就超厲害的公司工作，相比起來我好像蠻普通的（笑）</p><p>這場有跟 Pixiv 的 CTO 稍微聊到天，不過有點可惜大概是對不太到點所以沒能聊起來，但這大概也跟我英文聽力還不夠好有關係，不然感覺應該都是能聊技術才對。</p><p>另外就是有去找 Samuel 問關於 Fiber 的問題，因為之前做的 <a href="https://blog.frost.tw/posts/2018/08/21/Does-the-Fiber-have-any-benefit-for-Ruby/">Fiber 改善 HTTP 效能</a> 測試，我後來做了很多檢驗都跟我預期的結果差異不少。</p><p>這次綜合了前面的演講和我的猜測，算是獲得一個驗證就是之前少測試了一個情況，而這個情況應該才是 Fiber 表現最好的情況。之後有空大概還是得再次實作出來做一次測試，才能檢驗我的假設是否正確。</p><h2 id="Compacting-GC-for-MRI"><a href="#Compacting-GC-for-MRI" class="headerlink" title="Compacting GC for MRI"></a>Compacting GC for MRI</h2><p>網站上的講題不知道是不是當天的講題，因為這次很忙所以我只能在這個時間對口譯所以是完全沒聽到的。</p><blockquote><p>聽說有人在 Offical Party 跟大神許願，所以題目是早上突然改變的⋯⋯</p></blockquote><h2 id="從-Enumerator-看-Ruby-的迭代器"><a href="#從-Enumerator-看-Ruby-的迭代器" class="headerlink" title="從 Enumerator 看 Ruby 的迭代器"></a>從 Enumerator 看 Ruby 的迭代器</h2><p>我的講題，其實當我完成簡報最後的部分（在前一天晚上）我就知道這場大概是要絕望了 XD</p><p>整體上來說有一種 JavaScript 到處亂跳的 Callback 的感覺，所以我很難解釋，又沒有時間讓我思考怎樣畫圖才能動作，所以最後就是台下大家一臉呆滯。</p><p>簡單說就是討論 Enumerator 是怎麼來的，然後 Enumerator::Generator 和 Enumerator::Yielder 為什麼要存在，以及 Enumerator::Lazy 是怎樣應運用跟運作，結束後還好有 <a href="https://medium.com/@c9s" rel="external nofollow noopener noreferrer" target="_blank">c9s</a> 大大提問，雖然只是確認一些細節，但是至少讓我感覺到安慰，畢竟後面這種混亂的狀態還有人能搞懂⋯⋯</p><blockquote><p>總而言之，之後我會想辦法再寫幾篇文章討論這個，然後盡可能的詳細一點。</p></blockquote><h2 id="開拓者們建立鐵道的辛酸血淚史"><a href="#開拓者們建立鐵道的辛酸血淚史" class="headerlink" title="開拓者們建立鐵道的辛酸血淚史"></a>開拓者們建立鐵道的辛酸血淚史</h2><p>這場我沒有很認真聽，不過講者的公司真的是蠻拼的去嘗試這些東西。</p><blockquote><p>其實我覺得 Trailblazer 的問題是他的文件停留在 1.0 版，然後又蠻囉唆的，其實能適用的情況不一定是我們想像那麼美好。但是想法上是很不錯的，很值得學習。</p></blockquote><h2 id="Suit-up-for-frontend-and-backend-development"><a href="#Suit-up-for-frontend-and-backend-development" class="headerlink" title="Suit up for frontend and backend development"></a>Suit up for frontend and backend development</h2><p>大概是一場不用認真聽也知道在講什麼的演講，因為這就是目前我在做的專案辛酸血淚史的統合。雖然演講中沒有提到太多那個專案，不過裡面大部分的經驗跟技巧都是從那個專案學到很多教訓後整理出來的。</p><p>主要就是在討論怎麼拆分 Form / Presenter 等物件，之前才寫一篇的<a href="https://blog.frost.tw/posts/2019/05/28/How-to-use-Form-Object-and-others-for-Rails/">關於 Rails 中的 Form Object / Presenter 這些物件該怎麼用</a>系列文章其實也是在講這個，只是看的角度不太一樣，之後也會繼續的補完這系列。</p><blockquote><p>關於那個很崩潰的專案，給我的感覺是太久沒寫超糟的程式，所以回去反思到底是怎樣變糟的。雖然客戶方面的問題蠻多的，但是也反過來讓我把很多過去難以釐清跟不知道怎麼判斷的東西理解出來，算是把整個架構技能向上提升了一個等級吧 XD</p></blockquote><h2 id="Using-AWS-Lambda-with-Ruby-on-a-large-scale-system"><a href="#Using-AWS-Lambda-with-Ruby-on-a-large-scale-system" class="headerlink" title="Using AWS Lambda with Ruby on a large-scale system"></a>Using AWS Lambda with Ruby on a large-scale system</h2><p>我沒認真聽，大致上就是在想說在 Lambda 上跑 Ruby 的故事。</p><h2 id="What’s-new-in-Rails-6"><a href="#What’s-new-in-Rails-6" class="headerlink" title="What’s new in Rails 6?"></a>What’s new in Rails 6?</h2><p>一樣沒認真聽，雖然原本是想要認真聽一下 Rails 6 有什麼新功能的，不過跟前面那一場差不多都是我心流狀態，已經完全集中在寫 Gem 了 XD</p><h2 id="Virtual-Machines-their-common-parts-and-what-makes-them-special"><a href="#Virtual-Machines-their-common-parts-and-what-makes-them-special" class="headerlink" title="Virtual Machines: their common parts and what makes them special"></a>Virtual Machines: their common parts and what makes them special</h2><p>最後一場，這場我就有比較專注一點在聽。我覺得厲害的地方是能把蠻難搞懂的概念，用很簡單的例子舉出來。不過蠻可惜的是這段知識因為前幾年的 RubyKaigi 有在討論 Register Based VM 應用在 Ruby 上的可能性，所以我算是有去補充了這塊知識，嚴格說起來就是演講的內容剛好都在我懂的範圍內。</p><p>不過有拿 PHP7 改善效能後的設計來跟 Ruby 比較我覺得是很好的，因為我們大多只關注 Ruby 本身，但是也許其他語言有相同的問題需要解決，而且已經找到一個好方案如果沒有去看看的話，可能就浪費時間在某些沒有太大意義的地方上。</p><h2 id="After-Hack-Day"><a href="#After-Hack-Day" class="headerlink" title="After Hack Day"></a>After Hack Day</h2><p>這場活動主要是希望讓台灣的開發者可以多嘗試開發一些東西，或者對 Ruby 相關專案做貢獻。另外就是藉由這次機會，讓大家可以跟國外的開發者做技術上的交流，很多都是在台灣不容易遇到的高手。</p><p>上午主要是自我介紹跟簡單展示一下專案，雖然完全沒有照我跟 <a href="https://medium.com/@st0012" rel="external nofollow noopener noreferrer" target="_blank">Stan</a> 預想的情況進行，不過我覺得因為算是一個非正式活動，大家能交流跟互動是最好的。就結果上來說，我個人認為是還不錯的，大家都有稍微跟身邊的外國人互動、提問。</p><p>因為 RubyConf Taiwan 兩天我都在寫 Gem 但是還沒有測試，所以我今天大部分時間都在把 <a href="https://github.com/elct9620/hahamut" rel="external nofollow noopener noreferrer" target="_blank">Hahamut</a> 這個 Gem 的測試補完，主要是發現如果設計得夠好，其實測試會很容易寫。這大概也驗證了我開始了解測試怎麼寫的時候，認為如果測試發現很難測，那就一定是設計上有問題要改進。</p><p>後面大概四點快五點，我跑去翻 Samuel 寫的 Async Gem 裡面有一個關於 Enumerator 的問題被特別提出來，因為我的主題就是討論 Enumerator 所以就打開來看了一下，但是又沒有跟上討論的點就只好去問本人。</p><p>然後就這樣得到了一個半小時的 Commiter 一對一教學的機會，這個問題是一個在所有 Ruby 版本（1.9 之後有 Fiber）都會有的問題，他又很剛好是我在讀 Enumerator 原始碼的時候被我跳過的部分，簡單說就是 Enumerator 其實是有用 Fiber 的。</p><p>但是，因為 Ruby 目前的 Fiber 機制不夠完善，造成了下面的情況</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">iterate</span><span class="params">(&amp;block)</span></span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  Fiber.<span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">f = Fiber.new <span class="keyword">do</span></span><br><span class="line">  to_enum(<span class="symbol">:iterate</span>).to_a</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">f.resume</span><br></pre></td></tr></table></figure><p>照 Fiber 的邏輯，應該是要 <code>#to_a</code> 得到 <code>[1]</code> 然後 <code>f.resume</code> 得到一個 <code>2</code> 的回傳值，但是因為 <code>to_enum</code> 會產生一個 Fiber 區段，造成 <code>Fiber.yield</code> 實際上是跟 <code>yield 1</code> 的效果一樣，結果就變成 <code>#to_a</code> 得到 <code>[1, 2]</code> 然後 <code>f.resume</code> 是 <code>nil</code> 的狀況。</p><p>後面的討論（應該是單方面聽解說）就是圍繞在這個情境下要怎麼處理，還有 Samuel 的 <a href="https://github.com/ruby/ruby/pull/2002" rel="external nofollow noopener noreferrer" target="_blank">PR</a> 怎麼暫時性的解決，而這個解法其實不算好。就再講到 <code>Fiber.yield</code> 和 <code>#resume</code> 的行為是怎樣實作的，以及目前 Ruby 缺少了怎樣的機制才造成這個問題的發生等等。</p><p>非常有趣，不過我想大概也不是我目前能幫忙解決的 XD</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>整體上來說，經過這幾年參加國外研討會跟在台灣能有跟外國人交流的機會。其實有慢慢體會到 Ruby 社群文化的優點，這大概是相比其他語言社群一個很棒的優點。就是我們是盡量嘗試去跟外國的工程師接觸跟交流的，雖然還是要看個人，不過至少以<a href="https://5xruby.tw" rel="external nofollow noopener noreferrer" target="_blank">五倍紅寶石</a>本身公司文化來說，我們內部員工會盡量做這件事情是好的。</p><p>其實這樣說起來，以前大學參加研討會會嘗試跟講者、外國人交流，也許是從 RubyConf Taiwan 學來的，雖然整體下來我可能花了五六年才能達到完全不怕去跟外國人對話，但是就結果上來說是很棒的。而且能跟參與語言本身開發的工程師討論技術，收穫是遠比自己研究多上非常多的。</p><p>另外就是解釋技術的技巧，外國講者在解釋上我認為都有不少很用心的地方，盡可能讓這些東西能更容易被理解。至少相比之下，我的簡報跟演講大概就沒有這麼好懂了⋯⋯</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2019/07/29/My-experience-after-RubyConf-Taiwan-2019/#disqus_thread</comments>
    </item>
    
    <item>
      <title>巴哈姆特 Chatbot 之亂：用 Ruby on Rails 接收 Webhook</title>
      <link>https://blog.frost.tw/posts/2019/07/26/The-bahamut-chatbot-receiving-the-webhook/</link>
      <guid>https://blog.frost.tw/posts/2019/07/26/The-bahamut-chatbot-receiving-the-webhook/</guid>
      <pubDate>Fri, 26 Jul 2019 06:44:28 GMT</pubDate>
      <description>
      
        &lt;p&gt;六月底的時候發現巴哈姆特似乎想為他們推出的 Messaging APP （哈哈姆特）舉辦一個聊天機器人的比賽，看到之後想說還算蠻有趣的，所以我就跟朋友很隨意的組成一個團隊來開發。&lt;/p&gt;&lt;p&gt;跟大多數我們熟悉串接 Chatbot 的機制是類似的，我們可以用 Webhook 的方式接收一個來自使用者發送的訊息，然後再透過程式處理後回傳訊息給使用者。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>六月底的時候發現巴哈姆特似乎想為他們推出的 Messaging APP （哈哈姆特）舉辦一個聊天機器人的比賽，看到之後想說還算蠻有趣的，所以我就跟朋友很隨意的組成一個團隊來開發。</p><p>跟大多數我們熟悉串接 Chatbot 的機制是類似的，我們可以用 Webhook 的方式接收一個來自使用者發送的訊息，然後再透過程式處理後回傳訊息給使用者。</p><a id="more"></a><h2 id="了解-Webhook-機制"><a href="#了解-Webhook-機制" class="headerlink" title="了解 Webhook 機制"></a>了解 Webhook 機制</h2><p>在程式設計中，我們常常會使用一種叫做「Hook（鉤子）」或者「Callback（回呼）」的機制，用比較好懂的角度去說明，他是一個在「程式執行中插入額外動作」</p><p>舉例來說，我們會有像這樣的程式</p><ul><li>接收訊息</li><li>顯示訊息</li></ul><p>假設我們要增加一個 Hook 就會變成像這樣</p><ul><li>接收訊息</li><li>Hooks （可能有多個）</li><li>顯示訊息</li></ul><p>而 Webhook 就是指這個 Hook 利用 Web（網站）的方式執行，所以當這些 Messaging APP 收到訊息後，會利用 Webhook 做一些事情（像是發送給我們自己的伺服器）然後再繼續動作。</p><h2 id="了解-Signature-機制"><a href="#了解-Signature-機制" class="headerlink" title="了解 Signature 機制"></a>了解 Signature 機制</h2><p>不過當我們收到一段訊息的時候，要怎麼知道這段訊息是來是正確的使用者？</p><p>這就要靠 Signature 機制來幫助我們，透過一個共用的密鑰（Token）來對訊息內容加密，當我們收到訊息的時候只要用同樣的密鑰對訊息加密，就會獲得一段驗證碼，當我們比對驗證碼跟發送者提供給我們相同時，就可以假設這是可信的訊息。</p><blockquote><p>有些網站提供檔案下載時會提供 MD5 校驗碼也是同樣的原理。</p></blockquote><p>以哈哈姆特的 Webhook 為例子，我們會從哈哈姆特收到一個 Webhook 請求，這個請求會包含類似下面的資訊。</p><ul><li>X-BAHA-DATA-SIGNATURE 標頭（Header）</li><li>內容（Ex. 某段訊息）</li></ul><p>巴哈使用的是 SHA1 演算法（MD5 是另外一種），所以我們就要把內容用 SHA1 計算，再比對巴哈給我們的 <code>X-BAHA-DATA-SIGNATURE</code> 來驗證是否是來自巴哈，因為加密的密碼理論上只會有我們自己跟巴哈知道。</p><h2 id="接收請求"><a href="#接收請求" class="headerlink" title="接收請求"></a>接收請求</h2><p>如果你還沒有用過 Ruby on Rails 的話，可以參考<a href="https://kaochenlong.com/" rel="external nofollow noopener noreferrer" target="_blank">龍哥</a>所寫的<a href="https://railsbook.tw/" rel="external nofollow noopener noreferrer" target="_blank">為你自己學 Ruby on Rails</a> 這本書，在網站上看到的部分就足夠你入門。</p><p>首先，我們希望有一個網址（Endpoint）可以接收請求，所以要在 <code>config/routes.rb</code> 定義一個控制器（Controller）來處理。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Rails.application.routes.draw <span class="keyword">do</span></span><br><span class="line"> <span class="comment"># ...</span></span><br><span class="line"> </span><br><span class="line"> post <span class="symbol">:bahamut</span>, <span class="symbol">to:</span> <span class="string">'webhook#bahamut'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>透過 Ruby 的 DSL 特性，我們就可以定義出一個叫做 <code>/bahamut</code> 的位址，用來接收巴哈姆特的 Webhook。然後在上面定義要使用 Webhook 控制器上面的 <code>#bahamut</code> 方法來處理這個位址的動作。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app/controllers/webhook_controller.rb</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebhookController</span> &lt; ActionController::API</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bahamut</span></span></span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> Implement Chatbot Handler</span></span><br><span class="line">    render <span class="symbol">plain:</span> <span class="string">'Hello World'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在這邊我們可能需要下一點指令才能測試，或者你可以使用 <a href="https://www.getpostman.com/" rel="external nofollow noopener noreferrer" target="_blank">Postman</a> 這套軟體來模擬 POST 請求。</p><blockquote><p>POST 請求一般是我們送出表單的操作，所以無法直接用打開網頁的方式開啟。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST http://localhost:3000/bahamut</span><br></pre></td></tr></table></figure><p>然後我們就能看到我們的終端機（Terminal）出現了 <code>Hello World</code> 字樣。</p><p>如果我們希望巴哈能發送訊息到我們自己的本機電腦（localhost）就必須讓我們的電腦能在網路上被找到，這可以利用 <a href="https://ngrok.com/" rel="external nofollow noopener noreferrer" target="_blank">Ngrok</a> 這套軟體達成，透過 Ngrok 我們可以得到一個暫時性的網址，如此一來就能將本機測試的網站被巴哈呼叫到。</p><blockquote><p>我想大家可能有疑問，就是是不是一定要用 Ruby on Rails 才能做到，實際上因為 Ruby on Rails 對初學者來說是最容易搭建出網站的選項，才會選擇使用。不然只要是任何能處理網的程式語言，都是可以直接用來寫 Chatbot 的，只不過像是 Ruby on Rails 這類網站開發框架，能幫我們省下學習這些基礎知識的時間。</p></blockquote><h2 id="驗證-Signature"><a href="#驗證-Signature" class="headerlink" title="驗證 Signature"></a>驗證 Signature</h2><p>因為處理簽章（Signature）的機制比較複雜，在物件導向類型的語言中，我們會設計一個 Class 來專門處理這件事情。</p><p>所以我們來製作一個服務物件（Service Object）叫做 Signature Verifer （簽章驗證器）來專們針對巴哈姆特傳入的簽章做驗證。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app/services/signature_verifer.rb</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SignatureVerifer</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(request)</span></span></span><br><span class="line">    @request = request</span><br><span class="line">    <span class="comment"># 讀取內容</span></span><br><span class="line">    @body = @request.body.read</span><br><span class="line">    <span class="comment"># 讀取 Signature Header</span></span><br><span class="line">    @signature = request.headers[<span class="string">'x-baha-data-signature'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 把內容退回開頭（避免其他人讀取不到資料）</span></span><br><span class="line">    @request.body.rewind</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>第一個步驟我們要設計驗證器的「初始化（Initialize）」階段要做什麼，我們預期會收到一個 HTTP 請求（<code>request</code>）然後將裡面的簽章（<code>x-baha-data-signature</code>）取出來，以及內容（對話訊息）取出來，這是我們在前面提到驗證是否是由巴哈發出的訊息所需要的資訊。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app/services/signature_verifer.rb</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SignatureVerifer</span></span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">  </span><br><span class="line">  private</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">verify_signature</span></span></span><br><span class="line">    @verify_signature <span class="params">||</span>=</span><br><span class="line">      <span class="string">"sha1=<span class="subst">#&#123;OpenSSL::HMAC.hexdigest(<span class="string">'SHA1'</span>, ENV[<span class="string">'BAHA_SECRET'</span>], @body)&#125;</span>"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>這個步驟是根據巴哈的<a href="https://sites.google.com/gamer.com.tw/hahamut-bot/%E6%8E%A5%E6%94%B6webhook%E4%BA%8B%E4%BB%B6?authuser=0" rel="external nofollow noopener noreferrer" target="_blank">文件</a>將剛剛抓到的訊息跟聊天機器人的 Secret（秘鑰）做 SHA1 運算產生出我們自己計算的簽章，如此一來跟巴哈提供的比對，就會知道內容是不是一樣沒有被人偷偷竄改。</p><blockquote><p>要特別注意的是 <code>ENV[&#39;BAHA_SECRET&#39;]</code> 這邊我是使用「環境變數」<code>來儲存密鑰，這樣只有安裝伺服器的人會知道，就可以避面將這類敏感資訊放到程式碼之中。 在 Rails 5 之後，我們可以用</code>rails credentials:edit` 這個指令編輯一個加密的檔案，並把密鑰放到裡面，使用方法可以參考 <a href="https://guides.rubyonrails.org/configuring.html" rel="external nofollow noopener noreferrer" target="_blank">Ruby on Rails 文件</a></p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SignatureVerifer</span></span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">valid?</span></span></span><br><span class="line">      @signature == verify_signature</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  private</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>最後再提供一個 <code>valid?</code> 方法，用來讓我們查詢是否正確就可以了！</p><p>我們修改一下 <code>WebhookController</code> 來做一個簡單的檢查。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebhookController</span> &lt; ActionController::API</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bahamut</span></span></span><br><span class="line">    <span class="keyword">return</span> unathorized_error <span class="keyword">unless</span> valid_signature?</span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> Implement Chatbot Handler</span></span><br><span class="line">    render <span class="symbol">plain:</span> <span class="string">'Hello World'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  private</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">valid_signature?</span></span></span><br><span class="line">    SignatureVerifer.new(request).valid?</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unauthorized_error</span></span></span><br><span class="line">    render <span class="symbol">json:</span> &#123; <span class="symbol">error:</span> <span class="string">'Unauthorized'</span> &#125;, <span class="symbol">status:</span> <span class="symbol">:unauthorized</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>假設我們透過 <code>SignatureVerifer</code> 驗證失敗的話，就回傳一個 JSON 資訊表示未驗證，並且設定 HTTP 的狀態碼為 401（未授權）的狀態。</p><blockquote><p>JSON 是一種資料格式，常常用在不同伺服器溝同時當作交歡資料的格式，我們從巴哈收到的訊息也是 JSON 格式。</p></blockquote><h2 id="發送回應"><a href="#發送回應" class="headerlink" title="發送回應"></a>發送回應</h2><p>既然我們已經可以接收訊息，如果使用者都沒有辦法收到任何回應的話肯定會覺得奇怪，所以下一步就是要能發送訊息給使用者。</p><p>哈哈姆特目前支援文字、圖片、貼圖跟事件幾種類型，其中事件是最容易做的，打好基底後也會變得更容易修改成支援其他類型的發送程式。</p><p>我們先來看一下從巴哈接收到的訊息會是怎樣的格式（JSON）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="attr">"botid"</span>:&lt;BOT_ID&gt;,</span><br><span class="line"> <span class="attr">"time"</span>:<span class="number">1512353744843</span>,</span><br><span class="line"> <span class="attr">"messaging"</span>:[</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="attr">"sender_id"</span>:&lt;SENDER_ID&gt;,</span><br><span class="line">     <span class="attr">"message"</span>:&#123;</span><br><span class="line">       <span class="attr">"text"</span>:<span class="string">"Hello~"</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我們需要關注的只有 <code>messaging</code> 區塊的部分，裡面描述了「多個訊息」而每個訊息都會有「發送者」和「內容」兩個資訊。在上面這從官方文件複製的訊息範例中，使用者發送的內容是一段「文字（text）」</p><p>在 Rails 接收到之後，會自動的做好 JSON 解析的處理，所以我們可以直接像這樣使用。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 照每一個訊息處理</span></span><br><span class="line">params[<span class="string">'messaging'</span>].each <span class="keyword">do</span> <span class="params">|message|</span></span><br><span class="line"> <span class="comment"># 解析訊息跟回覆</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在開始處理之前，我們需要先能夠發送訊息到哈哈姆特。因為步驟也是比較多的，所以我們需要製作一個 Sender （發送器）物件來處理。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'net/http'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># app/services/text_sender.rb</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextSender</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(recipient, message)</span></span></span><br><span class="line">    @receipient = receipient</span><br><span class="line">    @message = message</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>首先我們在初始化階段要把「接收者」跟想要發送出去的「訊息」記錄起來。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'net/http'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># app/services/text_sender.rb</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextSender</span></span></span><br><span class="line">  ENDPOINT = <span class="string">'https://us-central1-hahamut-8888.cloudfunctions.net/'</span> \</span><br><span class="line">             <span class="string">"messagePush?access_token=<span class="subst">#&#123;ENV[<span class="string">'BAHA_TOKEN'</span>]&#125;</span>"</span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">perform</span></span></span><br><span class="line">    <span class="comment"># 發送訊息</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">uri</span></span></span><br><span class="line">    @uri <span class="params">||</span>= URI(ENDPOINT)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">ssl?</span></span></span><br><span class="line">    uri.scheme == <span class="string">'https'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">  private</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">request</span></span></span><br><span class="line">    <span class="comment"># 製作一個 HTTP 請求</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>接下來我們將巴哈文件上所提供的位置，以及一些發送請求需要的一些資訊製作出來。</p><blockquote><p>像是 <code>URI</code> 這類轉換是用於 Ruby 處理發送 HTTP 請求所需要的，所以我們都先做好處理方便使用。而 <code>ENV[&#39;BAHA_TOKEN&#39;]</code> 跟前面的 <code>ENV[&#39;BAHA_SECRET&#39;]</code> 用途是一樣的，都是需要避免直接寫在程式內的數值。</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'net/http'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># app/services/text_sender.rb</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextSender</span></span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">  </span><br><span class="line">  private</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">request</span></span></span><br><span class="line">    <span class="keyword">return</span> @request <span class="keyword">if</span> @request.present?</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 產生一個 HTTP Post 請求</span></span><br><span class="line">    @request = Net::HTTP::Post.new(uri)</span><br><span class="line">    <span class="comment"># 使用 JSON 格式（指定內容類型）</span></span><br><span class="line">    @request[<span class="string">'Content-Type'</span>] = <span class="string">'application/json'</span></span><br><span class="line">    <span class="comment"># 把要傳輸的內容轉換成 JSON 格式的資料</span></span><br><span class="line">    @request.body = body.to_json</span><br><span class="line">    @request</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>因為我們要將訊息發給巴哈，巴哈再將訊息發給指定的使用者。</p><blockquote><p>如果是 LINE 或者 Facebook Messenger 我們想對同一個人發訊息，在不同的 Chatbot 有不同的編號（ID）這樣就可以保護使用者不會被沒有授權的 Chatbot 騷擾，所以不論是發送還是接收，都需要透過巴哈的伺服器。</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'net/http'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># app/services/text_sender.rb</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextSender</span></span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">perform</span></span></span><br><span class="line">    http = Net::HTTP.new(uri.host, uri.port)</span><br><span class="line">    http.use_ssl = ssl?</span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> 處理回應</span></span><br><span class="line">    <span class="comment"># 發送請求給巴哈</span></span><br><span class="line">    http.request(request)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">body</span></span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="symbol">recipient:</span> &#123;</span><br><span class="line">        <span class="symbol">id:</span> @recipient</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="symbol">message:</span> &#123;</span><br><span class="line">        <span class="symbol">text:</span> @message</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  private</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>最後我們只需要將請求的內容（文字訊息）定義好，然後讓他可以發送出去，我們就能對使用者發送回應。</p><blockquote><p>這邊的 <code>recipient</code> 通常會是我們收到的 <code>sender_id</code></p></blockquote><p>我們可以在 Rails Console 裡面像這樣簡單測試是否可以發送訊息</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TextSender.new(<span class="string">'巴哈帳號'</span>, <span class="string">'Hello!'</span>)</span><br></pre></td></tr></table></figure><h2 id="自動回應相同訊息"><a href="#自動回應相同訊息" class="headerlink" title="自動回應相同訊息"></a>自動回應相同訊息</h2><p>我們將前面的程式整合後，可以改寫 <code>WebhookController</code> 讓他可以自動回應跟使用者相同的訊息。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebhookController</span> &lt; ActionController::API</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bahamut</span></span></span><br><span class="line">    <span class="keyword">return</span> unathorized_error <span class="keyword">unless</span> valid_signature?</span><br><span class="line">    </span><br><span class="line">    process_messages</span><br><span class="line">    render <span class="symbol">json:</span> &#123; <span class="symbol">message:</span> <span class="string">'OK'</span> &#125;, <span class="symbol">status:</span> <span class="symbol">:ok</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  private</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">process_messages</span></span></span><br><span class="line">    params[<span class="string">'messaging'</span>].each <span class="keyword">do</span> <span class="params">|message|</span></span><br><span class="line">      TextSender.new(</span><br><span class="line">        message[<span class="string">'sender_id'</span>],</span><br><span class="line">        <span class="string">"PONG: <span class="subst">#&#123;message[<span class="string">'message'</span>][<span class="string">'text'</span>]&#125;</span>"</span></span><br><span class="line">      )</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我們透過將每一條訊息（<code>messaging</code>）取出來，然後將接收者設定為發送者（<code>sender_id</code>）並把訊息內容前面加上 <code>PONG:</code> 用來區別，確保確實是經過我們的 Chatbot 處理後才回應的。</p><blockquote><p>PING/PONG 跟 Hello World 都有點像是一個習慣，通常我們用來測試一個伺服器是否有正常運作，就會透過發送 PING 然後確認伺服器有回應 PONG 來當判斷，如果想換成任何想要的訊息都是沒問題的。</p></blockquote><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>其實這些步驟在大多數情況應該被製作成一個 Gem （Ruby 的套件，可以想像成 Mod 之類的東西）直接使用，不過最近比較忙就沒有時間好好設計並且封裝成 Gem。</p><p>不過這篇文章的概念在處理各種類型的 Chatbot 是很好用的，如果有興趣的話也蠻推薦大家詳細了解一下。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2019/07/26/The-bahamut-chatbot-receiving-the-webhook/#disqus_thread</comments>
    </item>
    
    <item>
      <title>用 CloudFlare Workers 製作簡單的 Uptime Status 頁面</title>
      <link>https://blog.frost.tw/posts/2019/07/09/Build-a-simple-uptime-status-page-use-CloudFlare-Workers/</link>
      <guid>https://blog.frost.tw/posts/2019/07/09/Build-a-simple-uptime-status-page-use-CloudFlare-Workers/</guid>
      <pubDate>Tue, 09 Jul 2019 11:09:08 GMT</pubDate>
      <description>
      
        &lt;p&gt;最近跟朋友弄了一個透過 Chatbot 做出手遊效果的專案，沒出什麼意外的話大概能在九月看到一個雛形。不過既然是手遊類型的遊戲，更新資料跟維護其實就會遇到一些困難點。&lt;/p&gt;&lt;p&gt;如果是線上遊戲或者手遊，大多數只要在公告後把玩家切斷連線然後升級過程中避免玩家連上就好。不過因為是 Chatbot 所以除非能做到不停機升級，不然是很困難的。&lt;br&gt;如此一來，讓玩家知道遊戲（機器人）正在更新，處於無法使用的狀態，就是一個重要的關鍵。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>最近跟朋友弄了一個透過 Chatbot 做出手遊效果的專案，沒出什麼意外的話大概能在九月看到一個雛形。不過既然是手遊類型的遊戲，更新資料跟維護其實就會遇到一些困難點。</p><p>如果是線上遊戲或者手遊，大多數只要在公告後把玩家切斷連線然後升級過程中避免玩家連上就好。不過因為是 Chatbot 所以除非能做到不停機升級，不然是很困難的。<br>如此一來，讓玩家知道遊戲（機器人）正在更新，處於無法使用的狀態，就是一個重要的關鍵。</p><a id="more"></a><p>不過因為算是業餘的作品，玩家數量可能也不會到預期的那樣多。最簡單的方法就是開一個網頁，或者把流量都倒去一個暫時的伺服器就可以。<br>直覺想到的就是利用一些 Uptime Monitor 服務的狀態頁面，不過市面上能選的不多，有些方案即使最簡單的也要 $20/月，其實對小專案來說不太划算。</p><blockquote><p>其實還是有不少服務商能選，不過因為用量可能小到不忍直視就放棄這個念頭。</p></blockquote><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>回來思考我們的需求，其實很簡單：</p><ol><li>伺服器出現任何問題時還能被查詢</li><li>只需要最基本的正常或不正常的狀態呈現</li></ol><p>這種時候其實可以考慮人工用 GitHub Pages 的方式人工更新，不過身為工程師還是會想要偷懶一點，看看有沒有辦法自動化。</p><h2 id="CloudFlare-Workers"><a href="#CloudFlare-Workers" class="headerlink" title="CloudFlare Workers"></a>CloudFlare Workers</h2><p>評估了一下這類 Uptime Mointer 服務，做法都是簡單地去戳某個網站看看是否正常。不過因為只需要知道伺服器是否還在線上，所以直接由伺服器回報狀態其實也是個不錯的方法。<br>考量了像是 AWS Lambda / GCP Cloud Functions / Firebase 等等選項，意外想到 CloudFlare Workers 也許是一個選擇。</p><p>其實大家都很清楚使用雲端服務的花費是相對高的，但是整個服務互相串連整合的方便性就很難是一般虛擬主機服務可以比擬的。</p><p>不過像是簡單的應用情境，用一些簡單的服務反而能在性價比上得到一個不錯的結果。以 CloudFlare Workers 來看，光是基本的服務用量其實就足夠我們使用。<br>但是要保存狀態，所以我們還需要儲存資料的地方，而 CloudFlare Workers KV 也剛好提供了類似 NoSQL 的 Key-Value 儲存機制。</p><p>以花費來看，每個月 $5 美金可以換到 1000 萬次的請求額度，跟至少 10 萬次寫入以作為 Uptime Status 服務來說，基本上要監控上百台機器都沒問題。</p><blockquote><p>不過上百台機器的話，還是乖乖買服務比較實在⋯⋯</p></blockquote><h2 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h2><p>至於實作非常簡單，不過就是剛好因為 CloudFlare 正在改這個服務，所以 UI 有點混亂，要先做好以下的設定。</p><ol><li>付費啟用 CloudFlare Workers Pro 方案</li><li>到任一一個 Domain 下面的 Workers 分頁啟用 KV 功能</li></ol><h3 id="產生-Namespace"><a href="#產生-Namespace" class="headerlink" title="產生 Namespace"></a>產生 Namespace</h3><p>我們可以把 CloudFlare Workers KV 當作是一個超巨大的 Key-Value 儲存庫，而我們要在自己的資料庫下面切出一個區塊來存放特定資料。</p><blockquote><p>正確啟用後不用透過 API 直接在後台手動新增，拿到 Namespace Key 就好，會比打 API 方便很多</p></blockquote><h3 id="上傳資訊"><a href="#上傳資訊" class="headerlink" title="上傳資訊"></a>上傳資訊</h3><p>因為是 Ruby on Rails 專案，所以我簡單的封裝了一個物件讓我的 Rake Task 可以透過呼叫這個物件上傳伺服器的狀態。之後搭配 Whenever 就能以每分鐘的頻率去回報資訊。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Updater</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:hostname</span></span><br><span class="line"></span><br><span class="line">  API = <span class="string">'https://api.cloudflare.com/client/%&lt;version&gt;s/accounts'</span></span><br><span class="line">  ENDPOINT = <span class="string">'/%&lt;account&gt;s/storage/kv/namespaces/%&lt;namespace&gt;s/values/%&lt;node&gt;s'</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></span><br><span class="line">    @node_name = ENV[<span class="string">'NODE_NAME'</span>] <span class="params">||</span> Socket.gethostname</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">update!</span></span></span><br><span class="line">    Net::HTTP.start(uri.host, uri.port, <span class="symbol">use_ssl:</span> ssl?) <span class="keyword">do</span> <span class="params">|http|</span></span><br><span class="line">      http.request request</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">request</span></span></span><br><span class="line">    request = Net::HTTP::Put.new(uri)</span><br><span class="line">    request[<span class="string">'X-Auth-Email'</span>] = ENV[<span class="string">'CF_EMAIL'</span>]</span><br><span class="line">    request[<span class="string">'X-Auth-Key'</span>] = ENV[<span class="string">'CF_TOKEN'</span>]</span><br><span class="line">    request.body = body.to_json</span><br><span class="line">    request</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">ssl?</span></span></span><br><span class="line">    uri.scheme == <span class="string">'https'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">uri</span></span></span><br><span class="line">    @uri <span class="params">||</span>=</span><br><span class="line">      URI(format(<span class="string">"<span class="subst">#&#123;API&#125;</span><span class="subst">#&#123;ENDPOINT&#125;</span>"</span>, options))</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">options</span></span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="symbol">version:</span> <span class="string">'v4'</span>,</span><br><span class="line">      <span class="symbol">account:</span> ENV[<span class="string">'CF_ACCOUNT_ID'</span>],</span><br><span class="line">      <span class="symbol">namespace:</span> ENV[<span class="string">'CF_NAMESPACE_ID'</span>],</span><br><span class="line">      <span class="symbol">node:</span> @node_name</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">body</span></span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="symbol">status:</span> <span class="symbol">:online</span>,</span><br><span class="line">      <span class="symbol">timestamp:</span> Time.now.to_i</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>這段實作只是很簡單的 HTTP Client 而已，最重要的主要是要把 <code>timestamp</code> 上傳上去，我們才能夠過這個時間戳記去推斷最後一次有反應是什麼時候。</p><blockquote><p>理論上關機或者停止這個指令，就不會被更新伺服器狀態上去。不過這實際上還是不太精確的，應該包含像是 CPU 和記憶體的資訊，才能知道伺服器是否過度忙碌而無法提供服務。</p></blockquote><h3 id="回傳資訊"><a href="#回傳資訊" class="headerlink" title="回傳資訊"></a>回傳資訊</h3><p>接下來我們就利用 CloudFlare Workers 來把存進去的資料抓出來呈現，如果有興趣綁定到特定 Domain 之類的，請利用他的 CLI 工具設定好之後，再繼續操作。</p><blockquote><p>主要是目前 KV 功能還無法用 CLI 工具設定，會互相蓋掉（而綁定 Domain / Path 則是都得靠 CLI 工具）</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">addEventListener(<span class="string">'fetch'</span>, event =&gt; &#123;</span><br><span class="line">    event.respondWith(handleRequest(event.request))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Fetch <span class="keyword">and</span> log a request</span><br><span class="line"> * @param &#123;Request&#125; request</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">async function handleRequest(request) &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ Response as JSON</span></span><br><span class="line"><span class="regexp">    let responseInit = &#123;</span></span><br><span class="line"><span class="regexp">        status: 200,</span></span><br><span class="line"><span class="regexp">        headers: &#123;</span></span><br><span class="line"><span class="regexp">            'Content-Type': 'application/json</span>;charset=UTF-<span class="number">8</span><span class="string">'</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // Find all request nodes</span></span><br><span class="line"><span class="string">    let url = new URL(request.url)</span></span><br><span class="line"><span class="string">    let nodes = url.searchParams.getAll('</span>node[]<span class="string">')</span></span><br><span class="line"><span class="string">    let status = await getAllNodeStatus(nodes);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return new Response(JSON.stringify(status), responseInit)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// Read nodes status from KV</span></span><br><span class="line"><span class="string">async function getAllNodeStatus(nodes) &#123;</span></span><br><span class="line"><span class="string">    let status = &#123;&#125;;</span></span><br><span class="line"><span class="string">    await Promise.all(nodes.map(async (node) =&gt; &#123;</span></span><br><span class="line"><span class="string">        var nodeStatus = await Status.get(node, '</span>json<span class="string">');</span></span><br><span class="line"><span class="string">        if (nodeStatus) &#123;</span></span><br><span class="line"><span class="string">            status[node] = nodeStatus</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;));</span></span><br><span class="line"><span class="string">    return status;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>因為會有多個服務，所以我設計了一個很簡單的機制去抓取 GET 請求的 Search Params 然後把抓到的 Hostname （當作 Key 的數值）拿去問 Store 是否有存過 JSON 資訊，然後把它組合成新的 JSON 回傳出來。</p><h3 id="顯示資訊"><a href="#顯示資訊" class="headerlink" title="顯示資訊"></a>顯示資訊</h3><p>接下來就是隨意的做一個頁面，把狀態呈現出來。<br>因為是很前期的東西，所以我先找了一個 Open Source 的佈景，然後用 Jekyll 部署到 GitHub Pages 上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> STATUS_API = <span class="string">'https://status.basaltic.tw/api/status.json'</span>;</span><br><span class="line">  <span class="keyword">var</span> $nodes = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.node'</span>)</span><br><span class="line">  <span class="keyword">var</span> nodes = &#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> uri = <span class="keyword">new</span> URL(STATUS_API)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Load Nodes on Page</span></span><br><span class="line">  $nodes.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hostname = node.dataset.hostname;</span><br><span class="line">    <span class="comment">// Cache DOM</span></span><br><span class="line">    nodes[hostname] = &#123;</span><br><span class="line">      $el: node,</span><br><span class="line">      $color: node.querySelector(<span class="string">'.legend__color'</span>),</span><br><span class="line">      $status: node.querySelector(<span class="string">'.legend__value'</span>),</span><br><span class="line">      hostname: hostname</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// Add for Query</span></span><br><span class="line">    uri.searchParams.append(<span class="string">'node[]'</span>, hostname);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> currentTime = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime() / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Refactor</span></span><br><span class="line">  fetch(uri)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123; <span class="keyword">return</span> res.json() &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">statuses</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> node = &#123;&#125;</span><br><span class="line">      <span class="keyword">var</span> $color = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">var</span> $status = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> hostname <span class="keyword">in</span> statuses) &#123;</span><br><span class="line">        node = statuses[hostname];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( node &amp;&amp; nodes[hostname] ) &#123;</span><br><span class="line">          $color = nodes[hostname][<span class="string">'$color'</span>];</span><br><span class="line">          $status = nodes[hostname][<span class="string">'$status'</span>];</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Online</span></span><br><span class="line">          <span class="keyword">if</span> ((currentTime - node.timestamp) / <span class="number">60</span> &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">            $color.style.cssText = <span class="string">"--color: var(--color-online)"</span>;</span><br><span class="line">            $status.innerText = <span class="string">"Online"</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $color.style.cssText = <span class="string">"--color: var(--color-offline)"</span>;</span><br><span class="line">            $status.innerText = <span class="string">"Offline"</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure><p>主要是這段 JavaScript 我們利用 <code>data-</code> 這類 Data Attribute 去把想顯示的 Hostname 抓取出來，然後統一發一次 API 請求出去查詢。</p><blockquote><p>CloudFlare Workers 有查詢限制 10ms (Free) 50ms (Pro) 但是以 Key-Value Store 來說一次查幾百個大概都沒什麼影響吧⋯⋯</p></blockquote><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>大家想看成果的話可以到 <a href="https://status.basaltic.tw/" rel="external nofollow noopener noreferrer" target="_blank">Basaltic Studio Status</a> 這個頁面看看，這是我以前大學跟朋友做畢業專題的團隊名稱（Basaltic Studio）至於前面的兩段程式碼都放在 <a href="https://gist.github.com/elct9620/fc1c75ac7fb9a447bbd1993e840e8eba" rel="external nofollow noopener noreferrer" target="_blank">Gits</a> 不過直接複製文章的也沒問題就是了。</p><p>前幾天剛好跟同事聊到，不是用技術去解決問題，而是要看問題選對的技術去解決。雖然說起來很簡單，不過對工程師來說大概是很困難的。所以最容易做好的就是有技術就玩，別太糾結在「去解決某個問題」這件事情，而是要去了解技術的性質，在未來碰到問題的時候有「解決問題的方案」</p><p>以這個小東西來說，大部分時候都是沒用的。不過這也讓我了解 CloudFlare Workers 的應用，而且變化起來其實還能做不少事情。像是 Servier Discovery 其實就跟這個機制很像（服務回報自己節點資訊，給其他人查詢）在某些奇怪的應用狀況下，說不定也是個可以應用的方向（不過我猜不會有人會想把這個功能丟在第三方服務上⋯⋯）</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2019/07/09/Build-a-simple-uptime-status-page-use-CloudFlare-Workers/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Ruby 中 Constant 和 Class 的關係</title>
      <link>https://blog.frost.tw/posts/2019/06/18/The-relationship-between-constant-and-class-in-ruby/</link>
      <guid>https://blog.frost.tw/posts/2019/06/18/The-relationship-between-constant-and-class-in-ruby/</guid>
      <pubDate>Tue, 18 Jun 2019 11:13:17 GMT</pubDate>
      <description>
      
        &lt;p&gt;下班前&lt;a href=&quot;https://kaochenlong.com/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;龍哥&lt;/a&gt;說在 Mailing List 看到了一段 Code 很有趣。&lt;/p&gt;&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;a = Class.new&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p a        &lt;span class=&quot;comment&quot;&gt;#=&amp;gt; #&amp;lt;Class:0x0000558d34f68b48&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p a.name   &lt;span class=&quot;comment&quot;&gt;#=&amp;gt; nil&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;B = a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p a.name   &lt;span class=&quot;comment&quot;&gt;#=&amp;gt; &#39;B&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;C = a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p C.name   &lt;span class=&quot;comment&quot;&gt;#=&amp;gt; &#39;B&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;裡面 &lt;code&gt;C = a&lt;/code&gt; 到底發生了什麼事情，是很值得討論的，因為有了線索是 &lt;code&gt;rb_const_set&lt;/code&gt; 可以找到原因，所以就利用下班時間來讀看看這段。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;關於前面的用法可以參考之前寫過的&lt;a href=&quot;https://blog.frost.tw/posts/2017/10/22/The-ruby-s-class-is-free-Part-1/&quot;&gt;自由的 Ruby 類別&lt;/a&gt;來了解原因。&lt;/p&gt;&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>下班前<a href="https://kaochenlong.com/" rel="external nofollow noopener noreferrer" target="_blank">龍哥</a>說在 Mailing List 看到了一段 Code 很有趣。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = Class.new</span><br><span class="line"></span><br><span class="line">p a        <span class="comment">#=&gt; #&lt;Class:0x0000558d34f68b48&gt;</span></span><br><span class="line">p a.name   <span class="comment">#=&gt; nil</span></span><br><span class="line"></span><br><span class="line">B = a</span><br><span class="line">p a.name   <span class="comment">#=&gt; 'B'</span></span><br><span class="line"></span><br><span class="line">C = a</span><br><span class="line">p C.name   <span class="comment">#=&gt; 'B'</span></span><br></pre></td></tr></table></figure><p>裡面 <code>C = a</code> 到底發生了什麼事情，是很值得討論的，因為有了線索是 <code>rb_const_set</code> 可以找到原因，所以就利用下班時間來讀看看這段。</p><blockquote><p>關於前面的用法可以參考之前寫過的<a href="https://blog.frost.tw/posts/2017/10/22/The-ruby-s-class-is-free-Part-1/">自由的 Ruby 類別</a>來了解原因。</p></blockquote><a id="more"></a><p>我大致上翻了一下 Ruby 的原始碼，這段程式主要是定義在 <code>variable.c</code> 這個檔案，在 Ruby 裡面我們可以簡單把 Constant（常數）理解為一種特殊的變數，跟一些語言在使用了 <code>const</code> 關鍵字後無法更改的概念上是不太一樣。</p><h2 id="常數如何被賦值"><a href="#常數如何被賦值" class="headerlink" title="常數如何被賦值"></a>常數如何被賦值</h2><p>因為 <code>rb_const_set</code> 接受了一些參數我們不好理解，所以先看看是由誰來呼叫他。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">rb_define_const(VALUE klass, <span class="keyword">const</span> <span class="keyword">char</span> *name, VALUE val)</span><br><span class="line">&#123;</span><br><span class="line">    ID id = rb_intern(name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!rb_is_const_id(id)) &#123;</span><br><span class="line">true      rb_warn(<span class="string">"rb_define_const: invalid name `%s' for constant"</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">    rb_const_set(klass, id, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">rb_define_global_const(<span class="keyword">const</span> <span class="keyword">char</span> *name, VALUE val)</span><br><span class="line">&#123;</span><br><span class="line">    rb_define_const(rb_cObject, name, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Ruby 裡面我們要定義一個常數 <code>A = x</code> 是透過 <code>rb_define_const</code> 來實現的，如果是 Global 的話，就會直接定義在 <code>Object</code> 下面，而我們提供給 <code>rb_const_set</code> 的三個參數裡面 <code>ID</code> 這個數值可以先來看一下 <code>rb_intern</code> 的用法。</p><p>現在我們在 Ruby 裡面會經常使用 <code>:name</code> 這樣的寫法，表示他是一種 Symbol 而在 Ruby 裡面的實作，都會透過 <code>rb_intern</code> 這個方法來從 <code>char*</code> 轉換過去，基本上我們可以理解 Ruby 所有物件、常數的命名，都會被統一記錄起來，方便之後重複使用。</p><p>不過這邊有趣的地方其實是他會檢查這個 <code>ID</code> 類型，往下追之後會看到像這樣的檢查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> is_const_id(id) (id_type(id)==ID_CONST)</span></span><br></pre></td></tr></table></figure><blockquote><p>不過關於這段稍微追了下發現又是一個有點長的過程，這邊簡單解釋就是在定義 Symbol 的時候 Ruby 會依照這個 Symbol 的特性去區分出他的類型，像是 <code>$</code> 開頭會標記成 Golbal Variable 這樣的感覺</p></blockquote><h2 id="常數賦值的過程"><a href="#常數賦值的過程" class="headerlink" title="常數賦值的過程"></a>常數賦值的過程</h2><p>接下來我們就可以往 <code>rb_const_set</code> 深入來看，因為整體是相對長的，我們就針對需要的部份重點式的閱讀。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rb_const_entry_t</span> *ce;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_id_table</span> *<span class="title">tbl</span> = <span class="title">RCLASS_CONST_TBL</span>(<span class="title">klass</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (NIL_P(klass)) &#123;</span><br><span class="line"> rb_raise(rb_eTypeError, <span class="string">"no class/module to define constant %"</span>PRIsVALUE<span class="string">""</span>, QUOTE_ID(id));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check_before_mod_set(klass, id, val, <span class="string">"constant"</span>);</span><br><span class="line"><span class="keyword">if</span> (!tbl) &#123;</span><br><span class="line">  <span class="comment">// PART1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// PART2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一階段 Ruby 會先去看看這個 Class 裡面是不是已經初始化過紀錄下面所屬的常數的一個表格，如果沒有的話就初始化一個出來。已經存在的話則是做 Autoload 動作，如果有讀取到對應的常數，那就會跳出錯誤警告，沒有的話就跟前面產生表的行為一樣，把這個常數插入進去。</p><p>看起來常數的賦值應該就這樣結束了，不過為了處理一些特殊情況，所以往下會看到一段註解。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Resolve and cache class name immediately to resolve ambiguity</span></span><br><span class="line"><span class="comment"> * and avoid order-dependency on const_tbl</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>這就是我們這次要討論的問題來源，要觸發這個處理依照原始碼的實作要滿足某些條件才行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rb_cObject &amp;&amp; (RB_TYPE_P(val, T_MODULE) || RB_TYPE_P(val, T_CLASS))) &#123;</span><br></pre></td></tr></table></figure><ol><li><code>Object</code> 是有被定義的（正常情況下都應該是被定義的）</li><li>賦予的數值必須是 Module 或者 Class</li></ol><p>接下來要再滿足另一個條件，就是通過 <code>rb_class_path_cached</code> 的檢查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (NIL_P(rb_class_path_cached(val))) &#123;</span><br></pre></td></tr></table></figure><p>因為裡面的實作也有點多，所以這邊直接去找了一下<a href="https://docs.ruby-lang.org/ja/latest/function/rb_class_path.html" rel="external nofollow noopener noreferrer" target="_blank">文件</a>關於 <code>rb_class_path</code> 的用途，然後再去看 <code>rb_class_path_cached</code> 的這段實作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">VALUE</span><br><span class="line">rb_class_path_cached(VALUE klass)</span><br><span class="line">&#123;</span><br><span class="line">    st_table *ivtbl;</span><br><span class="line">    <span class="keyword">st_data_t</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!RCLASS_EXT(klass)) <span class="keyword">return</span> Qnil;</span><br><span class="line">    <span class="keyword">if</span> (!(ivtbl = RCLASS_IV_TBL(klass))) <span class="keyword">return</span> Qnil;</span><br><span class="line">    <span class="keyword">if</span> (st_lookup(ivtbl, (<span class="keyword">st_data_t</span>)classpath, &amp;n)) <span class="keyword">return</span> (VALUE)n;</span><br><span class="line">    <span class="keyword">if</span> (st_lookup(ivtbl, (<span class="keyword">st_data_t</span>)tmp_classpath, &amp;n)) <span class="keyword">return</span> (VALUE)n;</span><br><span class="line">    <span class="keyword">return</span> Qnil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致上我們可以理解成每個有名字的 Class 或 Module 都會被記錄起來，所以這邊要找的條件是「匿名的 Class 或是 Module」都符合條件後，就會做下面的動作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (klass == rb_cObject) &#123;</span><br><span class="line"> rb_ivar_set(val, classpath, rb_id2str(id));</span><br><span class="line"> rb_name_class(val, id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">VALUE path;</span><br><span class="line">ID pathid;</span><br><span class="line"><span class="keyword">st_data_t</span> n;</span><br><span class="line">st_table *ivtbl = RCLASS_IV_TBL(klass);</span><br><span class="line"><span class="keyword">if</span> (ivtbl &amp;&amp;</span><br><span class="line">    (st_lookup(ivtbl, (<span class="keyword">st_data_t</span>)(pathid = classpath), &amp;n) ||</span><br><span class="line">     st_lookup(ivtbl, (<span class="keyword">st_data_t</span>)(pathid = tmp_classpath), &amp;n))) &#123;</span><br><span class="line">    path = rb_str_dup((VALUE)n);</span><br><span class="line">    rb_str_append(rb_str_cat2(path, <span class="string">"::"</span>), rb_id2str(id));</span><br><span class="line">    OBJ_FREEZE(path);</span><br><span class="line">    rb_ivar_set(val, pathid, path);</span><br><span class="line">    rb_name_class(val, id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假設這個常數是定義在 <code>Object</code>（全域）的情況，那麼就直接對他做兩件事情：</p><ol><li>設定 <code>classpath</code> （就是前面的暫存檢查）</li><li>對這個匿名的 Class 或 Module 設定名字為當下的常數</li></ol><p>如果是定義在某個 Class 或 Module 下面的話，因為 <code>classpath</code> 就不會是剛好的，所以要先算過（產生） <code>classpath</code> 然後再做一樣的事情。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>找完之後我們就可以解釋為什麼文章一開始的 <code>C = a</code> 再去問 <code>C.name</code> 會得到 <code>B</code> 這個結果了，主要是因為已經被命名過的 Class 會在記憶體中製作一個類似捷徑的東西，讓下次去呼叫這個 Class 或 Module 可以更快。</p><p>而給這個 Class 或 Module 物件命名的時機點，就在於它被記錄到捷徑的時機，所以即使再次賦予給其他常數，也不會改變他的名字。</p><blockquote><p>這樣我們可以延伸出來的問題是 <code>C = a</code> 的情況下，因為 <code>classpath</code> 是 Cache 在 <code>B</code> 上面，這時候使用 <code>C</code> 是不是會比 <code>B</code> 更慢呢？而匿名的 Class 和 Module 會不會對效能有所影響。</p></blockquote>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2019/06/18/The-relationship-between-constant-and-class-in-ruby/#disqus_thread</comments>
    </item>
    
    <item>
      <title>關於 Rails 中的 Form Object / Presenter 這些物件該怎麼用（一）</title>
      <link>https://blog.frost.tw/posts/2019/05/28/How-to-use-Form-Object-and-others-for-Rails/</link>
      <guid>https://blog.frost.tw/posts/2019/05/28/How-to-use-Form-Object-and-others-for-Rails/</guid>
      <pubDate>Tue, 28 May 2019 15:54:08 GMT</pubDate>
      <description>
      
        &lt;p&gt;前陣子在 Review 新專案中同事的程式碼時，發現同事對像是 Service Object / Form Object 這類物件不太有概念。不過這個新專案因為是接手其他公司的專案，所以有不少地方要微調。至少那個值得吐槽的「因為 Controller 程式碼太長不知道放哪裡，就都丟去 Service Object 好了！」的神奇用法，完全沒有幫助改善程式碼。&lt;/p&gt;&lt;p&gt;也因為這個機會，我用了一點時間跟專案的同事分享了一下我對這些物件的看法。畢竟當出我也是搞不太懂，不過隨著了解物件導向和 Ruby 的語言特性，從這些角度切入後，就比較能理解該怎麼使用。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>前陣子在 Review 新專案中同事的程式碼時，發現同事對像是 Service Object / Form Object 這類物件不太有概念。不過這個新專案因為是接手其他公司的專案，所以有不少地方要微調。至少那個值得吐槽的「因為 Controller 程式碼太長不知道放哪裡，就都丟去 Service Object 好了！」的神奇用法，完全沒有幫助改善程式碼。</p><p>也因為這個機會，我用了一點時間跟專案的同事分享了一下我對這些物件的看法。畢竟當出我也是搞不太懂，不過隨著了解物件導向和 Ruby 的語言特性，從這些角度切入後，就比較能理解該怎麼使用。</p><a id="more"></a><p>我想，在能夠應用 Rails 開發網站後，撇除 Controller / Model 之外，要在加入其他的物件類型，就很難去「區分」該如何使用了！所以，我們應該要先來看「物件向語言」之所以要製作成物件的理由。</p><h2 id="物件導向"><a href="#物件導向" class="headerlink" title="物件導向"></a>物件導向</h2><p>剛開始，我們寫程式就是直接把想要做的事情描述出來，類似這樣</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">puts <span class="string">'[INFO] Server started'</span></span><br></pre></td></tr></table></figure><p>不過隨著行為重複的使用，每次都要複製同樣的程式碼，我們通常會包裝成一個「方法」</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(level, message)</span></span></span><br><span class="line">  puts <span class="string">"[<span class="subst">#&#123;level.upcase&#125;</span>] <span class="subst">#&#123;message&#125;</span>"</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>隨著這些行為變得複雜，我們可能會有一些希望共用的情境跟邏輯，那就會製作成一個「物件」</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(output)</span></span></span><br><span class="line">    @output = output</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">info</span><span class="params">(message)</span></span></span><br><span class="line">    log(<span class="string">'info'</span>, message)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(level, message)</span></span></span><br><span class="line">    @output.write <span class="string">"[<span class="subst">#&#123;level.upcase&#125;</span>] <span class="subst">#&#123;message&#125;</span>"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我們依照這個脈絡來看，其實我們都是在做「輸出紀錄」的功能，只是輸出記錄這件事情有越來越多行為，所以我們一步一步的把它封裝起來。</p><blockquote><p>其實這也是重構的基本思考方式，我們該如何將散落的「相似程式」整理歸納，變成一個統一的行為跟功能。</p></blockquote><p>有了這樣的概念，我們再去看隨著學習 Rails （或是任何框架）不斷出現的新物件類型，就能夠抓到這樣應用的理由。</p><h2 id="Form-Object"><a href="#Form-Object" class="headerlink" title="Form Object"></a>Form Object</h2><p>一開始我要講的是 Form Object，通常是用來處理不同畫面上不同輸入的需求。依照前面的脈絡，物件導向語言的設計大多遵從 <a href="https://zh.wikipedia.org/wiki/SOLID_(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1)" rel="external nofollow noopener noreferrer" target="_blank">SOLID</a> 的原則，不過我們先關注 S（單一功能）這件事情就好了。</p><p>既然叫做 Form Object 也就表示 Form Object 著重在處理使用者填寫表單的輸入，一開始你可能會覺得直接放到 Model 不就好了嗎？</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@post = Post.new(post_params)</span><br><span class="line"><span class="keyword">return</span> redirect_to posts_path <span class="keyword">if</span> @post.save</span><br><span class="line"></span><br><span class="line">render <span class="symbol">:new</span></span><br></pre></td></tr></table></figure><p>大多數時候我們都會這樣寫，不過這建立在的前提就是每次輸入的欄位都相同，假設新增跟編輯可以輸入的欄位有所不同，要怎麼控制？</p><blockquote><p>也許你會想到可以用 Validator 的 <code>on</code> 選定要在 <code>#update</code> 還是 <code>#create</code> 處理，這確實是一個方法，但是如果要判定的基準相對複雜，就不一定這麼方便。</p></blockquote><p>所以我們就會用 Form Object 來輔助。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostUpdateForm</span></span></span><br><span class="line">  <span class="keyword">include</span> ActiveModel::Model</span><br><span class="line">  </span><br><span class="line">  validate <span class="symbol">:content</span>, <span class="symbol">presence:</span> <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">save</span></span></span><br><span class="line">    @post = Post.find(@id)</span><br><span class="line">    </span><br><span class="line">    attrs = attributes.dup</span><br><span class="line">    attrs.delete(<span class="symbol">:id</span>)</span><br><span class="line">    @post.update(attrs)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@form = PostUpdateForm.new(create_params)</span><br><span class="line"><span class="keyword">return</span> render <span class="symbol">:new</span> <span class="keyword">unless</span> @form.valid?</span><br><span class="line"></span><br><span class="line">@form.save</span><br></pre></td></tr></table></figure><p>至少像這樣，我們就可以視情況單獨對某個表單做處理，而且 Model 就從要處理資料的角色，變成單純處理從資料庫進行讀寫以及建立資料關聯的角色。</p><p>至少在某種意義上，Model 的工作更簡單、更單純。</p><h2 id="Context-Object"><a href="#Context-Object" class="headerlink" title="Context Object"></a>Context Object</h2><p>搭配 Form Object 來講一下在我目前負責的其中一個專案，我們拿來處理「查詢資料」的物件類型。如果是在 PHP 中的 Laravel 的話，類似的物件應該會叫做 Repository。</p><p>不過，為什麼會需要 Context Object 呢？在一些比較複雜的系統，我們要處理的查詢條件是非常繁複的，一般的專案可能像是這樣就可以解決。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@posts = Post.where(<span class="symbol">category:</span> <span class="string">'Ruby'</span>)</span><br></pre></td></tr></table></figure><p>不過如果是一些大的系統，要的查詢條件可能會是跨兩三個資料表同時做 JOIN 查詢，再篩選出結果這樣可能就得變成像這樣有大量的判斷。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@posts = Post.all</span><br><span class="line">@posts = @posts.where(<span class="symbol">category:</span> @categories) <span class="keyword">if</span> @categories</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>一方面是看起來不這麼好看，另一方面是可能需要先去從其他資料表篩選出一些資訊才能夠查詢，都塞進去的話 Controller 大概就爆炸了！</p><p>所以我們就會像這樣做改寫</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostContext</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(params)</span></span></span><br><span class="line">    @params = params</span><br><span class="line">    @relation = Post</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">perform</span></span></span><br><span class="line">    scope_by_categories</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    @relation</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">scope_by_categories</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> @params[<span class="symbol">:categories</span>].blank?</span><br><span class="line">    </span><br><span class="line">    categories = Category.where(<span class="symbol">name:</span> @params[<span class="symbol">:categories</span>])</span><br><span class="line">    @relation = @relation.where(<span class="symbol">category:</span> caregories)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如此一來搭配查詢的時候就會像這樣應用</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@context = PostContext.new(params)</span><br><span class="line">@posts = @context.perform</span><br></pre></td></tr></table></figure><p>那麼我們就可以將不同的查詢條件處理實作在 Context 裡面，就不需要在 Controller 裡面實作了！（有點類似 Ransack 的感覺）</p><blockquote><p>有些人會把這類問題都用 Service Object 解決，其實最近處理專案的經驗看起來，如果分不出來該怎麼做，通常就會被當作 Service Object 去做，但是如果類似的邏輯已經很多了，那麼獨立出來成一類有統一行為的物件會是更好的。</p></blockquote><p>不過即使這樣實作，我們還是會遇到兩類問題：</p><ol><li><code>params</code> 的參數不是 Context 想要的</li><li>查詢條件太過複雜</li></ol><p>我們先討論第一點，假設我們只希望使用者查詢一年內的資料，要怎麼限制呢？其實這時候 Form Object 就會再度出場，畢竟他的職責就是處理「使用者的輸入」</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostSearchForm</span></span></span><br><span class="line">  <span class="comment"># 其實這行應該放在 BaseForm</span></span><br><span class="line">  <span class="keyword">include</span> ActiveModel::Model</span><br><span class="line">  </span><br><span class="line">  validate <span class="symbol">:search_ranges</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">search_ranges</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (@end_at - @start_at).to_i.abs &gt; <span class="number">365</span></span><br><span class="line">    </span><br><span class="line">    errors.add(<span class="symbol">:end_at</span>, I18n.t(<span class="string">'.invalid_search_ranges'</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如此一來，我們就可以像這樣使用</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@form = PostSearchForm.new(params)</span><br><span class="line"><span class="keyword">return</span> render <span class="symbol">:index</span> <span class="keyword">unless</span> @form.valid?</span><br><span class="line"></span><br><span class="line">@context = PostContext.new(@form)</span><br><span class="line">@posts = @context.perform</span><br></pre></td></tr></table></figure><p>看起來就會精簡很多，不過 Context 似乎出錯了，因為 Form Object 並沒有 <code>@form[:categories]</code> 這樣行為可以使用，要怎麼解決呢？</p><p>對 Ruby 來說，其實不外乎就是 Duck Typing 的問題，而其他語言來看，其實就是物件有沒有相同的 Interface 而已，我們只需要對 Form Object 做擴充即可。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Form</span></span></span><br><span class="line"> <span class="class"><span class="keyword">module</span> <span class="title">HasHashAccessor</span></span></span><br><span class="line">   extend ActiveSupport::Concern</span><br><span class="line">   </span><br><span class="line">   included <span class="keyword">do</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">[]</span><span class="params">(attribute)</span></span></span><br><span class="line">       instance_variable_get(<span class="string">"@<span class="subst">#&#123;attribute&#125;</span>"</span>)</span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostSearchForm</span></span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">  <span class="keyword">include</span> Form::HasHashAccessor</span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如此一來，就可以用非常漂亮的方式讓 Form / Context / Model 三種物件串連起來一起運作，並且都只處理一種類型的行為。</p><blockquote><p><code>HasHashAccessor</code> 的命名方式是我從之前一個日本客戶的專案學來的，他可以很直觀的告訴我們這個物件上擴充了什麼行為，對 Ruby 語言特性來說會是個比 <code>HashAccessor</code> 這樣單純的命名更加容易理解。</p></blockquote><p>大家可能會疑惑為什麼要在這個時候用 Module 呢？一方面是剛剛有提到，這是一個通用的 Interface 對 Context 來說，拿到的是 Form Object 或者 Params 其實都沒有關係，只要可以用 <code>[]</code> 方法存取他要用來查詢的參數就好了。</p><p>但是 <code>ActionController::Parameters</code> 物件其實不能滿足我們驗證查詢或者預處理之類的行為，那麼交給 Form Object 來做看起來是更恰當的，那麼要滿足 Context 的使用條件，提供他 <code>[]</code> 行為就是合理的，而且這個行為應該只提供給 SearchForm 而非所有的 Form Object。</p><blockquote><p>簡單說對 Ruby 來說就是 Duck Typing 只在意有沒有 <code>[]</code> 方法，其他語言可能就是有沒有實作 <code>[]</code> 行為了！</p></blockquote><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>在我目前的專案其實還有像是 Transformer、Calculator 等等各種類型物件的變化，不過如果每一種都討論的話大概是一篇文章無法討論完全的。</p><p>下一篇就來討論跟呈現資料有關係的 Presenter 和 Decorator 這兩個物件，還有 Context 還可以怎樣做拆分。</p><blockquote><p>要注意的是，不管他是哪類型的物件，其實想要使用都可以使用。只不過這些物件都是在過去經驗總結中，經常會重複使用所以分類出來的物件。照這樣的邏輯來看，只有 Service Object 通常會有 PhotoUploadService 和 PhotoUploader 兩種方式來命名，後者會用這樣的命名邏輯，也許就是當這類物件增加之後，直接分出一類會是更加適合的。</p></blockquote>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2019/05/28/How-to-use-Form-Object-and-others-for-Rails/#disqus_thread</comments>
    </item>
    
    <item>
      <title>利用 Ruby 的 Lambda 做條件判斷</title>
      <link>https://blog.frost.tw/posts/2019/05/20/Use-Ruby-s-Lambda-as-case-when-condition/</link>
      <guid>https://blog.frost.tw/posts/2019/05/20/Use-Ruby-s-Lambda-as-case-when-condition/</guid>
      <pubDate>Mon, 20 May 2019 13:59:53 GMT</pubDate>
      <description>
      
        &lt;p&gt;週末在思考一些 Ruby 特性可以應用的小技巧時，想到龍哥大概跟我講了三次以上的一個特性。&lt;/p&gt;&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;fn = -&amp;gt;(other) &amp;#123; other == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fn == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# =&amp;gt; false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fn === &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# =&amp;gt; true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;剛好最近工作的專案上有個問題，似乎挺適合用這個技巧。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>週末在思考一些 Ruby 特性可以應用的小技巧時，想到龍哥大概跟我講了三次以上的一個特性。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn = -&gt;(other) &#123; other == <span class="number">1</span> &#125;</span><br><span class="line">fn == <span class="number">1</span></span><br><span class="line"><span class="comment"># =&gt; false</span></span><br><span class="line">fn === <span class="number">1</span></span><br><span class="line"><span class="comment"># =&gt; true</span></span><br></pre></td></tr></table></figure><p>剛好最近工作的專案上有個問題，似乎挺適合用這個技巧。</p><a id="more"></a><h2 id="Proc-物件的-方法"><a href="#Proc-物件的-方法" class="headerlink" title="Proc 物件的 === 方法"></a>Proc 物件的 === 方法</h2><p>我們在 Proc 的原始碼可以看到，<code>Proc</code> 類別被特別定義了 <code>#===</code> 方法，但不包括了 <code>#==</code> 方法，而這個 <code>#===</code> 方法又剛好指定成呼叫方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rb_add_method(rb_cProc, rb_intern(<span class="string">"==="</span>), VM_METHOD_TYPE_OPTIMIZED,</span><br><span class="line">truetrue  (<span class="keyword">void</span> *)OPTIMIZED_METHOD_TYPE_CALL, METHOD_VISI_PUBLIC);</span><br></pre></td></tr></table></figure><p>同樣還有像是 <code>#[]</code> 也有類似的性質，簡單說就是 <code>#call</code> 方法的別名。這個使用方式也可以在 <a href="https://ruby-doc.org/core-2.6.2/Proc.html#method-i-3D-3D-3D" rel="external nofollow noopener noreferrer" target="_blank">Ruby Doc</a> 上找到。<br>因為這樣的特性，剛好有些情境就是不錯的應用情況。</p><h2 id="Excel-的產生難題"><a href="#Excel-的產生難題" class="headerlink" title="Excel 的產生難題"></a>Excel 的產生難題</h2><p>最近花了不少時間在幫客戶處理 Excel 報表的生成功能，中間就發現了一個問題，因為客戶的報表有很多種（十幾種）而且需要的欄位又不太一樣，每種都寫一次程式的話其實是很沒有效率的（而且未來還希望能自訂報表的呈現）所以用設定檔方式設計是最適合的，不過產生的 Excel 檔案卻無法指定格式（Ex. 文字、日期）尤其是「日期」客戶每張報表的要求又不太一樣，這讓生成就變成一個難題。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">KPI</span> <span class="string">Report</span></span><br><span class="line"><span class="attr">  columns:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">user_id</span></span><br><span class="line"><span class="attr">      display:</span> <span class="string">User</span> <span class="string">ID</span></span><br><span class="line"><span class="attr">      format:</span> <span class="string">:integer</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">signup_at</span></span><br><span class="line"><span class="attr">      display:</span> <span class="string">Signup</span> <span class="string">At</span></span><br><span class="line"><span class="attr">      format:</span> <span class="string">:datetime</span></span><br><span class="line"><span class="attr">      datetime:</span> <span class="string">:customize</span></span><br><span class="line"><span class="attr">      excel_format:</span> <span class="string">'[$-409]yyyy-MM-dd;@'</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">last_active_at</span></span><br><span class="line"><span class="attr">      display:</span> <span class="string">Last</span> <span class="string">Active</span> <span class="string">At</span></span><br><span class="line"><span class="attr">      format:</span> <span class="string">:datetime</span></span><br><span class="line"><span class="attr">      datetime:</span> <span class="string">:split</span></span><br></pre></td></tr></table></figure><p>以上面這個 YAML 設定檔為例子，客戶可能會希望顯示 <code>yyyy-MM-dd</code> 或者 <code>yyyy-MM-dd</code> + <code>HH:mm</code> 之類的格式，所以在判斷 Excel 要提供怎樣的欄位的時候，就變得相對的複雜。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">formats</span></span></span><br><span class="line">  @columns.map <span class="keyword">do</span> <span class="params">|column|</span></span><br><span class="line">    <span class="keyword">next</span> <span class="keyword">unless</span> column[<span class="symbol">:format</span>] == <span class="symbol">:datetime</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> column[<span class="symbol">:datetime</span>]</span><br><span class="line">    <span class="keyword">when</span> <span class="symbol">:split</span> <span class="keyword">then</span> [@date_format, @time_format]</span><br><span class="line">    <span class="keyword">when</span> <span class="symbol">:customize</span> <span class="keyword">then</span> format(column[<span class="symbol">:excel_format</span>])</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      @date_format</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span>.flatten</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>雖然上面的情況看起來還算單純，不過最後再加入其他不同類型的欄位判斷後，可能就會越來越複雜跟難以辨識。</p><p>在這個狀況下，利用 <code>Proc</code> 的 <code>#===</code> 特性就可能會是一個不錯的作法。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">is_datetime = -&gt;(c) &#123; c[<span class="symbol">:format</span>] == <span class="symbol">:datetime</span> &#125;</span><br><span class="line">is_split_datetime = -&gt;(c) &#123; c[<span class="symbol">:format</span>] == <span class="symbol">:datetime</span> &amp;&amp; c[<span class="symbol">:datetime</span>] == <span class="symbol">:split</span> &#125;</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> column</span><br><span class="line"><span class="keyword">when</span> is_split_datetime <span class="keyword">then</span> [@date_format, @time_format]</span><br><span class="line"><span class="keyword">when</span> is_datetime <span class="keyword">then</span> @date_format</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>不過這實際上並無法解決有很多複雜情況的時候，不過既然我們已經知道了 <code>#===</code> 在 <code>case ... when</code> 上可以發揮作用，那麼是否可以進一步封裝呢？</p><h2 id="自訂物件"><a href="#自訂物件" class="headerlink" title="自訂物件"></a>自訂物件</h2><p>假設我們有個可以把設定檔轉成 <code>ExcelColumn</code> 物件的設計，也許可以像這樣實作。</p><p>先定義 <code>ExcelColumn</code> 物件，而且可以被做 <code>Pattern Matching</code>（簡易版）然後在提供回傳對應的格式跟數值的機制。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExcelColumn</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(format = <span class="literal">nil</span>, **pattern, &amp;block)</span></span></span><br><span class="line">    @name = name</span><br><span class="line">    @format = format</span><br><span class="line">    @pattern = pattern</span><br><span class="line">    @value_of = block</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">===</span><span class="params">(other)</span></span></span><br><span class="line">    @pattern.reduce(<span class="literal">true</span>) <span class="keyword">do</span> <span class="params">|prev, (key, value)|</span></span><br><span class="line">      prev &amp; (other[key] == value)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">format</span></span></span><br><span class="line">    <span class="keyword">return</span> @format <span class="keyword">if</span> @format.<span class="literal">nil</span>? <span class="params">||</span> @format.is_a?(Symbol)</span><br><span class="line">    </span><br><span class="line">    format(@format) <span class="comment"># Customize Format</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">value</span><span class="params">(name, row)</span></span></span><br><span class="line">    <span class="keyword">return</span> row.send(name) <span class="keyword">if</span> @value_of.<span class="literal">nil</span>?</span><br><span class="line">    </span><br><span class="line">    @value_of.call(name, row)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>然後再設計 DSL 讓我們可以定義需要的格式。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExcelGenerator</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> &lt;&lt; self</span></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:patterns</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pattern</span><span class="params">(format, **pattern, &amp;block)</span></span></span><br><span class="line">      @patterns <span class="params">||</span>= []</span><br><span class="line">      @patterns &lt;&lt; ExcelColumn.new(name, format, pattern, &amp;block)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">columns</span></span></span><br><span class="line">    @columns <span class="params">||</span>=</span><br><span class="line">      @config.columns.map <span class="keyword">do</span> <span class="params">|column|</span></span><br><span class="line">        [</span><br><span class="line">         column,</span><br><span class="line">         <span class="keyword">self</span>.patterns.find &#123; <span class="params">|pattern|</span> pattern === column &#125; <span class="params">||</span> ExcelColumn.new</span><br><span class="line">        ]</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>接下來就可以在實際使用時，像這樣去拓展 Excel 產生器，然後定義我們所需要的報表格式生成。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExcelReportGnerator</span> &lt; ExcelGenerator</span></span><br><span class="line">  pattern format(<span class="symbol">:date</span>), <span class="symbol">datetime:</span> <span class="symbol">:date</span> <span class="keyword">do</span> <span class="params">|name, row|</span></span><br><span class="line">    row.send(name)&amp;.to_datetime</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如此一來就能夠利用 DSL 跟 <code>#===</code> 的特性，針對我們需要有特殊格式的欄位挑選出來，然後給予特定的規則來產生對應的 Excel Cell 設定。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">insert_header(headers)</span><br><span class="line"></span><br><span class="line">formats = columns.map(&amp;<span class="symbol">:last</span>).map(&amp;<span class="symbol">:format</span>)</span><br><span class="line">rows.each <span class="keyword">do</span> <span class="params">|row|</span></span><br><span class="line">  items = columns.map &#123; <span class="params">|column, pattern|</span> pattern.value_of(column[<span class="symbol">:name</span>], row) &#125;</span><br><span class="line">  insert_row(items, <span class="symbol">formats:</span> formats)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>最後實作的版本其實還是一個構想，畢竟這樣的情境是不常使用到的，不過在某些時候似乎又是個非常有用的小技巧。而這樣的構想是否適合這樣使用，以及能不能有更好的改進（例如一開始就直接定義好對應的欄位類型物件，而不要像這樣動態的定義）都還要再討論。</p><p>不過在 Ruby 中確實有不少有趣的應用技巧，多多挖掘的話其實能在不少不同的應用情況下用足夠簡單的方式實現，而不是繞一大圈去做。</p><p>更重要的是，這些技巧往往會是在時間緊迫下的輔助，有些功能透過這些技巧就可以很快地實現，而將時間投資在其他地方，而不是只能用一些折衷的方案暫時做好，之後再回來慢慢修改。</p><blockquote><p>這是最近做專案的心得，因為客戶是新成立的部門很需要有一個實績，所以開發上難免偏向以開發進度為主。很多其實花時間思考後能做更好的部分，就這樣變成技術債了⋯⋯</p></blockquote>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2019/05/20/Use-Ruby-s-Lambda-as-case-when-condition/#disqus_thread</comments>
    </item>
    
    <item>
      <title>如何在沒有任何設定下產生 Rails 的 Docker Image</title>
      <link>https://blog.frost.tw/posts/2019/03/20/The-zero-configure-dockerfile-for-rails/</link>
      <guid>https://blog.frost.tw/posts/2019/03/20/The-zero-configure-dockerfile-for-rails/</guid>
      <pubDate>Wed, 20 Mar 2019 15:37:22 GMT</pubDate>
      <description>
      
        &lt;p&gt;前陣子看到 &lt;a href=&quot;https://thoughtbot.com/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Throughbot&lt;/a&gt; 這間在 Ruby 圈 算是蠻有名的公司做了一個叫做 &lt;a href=&quot;https://github.com/thoughtbot/suspenders&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Suspenders&lt;/a&gt; 的 Gem 主要是對 Rails 擴充，簡單說就是基於原本的 &lt;code&gt;rails new&lt;/code&gt; 做了一個替代品，而這個替代品會自動幫你先做好一些原本要手動做的事情。&lt;/p&gt;&lt;p&gt;像是安裝好常用的 Gem、套版之類的，想了一下覺得&lt;a href=&quot;https://5xruby.tw&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;五倍&lt;/a&gt;其實也很需要，不少新專案也都是從我這邊經手初始化的，有一個這樣的工具會省下不少時間。&lt;/p&gt;&lt;p&gt;所以 &lt;a href=&quot;https://github.com/5xRuby/bankai&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Bankai&lt;/a&gt; （卍解） 這個 Gem 就樣做出來了，裡面基本上就是設置好在五倍大多數時候用的標配 Ex. GitLab CI 設定、RSpec 等等&lt;/p&gt;&lt;p&gt;但是又發現好像不太夠用，有些時候有 Docker 會方便很多，但是 Bankai 現在做不到！&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>前陣子看到 <a href="https://thoughtbot.com/" rel="external nofollow noopener noreferrer" target="_blank">Throughbot</a> 這間在 Ruby 圈 算是蠻有名的公司做了一個叫做 <a href="https://github.com/thoughtbot/suspenders" rel="external nofollow noopener noreferrer" target="_blank">Suspenders</a> 的 Gem 主要是對 Rails 擴充，簡單說就是基於原本的 <code>rails new</code> 做了一個替代品，而這個替代品會自動幫你先做好一些原本要手動做的事情。</p><p>像是安裝好常用的 Gem、套版之類的，想了一下覺得<a href="https://5xruby.tw" rel="external nofollow noopener noreferrer" target="_blank">五倍</a>其實也很需要，不少新專案也都是從我這邊經手初始化的，有一個這樣的工具會省下不少時間。</p><p>所以 <a href="https://github.com/5xRuby/bankai" rel="external nofollow noopener noreferrer" target="_blank">Bankai</a> （卍解） 這個 Gem 就樣做出來了，裡面基本上就是設置好在五倍大多數時候用的標配 Ex. GitLab CI 設定、RSpec 等等</p><p>但是又發現好像不太夠用，有些時候有 Docker 會方便很多，但是 Bankai 現在做不到！</p><a id="more"></a><p>所以 Bankai Docker 這個外掛就這樣在一週左右完成原型的製作，作為 Bankai 的額外擴充被支援了！</p><h2 id="特色"><a href="#特色" class="headerlink" title="特色"></a>特色</h2><p>Bankai Docker 目前功能還很陽春，不過對於大多數情況應該都是夠用的。</p><p>產生的 Docker Image 大小會落在 180MB 上下，主要是因為 Ruby + Node.js 約 80MB 剩下的則是安裝的 Gem 所佔用的，以一個 Docker Image 來說不算輕量，但也在可以接受的範圍內。</p><p>主要的特色是<strong>不用任何設定</strong>，也就是說在安裝好 Bankai Docker 後，直接執行 <code>rake docker:build</code> 你的專案就會自動被打包好，而且馬上可以使用。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>目前還在考慮是否要能獨立運作，不過預設是相依 Bankai 的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安裝 Bankai</span></span><br><span class="line">gem install bankai</span><br><span class="line"></span><br><span class="line"><span class="comment"># 開啟新專案</span></span><br><span class="line">bankai dockerize</span><br></pre></td></tr></table></figure><p>這樣就能產生一個全新的 Rails 專案（五倍版）目前還沒有支援 <code>rails g bankai:docker</code> 的選項，所以先手動把 <code>bankai-docker</code> 加入到 Gemfile 裡面。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">group <span class="symbol">:development</span> <span class="keyword">do</span></span><br><span class="line"> <span class="comment"># ... 略</span></span><br><span class="line"> gem <span class="string">'bankai'</span></span><br><span class="line"> gem <span class="string">'bankai-docker'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>接下來跑一下 <code>bundle install</code> 就安裝完畢了！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安裝 Bankai Docker 到專案中</span></span><br><span class="line">bundle install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包 Docker Image</span></span><br><span class="line">rake docker:build</span><br></pre></td></tr></table></figure><p>好像什麼事情都沒做就產生 Docker Image 對吧？我想要的就是這種感覺！！</p><h2 id="DSL"><a href="#DSL" class="headerlink" title="DSL"></a>DSL</h2><p>自動化的設定總是會有限制，所以在設計的時候已經預先想好可以透過 <code>config/docker.rb</code> 這個設定檔來寫 DSL 用來修改原本的行為。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rails g bankai:docker:install</span><br></pre></td></tr></table></figure><p>這個指令可能會替換掉，跑完之後會把原本放在 Gem 裡面的 <code>docker.rb</code> 放到 <code>config/docker.rb</code> 裡面，然後我們就可以安心的來修改了！</p><p>像是預設的 Docker Image 會是 <code>$(whoami)/APP_NAME</code> 以剛剛的範例就會是 <code>elct9620/dockerize</code> 一般情況可能沒什麼問題，但是如果像我想要用五倍內部的 Registry 伺服器，這個命名就不適合了！</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bankai::Docker.setup <span class="keyword">do</span></span><br><span class="line">  name <span class="string">'registry.5xruby.tw/elct9620/dockerize'</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 略</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>簡單來說，要在預設的 DSL 設定裡面補上這個 <code>name</code> 設定，就可以修改預設的 Docker Image 名稱，大致上就是這樣使用的。</p><p>因為新版本的 Docker 多了叫做 Multi Stage 的機制，所以我們可以把 <code>bundle install</code> 的步驟放到一個單獨的 <code>stage</code> 編譯好後再複製到主體，這樣就可以省下很多空間（因為不用安裝額外的套件）</p><p>所以 DSL 的結構就會像這樣：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Bankai::Docker.setup <span class="keyword">do</span></span><br><span class="line">  stage <span class="symbol">:gem</span> <span class="keyword">do</span></span><br><span class="line">   <span class="comment"># ...</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">  </span><br><span class="line">  main <span class="keyword">do</span></span><br><span class="line">   <span class="comment"># ...</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在 Stage 中就可以使用對應 Docker 原本有的指令，像是 <code>RUN bundle install</code> 會對應成 <code>run &#39;bundle install</code> 目前大多數都支援，還有少部分之後會慢慢補齊。</p><p>如此一來，我們就可以很簡單的去修改原本 Docker 建置的過程。</p><blockquote><p>目前還不支援預設值，後續的改版會簡化為如果不修改 gem / node / main 三個預設設定，就不用寫出來去覆蓋。</p></blockquote><h2 id="Auto-Package"><a href="#Auto-Package" class="headerlink" title="Auto Package"></a>Auto Package</h2><p>有一些 Gem 會需要先安裝好一些套件才能使用，像是 <code>pg</code> 和 <code>mysql2</code> 這兩個大家常用的資料庫套件，為了可以無視這些設定，所以透過「工人智慧」我們可以用 DSL 去定義偵測條件，自動的安裝套件。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Bankai::Docker.setup <span class="keyword">do</span></span><br><span class="line">  detect_package <span class="symbol">:database</span>, <span class="symbol">:gem</span> <span class="keyword">do</span> <span class="params">|package|</span></span><br><span class="line">    <span class="keyword">if</span> pg?</span><br><span class="line">      package.add_dependency <span class="string">'postgresql-dev'</span>, <span class="symbol">runtime:</span> <span class="literal">false</span></span><br><span class="line">      package.add_runtime_dependency <span class="string">'postgresql-libs'</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> mysql?</span><br><span class="line">      package.add_dependency <span class="string">'mariadb-dev'</span>, <span class="symbol">runtime:</span> <span class="literal">false</span></span><br><span class="line">      package.add_runtime_dependency <span class="string">'mariadb-client-libs'</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>像是上面這樣，我們可以在 <code>gem</code> 這個階段增加 <code>postgresql-dev</code> 套件，而實際執行的時候只使用 <code>postgresql-libs</code> 如此一來就可以盡可能的縮小最後產出的檔案大小。</p><blockquote><p>上面是節錄自 <a href="https://github.com/5xRuby/bankai-docker/blob/master/templates/auto_package.rb" rel="external nofollow noopener noreferrer" target="_blank">templates/auto_package.rb</a> 這個檔案，如果有一些常用的套件需要增加，可以送 PR 給我們。</p></blockquote><h2 id="COPY-FROM"><a href="#COPY-FROM" class="headerlink" title="COPY FROM"></a>COPY FROM</h2><p>另外一個比較困擾的是 <code>COPY --from=gem</code> 這指令，如果要手動下在 <code>main</code> 的話其實有點麻煩，所以就提供了 <code>produce</code> 這個 DSL 來輔助。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stage <span class="symbol">:node</span>, <span class="symbol">from:</span> <span class="string">'node:10.15.2-alpine'</span> <span class="keyword">do</span></span><br><span class="line">  run <span class="string">'mv /opt/yarn-v$&#123;YARN_VERSION&#125; /opt/yarn'</span></span><br><span class="line"></span><br><span class="line">  produce <span class="string">'/usr/local/bin/node'</span></span><br><span class="line">  produce <span class="string">'/opt/yarn'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>像是這邊我們處理好 Node.js 之後，要讓最後產出能有 <code>/usr/local/bin/node</code> 這個檔案和 <code>/opt/yarn</code> 目錄，我們就可以用 <code>produce</code> 告訴 Bankai Docker 要在最後產出時自動給這樣指令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY --from=node /usr/local/bin/node /usr/local/bin/node</span><br><span class="line">COPY --from=node /opt/yarn /opt/yarn</span><br></pre></td></tr></table></figure><p>如此一來就省事很多，在處理 Docker Image 生成的不少小細節都已經先在 Bankai Docker 做掉（像是 <code>.dockerignore</code> 的設定等等）使用起來就比自己寫 Dockerfile 快上非常多。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>以前常想「資深工程師」有哪些特質，其中一個我認為有的特質就是能製作「順手」的工具，畢竟當你有自己的一套方法現有的預設做法或者一些設定，就不一定符合需求。雖然能製作自己使用的工具不代表有資深工程師的實力，不過開始有這樣的需求時，應該就是走在這條路上了吧！</p><p>當這個 Gem 成型之後，其實後面還有更厲害的組合應用還沒完成，下次有機會的話會再跟大家分享怎麼用這樣的特性做 DevOps 來改善開發流程。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2019/03/20/The-zero-configure-dockerfile-for-rails/#disqus_thread</comments>
    </item>
    
    <item>
      <title>我在 Ruby 埋了一個陷阱 - Signal 的應用</title>
      <link>https://blog.frost.tw/posts/2019/03/12/I-make-a-trap-in-the-Ruby-the-usage-of-Signal/</link>
      <guid>https://blog.frost.tw/posts/2019/03/12/I-make-a-trap-in-the-Ruby-the-usage-of-Signal/</guid>
      <pubDate>Tue, 12 Mar 2019 13:29:15 GMT</pubDate>
      <description>
      
        &lt;p&gt;在 Ruby 之中，其實隱藏了很多非常實用的標準函式庫，而 Signal 就是其中一個。&lt;/p&gt;&lt;p&gt;我們在寫 Ruby 大多數時候都是 Ruby on Rails 框架的應用，但是你們有想過當我們在一些 Gem 運行的時候，使用 Ctrl + C 為什麼不會出現錯誤嗎？&lt;/p&gt;&lt;p&gt;例如我們常常用到的 &lt;code&gt;irb&lt;/code&gt; 和 &lt;code&gt;pry&lt;/code&gt; 為什麼按下 Ctrl + C 的時候不是直接中斷，卻還能繼續運作？&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>在 Ruby 之中，其實隱藏了很多非常實用的標準函式庫，而 Signal 就是其中一個。</p><p>我們在寫 Ruby 大多數時候都是 Ruby on Rails 框架的應用，但是你們有想過當我們在一些 Gem 運行的時候，使用 Ctrl + C 為什麼不會出現錯誤嗎？</p><p>例如我們常常用到的 <code>irb</code> 和 <code>pry</code> 為什麼按下 Ctrl + C 的時候不是直接中斷，卻還能繼續運作？</p><a id="more"></a><h2 id="常駐程式"><a href="#常駐程式" class="headerlink" title="常駐程式"></a>常駐程式</h2><p>一般來說我們很少會用 Ruby 寫一個常駐程式（Daemon）不過有時候我們希望持續的抓資料或者監聽一個 Socket 的時候，還是會需要用到類似下面這樣的實作。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">loop <span class="keyword">do</span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>當我們跑起來之後，用 Ctrl + C 去中斷的話，就會出現類似下面的錯誤訊息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">        2: from loop.rb:3:in `&lt;main&gt;&apos;</span><br><span class="line">        1: from loop.rb:3:in `loop&apos;</span><br><span class="line">loop.rb:5:in `block in &lt;main&gt;&apos;: Interrupt</span><br></pre></td></tr></table></figure><p>這是因為我們的程式在未預期的狀況下被「中斷（Interrupt）」的關係。</p><h2 id="Signal"><a href="#Signal" class="headerlink" title="Signal"></a>Signal</h2><p>在很多 Unix 作業系統中，我們可以對任一一個執行中的程式（Process）發送一個 Signal 來告訴這個程式該做什麼。</p><p>也因此，我們可以從<a href="https://zh.wikipedia.org/wiki/Unix%E4%BF%A1%E5%8F%B7" rel="external nofollow noopener noreferrer" target="_blank">維基百科</a>的解說其實可以了解到，平常我們很習慣的 Ctrl + C 其實就是發送訊號的動作，而這個訊號剛好就是 SIGINT （中斷訊號）</p><p>另一方面，我們的程式卡住又無法關閉的時候，也會使用 <code>kill</code> 指令來強致終止程式，其實也是對程式發送訊號的一種形式。</p><p>像是我想要終止 PID 1000 的程式，可以像這樣下指令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -int 1000</span><br></pre></td></tr></table></figure><p>如此一來就可以發送一個 SIGINT 給 PID 1000 的程式。</p><p>由此可見，有很多我們平常在使用的東西都有支援接收訊號，例如 Nginx 的<a href="https://nginx.org/en/docs/control.html" rel="external nofollow noopener noreferrer" target="_blank">文件</a>就有說明哪些訊號可以做哪些事情。</p><p>像是 <code>SIGHUP</code> 可以讓 Nginx 重新讀取設定檔，也就是 <code>nginx -s reload</code> 的指令（雖然大多數時候我們可能都會直接重開 Nginx 吧⋯⋯）</p><p>有了這些概念後，我們就可以用 Ruby 提供的 Signal 來做一些應用。</p><h2 id="Graceful-Shutdown"><a href="#Graceful-Shutdown" class="headerlink" title="Graceful Shutdown"></a>Graceful Shutdown</h2><p>當我們在執行一個迴圈處理事情的時候，如果遇到中斷的情況，很有可能會沒有把事情做完。</p><p>例如我們嘗試插入三筆資料到資料庫，到第二筆的時候就被中斷，那麼就會損失第三筆資料，而且下次重新執行的時候就會有錯誤的結果。</p><blockquote><p>這個情況實務上應該是要善用資料庫的 Transaction （交易）功能，來確保該做的事情都完成後一起 Commit （確認）</p></blockquote><p>所以，要避免一些「不應該直接被中斷」的情況，我們就可以善用 <code>Signal.trap</code> 這個方法。</p><p>稍微改良一下文章一開始的無限迴圈，變成像這樣：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">running = <span class="literal">true</span></span><br><span class="line">Signal.trap(<span class="symbol">:INT</span>) &#123; running = <span class="literal">false</span> &#125;</span><br><span class="line"></span><br><span class="line">loop <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">break</span> <span class="keyword">unless</span> running</span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>按下 Ctrl + C 就不會有任何錯誤，因為對 Ruby 來說他還是確實的執行完畢一個迴圈才停止，而不是跑到一半就被直接中斷。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>這算是一個超級冷知識吧，不過大多數的程式語言其實都有提供這樣的機制。而且這個功能其實也很好用，例如我們可以做一個 Ctrl + C 兩次才離開的功能。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">try_exit = <span class="number">0</span></span><br><span class="line">Signal.trap(<span class="symbol">:INT</span>) <span class="keyword">do</span></span><br><span class="line">  try_exit += <span class="number">1</span></span><br><span class="line">  puts <span class="string">"Are you sure exit? Press Ctrl + C Again"</span> <span class="keyword">if</span> try_exit == <span class="number">1</span></span><br><span class="line">  running = <span class="literal">true</span> <span class="keyword">if</span> try_exit == <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">loop <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">break</span> <span class="keyword">if</span> try_exit == <span class="number">2</span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如此一來，我們就可以有效的避免程式意外中斷。</p><blockquote><p>剩下要擔心的大概就是停電或者被強制中開機的狀況了吧⋯⋯</p></blockquote><p>另外 Ruby 還有一個叫做 <code>at_exit</code> 的方法，之後機會可以來和 Signal 比較一下使用情境上的差異。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2019/03/12/I-make-a-trap-in-the-Ruby-the-usage-of-Signal/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Rails 串接 ProxmoxVE API 自動化教學用虛擬機分配</title>
      <link>https://blog.frost.tw/posts/2019/02/19/Automatic-VM-allocate-using-Proxmox-VE-and-Rails/</link>
      <guid>https://blog.frost.tw/posts/2019/02/19/Automatic-VM-allocate-using-Proxmox-VE-and-Rails/</guid>
      <pubDate>Tue, 19 Feb 2019 11:41:59 GMT</pubDate>
      <description>
      
        &lt;p&gt;之前有一段時間因為用 KVM 手動管理&lt;a href=&quot;https://5xruby.tw&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;五倍&lt;/a&gt;的虛擬機花上不少時間，評估之後我們就調整成 ProxmoxVE 來管理，至少在大多數的情況有 GUI 是很方便的。&lt;/p&gt;&lt;p&gt;不過使用的權限還是限制在有權限管理機器的人身上，最近剛好有不少新同事加入，想讓他們練習部署伺服器。&lt;/p&gt;&lt;p&gt;所以就有了這樣的問題：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;可以讓同事自己申請虛擬機來練習嗎？&lt;/strong&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>之前有一段時間因為用 KVM 手動管理<a href="https://5xruby.tw" rel="external nofollow noopener noreferrer" target="_blank">五倍</a>的虛擬機花上不少時間，評估之後我們就調整成 ProxmoxVE 來管理，至少在大多數的情況有 GUI 是很方便的。</p><p>不過使用的權限還是限制在有權限管理機器的人身上，最近剛好有不少新同事加入，想讓他們練習部署伺服器。</p><p>所以就有了這樣的問題：</p><p><strong>可以讓同事自己申請虛擬機來練習嗎？</strong></p><a id="more"></a><p>其實算是很簡單的，只要會最基本的 Ruby 就能夠把這些東西串起來。不過因為有一些非同步操作，所以我們會需要把一些「觀念」放下，才可以在快速打造原型的時候用最簡單的方式呈現。</p><p>開始之前先看一下週末大概一天多的快速原型長怎樣</p><p><img src="https://blog.frost.tw/images/2019-02-19-automatic-vm-allocate-using-proxmox-ve-and-rails/B1C5927BAA75A6CBB07D220E20B5E687.png" alt="螢幕快照 2019-02-18 上午12.34.25.png"></p><blockquote><p>ProxmoxVE 的 Rollback 機制似乎連選項都會 Rollback 所以正在跑那台又被改回去原本設定的名字了⋯⋯</p></blockquote><p><img src="https://blog.frost.tw/images/2019-02-19-automatic-vm-allocate-using-proxmox-ve-and-rails/6A5F3F8546357A6AC62C7EB32DC5033D.png" alt="螢幕快照 2019-02-18 上午12.34.37.png"></p><h2 id="ProxmoxVE-的-Ticket-機制"><a href="#ProxmoxVE-的-Ticket-機制" class="headerlink" title="ProxmoxVE 的 Ticket 機制"></a>ProxmoxVE 的 Ticket 機制</h2><p>我們以往在串接 API 時會很習慣用 API Token 之類的呼叫 API 但是 ProxmoxVE 用了一個有點微妙的方式，就是提供了一個「可以得到 Cookie 的 API」讓我們來生成叫做 Ticket 的東西。</p><p>簡單說我們要用 Ticket API 用帳號密碼登入，然後拿到一段 Cookie 的數值在需要登入的 API 時一起送過去。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'net/http'</span></span><br><span class="line">rquire <span class="string">'oj'</span></span><br><span class="line"></span><br><span class="line">uri = URI(<span class="string">'https://192.168.100.220:8006/api2/json/access/ticket'</span>)</span><br><span class="line">req = Net::HTTP::Post.new</span><br><span class="line">req[<span class="string">'Content-Type'</span>] = <span class="string">'application/x-www-form-urlencoded'</span></span><br><span class="line">req.body = URI.encode_www_form(<span class="symbol">username:</span> <span class="string">'xxx@pve'</span>, <span class="symbol">password:</span> <span class="string">'xxx'</span>)</span><br><span class="line"></span><br><span class="line">token = &#123;&#125;</span><br><span class="line">Net::HTTP.start(uri.host, uri.port, <span class="symbol">use_ssl:</span> <span class="literal">true</span>) <span class="keyword">do</span> <span class="params">|http|</span></span><br><span class="line">  res = http.request(req)</span><br><span class="line"></span><br><span class="line">  token = Oj.load(res.body)&amp;.fetch(<span class="string">'data'</span>, &#123;&#125;)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">puts token[<span class="string">'ticket'</span>] <span class="comment"># =&gt; XXXX</span></span><br><span class="line">puts token[<span class="string">'CSRFPreventionToken'</span>] <span class="comment"># =&gt; XXX</span></span><br></pre></td></tr></table></figure><p>大致上使用方式就是，如果是 GET 請求只要在 Cookie 中帶有回傳的 Ticket 數值即可，如果是 POST 請求的話，還要額外在 Header 加上 CSRFPreventionToken 才行。</p><blockquote><p>這邊有幾點要注意跟可以善用：</p><ol><li>如果你的 ProxmoxVE 跟我們一樣是在內網，你需要讓 Ruby 的 Net::HTTP 不要見證 SSL</li><li>ProxmoxVE 有提供 ACL 的機制，所以我先針對可以用的機器開了專用的群組分配了足夠的權限，避免影響其他人</li></ol></blockquote><h2 id="呼叫其他-API"><a href="#呼叫其他-API" class="headerlink" title="呼叫其他 API"></a>呼叫其他 API</h2><p>可以順利取得 Token 後，就可以參考<a href="https://pve.proxmox.com/pve-docs/api-viewer/index.html" rel="external nofollow noopener noreferrer" target="_blank">官方的文件</a>來實作各類的 API 雖然有點說明不清楚，但是透過幾次嘗試多少還是堪用的。</p><p>為了要可以正常的呼叫，我們需要對 Request 補上 Cookie 資訊：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 略</span></span><br><span class="line"></span><br><span class="line">req = Net::HTTP::Get.new(uri)</span><br><span class="line">req[<span class="string">'Cookie'</span>] = <span class="string">"PVEAuthCookie=<span class="subst">#&#123;token[<span class="string">'ticket'</span>]&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 略</span></span><br></pre></td></tr></table></figure><p>其實很簡單，在 HTTP 請求裡面 <code>Cookie</code> Header 表示的是用戶已知的 Cookie 資訊，用來傳給伺服器。而收到回應時 <code>Set-Cookie</code> 則是要求用戶更新 Cookie 資訊。</p><p>掌握好之後，在寫一些網路爬蟲的時候，就能很簡單的做到模擬登入的效果。</p><p>如果是要發送 POST 類型的請求，則是在補上 CSRF 對應的 Header 即可</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 略</span></span><br><span class="line"></span><br><span class="line">req = Net::HTTP::Post.new(uri)</span><br><span class="line">req[<span class="string">'Cookie'</span>] = <span class="string">"PVEAuthCookie=<span class="subst">#&#123;token[<span class="string">'ticket'</span>]&#125;</span>"</span></span><br><span class="line">req[<span class="string">'CSRFPreventionToken'</span>] = token[<span class="string">'CSRFPreventionToken'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 略</span></span><br></pre></td></tr></table></figure><p>礙於篇幅的關係，在這之前我已經簡單封裝好了一個叫做 <code>Proxmox::API</code> 來管理 API 請求，以及幾個「假 Model」來封裝成對應的行為，像是上一段提到的 Ticket 變成像這樣</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxmox::API.ticket = Proxmox::Ticket.create(<span class="string">'user@pve'</span>, <span class="string">'password'</span>)</span><br></pre></td></tr></table></figure><p>後面的文章會直接用這個封裝過的行為來示範，如果想知道細節的話我們可以在其他文章中再做討論。</p><h2 id="非同步行為"><a href="#非同步行為" class="headerlink" title="非同步行為"></a>非同步行為</h2><p>不過，像是虛擬機的開關機其實都是非同步的行為。</p><p>也就是說，像是我做了這樣的呼叫：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Proxmox::API.post(<span class="string">'nodes/pve/100/status/start'</span>)</span><br><span class="line">            .fetch(<span class="symbol">:data</span>)</span><br><span class="line"><span class="comment"># =&gt; UPID:pve:00001560:3C9C598C:5C6944F7:qmstart:100:user<span class="doctag">@pve</span>:</span></span><br></pre></td></tr></table></figure><blockquote><p>裡面的 <code>pve</code> 是節點的名稱，而 <code>100</code> 是虛擬機的編號</p></blockquote><p>會得到一個叫做 UPID 的回傳，而這個回傳數值是表示在 ProxmoxVE 中的某個 Task （任務）我們可以透過兩種 API 來查詢：</p><ol><li><code>cluster/tasks</code></li><li><code>nodes/{node}/tasks/{upid}/status</code></li></ol><p>要注意的是第一種只會得到大概，而且最近（一段時間後會被刪掉）的任務資訊，而第二個需要知道確切的 Node 和 UPID 才能夠拿到。</p><p>也就是說，我們想知道「開機」有沒有執行完成，需要做像這樣的設計</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(node, upid)</span></span></span><br><span class="line">  Proxmox::API.get(<span class="string">"nodes/<span class="subst">#&#123;node&#125;</span>/tasks/<span class="subst">#&#123;upid&#125;</span>/status"</span>)</span><br><span class="line">              .dig(<span class="symbol">:data</span>, <span class="symbol">:status</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">upid = start(<span class="string">'pve'</span>, <span class="string">'100'</span>) <span class="comment"># 開機</span></span><br><span class="line">loop <span class="keyword">do</span></span><br><span class="line">  status = task(<span class="string">'pve'</span>, upid)</span><br><span class="line">  <span class="keyword">break</span> <span class="keyword">if</span> status[<span class="string">'exitstatus'</span>] == <span class="string">'OK'</span></span><br><span class="line">  sleep <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 開機完成</span></span><br></pre></td></tr></table></figure><p>不過這會遇到一個問題，就是「如果錯誤或者沒有結果」那麼我們的程式就會被卡在無限迴圈之中，這樣在 Rails 端就會有一個 HTTP 請求被卡住。</p><p>這時候我們可以利用 Ruby 的 <code>Timeout</code> 機制</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'timeout'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 略</span></span><br><span class="line">Timeout::timeout(<span class="number">30</span>) <span class="keyword">do</span></span><br><span class="line"> loop <span class="keyword">do</span></span><br><span class="line">   <span class="comment"># 略</span></span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># 略</span></span><br></pre></td></tr></table></figure><p>如此一來，假設執行超過 30 秒，就會因為收到 <code>Timeout::Error</code> 的超時錯誤，強制終止這段程式。</p><blockquote><p>超時之後可以再對機器下過像是 <code>stop</code> 之類的指令關機，避免佔用資源</p></blockquote><h2 id="自動還原"><a href="#自動還原" class="headerlink" title="自動還原"></a>自動還原</h2><p>ProxmoxVE 裡面提供了 Backup 和 Snapshot 兩種備份方式，不過 API 只有 Snapshot 可以選用。</p><p>要注意的是在製作 Snapshot 之前除了機器要安裝好之外，也要記得將像是 Options 裡面的各項設定都調整好，不然我們會因為在 Rollback 的過程中，讓設定跑回原本的舊設定。</p><p>Snapshot 還原的 API 會是像這樣：<code>nodes/{node}/qemu/{vmid}/snapshot/{name}/rollback</code></p><p>因為我們是練習用的虛擬機，所以直接在設定好的環境下，製作一個叫做 <code>initialize_state</code> 的 Snapshot 統一還原回去就可以了！</p><blockquote><p>或者你會想要做更複雜的管理，不過對我們來說這樣就是堪用的。</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">upid = Proxmox::API.post(<span class="string">'nodes/pve/qemu/100/snapshot/initialize_state/rollback'</span>)</span><br><span class="line"><span class="comment"># 等待完成</span></span><br></pre></td></tr></table></figure><p>做 Snapshot 的 Rollback 是非同步的（要先關機再把資料寫回去）所以會比開機之類的還要等稍微久一點，不過用跟上一段提到的 <code>Timeout</code> 機制就可以做到在還原會繼續動作的設計。</p><h2 id="自動安裝-SSH-Key"><a href="#自動安裝-SSH-Key" class="headerlink" title="自動安裝 SSH Key"></a>自動安裝 SSH Key</h2><p>另外一個難題是裝好的機器其實誰都 SSH 不進去，對我們來說 VNC 串接似乎也比較麻煩。</p><p>還好使用 Qemu 有一個叫做 Qemu Guest Agent 的背景程序，我們可以透過安裝這個程序進行「裡應外合」讓我們可以存取到和操作虛擬機內的部分功能。</p><p>因為我們習慣使用 CentOS 所以可以用 YUM 來安裝。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install qemu-guest-agent</span><br></pre></td></tr></table></figure><p>重開機後如果在 ProxmoxVE 上看到這樣的訊息，就算是成功了！</p><p><img src="https://blog.frost.tw/images/2019-02-19-automatic-vm-allocate-using-proxmox-ve-and-rails/912F134AB7BBA01EFA083119460302AB.png" alt="螢幕快照 2019-02-18 上午1.09.10.png"></p><p>不過，要能自動寫入 SSH Key 還有一個問題，因為 Qemu Guest Agent 雖然提供寫入檔案的功能，但是會受到以下限制：</p><ol><li>設定檔預設不開放使用</li><li>SELinux 會阻止你寫入某些檔案</li><li>必須是存在的檔案（至少讀取是）</li></ol><p>所以我們要先做幾件事情：</p><ol><li>修改 <code>/etc/sysconfig/qemu-ga</code> 把 BLACKLIST 註解掉（練習用的機器安全性就放一邊吧！）</li><li>修改 <code>/etc/selinux/config</code> 把 SELinux 設定成 <code>disabled</code> 狀態</li><li>產生一個空的 <code>/root/.ssh/authorized_keys</code> 檔案</li></ol><blockquote><p>要確定 <code>/root/.ssh</code> 目錄權限是 700 而 <code>authorized_keys</code> 檔案權限是 600 不然 SSH 是會因為權限設定錯誤而無法登入！</p></blockquote><p>前置動作就緒，也重開機讓設定確實生效之後，就可以透過 API 來寫入檔案</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Proxmox::API</span><br><span class="line">  .post(</span><br><span class="line">    <span class="string">'nodes/pve/qemu/100/agent/file-write'</span>,</span><br><span class="line">    <span class="symbol">file:</span> <span class="string">'/root/.ssh/authorized_keys'</span>,</span><br><span class="line">    <span class="symbol">content:</span> <span class="string">'...'</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>大家可能會好奇 SSH Key 要從哪裡取得？因為五倍有自己的 GitLab 來放各種專案，所以在設計的時候透過 OmniAuth GitLab 直接讓員工登入，然後直接透過 GitLab 的 API 把大家設定的 SSH Key 讀取出來使用。</p><p>畢竟大部分的人都會把預設的 SSH Key 當作 Git 用的 Key 一般來說會直接通用。</p><blockquote><p>做完之後記得重新設置一次 Snapshot 確保新設定都能在被重設的時候吃到！</p></blockquote><h2 id="自動產生乾淨環境"><a href="#自動產生乾淨環境" class="headerlink" title="自動產生乾淨環境"></a>自動產生乾淨環境</h2><p>結合以上所有的技巧，我們可以封裝成像是這樣的 Service Object 在使用者點選「使用」的時候初始化這台虛擬機。</p><p>以下是真實實作的程式碼：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frozen_string_literal: true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">require</span> <span class="string">'timeout'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldVMService</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:vmid</span>, <span class="symbol">:user</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(vmid, user)</span></span></span><br><span class="line">    @vmid = vmid</span><br><span class="line">    @user = user</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">perform</span></span></span><br><span class="line">    <span class="comment"># rubocop:disable Style/ColonMethodCall</span></span><br><span class="line">    Timeout::timeout(<span class="number">30</span>) <span class="keyword">do</span></span><br><span class="line">      vm = Proxmox::VM.find(@vmid)</span><br><span class="line">      wait_task vm.reinitialize!</span><br><span class="line">      wait_task vm.start!</span><br><span class="line">      install(vm, @user.keys)</span><br><span class="line">      <span class="literal">true</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># rubocop:enable Style/ColonMethodCall</span></span><br><span class="line">  <span class="keyword">rescue</span> Timeout::Error</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  private</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">wait_task</span><span class="params">(id)</span></span></span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> Use nodes/&#123;node&#125;/tasks/&#123;upid&#125;/status instead pull all tasks</span></span><br><span class="line">    loop <span class="keyword">do</span></span><br><span class="line">      tasks = Proxmox::Task.all</span><br><span class="line">      <span class="keyword">break</span> <span class="keyword">if</span> tasks.find &#123; <span class="params">|t|</span> t.upid == id &amp;&amp; t.status == <span class="string">'OK'</span> &#125;</span><br><span class="line">      sleep <span class="number">0</span>.<span class="number">5</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">install</span><span class="params">(machine, keys)</span></span></span><br><span class="line">    machine.install_authorized_keys(keys)</span><br><span class="line">  <span class="keyword">rescue</span> Proxmox::API::ServerError</span><br><span class="line">    <span class="keyword">retry</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>因為在看文件時沒仔細看，所以還是用到了 <code>cluster/tasks</code> 的方式來讀取 Task 可能會跟文章上面介紹的方式有點出入（直接讀取對應的 UPID 會比這個方式好）</p><p>雖然跟文章介紹的有不少出入（像是 <code>Proxmox::VM</code> 封裝）但是整體上可以看出來，想要製作一個自動設定好乾淨環境的虛擬機提供同事練習，其實不困難：</p><ol><li>安裝並設定好虛擬機</li><li>利用迴圈不斷檢查處理狀態</li><li>利用 Qemu Guest Agent 寫入檔案設定 SSH Key</li><li>開始使用！</li></ol><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>說好的 Rails 在哪裡？目前其實除了是用 Rails 當基底之外，其實還沒使用到 Rails 的功能。不過後續會加上「限制其他使用者搶走虛擬機」之類的權限管理，就會要靠 Rails 跟資料庫的串接了。</p><p>這篇文章只是很簡單、快速的帶過整個在設計跟思考上的過程是怎樣運行的。</p><p>實際上是很考驗使用 Ruby 的經驗跟技巧，不過我們身為 Ruby 使用者其實常常因為 Rails 的關係限制住了視野，透過這樣的方式練習用不同的思考方式去做一些看起來不能做的機制或者功能，其實是很有趣的。</p><p>尤其是這只是很簡單的 API 串接技巧，最早有這個想法的時候是想要用 <code>libvirt</code> 去跟 KVM 的底層互動，不過因為太花時間就先暫時放棄。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2019/02/19/Automatic-VM-allocate-using-Proxmox-VE-and-Rails/#disqus_thread</comments>
    </item>
    
    <item>
      <title>探索 Ruby 的 each 方法（一）</title>
      <link>https://blog.frost.tw/posts/2019/02/13/Deep-into-ruby-s-each-method-Part-1/</link>
      <guid>https://blog.frost.tw/posts/2019/02/13/Deep-into-ruby-s-each-method-Part-1/</guid>
      <pubDate>Tue, 12 Feb 2019 17:00:23 GMT</pubDate>
      <description>
      
        &lt;p&gt;原本是想討論 Enumerable 這個 Module 的機制跟運作原理，不過越寫越發現光是一篇文章很難講明白。&lt;/p&gt;&lt;p&gt;所以就一邊查資料跟 Ruby 原始碼，慢慢的把 Enumerable / Enumerator 這兩個讓 &lt;code&gt;#each&lt;/code&gt; 運作起來的機制討論清楚。&lt;/p&gt;&lt;p&gt;在 Ruby 裡面我們已經很熟悉使用 &lt;code&gt;#each&lt;/code&gt; 來對陣列相關的物件進行操作，不過在大部分的語言我們都需要透過迴圈的方式來取出陣列的元素，那麼 &lt;code&gt;#each&lt;/code&gt; 這個方法到底是怎麼讓我們用這麼方便的機制來操作陣列的呢？&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>原本是想討論 Enumerable 這個 Module 的機制跟運作原理，不過越寫越發現光是一篇文章很難講明白。</p><p>所以就一邊查資料跟 Ruby 原始碼，慢慢的把 Enumerable / Enumerator 這兩個讓 <code>#each</code> 運作起來的機制討論清楚。</p><p>在 Ruby 裡面我們已經很熟悉使用 <code>#each</code> 來對陣列相關的物件進行操作，不過在大部分的語言我們都需要透過迴圈的方式來取出陣列的元素，那麼 <code>#each</code> 這個方法到底是怎麼讓我們用這麼方便的機制來操作陣列的呢？</p><a id="more"></a><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>在<a href="https://zh.wikipedia.org/wiki/%E8%BF%AD%E4%BB%A3%E5%99%A8" rel="external nofollow noopener noreferrer" target="_blank">維基百科</a>裡面提到 Ruby 是隱式的將迭代器內建在語言裡面的。</p><p>我們可以先來看看迭代器通常是怎麼實現的：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterator</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(collection)</span></span></span><br><span class="line">    @collection = collection</span><br><span class="line">    @ptr = <span class="number">0</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">next</span></span></span><br><span class="line">   ret = @collection[@ptr]</span><br><span class="line">   @ptr += <span class="number">1</span></span><br><span class="line">   ret</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">rewind</span></span></span><br><span class="line">    @ptr = <span class="number">0</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>那麼我們就可以用像下面這樣的方式來讀取陣列的內容</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">array = (<span class="number">1</span>..<span class="number">10</span>).to_a</span><br><span class="line">iter = Iterator.new(array)</span><br><span class="line">iter.<span class="keyword">next</span> <span class="comment"># =&gt; 1</span></span><br><span class="line">iter.<span class="keyword">next</span> <span class="comment"># =&gt; 2</span></span><br><span class="line">iter.rewind</span><br><span class="line">iter.<span class="keyword">next</span> <span class="comment"># =&gt; 1</span></span><br></pre></td></tr></table></figure><p>實際上，在 Ruby 中已經有內建這樣的機制，那就是 <code>Enumerator</code> 類別。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">array = (<span class="number">1</span>..<span class="number">10</span>).to_a</span><br><span class="line">iter = Enumerator.new(array)</span><br><span class="line"><span class="comment"># warning: Enumerator.new without a block is deprecated; use Object#to_enum</span></span><br><span class="line">iter.<span class="keyword">next</span> <span class="comment"># =&gt; 1</span></span><br><span class="line">iter.<span class="keyword">next</span> <span class="comment"># =&gt; 2</span></span><br><span class="line">iter.rewind</span><br><span class="line">iter.<span class="keyword">next</span> <span class="comment"># =&gt; 1</span></span><br></pre></td></tr></table></figure><p>那麼，假設我們對陣列使用 <code>#each</code> 方法時，不傳入 Block 的話，會看到什麼呢？</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">irb(main):067:0&gt;</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].each</span><br><span class="line">=&gt; #&lt;Enumerator: [1, 2, 3]:each&gt;</span><br></pre></td></tr></table></figure><p>我們會得到一個 <code>Enumerator</code> 物件，也就是說 <code>#each</code> 方法回傳的就是迭代器。</p><h2 id="使用-Block-的情境"><a href="#使用-Block-的情境" class="headerlink" title="使用 Block 的情境"></a>使用 Block 的情境</h2><p>不過，當我們提供了 Block 之後，回傳的卻是普通的陣列，又是怎麼一回事？</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">irb(main):070:0&gt;</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].each &#123; <span class="params">|v|</span> p v &#125;.class</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">=&gt; Array</span><br></pre></td></tr></table></figure><p>而且，當我們使用不同類型的物件時，也會得到同樣的物件類型</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">irb(main):074:0&gt;</span> (<span class="number">1</span>..<span class="number">2</span>).each</span><br><span class="line">=&gt; #&lt;Enumerator: 1..2:each&gt;</span><br><span class="line"><span class="meta">irb(main):075:0&gt;</span> (<span class="number">1</span>..<span class="number">2</span>).each &#123; <span class="params">|v|</span> p v &#125;.class</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">=&gt; Range</span><br></pre></td></tr></table></figure><p>這就表示在 Ruby 中 <code>#each</code> 的行為並不單純是我們所看到的這樣，不過這就要再跟 <code>Enumerator</code> 的實作有所關聯，所以就將它留到下一篇文章再討論吧！</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>在寫這篇文章之前其實都沒有認真思考過 <code>#each</code> 是怎麼運作的，雖然他是很常見而且很常使用的功能。但是從 Ruby 1.8 到現在的 Ruby 2.6 中間所出現的改變一些新的特性，其實是蠻值得去探討的。</p><p>會寫這系列文章主要是因為最近手邊的專案遇到了一個蠻有趣的問題，就是如果靠 ActiveRecord 的話，會產生多餘的 N+1 Query 而如果是直接針對讀取出來的資料進行普通的陣列操作，反而可以避開，又不會浪費太多的資源。</p><p>這就成為了一個盲點，也就是我們大多數時候已經習慣了 Rails 提供給我們的便利功能，而忘記應該評估使用情境去選擇適合的方案來處理。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2019/02/13/Deep-into-ruby-s-each-method-Part-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>你看懂五倍紅寶石粉專上的 Ruby 版台灣共識了嗎？</title>
      <link>https://blog.frost.tw/posts/2019/01/14/Do-you-understand-the-Ruby-version-Taiwan-Consensus-on-5xruby-s-fanpage/</link>
      <guid>https://blog.frost.tw/posts/2019/01/14/Do-you-understand-the-Ruby-version-Taiwan-Consensus-on-5xruby-s-fanpage/</guid>
      <pubDate>Mon, 14 Jan 2019 14:00:39 GMT</pubDate>
      <description>
      
        &lt;p&gt;最近「台灣共識」很熱門，公司的粉專也分享了 Ruby 版的台灣共識。&lt;/p&gt;&lt;p&gt;我們在公司內部的群組大家其實討論了蠻久，如果只是單純的去實作跟其他語言一樣的內容，不就沒有意義了嗎？&lt;/p&gt;&lt;p&gt;我們之所以會選擇用 Ruby 來當作工作上的工具，就表示他有一些特別的地方吸引我們。&lt;/p&gt;&lt;p&gt;所以，上面用了哪些 Ruby 技巧讓我們一起來分析看看！&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>最近「台灣共識」很熱門，公司的粉專也分享了 Ruby 版的台灣共識。</p><p>我們在公司內部的群組大家其實討論了蠻久，如果只是單純的去實作跟其他語言一樣的內容，不就沒有意義了嗎？</p><p>我們之所以會選擇用 Ruby 來當作工作上的工具，就表示他有一些特別的地方吸引我們。</p><p>所以，上面用了哪些 Ruby 技巧讓我們一起來分析看看！</p><a id="more"></a><p>先來看一下原始的版本，這是一個可以實際執行的 Ruby 語法。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Consensus92</span><span class="params">(<span class="symbol">countries:</span>, <span class="symbol">system:</span>)</span></span></span><br><span class="line">  Module.new <span class="keyword">do</span></span><br><span class="line">    define_method <span class="string">'definition'</span> <span class="keyword">do</span></span><br><span class="line">      &#123; <span class="symbol">countries:</span> countries, <span class="symbol">system:</span> system &#125;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    define_method <span class="string">'build_consensus_with?'</span> <span class="keyword">do</span> <span class="params">|other|</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span> <span class="keyword">if</span> definition == other.definition</span><br><span class="line">      raise <span class="string">"This is not <span class="subst">#&#123;other&#125;</span> consensus"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Taiwan</span></span></span><br><span class="line">  extend Consensus92(<span class="symbol">countries:</span> <span class="number">2</span>, <span class="symbol">system:</span> <span class="number">2</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">China</span></span></span><br><span class="line">  extend Consensus92(<span class="symbol">countries:</span> <span class="number">1</span>, <span class="symbol">system:</span> <span class="number">2</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">China.build_consensus_with?(Taiwan)</span><br></pre></td></tr></table></figure><h2 id="include-與-extend"><a href="#include-與-extend" class="headerlink" title="include 與 extend"></a>include 與 extend</h2><p>大多數時候我們都是對 <code>include</code> 比較熟悉，因為它可以把一些方法切割到一個 Module 裡面，然後在物件中呼叫。</p><p>我們先來看一下這段程式碼：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Extension</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">echo</span></span></span><br><span class="line">    puts <span class="string">'ECHO'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line">  <span class="keyword">include</span> Extension</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line">  extend Extension</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p A.ancestors</span><br><span class="line"><span class="comment"># =&gt; [A, Extension, Object, Kernel, BasicObject]</span></span><br><span class="line">A.new.echo</span><br><span class="line">p B.ancestors</span><br><span class="line"><span class="comment"># =&gt; [B, Object, Kernel, BasicObject]</span></span><br><span class="line">B.echo</span><br></pre></td></tr></table></figure><p>我們會發現在 <code>B</code> 上面的繼承上，是沒有 <code>Extension</code> 模組的，所以兩者的差異在哪邊呢？</p><blockquote><p>因為我們希望是 <code>China.build_consensus_with?(Taiwan)</code> 而不是 <code>China.new.build_consensus_with?(Taiwan.new)</code> 的寫法，才選擇用 <code>extend</code></p></blockquote><h3 id="線索一"><a href="#線索一" class="headerlink" title="線索一"></a>線索一</h3><p>調查了 Ruby 的文件會發現 <code>include</code> 屬於 <code>Module</code> 物件的行為，而 <code>extend</code> 則是屬於 <code>Object</code> 物件的行為。</p><p>簡單說就表示 <code>include</code> 只能作用在 <code>Class</code> 上，物件的實例是不行的，像是下面這樣：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.new.<span class="keyword">include</span> Extension</span><br></pre></td></tr></table></figure><p>但是 <code>extend</code> 是屬於 <code>Object</code> 的行為，所以原本我們預期是這樣</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B.new.extend Extension</span><br></pre></td></tr></table></figure><p>但是同時 Ruby 的所有東西都是物件的一種，所以同理可以證明 <code>Module</code> 也是一種物件（而 <code>Class</code> 物件繼承於 <code>Module</code>）所以下面的用法也會成立：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B.extend Extension</span><br></pre></td></tr></table></figure><h3 id="線索二"><a href="#線索二" class="headerlink" title="線索二"></a>線索二</h3><p>根據 Ruby 文件提供的 <code>extend</code> 實作，大概是長這樣的，意外的很簡單。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> VALUE</span><br><span class="line">rb_obj_extend(<span class="keyword">int</span> argc, VALUE *argv, VALUE obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    ID id_extend_object, id_extended;</span><br><span class="line"></span><br><span class="line">    CONST_ID(id_extend_object, <span class="string">"extend_object"</span>);</span><br><span class="line">    CONST_ID(id_extended, <span class="string">"extended"</span>);</span><br><span class="line"></span><br><span class="line">    rb_check_arity(argc, <span class="number">1</span>, UNLIMITED_ARGUMENTS);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">        Check_Type(argv[i], T_MODULE);</span><br><span class="line">    <span class="keyword">while</span> (argc--) &#123;</span><br><span class="line">        rb_funcall(argv[argc], id_extend_object, <span class="number">1</span>, obj);</span><br><span class="line">        rb_funcall(argv[argc], id_extended, <span class="number">1</span>, obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>裡面其實就只是把 <code>extend</code> 傳入的 Module 都帶入，並且呼叫 <code>extended</code> 和 <code>extend_object</code> 兩個方法。</p><p>經過簡單的測試，像下面這樣的修改就能阻止 <code>extend</code> 複製方法。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Extension</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">extend_object</span><span class="params">(obj)</span></span></span><br><span class="line">    <span class="comment"># Do Nothing</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">echo</span></span></span><br><span class="line">    puts <span class="string">'ECHO'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line">  extend Extension</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">B.echo</span><br><span class="line"><span class="comment"># =&gt; undefine method</span></span><br></pre></td></tr></table></figure><p>也就是說，在 <code>extend</code> 的行為下，我們會透過 <code>extend_object</code> 方法做某些處理後，才得以「複製」方法，而不是像 <code>include</code> 一樣把整個 Module 放入物件的繼承體系之中。</p><blockquote><p>因為文章篇幅限制，我們先不去追 <code>extend_object</code> 的源頭。</p></blockquote><h2 id="Consensus92-的用法"><a href="#Consensus92-的用法" class="headerlink" title="Consensus92 的用法"></a>Consensus92 的用法</h2><p>首先，大家可能會有點疑惑為什麼可以用 <code>extend Consensus92()</code> 這樣的寫法，我們先釐清一下「方法」和「常數」的差異。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Consensus92</span>;</span> <span class="keyword">end</span></span><br><span class="line">p Consensus92()</span><br><span class="line">p Consensus92 <span class="comment"># =&gt; uninitialized constant Consensus92</span></span><br></pre></td></tr></table></figure><p>從上面這段程式碼我們可以發現，實際上「方法」和「常數」的命名空間是不同的，也就是說他們兩者並不衝突可以並存。而 Ruby 在這個情況下是透過有沒有 <code>()</code> 來判斷到底是個方法，還是一個常數。</p><blockquote><p>這邊省略 Ruby 的 Keyword Arguments 解釋，這部分雖然不常見但還是屬於日常使用的一部分。</p></blockquote><p>那麼，為什麼 <code>Consensus92()</code> 的回傳結果可以被 <code>extend</code> 呢？</p><p>這個問題大家可能很快就猜到了，因為我們使用了「匿名模組」的技巧，雖然不確定是否真的有這個詞，不過大多數我們都用「匿名 XX」來稱呼一些沒有取名的定義，所以這邊也就這樣使用吧！</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Consensus92</span></span></span><br><span class="line">  Module.new; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Taiwan</span></span></span><br><span class="line">  extend Consensus92</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>因為不論 <code>include</code> 還是 <code>extend</code> 都只會確認對象是不是一個 Module 所以在這邊我們「即時」產生一個新的 Module 是符合 Ruby 在運作上的判定，也因此會被視為合法的行為。</p><p>所以實際上我們在 <code>Taiwan</code> 和 <code>China</code> 擴充的模組是不一樣的，這樣在程式的意義上，剛好也跟「九二共識沒有共識」的意思重疊在一起，畢竟從一開始「拓展（extend）」的共識就是不同的。</p><blockquote><p>如果有在使用 Rails 的話，可能會注意到像是 <code>Association_User_CollectionProxy</code> 之類的類別名稱，其實就是運用這種技巧去動態產生的 Class 喔！</p></blockquote><h2 id="define-method-的理由"><a href="#define-method-的理由" class="headerlink" title="define_method 的理由"></a>define_method 的理由</h2><p>實際上，我們使用 <code>Module.new do; end</code> 和 <code>module Extension; end</code> 的效果是相同的，從下面的程式碼可以得到驗證：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A = Module.new</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">echo</span></span></span><br><span class="line">    puts <span class="string">'ECHO'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line">  extend A</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">B.echo</span><br></pre></td></tr></table></figure><p>既然這樣也會運作，那麼我們為什麼還需要用 <code>define_method</code> 呢？</p><p>這是因為我們希望達到類似 Closure 的技巧，看看下面這段程式就會注意到一個有趣的問題：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Consensus92</span><span class="params">(<span class="symbol">countries:</span>)</span></span></span><br><span class="line">  Module.new</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">definition</span></span></span><br><span class="line">      &#123; <span class="symbol">countries:</span> countries &#125;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Taiwan</span></span></span><br><span class="line">  extend Consensus(<span class="symbol">countries:</span> <span class="number">2</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Taiwan.definition</span><br><span class="line"><span class="comment"># =&gt; undefine variable countries</span></span><br></pre></td></tr></table></figure><p>為什麼會這樣，因為對 <code>def</code> 來說 <code>countries</code> 已經是屬於在執行階段的一部分，所以我們在呼叫 <code>definition</code> 的時候才會嘗試去尋找 <code>countries</code> 這個東西，但是他已經無法被找到。</p><p>但是 <code>define_method</code> 就不太一樣了！</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Consensus92</span><span class="params">(<span class="symbol">countries:</span>)</span></span></span><br><span class="line">  Module.new <span class="keyword">do</span></span><br><span class="line">    define_method <span class="string">'definition'</span> <span class="keyword">do</span></span><br><span class="line">      &#123; <span class="symbol">countries:</span> countries &#125;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Taiwan</span></span></span><br><span class="line">  extend Consensus92(<span class="symbol">countries:</span> <span class="number">2</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>實際上 <code>define_method</code> 在被呼叫的當下，會被轉成像這樣的樣子</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">definition</span></span></span><br><span class="line">  &#123; <span class="symbol">countries:</span> <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>這是因為對於 <code>define_method</code> 所傳入的 Block 是用來定義方法的內容，但是因為我們是在呼叫一個方法，所以 <code>countries</code> 變數就被視為是處於 <code>Consensus92</code> 方法的環境下，而不是呼叫的當下。</p><blockquote><p>稍微有點難懂，不過是不是很像 Closure 的感覺呢？</p></blockquote><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>這段程式碼其實算是有不少巧思在裡面，把程式碼換成中文讀起來意思也是很容易懂的。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 九二共識<span class="params">(國家<span class="symbol">:</span>, 制度<span class="symbol">:</span>)</span></span></span><br><span class="line">  Module.new <span class="keyword">do</span></span><br><span class="line">    define_method <span class="string">'定義'</span> <span class="keyword">do</span></span><br><span class="line">      &#123; 國家: 國家, 制度: 制度 &#125;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    define_method <span class="string">'建立共識？'</span> <span class="keyword">do</span> <span class="params">|定義|</span></span><br><span class="line">      <span class="keyword">return</span> 是 如果 定義 == 對方.定義</span><br><span class="line">      raise <span class="string">"這不是<span class="subst">#&#123;對方&#125;</span>共識"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 台灣</span></span><br><span class="line">  擴充 九二共識(國家: <span class="number">2</span>, 制度: <span class="number">2</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 中國</span></span><br><span class="line">  擴充 九二共識(國家: <span class="number">1</span>, 制度: <span class="number">2</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">中國.建立共識?（台灣）</span><br><span class="line"><span class="comment"># =&gt; 錯誤「這不是台灣共識」</span></span><br></pre></td></tr></table></figure><p>這也是 Ruby 在 DSL 表現優異上的原因之一，我們可以透過許多動態定義或者語法上的特殊技巧，製作出非常接近我們習慣的語言跟用法。</p><p>這篇文章提到關於 Ruby 類別上的應用，可以參考之前寫過的<a href="https://blog.frost.tw/posts/2017/10/22/The-ruby-s-class-is-free-Part-1/">自由的 Ruby 類別</a>來了解背後的機制。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2019/01/14/Do-you-understand-the-Ruby-version-Taiwan-Consensus-on-5xruby-s-fanpage/#disqus_thread</comments>
    </item>
    
    <item>
      <title>用 Ruby 來尋找區網中的 Airplay、Chromecast</title>
      <link>https://blog.frost.tw/posts/2018/12/25/Use-Ruby-to-find-the-Airplay-or-Chromecast-device/</link>
      <guid>https://blog.frost.tw/posts/2018/12/25/Use-Ruby-to-find-the-Airplay-or-Chromecast-device/</guid>
      <pubDate>Tue, 25 Dec 2018 10:42:06 GMT</pubDate>
      <description>
      
        &lt;p&gt;從雲端開始熱門起來後，為了能能讓提供不同服務的伺服器能夠被自動的偵測，我們在許多雲端相關的工具都會看到 Service Discovery 這個名詞。&lt;/p&gt;&lt;p&gt;不過，除了雲端上的服務能夠透過這樣的機制互相「發現」對方，我們也可以在區網中用類似的方法找到「提供服務」的裝置。&lt;/p&gt;&lt;p&gt;這就要從 mDNS (Multicast DNS) 和 DNS-SD (DNS-based Service Discovery) 開始談起。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>從雲端開始熱門起來後，為了能能讓提供不同服務的伺服器能夠被自動的偵測，我們在許多雲端相關的工具都會看到 Service Discovery 這個名詞。</p><p>不過，除了雲端上的服務能夠透過這樣的機制互相「發現」對方，我們也可以在區網中用類似的方法找到「提供服務」的裝置。</p><p>這就要從 mDNS (Multicast DNS) 和 DNS-SD (DNS-based Service Discovery) 開始談起。</p><a id="more"></a><h2 id="概觀"><a href="#概觀" class="headerlink" title="概觀"></a>概觀</h2><p>想要可以發現區網的裝置，我們需要先搞懂 mDNS 和 DNS-SD 這兩個東西在做些什麼。簡單來說 mDNS 就是對區網做「廣播」而廣播的內容則是我們熟悉的 DNS Query。當其他有在關注 mDNS 的裝置注意到之後，就會把回應廣播回區網上。也因為這樣的特性，我們不需要特別在區網架設一個 DNS 伺服器，因為我們會直接在這個區網中交換有興趣的訊息。</p><p>而 DNS-SD 其實是由 Apple 所提出的，如果看到 Bonjour 大致上他們可能是同一個東西。簡單來說就是基於 mDNS 在區網用特定的規則「查詢」和「回應」就能讓某個裝置辨識出另一個裝置有提供的服務，從而做到 Service Discovery 的功能。</p><blockquote><p>Bonjour 是不是相等 DNS-SD 資料不多，所以我不太敢直接斷定是同樣的東西，不過 DNS-SD 文件上是會出現 Bonjour 這個名詞的。</p></blockquote><h2 id="Ruby-的-Resolv-標準函式庫"><a href="#Ruby-的-Resolv-標準函式庫" class="headerlink" title="Ruby 的 Resolv 標準函式庫"></a>Ruby 的 Resolv 標準函式庫</h2><p>基本上 <code>Resolv</code> 這個函式庫存在感低到我都懷疑他為什麼一直在 Ruby 原始碼中活得好好的，沒有被切割出來。不過如果我們想產生 DNS 查詢的封包，就得靠他來實現。</p><blockquote><p>原本我是看著這篇<a href="https://routley.io/tech/2017/12/28/hand-writing-dns-messages.html" rel="external nofollow noopener noreferrer" target="_blank">文章</a>透過 Python 來實作產生和解析封包的功能，但是想起來我曾經對 Ruby 送過 PR 剛好就是 Resolv 相關的。</p></blockquote><p>先來一段 <code>Resolv::DNS</code> 的官方使用，讓我們快速了解一下怎麼送出 DNS 查詢。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'resolv'</span></span><br><span class="line"></span><br><span class="line">Resolv::DNS.new</span><br><span class="line">           .each_resource(<span class="string">'frost.tw'</span>, Resolv::DNS::Resource::IN::A) <span class="keyword">do</span> <span class="params">|record|</span></span><br><span class="line">             pp record</span><br><span class="line">           <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如此一來就可以查詢到 <code>frost.tw</code> 的 A 紀錄有哪些，那麼從前面的介紹來看假設 mDNS 也是使用 DNS 封包來互動的話，是不是就表示 <code>Resolv::DNS</code> 已經提供了足夠我們實現 mDNS 和 DNS-SD 的必要實作了呢？</p><h2 id="監聽-mDNS-封包"><a href="#監聽-mDNS-封包" class="headerlink" title="監聽 mDNS 封包"></a>監聽 mDNS 封包</h2><p>跟我們平常使用的 <code>Socket</code> 功能比起來要正確的設定 <code>UDPSocket</code> 才能夠順利加入一個 <a href="https://en.wikipedia.org/wiki/Multicast" rel="external nofollow noopener noreferrer" target="_blank">Multicast 群組</a>，然後接收裡面的訊息。</p><p>根據 <a href="https://en.wikipedia.org/wiki/Multicast_DNS" rel="external nofollow noopener noreferrer" target="_blank">mDNS 定義</a>的 Multicast IPv4 位置，我們需要監聽 <code>224.0.0.251</code> 上的 <code>5353</code> 埠就可以收到 mDNS 的封包，剛開始我們可能會覺得像這樣實作應該就可以了。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'socket'</span></span><br><span class="line"></span><br><span class="line">socket = UDPSocket.new</span><br><span class="line">socket.bind(<span class="string">'224.0.0.251'</span>, <span class="number">5353</span>)</span><br></pre></td></tr></table></figure><p>不過馬上就會得到 <code>Errno::EADDRINUSE (Address already in use - bind(2) for &quot;224.0.0.251&quot; port 5353)</code> 這樣的錯誤訊息，所以我們需要對這個 UDPSocket 做一些設定，讓他以「加入 Multicast 群組成員」的形式運作。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">membership = IPAddr.new(<span class="string">'224.0.0.251'</span>).hton + IPAddr.new(<span class="string">'0.0.0.0'</span>).hton</span><br><span class="line">socket = UDPSocket.new</span><br><span class="line"></span><br><span class="line">socket.setsockopt(<span class="symbol">:IPPROTO_IP</span>, <span class="symbol">:IP_ADD_MEMBERSHIP</span>, membership)</span><br><span class="line">socket.setsockopt(<span class="symbol">:SOL_SOCKET</span>, <span class="symbol">:SO_REUSEPORT</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">socket.bind(<span class="string">'0.0.0.0'</span>, <span class="number">5353</span>)</span><br></pre></td></tr></table></figure><p>上述的程式碼簡單來說做了這幾件事情：</p><ol><li>設定 Socket 要加入 <code>224.0.0.251</code> 作為成員</li><li>設定 Socket 允許重複使用 5353 這個 Port</li></ol><p>設定 5353 Port 可以被重複使用是因為在這個裝置上可能還有其他服務存在，他也會需要關注 mDNS 或者做出廣播，所以我們可能會跟其他人共用這個 Port。</p><p>而加入 <code>224.0.0.251</code> 成員就相對不容易理解了，對沒學過網路相關知識的人來說還真的不太好好懂（所以特地查了一下資料）</p><p>我們先看 <code>setsockopt</code> 在 Ruby 原始碼做了什麼，才會知道上面這段的意思。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 略</span><br><span class="line"><span class="keyword">if</span> (setsockopt(fptr-&gt;fd, level, option, v, vlen) &lt; <span class="number">0</span>)</span><br><span class="line">        rsock_sys_fail_path(<span class="string">"setsockopt(2)"</span>, fptr-&gt;pathv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> INT2FIX(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>在實作上 Ruby 會直接去呼叫 C API 來做這件事情，而 <code>level</code>, <code>option</code>, <code>v</code> 就是我們從 Ruby 傳入的數值。</p><p>接下來再看看我查到的 <code>IP_ADDD_MEMBERSHIP</code> 的 C API <a href="https://www.tldp.org/HOWTO/Multicast-HOWTO-6.html" rel="external nofollow noopener noreferrer" target="_blank">使用說明</a>（嚴格上來說是 Multicast 的說明）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_multiaddr</span>;</span>   <span class="comment">/* IP multicast address of group */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_interface</span>;</span>   <span class="comment">/* local IP address of interface */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsockopt (socket, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;mreq, <span class="keyword">sizeof</span>(mreq));</span><br></pre></td></tr></table></figure><p>實際上跟 Ruby 的版本幾乎沒有差別，最主要的是 <code>ip_mreq</code> 是一個資料結構，我們要怎樣才能夠正確的傳遞進去呢？</p><p>先看看 <code>IPAddr.new(&#39;224.0.0.251&#39;).hton</code> 執行後會得到什麼？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">irb(main):003:0&gt; IPAddr.new(<span class="string">'224.0.0.251'</span>).hton</span><br><span class="line">=&gt; <span class="string">"\xE0\x00\x00\xFB"</span></span><br></pre></td></tr></table></figure><p>那麼跟 <code>0.0.0.0</code> 的 <code>IPAddr#hton</code> 相加之後，因為是字串所以會變成像這樣</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">irb(main):004:0&gt; IPAddr.new(<span class="string">'224.0.0.251'</span>).hton + IPAddr.new(<span class="string">'0.0.0.0'</span>).hton</span><br><span class="line">=&gt; <span class="string">"\xE0\x00\x00\xFB\x00\x00\x00\x00"</span></span><br></pre></td></tr></table></figure><p>我們再回去看 Ruby 在 <code>setsockopt</code> 實作中，遇到 <code>String</code> 時，會怎樣處理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *v;</span><br><span class="line"></span><br><span class="line"># 略</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (TYPE(val)) &#123;</span><br><span class="line">      # 略</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        StringValue(val);</span><br><span class="line">        v = RSTRING_PTR(val);</span><br><span class="line">        vlen = RSTRING_SOCKLEN(val);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"># C API 呼叫處</span><br></pre></td></tr></table></figure><p>簡單說就是直接弄成一段 <code>char</code> 陣列，基本上我們在 C 裡面只要大小一樣直接對到結構上基本上是會運作的，於是我們就很自然的利用 Ruby 的字串變成一個在 C 裡面的 <code>ip_mreq</code> 資料結構，順利的傳遞進去了。</p><p>至於 <code>#hton</code> 是什麼呢？他是 <code>Host Byte Order to Network Byte Order</code> 的縮寫，簡單說在處理網路封包的時候需要知道 IP 位置，所以有一個特殊的格式，但是因為作業系統差異，存位置的規格可能有差異，所以送到網路上時會統一轉成網路用的位元順序。</p><p>總而言之，我們目前可以順利的接收到來自 mDNS 的廣播封包拉！</p><h2 id="解析封包"><a href="#解析封包" class="headerlink" title="解析封包"></a>解析封包</h2><p>首先，我們先把上面的程式碼簡單重構成下面這樣的結構</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'socket'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'resolv'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'awesome_print'</span></span><br><span class="line"></span><br><span class="line">MDNS_PORT = <span class="number">5353</span></span><br><span class="line">MDNS_ADDRESS = <span class="string">'224.0.0.251'</span>.freeze</span><br><span class="line">BIND_ADDRESS = <span class="string">'0.0.0.0'</span>.freeze</span><br><span class="line"></span><br><span class="line">M_MEMBERSHIP = IPAddr.new(MDNS_ADDRESS).hton + IPAddr.new(BIND_ADDRESS).hton</span><br><span class="line"></span><br><span class="line"><span class="comment"># :nodoc:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MDNS</span></span></span><br><span class="line">  <span class="keyword">include</span> Enumerable</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></span><br><span class="line">    @socket = UDPSocket.new</span><br><span class="line">    @socket.setsockopt(<span class="symbol">:IPPROTO_IP</span>, <span class="symbol">:IP_ADD_MEMBERSHIP</span>, M_MEMBERSHIP)</span><br><span class="line">    @socket.setsockopt(<span class="symbol">:SOL_SOCKET</span>, <span class="symbol">:SO_REUSEPORT</span>, <span class="number">1</span>)</span><br><span class="line">    @socket.bind(BIND_ADDRESS, MDNS_PORT)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">each</span><span class="params">(&amp;_block)</span></span></span><br><span class="line">    loop <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">yield</span> @socket.recvfrom(<span class="number">4096</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">mdns = MDNS.new</span><br><span class="line">mdns.each <span class="keyword">do</span> <span class="params">|packet|</span></span><br><span class="line">  ap packet</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>執行之後，稍微等待一段時間就可以收到類似像這樣的封包資訊</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    [<span class="number">0</span>] <span class="string">"\x00\x00\x84\x00\x00\x00\x00\x02\x00\x00\x00\x01\aAndroid\x05local\x00\x00\x01\x80\x01\x00\x00\x00x\x00\x04\xAC\x1F\x01\xC0\xC0\f\x00\x1C\x80\x01\x00\x00\x00x\x00\x10\xFE\x80\x00\x00\x00\x00\x00\x00\xAEc\xBE\xFF\xFE\xC21;\xC0\f\x00/\x80\x01\x00\x00\x00x\x00\b\xC0\f\x00\x04@\x00\x00\b"</span>,</span><br><span class="line">    [<span class="number">1</span>] [</span><br><span class="line">        [<span class="number">0</span>] <span class="string">"AF_INET"</span>,</span><br><span class="line">        [<span class="number">1</span>] <span class="number">5353</span>,</span><br><span class="line">        [<span class="number">2</span>] <span class="string">"172.31.1.192"</span>,</span><br><span class="line">        [<span class="number">3</span>] <span class="string">"172.31.1.192"</span></span><br><span class="line">    ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>那麼我們該如何解析呢？因為封包內容其實就是 DNS 查詢（或者回應）所以我們只需要透過 <code>Resolv::DNS::Message</code> 的 <code>#decode</code> 去解析就可以知道內容了！</p><blockquote><p>比較痛苦的大概是 <code>Resolv::DNS</code> 本身是 Class 所以無法用 <code>include</code> 進來使用，要打很長 Class Name XD</p></blockquote><p>我們稍微調整讀取封包的程式，改成這個樣子</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mdns = MDNS.new</span><br><span class="line">mdns.each <span class="keyword">do</span> <span class="params">|packet, _addr|</span></span><br><span class="line">  ap Resolv::DNS::Message.decode(packet)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>執行後就可以看到 <code>Resolv::DNS::Message</code> 物件被產生，然後裡面包含了各種類型的 DNS 查詢。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&lt;Resolv::DNS::Message:0x00007ff3dc0b8420 <span class="doctag">@id</span>=0, <span class="doctag">@qr</span>=0, <span class="doctag">@opcode</span>=0, <span class="doctag">@aa</span>=0, <span class="doctag">@tc</span>=0, <span class="doctag">@rd</span>=0, <span class="doctag">@ra</span>=0, <span class="doctag">@rcode</span>=0, <span class="doctag">@question</span>=[[#&lt;Resolv::DNS::Name: _airplay._tcp.local.&gt;, Resolv::DNS::Resource::Generic::Type12_Class32769]], <span class="doctag">@answer</span>=[[#&lt;Resolv::DNS::Name: _airplay._tcp.local.&gt;, 4487, #&lt;Resolv::DNS::Resource::IN::PTR:0x00007ff3de822790 <span class="doctag">@name</span>=#&lt;Resolv::DNS::Name: \xE8\x87\xA5\xE5\xAE\xA4._airplay._tcp.local.&gt;, <span class="doctag">@ttl</span>=4487&gt;]], <span class="doctag">@authority</span>=[], <span class="doctag">@additional</span>=[]&gt;</span></span><br><span class="line"><span class="comment">#&lt;Resolv::DNS::Message:0x00007ff3de820ff8 <span class="doctag">@id</span>=0, <span class="doctag">@qr</span>=0, <span class="doctag">@opcode</span>=0, <span class="doctag">@aa</span>=0, <span class="doctag">@tc</span>=0, <span class="doctag">@rd</span>=0, <span class="doctag">@ra</span>=0, <span class="doctag">@rcode</span>=0, <span class="doctag">@question</span>=[[#&lt;Resolv::DNS::Name: _airplay._tcp.local.&gt;, Resolv::DNS::Resource::IN::PTR]], <span class="doctag">@answer</span>=[[#&lt;Resolv::DNS::Name: _airplay._tcp.local.&gt;, 4486, #&lt;Resolv::DNS::Resource::IN::PTR:0x00007ff3dc0e3198 <span class="doctag">@name</span>=#&lt;Resolv::DNS::Name: \xE8\x87\xA5\xE5\xAE\xA4._airplay._tcp.local.&gt;, <span class="doctag">@ttl</span>=4486&gt;]], <span class="doctag">@authority</span>=[], <span class="doctag">@additional</span>=[]&gt;</span></span><br></pre></td></tr></table></figure><p>不過有些是查詢，有些則是回應，我們先把回應區分出來。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mdns = MDNS.new</span><br><span class="line">mdns.each <span class="keyword">do</span> <span class="params">|packet, _addr|</span></span><br><span class="line">  message = Resolv::DNS::Message.decode(packet)</span><br><span class="line">  <span class="keyword">next</span> <span class="keyword">if</span> message.qr.zero?</span><br><span class="line"></span><br><span class="line">  ap message</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在 <code>Resolve::DNS::Message</code> 物件上有一個叫做 <code>qr</code> 的屬性，當他是 0 的時候表示這是一個「查詢」而 1 的時候，就是回應，所以只需要排除是 0 的訊息。</p><h2 id="根據-DNS-SD-篩選出-Airplay-Chromecast-裝置"><a href="#根據-DNS-SD-篩選出-Airplay-Chromecast-裝置" class="headerlink" title="根據 DNS-SD 篩選出 Airplay / Chromecast 裝置"></a>根據 DNS-SD 篩選出 Airplay / Chromecast 裝置</h2><p>首先我們要先搞懂幾個 DNS-SD 的規則，才能夠找到我們希望找到的資訊。</p><ol><li>DNS-SD 的 FQDN 結構</li><li>DNS-SD 會使用的 Record</li></ol><p>關於 FQDN 結構，我們會看到三種</p><ol><li>&lt; Service &gt;.&lt; Domain &gt;</li><li>&lt; Instance &gt;.&lt; Service &gt;.&lt; Domain &gt;</li><li>&lt; Hostname &gt;</li></ol><p>扣掉第三種不算，因為他就是 Host Name 之外，以 Airplay 裝置會這樣表示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_airplay._tcp_.local</span><br></pre></td></tr></table></figure><p>基本上在區網使用 <code>.local</code> 是必然的，然後 <code>_tcp</code> 暴露出了他是透過 TCP 連線，而 <code>_airplay</code> 就是這個服務的類型。</p><p>以我的房間為例，我有一台 Sonos One 音響叫做「臥室」那在 mDNS 中就可以查到 <code>臥室._airplay._tcp.local</code> 這個 DNS 紀錄。</p><p>至於會用到的 DNS Record 則有四種</p><ol><li>PTR (Pointer Record)</li><li>SRV (Service Record)</li><li>A (Address Record)</li><li>TXT (Text Record)</li></ol><p>簡單說 PTR 是一個指標，他會回應一個 Instance 給我們，讓我們知道該去問誰要這個 Service 的資訊，而 SRV / TXT 則提供了這個 Service 的 Port &amp; Hostname 資訊，以及一些 Metadata 讓我們可以了解這個服務。</p><p>最後 A (or AAAA) 則會在我們詢問 Hostname 時回應區網的 IP 位置，讓我們知道該連到哪裡。</p><blockquote><p>這個機制看起來很聰明，有興趣的話可以參考 Spotify 的 <a href="https://labs.spotify.com/2017/03/31/spotifys-lovehate-relationship-with-dns/" rel="external nofollow noopener noreferrer" target="_blank">DNS-SD</a> 文章，跟這個其實很像。</p></blockquote><p>所以整體流程會變成像這樣</p><ol><li>詢問 <code>PTR _airplay._tcp.local</code> 獲得 <code>_airplar._tcp.local PTR 臥室._airplay_.tcp.local</code> 的回答</li><li>詢問 <code>SRV 臥室._airplay_.tcp.local</code> 獲得 <code>臥室._airplay_.tcp.local SRV 0 0 7000 Sonos-0xAF.local</code> 的回答</li><li>詢問 <code>A Sonos-0xAF.local</code> 獲得 <code>Sonos-0xAF.local A 172.31.1.166</code> 的回答</li></ol><p>基於這些情報，我們可以彙整出：</p><ol><li>有一個裝置叫做「臥室」</li><li>IP 位置是 <code>172.31.1.166</code></li><li>使用 7000 Port 可以和他建立連線</li></ol><p>那麼，我們稍微調整一下程式碼讓我們可以拿到 PTR 來顯示詳細資訊。</p><blockquote><p>DNS-SD 的 <a href="https://tools.ietf.org/html/rfc6763" rel="external nofollow noopener noreferrer" target="_blank">RFC6763</a> 提到回應 PTR 時要把 SRV / TXT / A 都一起回覆，理論上我們是不太需要重複詢問 SRV / TXT / A 的，不過因為除了 PTR 會把 TTL 設定的比較長，其他都會設定為短時間，好在一段時間後確認 IP 是否有變動之類的。</p></blockquote><p>我們先稍微重構一下，讓 <code>MDNS</code> 可以指篩選出我們有興趣的 PTR Record 回應給我們。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># :nodoc:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MDNS</span></span></span><br><span class="line">  <span class="keyword">include</span> Enumerable</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 略</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">listen</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> @thread</span><br><span class="line"></span><br><span class="line">    @thread = Thread.new <span class="keyword">do</span></span><br><span class="line">      loop <span class="keyword">do</span></span><br><span class="line">        packet, = @socket.recvfrom(<span class="number">4096</span>)</span><br><span class="line">        reply = Resolv::DNS::Message.decode(packet)</span><br><span class="line">        <span class="keyword">next</span> <span class="keyword">if</span> reply.qr.zero?</span><br><span class="line">        <span class="keyword">next</span> <span class="keyword">if</span> ptr?(reply)</span><br><span class="line"></span><br><span class="line">        @replies &lt;&lt; reply</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">each</span><span class="params">(&amp;_block)</span></span></span><br><span class="line">    loop <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">yield</span> @replies.shift <span class="keyword">until</span> @replies.empty?</span><br><span class="line">      sleep <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  private</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">ptr?</span><span class="params">(reply)</span></span></span><br><span class="line">    reply.answer.reduce(<span class="literal">true</span>) <span class="keyword">do</span> <span class="params">|prev, (_, _, data)|</span></span><br><span class="line">      prev &amp; data.is_a?(Resolv::DNS::Resource::IN::PTR)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">mdns = MDNS.new</span><br><span class="line">mdns.listen</span><br><span class="line">mdns.each <span class="keyword">do</span> <span class="params">|reply|</span></span><br><span class="line">  reply.each_answer <span class="keyword">do</span> <span class="params">|name, _, _|</span></span><br><span class="line">    ap name</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>執行後會獲得類似這樣的的訊息，因為 PTR 回應的是 Instance Name 所以是預期的結果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#&lt;Resolv::DNS::Name: 臥室._airplay._tcp.local.&gt;</span><br><span class="line">#&lt;Resolv::DNS::Name: Sonos-7828CAC4542C.local.&gt;</span><br><span class="line">#&lt;Resolv::DNS::Name: 7828CAC4542C@臥室._raop._tcp.local.&gt;</span><br></pre></td></tr></table></figure><p>如此一來，我們只要稍加修改就可以篩選出是提供 Airplay / Chromecast 的裝置。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Airplay 有兩種</span></span><br><span class="line">airplay = Resolv::DNS::Name.create(<span class="string">'_airplay._tcp.local.'</span>)</span><br><span class="line">raop = Resolv::DNS::Name.create(<span class="string">'_raop._tcp.local.'</span>)</span><br><span class="line"><span class="comment"># Chromecast</span></span><br><span class="line">chromecast = Resolv::DNS::Name.create(<span class="string">'_googlecast._tcp.local.)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mdns.each do |reply|</span></span><br><span class="line"><span class="string">  reply.each_answer do |name, _, _|</span></span><br><span class="line"><span class="string">    next unless name.subdomain_of?(airplay)</span></span><br><span class="line"><span class="string">    next unless name.subdomain_of?(raop)</span></span><br><span class="line"><span class="string">    next unless name.subdomain_of?(chromecast)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    ap name</span></span><br><span class="line"><span class="string">  end</span></span><br><span class="line"><span class="string">end</span></span><br></pre></td></tr></table></figure><blockquote><p>另外我們可以透過 <code>reply.each_addationial</code> 獲取更多資訊，不過可惜的是 <code>Resolv::DNS::Message</code> 在解析時可能因為某些關係只能知道他是 <code>PTR</code> 但是無法正確解析，就會獲得 <code>Generic::Type12_XXXX</code> 這種類型的物件，反而不好處理。</p></blockquote><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>在做這個技術測試的時候，發現蠻多情境下大家都是串 C API 然後去呼叫作業系統提供的 DNS-SD 機制來實作，不過在了解原理的狀況下，其實我們還是可以靠純 Ruby 的方式實現一定程度的 DNS-SD 機制。</p><p>那麼，這個技術有什麼用途嗎？在五倍的 IoT 專案 <a href="https://tamashii.io" rel="external nofollow noopener noreferrer" target="_blank">Tamashii</a> 當時因為裝置很多的關係，我們就有研究過透過 DNS-SD 去找到區網內的裝置，然後讓他能夠一次性的套用或者修改設定，不過礙於各種因素就暫時沒有把他實作出來。</p><p>這次重新審視之後發現其實還是非常有用的，近期應該會更新一個在 Tamashii 專案下可以使用的 DNS-SD Gem 吧！</p><blockquote><p>礙於篇幅，其實還有下篇 - 偽裝成 Airplay 裝置的系列，不過就先到這裡告一段落吧！</p></blockquote>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/12/25/Use-Ruby-to-find-the-Airplay-or-Chromecast-device/#disqus_thread</comments>
    </item>
    
    <item>
      <title>為什麼要學習 Bootstrap 呢？</title>
      <link>https://blog.frost.tw/posts/2018/11/27/Why-we-choose-the-Bootstrap/</link>
      <guid>https://blog.frost.tw/posts/2018/11/27/Why-we-choose-the-Bootstrap/</guid>
      <pubDate>Tue, 27 Nov 2018 13:07:50 GMT</pubDate>
      <description>
      
        &lt;p&gt;最近在工作上或者跟有在做網站開發的朋友聊天，都剛好會討論到 &lt;a href=&quot;https://getbootstrap.com/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Bootstrap&lt;/a&gt; 這個 CSS 框架。&lt;/p&gt;&lt;p&gt;在業界，我想大部分的公司也大多會以 Bootstrap 為基礎來開發網站，而這幾年網路上可以買到的版型也多以 Bootstrap 為主。&lt;/p&gt;&lt;p&gt;從這些跡象看起來，會使用 Bootstrap 很重要，中間的過程跟原因是什麼呢？&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>最近在工作上或者跟有在做網站開發的朋友聊天，都剛好會討論到 <a href="https://getbootstrap.com/" rel="external nofollow noopener noreferrer" target="_blank">Bootstrap</a> 這個 CSS 框架。</p><p>在業界，我想大部分的公司也大多會以 Bootstrap 為基礎來開發網站，而這幾年網路上可以買到的版型也多以 Bootstrap 為主。</p><p>從這些跡象看起來，會使用 Bootstrap 很重要，中間的過程跟原因是什麼呢？</p><a id="more"></a><h2 id="很久以前"><a href="#很久以前" class="headerlink" title="很久以前"></a>很久以前</h2><p>最早的時候，我們在製作網頁大多還是透過像是 <code>&lt;table&gt;</code> 跟 <code>float: left</code> 等等變化去組合網頁，當時其實大多沒什麼概念，能跟後端的程式搭配起來就好了。</p><p>像是 PHP 早期就會將 HTML 和 PHP 混合在一起撰寫，而很多程式語言最初也都是用類似的方式動態的組合 HTML 並且將它輸出到網頁上。</p><p>不過，當專案越來越大的時候，這看起來就不太好維護了！</p><h2 id="樣板引擎"><a href="#樣板引擎" class="headerlink" title="樣板引擎"></a>樣板引擎</h2><p>像是 Ruby 中有 <code>ERB</code>、<code>slim</code> 可以使用，或者 PHP 有 <code>Twig</code>、<code>Smarty</code> 等等，為了能將程式的邏輯部分跟顯示的部分分離出來，開始出現了樣版引擎這種類型的工具，讓我們可以將工作區分為負責邏輯部分以及顯示部分兩個區塊，只要數值能對應起來，就可以正常顯示。</p><blockquote><p>此時，都還是後端工程師在製作這些網頁，沒有前後端之分。</p></blockquote><h2 id="JavaScript-的時代"><a href="#JavaScript-的時代" class="headerlink" title="JavaScript 的時代"></a>JavaScript 的時代</h2><p>大概在 Gmail 使用了 Ajax 技術之後，大家開始注意到網頁的可能性。透過 JavaScript 以及各種 CSS/HTML 組合的技巧，網頁開始豐富了起來。</p><p>這也為之後的 HTML5 發展揭開了序幕。</p><h2 id="分工的變化"><a href="#分工的變化" class="headerlink" title="分工的變化"></a>分工的變化</h2><p>我們從將 HTML 和程式混合在一起，發展到了樣版引擎，又發展到了更加複雜且豐富的 HTML5 時代，原本簡單的 HTML 也變得不簡單，也因此我們需要耗費更多力氣在 HTML 和 CSS 上，這也是前端被切割出來的原因之一。</p><blockquote><p>最早的時候大概只會分設計跟後端而已，而且設計給的圖片就由後端想辦法實現。</p></blockquote><h2 id="互相卡住的分工"><a href="#互相卡住的分工" class="headerlink" title="互相卡住的分工"></a>互相卡住的分工</h2><p>當我們有了設計、前端跟後端，分工變的精細，卻也因此被其他人的工作進度卡住。因為後端總是要等前端提供可操作的網頁，整合到後端上才能夠進行測試。而前端又需要等待設計提供設計圖，才能夠依照設計圖切出對應的版型。</p><p>所以這個分工組合剛開始出現時，我們很容易就變成「等設計」「等前端」再「等後端」的流程，讓效率變得非常差。</p><p>以前我也常思考能不能優化這個流程，而這也是當時大家偶爾會思考到的問題，一些大公司到底有什麼作法呢？我們也不一定有機會知道。</p><h2 id="標準化"><a href="#標準化" class="headerlink" title="標準化"></a>標準化</h2><p>不過同時間，設計跟前端的工作量也逐漸變大，而且 UX 的意識也逐漸出現，為了應對這些問題，我們開始看到一些大公司整理了 Design Pattern（不是程式上的，是 UI 設計上的模式）來將常見的網頁排版歸納。</p><p>基於這樣的的改念，我們開始看到了「元件化」概念的出現，而 Bootstrap 從這樣的時空背景下，將 Twitter 製作網站的 UI 元件搜集起來，基於這樣的概念，我們發現了一個重要的事情。</p><h2 id="缺少的東西"><a href="#缺少的東西" class="headerlink" title="缺少的東西"></a>缺少的東西</h2><p>Bootstrap 提供了我們以往很少完整規劃的 UI 元件組合，而大家也開始注意到如果有一個統一的「標準」不論是設計、前端或者後端，我們都能夠在不互相干擾的前提之下「同時作業」</p><p>以設計的工作來看，設計只要能夠提供與 Bootstrap UI 元件對應的樣式風格，即使再怎麼調整或者修改，前端都有辦法在不影響原有的進度下，根據設計提供的元件繼續的擴充或者修改。</p><p>而後端要測試系統的操作，也只需要使用符合 Bootstrap 規範的 HTML 結構即可，在未來只要由前端調整或者直接使用，那麼就可以使用。</p><p>有了這樣的機制，我們就能夠減少很多溝通跟調整的時間成本，進而專注在自己應該專注的任務上。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>簡單的從網頁的發展的幾個里程碑變化來看 Bootstrap 的出現原因就能夠大概發現他的優點，其實最近工作上也有遇到客戶的前端切版出來後因為不是使用 Bootstrap 而切版的方式幾乎是換一頁就無法重複利用元件，反而造成困擾的狀況。雖然問題不是出在沒有使用 Bootstrap 上，但是不完整的元件切割跟高度耦合頁面呈現，都讓開發人員在套用版型上遇到了很大的困難，反而讓效率下降很多。</p><p>實際上使用 Bootstrap 並不是重要的關鍵，像是 Material UI 也是可以採用的選項，不過因為 Bootstrap 已經非常普及，再加上大部分的人都能夠使用，所以在開發專案有時程壓力的情況下，使用 Bootstrap 大多是容易調整跟減少溝通時間的最佳方案。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/11/27/Why-we-choose-the-Bootstrap/#disqus_thread</comments>
    </item>
    
    <item>
      <title>轉職工程師：尋找自己的價值</title>
      <link>https://blog.frost.tw/posts/2018/11/06/Become-a-programmer-Find-your-own-value/</link>
      <guid>https://blog.frost.tw/posts/2018/11/06/Become-a-programmer-Find-your-own-value/</guid>
      <pubDate>Tue, 06 Nov 2018 12:55:40 GMT</pubDate>
      <description>
      
        &lt;p&gt;這系列的文章已經稍微討論過我自己在學習寫程式過程中的&lt;a href=&quot;https://blog.frost.tw/posts/2018/09/25/Become-a-programmer-lose-at-the-starting-line/&quot;&gt;心態&lt;/a&gt;、&lt;a href=&quot;https://blog.frost.tw/posts/2018/10/02/Become-a-programmer-how-to-start/&quot;&gt;方法&lt;/a&gt;跟&lt;a href=&quot;https://blog.frost.tw/posts/2018/10/23/Become-a-programmer-Why-is-bottleneck-coming-very-soon/&quot;&gt;困難&lt;/a&gt;，最後就來討論最後一個我認為很重要的問題。&lt;/p&gt;&lt;p&gt;不論學了什麼，或者有多麽厲害的技術，作為一個工程師我們的價值在哪裡？&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>這系列的文章已經稍微討論過我自己在學習寫程式過程中的<a href="https://blog.frost.tw/posts/2018/09/25/Become-a-programmer-lose-at-the-starting-line/">心態</a>、<a href="https://blog.frost.tw/posts/2018/10/02/Become-a-programmer-how-to-start/">方法</a>跟<a href="https://blog.frost.tw/posts/2018/10/23/Become-a-programmer-Why-is-bottleneck-coming-very-soon/">困難</a>，最後就來討論最後一個我認為很重要的問題。</p><p>不論學了什麼，或者有多麽厲害的技術，作為一個工程師我們的價值在哪裡？</p><a id="more"></a><h2 id="殘酷的問題"><a href="#殘酷的問題" class="headerlink" title="殘酷的問題"></a>殘酷的問題</h2><p>有時候，可能會想到一些在網路上看過或者似乎很已明的人，可能會有點嫉妒「明明沒什麼能力為什麼待遇這麼好？」「他只是運氣好而已吧！」「他只是靠關係而已！」之類的，我們越思考這個問題，就開始覺得有很多人「條件比自己差」但是總是能能拿到比自己好的待遇。</p><p>所以，問題真的是自己「能力」差的關係嗎？忘記從什麼時候開始，我偶爾會思考這個問題。</p><p>很可惜，在「業界」能力雖然很重要，但是偏偏不是「唯一」的條件。</p><blockquote><p>還有一些人是很擅長包裝自己，不過這篇文章不討論，因為我也不太清楚那是怎麼運作的。</p></blockquote><h2 id="應該扮演的角色"><a href="#應該扮演的角色" class="headerlink" title="應該扮演的角色"></a>應該扮演的角色</h2><p>以在五倍來說，在很多外面的活動如果被老闆們介紹，常常會聽到老闆說「我們家的工程師都比老闆厲害」這樣的話，在五倍老闆（甚至負責行政的同事）幾乎全部的人都懂程式，但是為什麼會這樣介紹呢？</p><p>單純就技術面來說，老闆們確實在像是「開會」的這些日常任務中慢慢失去了可以磨練技術的機會。但是對五倍這間公司重要的是什麼？公司的案源、人脈，還有面對客戶的壓力等等問題，都是由「老闆」這個角色負責的，所以能力真的很重要嗎？</p><p><strong>要看你現在是什麼角色</strong></p><p>我從小就確定我不適合當「領導者」這個角色，如果是小團隊的話我倒是有自信讓一個團隊發揮出更好的成果，但是如果是一個大的組織，我認為我是不適合帶領一大群人的。</p><p>所以我給自己的角色是一個「輔助者」的角色，儘可能的讓被支援的人可以安心的去專注在他應該專注的事情上，以我的工作來說，我要做的就是儘可能地去改善開發上的環境跟方法，讓公司能有更多的選擇。</p><blockquote><p>有機會我就會去嘗試一些新的東西，像是 CI/CD 的建立、一些針對工程師的輔助和管理的工具等等，或者是在部署上的嘗試，因為不知道什麼時候可能會需要用到，必要的時候也能夠過類似的概念去推測對應的方案。</p></blockquote><p>其實這些事情誰來做都可以，只不過⋯⋯</p><p><strong>對你來說，你認為值不值得做？</strong></p><h2 id="失去還是得到？"><a href="#失去還是得到？" class="headerlink" title="失去還是得到？"></a>失去還是得到？</h2><p>以前和人聊過，如果把一些東西「自動化」之後，原本自己負責的工作就會變得輕鬆。那麼就有可能失業或者被安排更多的工作，那麼「自動化」到底是好還是不好呢？</p><p>像是前陣子因為人工智慧的發展，開始能夠自動的寫程式，就有人就開始提出「未來工程師會失業」之類的像法，或者像是淘寶這幾年用人工智慧製作廣告橫幅的技術好了，設計師或工程師真的會失業嗎？</p><p>週末在 Netflix 上看了一部叫做「機械拳擊（Megalo Box）」的動畫，在主角爭奪進入決賽的資格時，對上的就是人工智慧的拳擊裝甲，但是即使人工智慧能夠預測所有的動作，當他碰到預期之外的事情時，他就無法做出反應。</p><p>而裡面總是回提到一句話「在擂台上，只有真的能留下來」</p><p>所以，我實際上是不擔心，也不害怕我去做這些工具、自動化的輔助，會影響我在工作上的待遇或者工作的內容，對工作來說，我的想法也挺簡單的。</p><p><strong>得到多少待遇，就付出多少力氣</strong></p><p>所以當我有能力創造這些工作加速我的工作時，我應該是期待我的待遇會被提高才對吧？因為我能比其他人負擔更多任務，也就表示我在一個團隊裡面「更重要」</p><p>另一方面，即使我把這些東西設定和配置出來，也不代表在缺少我的情況下這些工具是能使用的。</p><blockquote><p>大家有沒有碰過一些接過來的專案，所有人都是照著使用，但是卻沒有人知道最初是怎麼用的？而原作者可能還已經離職很久了，這個東西其實處於隨時都可能突然無法用的狀態。</p></blockquote><p>就像我配置的 CI 設定好了，雖然大部分的專案都能複製過去使用，但是每個專案的細微差距，其實在不同專案間因為沒有調整而有些微的問題，但有在使用的同事都沒有注意到（最後是我自己找出來）</p><p><strong>改善自己跟同事的工作環境，不會是件壞事</strong></p><blockquote><p>另一個角度想，某件事情都是你在負責，已經嚴重干擾自己日常的工作。把他教給同事跟自動化，是改善工作的品質的一種手段，而且能讓你更專心在該做的事情上。</p></blockquote><h2 id="你需不需要夥伴？"><a href="#你需不需要夥伴？" class="headerlink" title="你需不需要夥伴？"></a>你需不需要夥伴？</h2><p>以前我覺得我「自己」就能夠做到所有的事情，什麼事情都「自己來」就可以了。畢竟從後端、前端或者設計、管理以及其他相關的知識，我都學過，也都建立了一個基本的概念。</p><p>不過，如果只是一個小專案，自己來是沒有問題的。但是現在是一個稍微有點規模的專案呢？即使動作再快，方法再好，也跟不上需求，所以你總是會需要夥伴。</p><p><strong>在一個團隊，只追求自己的進步效果是很差的</strong></p><p>如果你待的是一間很好的公司，最後選擇離開的理由通常會是什麼？我認為大多會是待遇和同事跟不上你的進步，所以你必須去換一個更好的公司。</p><p>但是如果這是一間夠好的公司，同事跟待遇都還不錯，如果發現同事跟待遇都要跟不上自己的話，我該做什麼事情？</p><p><strong>讓這個團隊成長</strong></p><p>程式語言社群其實就是一個例子，只要還有人希望這個語言成長、有人使用，那麼就會開始分享、舉辦活動。這也是我很喜歡找同事聊技術（即使同事可能不想！？）或者參加研討會去分享我知道的東西，因為只有創造一個良性的循環，我們才有機會繼續互相讓對方成長。</p><blockquote><p>而且收到回饋的時候，會發現有更多有趣的事物可以去探索。</p></blockquote><h2 id="自身的價值"><a href="#自身的價值" class="headerlink" title="自身的價值"></a>自身的價值</h2><p>不論是在玩遊戲，或者是在工作上，我想不管是誰都希望自己「被信任」所以老闆/組長才會放心的把工作交給你，而我們的責任就是把工作做好、完成。</p><p>在五倍我也是很相信同個專案的同事，無關能力或者其他東西，我認為一起工作的夥伴都會把工作做好為前提，如果真的做的不理想，那麼就來討論為什麼會這樣，要怎麼改善就好。</p><p>所以，得到的待遇跟期待，有時候無關能力，還跟態度有關係。</p><p>就像<a href="https://blog.frost.tw/posts/2018/09/10/How-to-choose-your-first-job/">怎麼選第一篇工作？</a>和<a href="https://blog.frost.tw/posts/2018/05/14/About-my-first-time-interview-and-resume/">我怎麼準備履歷</a>兩篇文章，我都提出「態度」的問題。</p><p>我設定給自己的角色是一個「輔助」的角色，而且我相信同事跟老闆應該都是「信任」我會把事情做好，所以才會請我協助的。</p><blockquote><p>提升能力對我來說確實是重點，但是在能力之外，我還是會注意我自己的態度是不是正確，或者有沒有要改善的地方。</p></blockquote><p>偶爾有人會問我說「以你現在這樣的能力，這個待遇是不是太低了？」我雖然會想一下，但是其實並沒辦法做出一個適當的回答，一方面是我認為我的表現老闆都看得到。另一方面是我知道我自己還有很多地方做不好，像是有時候會對一些問題因為定義上很糾結，反而卡住跟客戶討論的進度，或者不太能掌握該提出什麼比較適合。</p><p><strong>能力只是一種手段可以靠學習，但是人格特質需要細心培養</strong></p><p>所以不要覺得上了課就能順利成為工程師，也不要覺得能力很強了就可以拿到好的待遇。因為我們的問題很可能「不在能力」上面。</p><blockquote><p>其實工程師的職缺也不難拿到，還是很常聽到有人在找工程師。只不過作為一個工程師之外，是不是還需要有其他人格上的要素去配合，才能擔任好這個角色？</p></blockquote><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>雖然文章提到了除了個人能力以外，扮演什麼角色也很重要。還有一個我「不擅長」也「不喜歡使用」的方式，那就是讓自己變得出名（包裝自己）。這不是一件壞事，只是要看運用得恰不恰當就是了，至少在我知道的人們裡面，有惡名昭彰的，也有我認為做得非常好我學不來的。</p><p><strong>太多出名的人都是過度包裝的</strong></p><p>如果是因為做事做得好（像是教學、熱心參與社群）而變得出名，那當然是令人尊敬的。不過現實上，程式圈我們總是會看到一些「沒有什麼實力」的人被很多人吹捧，然後因為支持者眾多，有很難提出反面的意見，反而讓很多可以思考跟討論的問題剩下一個唯一的答案。</p><p>雖然不知道是不是錯覺，其實我個人感覺這幾年很多真正的高手都像是隱居起來，然後一些社團之類的混亂，就這樣繼續亂下去⋯⋯（也許是真的回到累了，所以放手了吧 XD）</p><p>所以比起這些方式，我比較喜歡慢慢累積，隨著時間體現（累積）自己的價值。</p><blockquote><p>寫文章、分享、參與社群活動，其實很累，不過也是一種累積的方式。</p></blockquote>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/11/06/Become-a-programmer-Find-your-own-value/#disqus_thread</comments>
    </item>
    
    <item>
      <title>轉職工程師：為什麼馬上就遇到瓶頸？</title>
      <link>https://blog.frost.tw/posts/2018/10/23/Become-a-programmer-Why-is-bottleneck-coming-very-soon/</link>
      <guid>https://blog.frost.tw/posts/2018/10/23/Become-a-programmer-Why-is-bottleneck-coming-very-soon/</guid>
      <pubDate>Tue, 23 Oct 2018 12:49:47 GMT</pubDate>
      <description>
      
        &lt;p&gt;前面已經討論了&lt;a href=&quot;https://blog.frost.tw/posts/2018/09/25/Become-a-programmer-lose-at-the-starting-line/&quot;&gt;起步的心態&lt;/a&gt;跟&lt;a href=&quot;https://blog.frost.tw/posts/2018/10/02/Become-a-programmer-how-to-start/&quot;&gt;起步的方法&lt;/a&gt;兩個問題，好不容易開始寫程式了，卻發現⋯⋯&lt;/p&gt;&lt;p&gt;&lt;strong&gt;照著教學做，但是沒有教學就完全不會&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;不管是去上更多的課，還是看更多的教學，怎麼樣都無法擺脫這個問題。這到底是什麼原因呢？&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>前面已經討論了<a href="https://blog.frost.tw/posts/2018/09/25/Become-a-programmer-lose-at-the-starting-line/">起步的心態</a>跟<a href="https://blog.frost.tw/posts/2018/10/02/Become-a-programmer-how-to-start/">起步的方法</a>兩個問題，好不容易開始寫程式了，卻發現⋯⋯</p><p><strong>照著教學做，但是沒有教學就完全不會</strong></p><p>不管是去上更多的課，還是看更多的教學，怎麼樣都無法擺脫這個問題。這到底是什麼原因呢？</p><a id="more"></a><h2 id="學會使用"><a href="#學會使用" class="headerlink" title="學會使用"></a>學會使用</h2><p>在剛入門的階段，或者我在教人的時候，最初的階段我會希望「即使有問題也先不要問」我們先專注在一個事情上，那就是「熟練」</p><p>熟練什麼？以 Ruby 和 Rails 來舉例子，就是先要做到 Ruby 大部分的語法都可以不用查資料或者問題之類的，還有就是像 Rails 的一些基本的操作都能夠使用。</p><p>這樣一來，你在後續提問或者去找答案的時候才會有一種感覺。</p><p><strong>這個東西我知道，原來是因為這樣！</strong></p><p>舉例來說，如果一個寫 Ruby 的工程師連下面這段程式都還不太清楚會發生什麼事情，那麼去思考原理就還太早了。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].each <span class="keyword">do</span> <span class="params">|num|</span></span><br><span class="line">  puts num</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><blockquote><p>上述的程式即使你不清楚 <code>[]</code> <code>each</code> <code>do ... end</code> 是做什麼用的，至少也要有能力執行它發現會顯示出數字，或者根據過去操作的經驗推測他可能出現一些數字。</p></blockquote><p>當然，上面的舉例其實很基本，大部分的人在學到的時候應該都已經隱約了解一些原理了。</p><blockquote><p>其實一個課程或者教材的好或者不好，就看他是不是都只局限在這個階段，如果都給你一些反覆操作就能做出來的東西，那麼你就會覺得「卡住」跟「好像還是什麼都不會」</p></blockquote><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>既然我們已經對一些基本的程式有一些概念，接下來去探討原理或者「理由」之類的問題就會比較好理解跟上手。</p><p>我有時候會思考，我理解的「藍色」跟其他人的「藍色」是不是一樣的。不過因為沒辦法讀取別人的想法，所以我只能簡單的假設，因為看到的「藍色」是相同的東西，所以我們對藍色的理解應該是接近的。</p><blockquote><p>其實這是一個很有趣的問題，那麼當色盲遇到同樣的顏色分不出來，我們的理解還是相同的嗎？</p></blockquote><p>同樣的道理可以證明，為什麼在「初學」的階段先不要對各種「新事物」想要有太多的解答，因為這些知識就有點類似遊戲的關卡解鎖一樣，需要到某個程度的理解，才能夠繼續。</p><p><strong>如果現在不懂，去學點其他的東西，再回來看一遍</strong></p><p>從上面的程式來說，裡面用到了叫像是「陣列」「迴圈」「迭代器」這些概念，如果前面兩個無法瞭解的話，就很難對「迭代器」有概念，就會對 <code>each</code> 的原理有困難，而 <code>each</code> 的真正運作，又會跟 Ruby 語言特性的 Block （區塊）也就是 <code>do ... end</code> 有關係。</p><p>所以在第一次接觸新的寫法（即使是複雜的寫法）我都會打開電腦，然後試著寫出來看看，去檢測他的運作邏輯是怎樣的，在嘗試去理解背後的原理。</p><p>像是在 C 語言裡面關於陣列的儲存其實又跟「指標」是有關係的，如果理解了指標的概念，就會對陣列有更深入的了解，近一步的對迭代器的運作又會有新的認識。</p><p>透過這樣不斷的「擴充」知識，我們就能夠逐漸的對一個程式語言越來越了解，並且能夠組織更加複雜的專案。</p><p>關於這個階段，其實我猜我在教人的時候有時候可能會覺得我很兇是因為我常常會拿著程式碼然後問「你覺得這是怎樣的？」「這是什麼意思？」</p><p>其實我是在確認一個問題，就是對方是否「把知識連接起來」如果問了完全回答不出來，那麼就表示說要再往回退，找到一個適合的點把概念串接起來，才能夠順利繼續。</p><blockquote><p>所以有些工程師討論東西像在吵架⋯⋯</p></blockquote><p>另外一個有趣的地方是我以前常常會「塞」很多東西給新手，大概可以介紹個一兩小時這樣。然後就會被對方回答說「我回去再看看⋯⋯」然後就沒下文了，大概是被嚇到吧，或是消化需要花很多時間。</p><p>其實不管哪個領域都是這樣，我們很多時候都覺得自己（應該）很專業但是實際上如果發現自己連「舉例」都舉不出來，真的就不要有幻覺了⋯⋯</p><blockquote><p>上週五才跟同事討論 3D 建模的問題，因為他在讀碩班老師讓他選。我就簡單介紹了我在大學讀多媒體的知識，其實光是我這樣「皮毛」的東西，仔細想想可能就要花上一兩年練習了，所以我是建議不要選這塊比較不熟的。<br>3D 建模除了要會軟體外，其實還要有繪畫（材質）跟攝影（光影）的基礎，才能做出好看的靜態模型，動起來就更困難了⋯⋯</p></blockquote><h2 id="以一化千，化繁為簡"><a href="#以一化千，化繁為簡" class="headerlink" title="以一化千，化繁為簡"></a>以一化千，化繁為簡</h2><blockquote><p>這個小標題感覺超中二的 XD</p></blockquote><p>有些人可能知道我從蠻小的時候就開始學寫程式，不過真正有明顯進步的其實也才五六年。在這之前，我其實花了大概五六年做一件事情——留言板。</p><p>當時能做出來的東西其實很少，也很簡單。做過最多次的東西就是留言板，而且我常常跟人這樣講。</p><p><strong>當你會做留言板，你就能做出大部分的網站</strong></p><p>以最簡單的留言板功能來看，其實就是一個 CRUD 的表現。</p><p>假設我們現在想將留言板進化，只需要這樣。</p><ol><li>留言功能</li><li>留言功能（複製） -&gt; 改名叫做分類</li><li>原本的留言功能增加設定分類</li></ol><p>當一個留言有了分類之後，就進化到了叫做「討論版」的等級。</p><p>所以，我們在更近一步的去改良一下。</p><ol><li>留言功能</li><li>留言功能（複製）-&gt; 改名叫做回覆</li><li>在回覆功能上增加設定目標留言</li></ol><p>現在討論板又進化成叫做「論壇」的東西。</p><p>所以，依照這個邏輯繼續做下去，理論上來說所有類型的網站都要可以實現。</p><p><strong>但是沒有想像的這麼簡單啊！</strong></p><p>如果我們要產生會員功能，還要檢查留言的權限才行，其實只是在加入了「判斷」的功能。</p><ol><li>留言功能</li><li>留言功能（複製）-&gt; 改名叫做會員，增加一些相關欄位（帳號密碼）</li><li>留言功能增加設定發表的會員</li></ol><p>然後再到編輯，原本是沒有限制的，這次只是增加上限制。</p><ol><li>編輯</li><li>（新增）檢查現在的會員是不是發表的會員</li><li>可以編輯</li></ol><p>所以，照這樣繼續發展下去，有更多的判斷跟資料檢查，就會慢慢構成一個完整的網站。</p><p>這就是「以一化千」也就是在理論上，我們應該能只用一種技巧做完所有事情。</p><blockquote><p>大致上來說就是邏輯判斷，還有迴圈的使用。</p></blockquote><p>如果把這些東西反過來看，當我們學習了各種五花八門的技巧，要怎麼樣用「最少的動作」做到「最多的事情」那就是「化繁為簡」的領域。</p><p>不過要接觸到這個世界，至少要很熟練才會漸漸的有感覺，我自己是在這一兩年才比較有一種「原來是這樣」的感覺。</p><blockquote><p>突破貧頸其實有時候就是練習量到了，就會有一種「好像懂了！」然後也能解釋的狀態。不過越到後面其實越痛苦，以前可能幾個月就能感覺到，現在一年可能只有一兩次 XD</p></blockquote><p>化繁為簡的入門就是「重構」的技巧，也就是我們怎麼從鬆散的程式碼變成一堆「函式」然後隨著函式的增加我們在繼續轉換成「物件」而大量的物件成變成一個「套件」（Ex. Ruby Gem）然後透過這些累積的套件在組成一個完整的「專案」</p><p>雖然在工作上我們都是從「專案」開始慢慢的重構出小段落，但是「變複雜」然後再「變簡單」就是作為一個專業工程師「專業表現」的一種。</p><blockquote><p>專業表現還有很多面向都會讓人覺得你很專業，不過這種能夠隨心所欲的重組程式的技巧，算是很基本也很容易看出程度的一種類型。越厲害的工程師在初始階段就能夠做到越好的拆分跟規劃，以整個系統等級的規劃來說，個人認為就是架構師（而且可能含包含了網路跟硬體層級等等的規劃）</p></blockquote><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>雖然每次結尾都覺得好像離題，不過我想大致上還是有在主題上（心虛）</p><p>其實「瓶頸」主要是因為「知識不足以支持繼續」的情況所造成的，通常我們學語言的時候會覺得自己要「深入」但是到了某個階段後就會發現無法繼續深入。</p><p>因為我們還缺少不少「電腦科學」的知識，這時候資訊相關科系的人真的是比較吃香。在這種情況，就可以考慮以「廣泛學習」的心態，去接觸不同的語言。</p><p>像是 Ruby / JavaScript 這類型的語言其實都沒有型別，那麼就去試試看有形別的語言。然後看看像是指標之類的東西，再回到 Ruby / JavaScript 上面思考，就會發現一些原本只寫一種語言看不到的東西。</p><p>另一方面就像是我們大多數都在學做「網站」都使用 Rails 來開發，但是有沒有試過用 Rack 直接架構網站伺服器？這些都會幫助對 Rails 的理解，因為有很多零碎的概念已經在很多高手的重構中一層一層的被隱藏起來。</p><p>所以，如果卡住的時候先不要緊張或者焦慮。先看看「還有什麼能做的？」然後去把那些「可以做沒做過」的事情做看看，也許再回到原本的問題，就會被解決了。</p><p>所以，那些厲害的高手或者身邊進步很快的朋友是不是都有一個類似的特點？</p><p><strong>常常做東西出來看看</strong></p><p>因為我們練習還不夠，所以卡住了，如果想進步快一點多花時間在「不一樣」的嘗試會更有效果。</p><blockquote><p>上一篇文章寫完被實習生問「努力不一定有效果」後來我想想，努力還是有效果，只是可能會有個人差異。另外還有一種可能，那就是練習的方式錯了，練習再多「會的東西」除了做出來比較快幾乎沒有幫助。</p></blockquote>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/10/23/Become-a-programmer-Why-is-bottleneck-coming-very-soon/#disqus_thread</comments>
    </item>
    
    <item>
      <title>客製化你樹莓派上運行的 Linux</title>
      <link>https://blog.frost.tw/posts/2018/10/09/Customize-a-linux-for-your-raspberrypi/</link>
      <guid>https://blog.frost.tw/posts/2018/10/09/Customize-a-linux-for-your-raspberrypi/</guid>
      <pubDate>Tue, 09 Oct 2018 13:29:53 GMT</pubDate>
      <description>
      
        &lt;p&gt;最近因為手邊有一個工作以外的專案需要搭配硬體做一些 IoT 類型的應用，雖然之前在五倍紅寶石開發的 Tamashii 系列應用已經足以應對在這個專案上開發所需的解決方案，但是依舊缺少了一些功能。&lt;/p&gt;&lt;p&gt;也就是我們過去並沒有考慮到的，如果裝置是交給一般使用者的狀況下，如何在透過網路的前提將裝置更新。&lt;/p&gt;&lt;p&gt;這是很多硬體都會有的功能，但是就目前而言 Tamashii 並不支援。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>最近因為手邊有一個工作以外的專案需要搭配硬體做一些 IoT 類型的應用，雖然之前在五倍紅寶石開發的 Tamashii 系列應用已經足以應對在這個專案上開發所需的解決方案，但是依舊缺少了一些功能。</p><p>也就是我們過去並沒有考慮到的，如果裝置是交給一般使用者的狀況下，如何在透過網路的前提將裝置更新。</p><p>這是很多硬體都會有的功能，但是就目前而言 Tamashii 並不支援。</p><a id="more"></a><p>經過幾天的調查，發現有一個 Open Source 的專案似乎符合條件。</p><h1 id="Mender-的-OTA-伺服器"><a href="#Mender-的-OTA-伺服器" class="headerlink" title="Mender 的 OTA 伺服器"></a>Mender 的 OTA 伺服器</h1><p>這個開源專案叫做 <a href="https://mender.io/" rel="external nofollow noopener noreferrer" target="_blank">Mender</a> 是透過好幾種程式語言組合而成，功能也很簡單。在預先製作好的 Linux 發行版本中寫入 Mender 伺服器的位置，只要在伺服器上「認證」這一台裝置，未來就能夠收到來自 Mender 伺服器所提供的更新。</p><p>而更新的方式基本上就是製作一份新的 Rootfs 提供給硬體裝置下載，並且嘗試將這個新的版本加入到現有硬體中，並且嘗試是否能夠正常的運行，如果失敗的話再將舊版的 Rootfs 載入。</p><p>也因此，要能夠使用 Mender 來發布 OTA (Over the Air）更新的話，就必須要能夠製作自己的 Linux 發行版本才可以。</p><h1 id="Yocto-專案"><a href="#Yocto-專案" class="headerlink" title="Yocto 專案"></a>Yocto 專案</h1><p>想要讓所有人都知道怎麼自己編譯完整的 Linux 作業系統是很困難的，從韌體、核心（Kernel）到各種開機所需要的套件庫（Library）等等，光是編譯的步驟就非常繁複，更何況還要配合使用不同開發版或者晶片的使用者。</p><p>所以 Mender 也採許了另一套開放原始碼的解決方案，叫做 Yocto 專案。這個專案跟另一個開源專案 OpenEmbedded 已經整合在一起，或者說能夠互通使用。</p><p>在 Yocto 之中，我們透過所謂的 Layer 的疊加就能夠製作出我們所需的 Linux 系統，而有很多硬體上所需要配合的韌體，也大多會有社群貢獻，因此在大部分的情況下都不太需要擔心。</p><blockquote><p>Mender 團隊也提供付費協助處理硬體整合上的問題，也許這是主要的收入之一？</p></blockquote><p>舉例來說，我想要製作一個能在 RaspberryPi 上面執行的 Linux 環境，就需要叫做 <code>meta-respberrypi</code> 這一個 Layer 來幫助我。</p><p>他會依賴於 <code>oe-core</code> 和幾個相關的 Layer 才能夠正確編譯（因為已經有的設定不用重複撰寫）</p><p>當我加入 <code>meta-raspberry</code> 之後，我在選擇編譯的機器類型時，就能夠用像是 <code>MACHINE=raspberrypi3</code> 這樣的模式告知我希望得到能在 Raspberry Pi 3 上執行的 Linux。</p><p>最棒的是，當我們完成這個動作之後，生成的 Linux 鏡像檔案燒入到 SD 卡中就能夠正常運行。</p><blockquote><p>以前嘗試過使用 Buildroot 來製作，但是失敗率非常高。</p></blockquote><p>簡單來說 Yocto 就是一堆社群貢獻預先撰寫好的建置腳本，因此我們只需要專注在自己需要預先加入這個 Linux 環境的部分，像是 Tamashii 或者 Ruby 的運行環境。</p><h1 id="初次嘗試"><a href="#初次嘗試" class="headerlink" title="初次嘗試"></a>初次嘗試</h1><p>首先，我們需要可以運行的環境。這篇文章使用的是 CentOS 7 來進行示範，所需的相關套件可以參考 <a href="https://www.yoctoproject.org/docs/2.4/yocto-project-qs/yocto-project-qs.html#yp-resources" rel="external nofollow noopener noreferrer" target="_blank">Yocto 官方文件</a>來配置，另外要注意的是目前較新版本是需要有 Python 3 的環境，但是 CentOS 7 還是使用 Python 2 需要自己配置。</p><h2 id="下載-Poky"><a href="#下載-Poky" class="headerlink" title="下載 Poky"></a>下載 Poky</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b sumo git://git.yoctoproject.org/poky</span><br></pre></td></tr></table></figure><p>Poky 類似於一個基礎的樣板，裡面將生成 Yocto 版本的 Linux 必要的相關檔案都放在裡面，我們可以基於這個資料夾來進行後續的設定跟配置。</p><blockquote><p>Yocto 每個版本都會有代號，目前最新的穩定版是 Sumo (2.5) 版</p></blockquote><h2 id="加入-Mender"><a href="#加入-Mender" class="headerlink" title="加入 Mender"></a>加入 Mender</h2><p>這篇文章會以 Mender 作為例子，這樣在成品階段的時候也比較好用 Mender 來體驗。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd poky</span><br><span class="line">git clone -b sumo git://github.com/mendersoftware/meta-mender</span><br></pre></td></tr></table></figure><p>如此一來，我們就可以在後續的階段使用由 Mender 所製作的 Layer 來提供 OTA 的功能。<br>不過在此之前，因為我們希望製作的是 Raspberry Pi 版本的 Linux 發行版本，所以還需要先把 Raspberry Pi 對應的 Layer 加入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone -b sumo git://git.yoctoproject.org/meta-raspberrypi</span><br><span class="line">git clone -b sumo git://git.openembedded.org/meta-openembedded</span><br></pre></td></tr></table></figure><h2 id="配置-Layer"><a href="#配置-Layer" class="headerlink" title="配置 Layer"></a>配置 Layer</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source oe-init-build-env</span><br></pre></td></tr></table></figure><p>因為 Yocto 已經提供好了各種設置，所以我們只需要透過上面的指令就能切換到對應的建置環境中。</p><blockquote><p>預設會產生一個 <code>build</code> 目錄，如果想要其他目錄的話也可以在後面指定。</p></blockquote><p>然後我們要告訴 Yocto 想要使用哪些 Layer 才能夠正常運作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bitbake-layers add-layer ../meta-mender/meta-mender-core</span><br><span class="line">bitbake-layers add-layer ../meta-openembedded/meta-oe</span><br><span class="line">bitbake-layers add-layer ../meta-raspberrypi</span><br><span class="line">bitbake-layers add-layer ../meta-mender/meta-mender-raspberrypi</span><br></pre></td></tr></table></figure><p>加入上述的 Layer 後，我們就可以產生一個能在 Raspberry Pi 上運行，以及透過 Mender 來做 OTA 更新的 Linux 發行版本。</p><p>不過礙於篇幅的關係，這次我們直接使用 Mender 提供的 Demo Layer 來加入客製化的內容。</p><blockquote><p>如果想加入自己編譯的程式、服務等等，是需要自己建立一個 Layer 來加入的，這樣也能對原有的 Layer 做擴充或者增加設定。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bitbake-layers add-layer ../meta-mender/meta-mender-demo</span><br><span class="line">bitbake-layers add-layer ../meta-mender/meta-mender-raspberrypi</span><br></pre></td></tr></table></figure><p>接下來，我們要對 <code>conf/local.conf</code> 進行設定，把伺服器位置等等設定值都加入到產生的 Linux 發行版本中，才能夠連接到正確的 Mender 伺服器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 釋出的版本，需要不同才能被辨識出來</span><br><span class="line">MENDER_ARTIFACT_NAME = &quot;release-1&quot;</span><br><span class="line"></span><br><span class="line">INHERIT += &quot;mender-full&quot;</span><br><span class="line"></span><br><span class="line"># 指定為 Raspberry Pi 3 是預設的目標</span><br><span class="line">MACHINE ?= &quot;raspberrypi3&quot;</span><br><span class="line"></span><br><span class="line"># 針對 Raspberry Pi 的額外設定</span><br><span class="line">RPI_USE_U_BOOT = &quot;1&quot;</span><br><span class="line">MENDER_PARTITION_ALIGNMENT = &quot;4194304&quot;</span><br><span class="line">MENDER_BOOT_PART_SIZE_MB = &quot;40&quot;</span><br><span class="line">IMAGE_INSTALL_append = &quot; kernel-image kernel-devicetree&quot;</span><br><span class="line">IMAGE_FSTYPES_remove += &quot; rpi-sdimg&quot;</span><br><span class="line"></span><br><span class="line"># 你的 Mender OTA 更新伺服器</span><br><span class="line">MENDER_SERVER_URL = &quot;https://ota.tamashii.io&quot;</span><br><span class="line"></span><br><span class="line">DISTRO_FEATURES_append = &quot; systemd&quot;</span><br><span class="line">VIRTUAL-RUNTIME_init_manager = &quot;systemd&quot;</span><br><span class="line">DISTRO_FEATURES_BACKFILL_CONSIDERED = &quot;sysvinit&quot;</span><br><span class="line">VIRTUAL-RUNTIME_initscripts = &quot;&quot;</span><br><span class="line"></span><br><span class="line">ARTIFACTIMG_FSTYPE = &quot;ext4&quot;</span><br><span class="line"></span><br><span class="line"># Raspberry Pi WiFi 設定（Demo 才有開啟 WiFi 功能）</span><br><span class="line">MENDER_DEMO_WIFI_SSID ?= &quot;ssid&quot;</span><br><span class="line">MENDER_DEMO_WIFI_PASSKEY ?= &quot;password&quot;</span><br></pre></td></tr></table></figure><h2 id="建置"><a href="#建置" class="headerlink" title="建置"></a>建置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitbake core-image-full-cmdline</span><br></pre></td></tr></table></figure><p>執行這個指令後，大概會要花上數小時才會完成，這段時間可以睡覺或打個遊戲。</p><blockquote><p>開發階段我會推薦使用 <code>full-cmdline</code> 的版本，因為可以直接 SSH 到機器或者接上鍵盤除錯。</p></blockquote><p>確認跑起來都沒問題之後，就可以改為使用 <code>core-image-minimal</code> 製作出刪減掉除了開啟 Linux 以及自己加入的額外功能之外，所有不必要的檔案來盡可能的縮小檔案大小。</p><h1 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h1><p>到這篇文章完成建置的段落，其實從頭到尾只花上數小時。不過目前還在測試如何讓有 C Extension 的 Ruby Gem 可以正常的被 Cross Compile 並且放進自訂的發行版本。</p><p>如果只是想單純的啟用 Ruby 的功能，直接在 <code>conf/local.conf</code> 裡面加上這行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_INSTALL_append = &quot;ruby &quot;</span><br></pre></td></tr></table></figure><p>在自訂的發行版本就可以使用 ruby 指令（目前預設是 2.5.0 版）</p><h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>這篇文章其實只是很粗略的將 Yocto 可以做的事情介紹出來，實際上深入了解 <code>bitbake</code> 這套工具以及 Layer 機制後，就會發現還有很多東西可以做。</p><p>舉例來說能透過 <code>.bbclass</code> 定義一個範本（Ex. <code>rubygem.bbclass</code>）讓其他套件（<code>Package</code>）繼承使用，而除了 Layer 之外，底下還有細分了食譜（<code>Receipe</code>）和套件（<code>Package</code>）可以做很多變的調整。</p><p>或者透過 <code>.bbappend</code> 來對原本的套件修訂，像是目前正在製作的 Tamashii Linux 就是利用這種方法讓 Ruby Gem 的 Cross Compile 得以實現。</p><p>如果之後已經有成熟的 Tamashii Linux 案例，會在分享該如何在 Yocto 上面客製化以 Ruby 為基底的 IoT 裝置嵌入是系統。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/10/09/Customize-a-linux-for-your-raspberrypi/#disqus_thread</comments>
    </item>
    
    <item>
      <title>轉職工程師：要學什麼才好？</title>
      <link>https://blog.frost.tw/posts/2018/10/02/Become-a-programmer-how-to-start/</link>
      <guid>https://blog.frost.tw/posts/2018/10/02/Become-a-programmer-how-to-start/</guid>
      <pubDate>Tue, 02 Oct 2018 15:26:53 GMT</pubDate>
      <description>
      
        &lt;p&gt;上一篇文章&lt;a href=&quot;https://blog.frost.tw/posts/2018/09/25/Become-a-programmer-lose-at-the-starting-line/&quot;&gt;輸在起跑點&lt;/a&gt;已經稍微討論過心態上的問題，所以馬上就是要怎麼開始的問題。&lt;/p&gt;&lt;p&gt;大部分的人不論之前有沒有經驗，一定會冒出「要學什麼語言？」「某某語言很熱門是不是應該去學？」之類的問題。&lt;/p&gt;&lt;p&gt;很多時候，我認為這不是真正的問題。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>上一篇文章<a href="https://blog.frost.tw/posts/2018/09/25/Become-a-programmer-lose-at-the-starting-line/">輸在起跑點</a>已經稍微討論過心態上的問題，所以馬上就是要怎麼開始的問題。</p><p>大部分的人不論之前有沒有經驗，一定會冒出「要學什麼語言？」「某某語言很熱門是不是應該去學？」之類的問題。</p><p>很多時候，我認為這不是真正的問題。</p><a id="more"></a><h2 id="要快又要好"><a href="#要快又要好" class="headerlink" title="要快又要好"></a>要快又要好</h2><p>現在很多電腦補習班、或是一些線上課程的廣告，其實會誤導大家「三個月轉職」這種聽起來從學會寫程式到當工程是是一件很容易的事情。</p><p>認真想想，這種類型的課程到底教會了什麼？如果其他類型的工作都沒辦法這麼輕鬆，那麼為什麼寫程式就可以呢？</p><p>如果是以找工作為目的，程式相關的技能雖然重要，但是很明顯的搞錯了重點。</p><p><strong>有優秀的能力雖然很重要，但是有沒有潛力也會是另一個基準</strong></p><p>以我自身的經驗，寫程式的「入門門檻」確實很低，除非你連打字都不會。<br>但是作為一個工程師，從「入門」到「有實戰能力」到「獨當一面」就不是這麼簡單的問題。</p><p>所以要先面對現實，看你想要的是「學得快」還是「學的好」兩者幾乎無法並存</p><h2 id="寫程式的朋友"><a href="#寫程式的朋友" class="headerlink" title="寫程式的朋友"></a>寫程式的朋友</h2><p>如果不知道該學什麼，其實很簡單。如果你有一個會寫程式的朋友，學跟他一樣的。</p><p><strong>出問題有人問</strong></p><p>這是最效率的學法，飆車太快朋友會阻止你。進度太慢朋友會幫你！替代方案就是去上課，好的老師會負責擔任前面提到的朋友的任務。</p><p>如果剛出社會，以電腦補習班的學費來說覺得是一個負擔。那就選一個最近的社群活動參加吧！雖然對台北地區的人比較方便（其他縣市比較難找）但是你馬上就能找到適合的人幫助你。</p><p><strong>沒有朋友就找一個！</strong></p><p>也許你會覺得自己害羞內向不好相處，不過我想很多人都覺得自己是這樣，但是稍微試著聊天也許會發意外的合得來。</p><blockquote><p>我平常也都蠻怕跟陌生人聊天的，但是參加社群聚會總是會有人拉你去聊天，那就可以慢慢展開話題了！</p></blockquote><p>如果身邊沒有會寫程式的朋友，又對 Ruby 或者前端、React Native 之類的有興趣，可以來<a href="https://www.facebook.com/rubymokumokukai/" rel="external nofollow noopener noreferrer" target="_blank">默默會</a>看看，現在的狀況是一片混亂，但是想要找人問問題的話我想我們大多都有辦法跟你聊（太專業就是我們跟你學習摟！）</p><blockquote><p>不知道要找誰也可以說要來找我，不過目前我會花大概一小時教人之後才出來，有時候可能要等我一下。</p></blockquote><h2 id="補習班"><a href="#補習班" class="headerlink" title="補習班"></a>補習班</h2><p>當你決定要選擇補習班的時候，就要有心理準備。補習班基本上就是一個以「快」為目的的地方，所以上課基本上會以最有效率的方式來做教學。</p><p>在這種情況下，基礎就不一定會好。但是「學得快」這件事情本身不是一個問題，不如說我反而很推薦想要學新東西或者第一次入門的人用這種方法。</p><p><strong>如果開發新產品是每個人很有經驗的，那他一點也不新，而且可能也不賺錢</strong></p><p>如果你有一個想法想要實現，或者想要找到一份工作。這個方法是很有效的，因為你有能力「製作」一小部分的部件，這就足夠了。</p><p>就像打遊戲一樣，有人會在意<strong>第一次就玩得很好</strong>這件事情嗎？並不會，所以有些人會透過「熟練」和「分析」去讓自己更熟悉這個遊戲。</p><p>以大多數課程都是一個月到三個月左右，其實也就 32 ~ 96 個小時來看，一款遊戲破完第一輪獎盃一半都拿不到，這樣你會覺得學寫程式有這麼容易嗎？玩遊戲都沒這麼容易了！</p><p>不過選擇補習班跟打遊戲比起來，還是有好處的。那就是老師，像是我目前的公司<a href="https://5xruby.tw/" rel="external nofollow noopener noreferrer" target="_blank">五倍紅寶石</a>或是<a href="https://www.hexschool.com/" rel="external nofollow noopener noreferrer" target="_blank">六角學院</a>和 <a href="https://skilltree.my/" rel="external nofollow noopener noreferrer" target="_blank">SkillTree</a> 等等，應該都屬於我知道裡面風評不錯的的幾間補習班。</p><p>不過比起這些，其實我還是比較推薦去跟「上課的老師」在一些社群活動中接觸看看，才知道適不適合。</p><p>像是在五倍<a href="https://kaochenlong.com/" rel="external nofollow noopener noreferrer" target="_blank">龍哥</a>、<a href="https://kuro.tw/" rel="external nofollow noopener noreferrer" target="_blank">Kuro</a>、<a href="https://csscoke.com/" rel="external nofollow noopener noreferrer" target="_blank">Amos</a> 幾位講師有時候在公司就能碰到，我也有上過課都是不錯的。另外六角的話像是廖洧杰也是在前端社群很活躍的大大，另外 SkillTree 給我印象深刻的則是 <a href="https://dotblogs.com.tw/hatelove" rel="external nofollow noopener noreferrer" target="_blank">91 哥</a>的敏捷開發課程（雖然我聽的是研討會版本，但是收穫很多）</p><p>我會推薦去找講師交流看看，是因為即使像我「很熟悉寫程式」也不代表可以「好好教人」以擔任 Rails Girls 三次教練我的經驗，我到第三次才比較能好好引導學員，而且定的目標（作業）太不合理之類的，也會引響被教學者最後在學習上的態度。</p><p>所以也許你適合寫程式，但不一定適合「教別人學寫程式」如果能跟講師交流過，其實你很快就會知道講師適不適合教自己。</p><blockquote><p>另外補習班的成功案例看看就好，很多時候去參加課程的不一定會是新手，因為廣告看起來似乎可以學到很厲害的技能，但是實際上對某部分已經有一定基礎的人是過於簡單的，他們在課堂上的作品很容易就被拿來當廣告。至於誇大的程度，就要看各家補習班的做法了⋯⋯</p></blockquote><h2 id="看書"><a href="#看書" class="headerlink" title="看書"></a>看書</h2><p>如果想「學的好」那就無法避免的用看書的方式自學，但是這是一種非常沒有效率的學法。如果你不擅長整理、實驗這類型的技能，我還是推薦選擇直接上線上課程或者補習班，因為看書的資訊密度比課程來高的很多，所以你要會整理。</p><p>而且一個「書」的市場影響可以獲取的資源，入門通常會選擇熟悉的語言（像是中文）來讀，但是中文書技術類的市場不大，所以其實會慢慢發現「重複性高」跟「無法深入」所以自學就會遇到門檻。</p><p>這是因為這種初階入門書是大多數人比較會買的類型，太困難或者太複雜就會變成即使出書了也很難賣掉。</p><p>但是從這一大堆知識中磨練出來的歸納整理和實驗的技巧，就會變成非常扎實的技能。</p><p><strong>學程式的精髓不在學會那個語言，而是了解使用的方式</strong></p><p>舉個例子，我以前自學在看這些書的時候。我通常「不會照著書做」我會邊參考邊改出「我認為適合」的功能，然後執行看看。</p><p>如果成功了，就表示我的理解沒有問題，也學會了變化的應用。如果失敗了，就慢慢調整到接近書上的狀況，然後看看錯的地方是哪裡。</p><p>這種技巧其實某方面來說也叫做 DEBUG 常用的方式之一，至少在自學上我錯的次數應該是遠高於平均值，所以我找 BUG 的速度可能也相對快了一些吧 XD</p><blockquote><p>不過不是第一次學就要這樣做，剛開始學的時候還是先完全模仿一次之後再來改看看，加深印象跟嘗試理解。</p></blockquote><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>好像差點把後面要分段講的東西講掉一些了，不過這篇主要想跟大家說明幾個概念。</p><ol><li>學什麼比較好其實不重要，重要的是起步的時候要有人可以幫你</li><li>想要很快學好是不可能的，但是基礎是可以慢慢補回來的（下一篇會討論）</li><li>學的方法有很多種，要看適不適合自己</li><li>要記得慎選老師，有時候名師不一定是適合自己的老師</li><li>學程式其實不是在學程式</li></ol><p>很多人的「學程式的第一步」其實沒有想像中的重要，而重要的其實是在學的過程中學到的「分析」和「統整」的能力。</p><p>所以第一個語言大多不是問題，我也是從 PHP 轉到 Ruby 為主，但其實我也嘗試學過 C / C++ / C# / Golang / Lua / Java / JavaScript / TypeScript 等等（太多不列了⋯⋯）</p><p>但是我敢說我用的「熟練」的大概只有 PHP / Ruby / JavaScript 吧！不過如果要換工作，上述的語言我都有辦法寫，也有把握在一個月內慢慢調整到能夠有足夠的生產力在這個語言上。</p><p>之後也會提到學程式的幾種面向「語法」「特性」「架構」等等，我們其實都以為學會「語法」就好了，但是有考慮過「特性」跟後面的「架構」嗎？特性會限制架構的發展之類的，就會讓我們發現不同案例下總是會有「最適合」的語言，或者「看起來怎樣都很適合」的語言（通常是個坑⋯⋯）</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/10/02/Become-a-programmer-how-to-start/#disqus_thread</comments>
    </item>
    
    <item>
      <title>轉職工程師：輸在起跑點</title>
      <link>https://blog.frost.tw/posts/2018/09/25/Become-a-programmer-lose-at-the-starting-line/</link>
      <guid>https://blog.frost.tw/posts/2018/09/25/Become-a-programmer-lose-at-the-starting-line/</guid>
      <pubDate>Tue, 25 Sep 2018 15:33:23 GMT</pubDate>
      <description>
      
        &lt;p&gt;工作到現在差不多兩年多，因為公司業務的關係偶爾也會跟同事討論在學習當工程師或者寫程式上的經驗。所以打算寫一個系列的文章，跟大家分享一下我從學程式到成為一個工程師的過程，是怎麼樣的。&lt;/p&gt;&lt;p&gt;這是第一篇，我想用「輸在起跑點」來當開始。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>工作到現在差不多兩年多，因為公司業務的關係偶爾也會跟同事討論在學習當工程師或者寫程式上的經驗。所以打算寫一個系列的文章，跟大家分享一下我從學程式到成為一個工程師的過程，是怎麼樣的。</p><p>這是第一篇，我想用「輸在起跑點」來當開始。</p><a id="more"></a><h2 id="學習總是有兩種人"><a href="#學習總是有兩種人" class="headerlink" title="學習總是有兩種人"></a>學習總是有兩種人</h2><p>不知道什麼時候開始，總會有「不要讓你的孩子輸在起跑點」上之類的言論，從我小學開始，即使是鄉下的小學校也還是會有很多人放學就得到補習班補習。</p><p>然後就這樣比別人先學了英文、比別人多會了樂器等等⋯⋯</p><p>這類人，不是起步比別人早，不然就是家裡有那個資源可以讓他去學才藝或者嘗試各式各樣的東西。以我的家庭經濟狀況，基本上明顯會是屬於「輸在起跑點」上的情況。</p><p>不過，我還有「起步早」這個優勢。我跟很多認識的社群朋友，大多都是在小學就開始接觸這類東西的。所以單純來說，如果要比較有沒有贏在起跑點這個問題上，我想以經驗來說我肯定比很多人經驗豐富很多。</p><p>不過，出社會後才想學程式會輸在起跑點嗎？</p><p><strong>一直進步跟原地踏步是不一樣的，有進步就算是一小步你也是超前的那一類人</strong></p><blockquote><p>我母親是鋼琴老師，所以我小時候是有學鋼琴的。但是我國中之後幾乎不練習（沈迷寫程式），所以我的程度基本上跟初學者差不多，這就是原地踏步。</p></blockquote><h2 id="好的老師決定你進步的速度"><a href="#好的老師決定你進步的速度" class="headerlink" title="好的老師決定你進步的速度"></a>好的老師決定你進步的速度</h2><p>這邊的「老師」不一定是指學校的老師，可能是指導你的人，或者你讀的那本書的作者，也可能是你的朋友。我在<a href="https://blog.frost.tw/posts/2018/09/10/How-to-choose-your-first-job/">怎麼選第一份工作</a>這篇文章有提到公司看待員工的方式，會影響這個員工未來的發展。</p><p>假設你出社會後才第一次學習程式，要怎麼樣才能最快速的進步？這個問題很簡單，就是不要自己埋頭的學，去找「適合」的人教你或者跟他一起學習。</p><p>有好幾種形式，這邊講幾個案例。</p><p>一種是競爭，我國中的時候成績可以進步很大一部分是靠同班幾位比較好的同學。基本上就是互相比分數，因為這種良性的競爭，就會自然地帶動成績的提升。</p><p>當初在入門的時候，有個小我一歲的網友也是這樣，我們會邊打遊戲編寫程式（做攻略網站之類的）然後再互相看對方的作品跟進度。</p><p>另一種是分享，其實也就是我們在教育體系裡面從老師那邊接受知識的形式。我最早是寫 PHP 的，其實大概有五六年都是幾乎很微小的進步（跟當時網路資源不多跟完全自學有關）開了眼界是參加了 <a href="https://2016.phpconf.tw/" rel="external nofollow noopener noreferrer" target="_blank">PHPConf</a> 之後，才知道有像是開發框架（Framework）之類的東西，然後才對架構這類有概念，然後才快速的進步起來。</p><p>不過研討會的缺點是為了符合「大多數人」的程度，通常會遇到深入的議題不夠或者太過困難之類的情況。像是 <a href="https://laravelconf.tw/zh-TW" rel="external nofollow noopener noreferrer" target="_blank">LaravelConf TW</a> 就一直在嘗試做各種變化來改善這種問題。而 <a href="https://rubyconf.tw/" rel="external nofollow noopener noreferrer" target="_blank">RubyConf TW</a> 則因為工程師相對少，而且不多新人選擇進入，議程上普遍就比較有深度（同時也變成門檻）不過即使在日本 <a href="https://rubykaigi.org/" rel="external nofollow noopener noreferrer" target="_blank">RubyKaigi</a> 也是有這樣的狀況，但是因為有其他研討會能互補反而比較沒有台灣這種一種語言靠一個研討會支撐上的問題。</p><blockquote><p>這一直是台灣各語言社群的難題，不管是難或簡單都不好挑選。而且為了穩固新手讓他們成場起來，很多時候必須犧牲掉一些深入的題目（所以我後來參加研討會都跑去聊天，如果發現自己開始這樣做，也許是你的實力到了某個水準也說不定）</p></blockquote><h2 id="快速進步的方法"><a href="#快速進步的方法" class="headerlink" title="快速進步的方法"></a>快速進步的方法</h2><p>既然主題是「輸在起跑點」我們總該討論怎麼樣補上這個差距吧？理論上來說應該是沒有辦法，但是現實面來說我個人認為是一種「意志力」上的戰鬥。</p><p>在當兵的時候，我因為大學畢業專題開發遊戲（多媒體設計學系）所以攝取了大量的可樂跟麥當勞（我個人感覺畢業的時候同學全部胖一圈）所以後來跑 3000（公尺） 的體能測驗項目，我幾乎是落後中的落後。</p><p>不過中間經過了一些體能訓練之類的，學到了兩件事情。第一個就是你身體至少要能負擔這個程度的運動，才能在時間內跑完。另外一個就是你要能讓身體可以負擔，就是要在跑到想放棄的時候告訴自己「我還可以」盡可能把自己的極限逼出來。</p><p>其實這是在不管學什麼都通用的道理：</p><ol><li>基礎很重要</li><li>堅持很重要</li></ol><p>從這兩點來看，文章一開始的「我沒有堅持練鋼琴」就是造成我現在程度差的原因（還有不少，大學因為讀多媒體也會畫畫，畢業後就很少動筆了，基礎本身就差還沒有練習，就變成退步很多）</p><p><strong>基礎讓你不容易退步，堅持讓你可以進步</strong></p><p>所以，在衝刺之前我們應該先想想「準備好了嗎？」才知道自己有沒有那個餘裕往前衝刺，尤其是學習跟我們想像的不是什麼曲線，是梯狀的（也就是要度過瓶頸）如果不堅持的話是很容易在突破前一點的地方放棄。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>會以這篇文章作為開始，是因為我認為不管做什麼之前，都要有心理建設。不管建設了多少，只要有一個簡單的概念或是認知，就能很大的改善學習的過程。</p><blockquote><p>我認為自己很愛找藉口，所以常常用比較激烈的方式學東西。像是畢業後還想把電繪技巧練好，但是一直都是用時間不夠當藉口（明明把寫程式時間貢獻出來就可以了 XD）</p></blockquote><p>總之，一個簡單的結論。</p><p>不要管是不是本科系或者什麼有的沒的，只要先問自己「想不想學」「喜不喜歡」「撐不撐得下去」就好了，大多數時候我不鼓勵別人用跟我一樣激烈的方法，大學畢業前我大多是一定程度的把人際關係那些都犧牲掉，然後用來強化程式技能。所以用「我想學」「我喜歡」「我（自己一個人）撐得下去」的方式去進步，也許畢業後我跟很多人比「起步很順利」但不一定對每個人都是好的，你可能會發現「朋友跟不上自己」的孤獨感，比起這樣也許在職場跟朋友一起進步，說不定反而是件好事。</p><p>所以，先確定自己能不能堅持走這條路，在思考適合的走法。</p><blockquote><p>我的方法簡單粗暴，就是我不繞路，遇到障礙我就是一路往前推到障礙不見。他很花時間也很費力，不過我喜歡這種方式。</p></blockquote>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/09/25/Become-a-programmer-lose-at-the-starting-line/#disqus_thread</comments>
    </item>
    
    <item>
      <title>怎麼選第一份工作？</title>
      <link>https://blog.frost.tw/posts/2018/09/10/How-to-choose-your-first-job/</link>
      <guid>https://blog.frost.tw/posts/2018/09/10/How-to-choose-your-first-job/</guid>
      <pubDate>Mon, 10 Sep 2018 01:18:58 GMT</pubDate>
      <description>
      
        &lt;p&gt;從退伍到工作差不多過了兩年，這段時間有不少經驗我想已經足夠跟大家分享。這篇算是一個前導的文章，想來跟大家分享「第一份工作」的重要性。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;重點是技能成長那段，討論薪水的地方太長可以跳過喔 XD&lt;/p&gt;&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>從退伍到工作差不多過了兩年，這段時間有不少經驗我想已經足夠跟大家分享。這篇算是一個前導的文章，想來跟大家分享「第一份工作」的重要性。</p><blockquote><p>重點是技能成長那段，討論薪水的地方太長可以跳過喔 XD</p></blockquote><a id="more"></a><p>先不管工作的類型，或者自身的能力這些問題。已在台北工作來說，對一個外縣市的人搬到台北工作跟居住，最先要考慮的是有 30K 以上的薪資。</p><blockquote><p>我想這應該還不算難達成的目標，而這個是在台北生活的基本。</p></blockquote><h2 id="生活成本"><a href="#生活成本" class="headerlink" title="生活成本"></a>生活成本</h2><p>我搬到台北選擇房子的基準其實蠻簡單的，就是「舒適」要滿足。不要認為說可以居住就好，假設你會失眠，而且住的地方隔音很差，每天都會有不同的聲音來影響你休息。</p><p>這樣問題就顯而易見了，假設一天工作八小時。因為睡眠不足或者品質很差，讓你原本有 90% 的生產力下降到 70% 好了，這樣子工作的狀況會好嗎？</p><p>在吃的方面也是ㄧ樣，尤其是一些比較有心的房東會把房子處理好。但是對他來說商品的維持太糟糕，他會有額外的成本，所以可能會不允許煮飯。</p><p>那麼除了上班外食之外，晚餐跟早餐可能也都要在外面吃（而且還要吃到一定程度是健康的，不能餐餐都亂吃））</p><p>假設以套房（衛生考量）來看，一個月至少就是 9K （租屋） + 9K（餐費）左右的花費，這樣算下來 30K 的薪水，還沒扣掉水電跟瓦斯，還有可能要背的學貸跟電信費用，剩下的就幾本上就是應急用。</p><blockquote><p>也就是說，在考慮工作之前，要先評估過該城市的生活花費有多少。考慮生活品質是要創造正向的循環，而不是一種不斷惡化的情境給自己。</p></blockquote><h2 id="薪水成長"><a href="#薪水成長" class="headerlink" title="薪水成長"></a>薪水成長</h2><p>之前因為噗浪上有一個匿名的問卷，我就把它做成<a href="https://frost.tw/plurk-salary/" target="_blank" rel="noopener">薪水普查</a>這個頁面，用來統計上面（可解析）的薪資情報。</p><p>以上面的情況來看，比較可靠的資訊可以發現大多數都卡在 45K 就看起來比較沒有成長。</p><p>先假設我們的極限就到此為止好了，那麼要選擇怎樣的公司就顯而易見了吧？假設三年就能達到 45K 的極限，跟要花上十年才能達到極限，中間缺少的那塊就能攘你在人生規劃中做更多的事情。</p><blockquote><p>不過很可惜，我也不清楚同事調整薪水的狀況。不過第一年的調整我是蠻滿意的，第二年因為制度調整的關係我還不知道結果，不過我是蠻相信老闆們的 XD</p></blockquote><p>不過，假設薪水調整幅度「大」的公司，我想能提供的薪水上限肯定也是比較高的。</p><p>不過公司的規模不一定會讓薪資成長比較大，像是我聽過親戚在看起來蠻大的公司工作，第一次調薪竟然是幾百塊為單位的（這跟沒有一樣吧？）還有就是外商來臺灣以為人才也會相對便宜，結果初期開的薪資確實是比台灣高。但是這幾年下來因為調整不多，反而變得無法提供更高的薪資（因為有太多人需要先調高）</p><p>所以剛畢業這幾年，選擇風險高一點的新創公司，老闆願意提供高薪的機會是比較大的。</p><blockquote><p>而且有些公司會問為什麼換工作這麼頻繁，用前公司經營不善似乎是個不錯的理由（笑）</p></blockquote><h2 id="技能成長"><a href="#技能成長" class="headerlink" title="技能成長"></a>技能成長</h2><p>既然我們已經知道薪水方面該怎麼評估，再接下來我們要看，而且要看的「很注重」的就是技能成長這一塊。</p><p><strong>薪水少沒關係，公司給的環境更重要</strong></p><p>在一間公司工作，要怎麼樣讓你的技能成長？這跟公司的方針跟給予的環境有關係，如果沒有「環境」空有「福利」你是不會進步的。</p><blockquote><p>福利是什麼？下午茶算是一種，還有是會給你去上課，但是上的課是一些心靈課程？？？？</p></blockquote><p>以目前我所在的公司<a href="https://5xruby.tw" rel="external nofollow noopener noreferrer" target="_blank">五倍紅寶石</a>來說好了，我想我目前有的技能其實應該是可以考慮換一個工作，然後要求更高的薪水。但是我基本上除非公司沒辦法繼續養我（如果有一天我的技能已經超過公司成長的速度）不然我想我會繼續待著，因為制度和自由度上很適合我。</p><blockquote><p>不時還會有獵人頭問我，從今年開始我都是給目前工作 +30% 左右的「期望薪資」然後問問對方「現在的工作環境我很滿意，如果可以達到個水準的薪資，我再考慮放棄現在的環境」然後通常就沒下文了⋯⋯</p></blockquote><h3 id="引路人"><a href="#引路人" class="headerlink" title="引路人"></a>引路人</h3><p>以我們網路業來說，平常的工作就是網站相關的軟體工程師。我們通常會「號稱」有 Code Review （原始碼審查）或者 Pair Programming 等等機制存在，但是真正落實的機會不大，即使在五倍也沒有辦法完全落實。</p><p>原因不外乎就是成本，即使我們自己想做，客戶也不一定有時間跟經費讓我們這樣做。</p><p>但是，可以的話我們會盡力去做。尤其是針對公司的 Junior （初級工程師）做 Code Review 或者 Pair Programming 來幫助他們。</p><p>為什麼？如果你寫了十年的程式，但是從來沒有人告訴過你「其實有更好的方法」以及「用這樣的方式思考，是不是可以更俐落的解決問題」那麼你會進步嗎？除非你有一天頓悟，不然真的很難。</p><p><strong>工程師雖然面對電腦，但是人是需要互動跟交流的</strong></p><p>所以才會有像是 <a href="https://2018.rubyconf.tw/" rel="external nofollow noopener noreferrer" target="_blank">RubyElixirConf</a> 和<a href="https://www.facebook.com/rubymokumokukai/" rel="external nofollow noopener noreferrer" target="_blank">默默會</a>這類活動的存在，即使你是一個天才或者高手，你還是需要跟其他人討論和交流，去發掘自己不知道的領域和從沒有考慮過的問題。</p><blockquote><p>尤其時你越來越強，越容易忽略一些「理所當然」但是卻沒有細想過背後原理和機制的東西。</p></blockquote><p>再舉個例子，我的親戚也是工程師。但是他的公司前輩有一次問他「為什麼你要自己做，這個東西以前人做過複製貼上就好拉！」</p><p>後來我問，你做的東西問題其實很多，前輩都沒有訂正這種低級錯誤嗎？<br>「沒有，我們給客戶的產品只要 QA （品質測試）通過就可以了⋯⋯」</p><p>因為東西會動，所以品質測試就能通過。然後背後是否能夠有「最低限度」的可維護性，或者工程師的技能成長，就這樣被公司「節省」掉了！</p><p><strong>聽起來就像公司把你當做產生軟體的「工具」，而不是一個人力資源</strong></p><p>所以，你必須確定你的公司會在「能做到的範圍內」盡可能幫助你，而不是把你當做一個工具。</p><blockquote><p>重複使用不是問題，但是完全不明白自己在用什麼，就是個大問題。</p></blockquote><h3 id="自由"><a href="#自由" class="headerlink" title="自由"></a>自由</h3><p>在五倍，基本上不會強迫我們加班。而工作上，如果有餘裕的話，也可以用在一些改進自己技能的地方。</p><p>在五倍這兩年左右，其實我嘗試了不少東西。跟同事把原本的 Raspberry Pi （樹莓派）打卡機改寫，變成一套稍微簡單使用的 Ruby IoT 解決方案。</p><p>在公司內部嘗試了好幾次，做了很多改上讓 GitLab 跟 GitLab CI 可以運作起來、有 Staging 的環境可以自動化部屬最新的版本做測試。</p><p>最近也開始嘗試透過像是 Ansible 來做自動化的伺服器部署，以及使用 Vault 控管開發人員存取伺服器的權限等等。</p><p>甚至也嘗試基於 Scrum 和其他幾套敏捷開發的理論，改良出一套適合五倍通常以接案的專案管理流程，用來應對小團隊（三到五人）跟短期（一兩個月，或者半年）的開發。</p><p>中間還有不少時間讓我跟工作內容搭配，用來準備投稿國內外的研討會。雖然不多，但是一年至少也能夠在國內分享一兩次左右，運氣好還可以到日本分享。</p><p>最近同事也自發的在下班後利用公司的空間，開始互相教學一些自己會的技能，像是在美國住過的口說經驗、記憶學是怎麼用來輔助記憶東西的等等。</p><p><strong>短短兩年，你學會的技能就足以在下一次的工作上獲得更多優勢</strong></p><p>所以五倍的「技術力」很強嗎？從這樣的角度來看，即使現在不是，之後也會慢慢變強。</p><blockquote><p>當然，我們也不斷面臨人才的流失。但是我們也同時的讓更多人才被發掘和成長起來。</p></blockquote><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>我目前想到的大概是這些，其實從我接觸到的一些情況會發現一件事情。</p><p>「即使再有天份或者能力，如果在錯誤的公司，就算是天才也會變成普通人」</p><p>作為一個工程師你要考我演算法或者一些計算機科學的知識，身為一個「非本科生」我沒辦法「正確」的回答，但是我能用我的經驗跟理解去解釋。</p><p>所以很多時候，知識並不重要。對求職者來說，公司對你的「態度」很重要，他會影響你之後的職涯發展。</p><p>不過，相同的你對公司的「態度」也很重要。就像今年暑假我參與了審核實習生履歷的任務，我這樣對老闆說「像是一些頂尖的學校，如果不是特別突出的話，我會先考慮其他學校表現不錯的看看」並不是因為我是私立大學畢業有偏見，我的同事大概有一半也都是這類頂尖學校的。</p><p>我擔心的是我過去接觸過一些這些學校的學生，少數會因為有自己的「想法」所以就不接受其他人給他的「想法」</p><p>這樣要團隊合作就很難了，不過最近也遇到了同校的人也有這樣的狀況，不過在這些頂尖大學發生的情況就相對多出許多，畢竟他們更有自信，也更容易有這樣的問題。</p><p>私校的學生就剛好反過來，太沒有自信而不敢把「我不行」或者「我可以」明確的提出來，反而讓管理階層在評估要給予怎樣的工作跟適合的挑戰時，有所篇差。</p><blockquote><p>有點扯遠了，下一次的系列文就讓我來討論從我成為工程師這段時期，我的經驗和每一個階段面臨的困難和挑戰吧！</p></blockquote>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/09/10/How-to-choose-your-first-job/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
