<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>弦而時習之</title>
    <link>https://blog.frost.tw/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    
    <description>蒼時弦也的個人網誌，專注在前端、後端以及遊戲開發，大多使用 Ruby 和 Ruby on Rails 以及 Golang、JS 和 C 語言。</description>
    <pubDate>Sun, 20 May 2018 14:41:41 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>部署你的第一個 Ruby on Rails 網站（七）</title>
      <link>https://blog.frost.tw/posts/2018/05/20/Getting-started-deploy-your-Ruby-on-Rails-Part-7/</link>
      <guid>https://blog.frost.tw/posts/2018/05/20/Getting-started-deploy-your-Ruby-on-Rails-Part-7/</guid>
      <pubDate>Sun, 20 May 2018 14:39:15 GMT</pubDate>
      <description>
      
        &lt;p&gt;現在伺服器還沒辦法下載到 Ruby on Rails 專案的原始碼用來部署，這一篇會介紹該如何把原始碼下載回來，並且在伺服器上將相關的 Ruby Gem 都安裝好。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>現在伺服器還沒辦法下載到 Ruby on Rails 專案的原始碼用來部署，這一篇會介紹該如何把原始碼下載回來，並且在伺服器上將相關的 Ruby Gem 都安裝好。</p><a id="more"></a><h2 id="Deploy-Key"><a href="#Deploy-Key" class="headerlink" title="Deploy Key"></a>Deploy Key</h2><p>要讓 Capistrano 自動在伺服器上下載原始碼，我們必須先讓 GitHub 或者 Gitlab 這類服務允許這台伺服器下載，所以我們要先對 <code>deploy</code> 這個部署用的使用者，產生一組下載原始碼的 SSH Key 也就是所謂的 Deploy Key。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo su - deploy</div><div class="line">ssh-keygen -t rsa</div></pre></td></tr></table></figure><p>利用 <code>ssh-keygen</code> 指令，我們可以生成一組 Private Key 和一組 Public Key 給 <code>deploy</code> 這個使用者使用，跟我們用來 SSH 到伺服器的是一樣的概念，只不過現在是要讓他當作「驗證權限」的證明，讓 GitHub 接受伺服器下載原始碼。</p><p>將生成的 <code>~/.ssh/id_rsa.pub</code> 內容，複製後貼到 GitHub 專案中 Settings &gt; Deploy Keys 裡面，用來允許這台伺服器下載。</p><p><img src="https://blog.frost.tw/images/getting-started-deploy-your-ruby-on-rails-part-7/figure.png" alt="螢幕快照 2018-05-20 下午10.08.30.png"></p><blockquote><p>GitHub 只允許同一把 Deploy Key 存在一次，所以如果想要讓多台伺服器共用的話，可以先在一台產生，其他伺服器共用。但是盡量避免使用自己電腦中的，因為 Deploy Key 只能讀取會安全許多。</p></blockquote><p>如此一來，在設定正確的狀況下，我們就可以順利的讓伺服器下載到原始碼。</p><h2 id="檢查"><a href="#檢查" class="headerlink" title="檢查"></a>檢查</h2><p>一般在部署之前，我們都會用 <code>cap staging deploy:check</code> 確認基本的操作都是正常的，也就是產生這次部署的版本、下載原始碼跟設定檔已經正確生成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cap deploy:check</div></pre></td></tr></table></figure><p>如果伺服器正確的話，應該是不會有錯誤訊息。不過我們嘗試透過 git 來下載原始碼，伺服器上可能是沒有 git 環境的，所以先透過 yum 安裝套件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install git</div></pre></td></tr></table></figure><p>如此一來，<code>cap staging deploy:check</code> 就會回報已經可以正確地產生新的資料夾，以及下載原始碼。</p><h2 id="JavaScript-Runtime"><a href="#JavaScript-Runtime" class="headerlink" title="JavaScript Runtime"></a>JavaScript Runtime</h2><p>伺服器環境預設是沒有 JavaScript 的執行環境，不然在我們執行 <code>cap staging deploy</code> 的時候，就可以順利的部署完成。</p><p>不過，因為 Assets Precompile 的關係，我們至少需要有 Node.js 的環境才行。</p><p>我們可以利用 Node.js 官方提供的<a href="https://nodejs.org/en/download/package-manager/#enterprise-linux-and-fedora" target="_blank" rel="noopener">設定程式</a>，讓 CentOS 可以支援較新版本的 Node.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># Node 8 是寫這篇文章的穩定版</div><div class="line">curl --silent --location https://rpm.nodesource.com/setup_8.x | sudo bash -</div></pre></td></tr></table></figure><p>當這段設定程式執行完畢後，我們就可以利用 yum 指令更新或者安裝。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum install -y nodejs</div></pre></td></tr></table></figure><blockquote><p>實際上 Node.js 的環境影響並不大，即使是舊版的 Node.js 環境也是可以正常的完成 Assets Precompile</p></blockquote><p>假設有使用 Webpack 的話，對於 Webpacker 這個 Gem 還會需要使用 Yarn 來安裝 Node.js 套件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl --silent --location https://dl.yarnpkg.com/rpm/yarn.repo | sudo tee /etc/yum.repos.d/yarn.repo</div><div class="line">sudo yum install yarn</div></pre></td></tr></table></figure><p>安裝的方法跟 Node.js 基本上是沒有太大的差異，一樣是透過官方的設定程式將 yum 可以安裝的來源增加，就可以透過 yum 安裝或者升級。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>現在我們只需要透過 <code>cap staging deploy</code> 就可以把 Ruby on Rails 專案傳到伺服器，並且將一切都安裝完畢。</p><blockquote><p>如果有出現錯誤，可能就是使用的 Gem 使用了一些 C 語言編寫的套件，需要額外的安裝一些套件才可以解決，這就考驗大家的應變能力了！</p></blockquote><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>到這篇文章為止，我們只剩下一個步驟——設定 Nginx 伺服器。雖然我們安裝好了伺服器，但是並沒有設定這個專案要怎麼被 Passenger 啟動。</p><p>下一篇是最後一篇，會講解怎麼設定 Nginx 伺服器以及套用 Let’s Encrypt 來設定 SSL 加密。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/05/20/Getting-started-deploy-your-Ruby-on-Rails-Part-7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>關於我怎麼準備人生第一次的履歷和面試</title>
      <link>https://blog.frost.tw/posts/2018/05/14/About-my-first-time-interview-and-resume/</link>
      <guid>https://blog.frost.tw/posts/2018/05/14/About-my-first-time-interview-and-resume/</guid>
      <pubDate>Sun, 13 May 2018 16:58:04 GMT</pubDate>
      <description>
      
        &lt;p&gt;最近又到了畢業的季節，今年比較不一樣的大概是我有稍微幫幾個學弟妹看了一下履歷。還有公司今年暑期實習生的履歷，我也都看了一遍。&lt;/p&gt;
&lt;p&gt;看完之後就發現，跟當初退伍前準備的情況不一樣，我們肯定搞錯重點了 XD&lt;/p&gt;
&lt;p&gt;總之，這不是一篇雞湯文，是雞精文！&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>最近又到了畢業的季節，今年比較不一樣的大概是我有稍微幫幾個學弟妹看了一下履歷。還有公司今年暑期實習生的履歷，我也都看了一遍。</p><p>看完之後就發現，跟當初退伍前準備的情況不一樣，我們肯定搞錯重點了 XD</p><p>總之，這不是一篇雞湯文，是雞精文！</p><a id="more"></a><p>文章就分兩個部分，履歷跟面試，內容基本上就是約兩到三年前剛退伍後找工作的狀況。</p><p>不過，有一點要強調的是我的狀況不太一樣，我小學就因為興趣的關係自學程式。中間的累積跟從大學才開始認真練習的情況是差很多的，不過大部分的人都不是這樣，所以也不太需要擔心。</p><h2 id="履歷篇"><a href="#履歷篇" class="headerlink" title="履歷篇"></a>履歷篇</h2><p>履歷基本上分兩種，客製化的跟制式化的。制式化的基本上不用討論，大多就是求職網站提供的，或者再聯絡到某間公司由 HR（人力資源）提供的版本。</p><p>如果是走制式化的履歷，大概就是真的要拼學歷跟經歷了。畢竟那是方便快速篩選人的方法，先從最簡單的方法篩選，就是假設名校之類的比較厲害。</p><blockquote><p>不過以我看履歷的狀況，即使是台清交來投工程師，如果作品都是作業的話，我根本分不出來誰比較好，同樣的條件下就會先以有自己作品的優先，剩下無法比較才用學歷比（高學歷的人在學習上通常會有一套方法，這可以幫助他們快速適應新環境跟工作）</p></blockquote><p>所以，到了客製化履歷的情況，基本上我自己看的順序是這樣的。</p><ul><li>作品</li><li>專長</li><li>履歷外觀</li><li>自我介紹</li></ul><p>雖然老闆們的看法似乎不太一樣，不過我會這樣看（在一間軟體公司）是有原因的。</p><p>首先是作品，我看作品（一般是放在 GitHub 上）的原因主要是要確認「程式技能」到底是怎麼樣的。如果是熟練寫程式的人，基本上都會有自己的小專案或作品，然後再深入看他使用的這個語言，寫起來是怎麼樣的。</p><p>以 Ruby on Rails 專案來當例子，一個投實習生的人知道怎麼應用 <code>before_action</code> 或者 <code>Concern</code> 之類的技巧，基本上都可以放到正職候補了（實習階段來觀察）</p><p>所以第一點就是先看程式怎麼寫，雖然是很主觀的感覺，但是當寫程式的程度每提升一個階段，寫出來的東西就會差異很大。</p><blockquote><p>這幾年來我接觸過（能寫小東西）的語言可能也有快十種，學寫程式入門學的是邏輯，怎麼讓程式動起來，學會了換語言基本上沒問題。在下一步的是學特性，每種語言都有它設計的理由跟背景，快慢之類的還算其次，但精髓在於能不能了解這個語言或框架想解決的問題跟善用它針對的問題所提供的特性。</p></blockquote><p>另外 UI/UX 的實習生履歷我也有看，畢竟我在高中也是自學了一些設計上的理論知識，受過四年多媒體科系的教育，雖然現在無法當個戰力但是基本的鑑別能力還是有的。</p><p>跟看程式作品一樣，水準蠻好看出來的，基本上只要會「排版」就算通過最低門檻。在客製化履歷上也會體現出這個程度差異，如果連放在一張 A4 紙上的東西都能對齊到歪的，真的很難繼續研究什麼叫做 UI/UX 技能，就算 PhotoShop 或是 Illustrator 用的再好也沒用，搞不好連個會用 Word 的工程師都能做得比你整齊。</p><blockquote><p>客製化履歷的風險也在這邊，排版技能直接變成第一線的死穴。尤其 UI 上沒排好美感就不會出來，而 UX 上沒排好也不會有好的體驗。</p></blockquote><p>接下來就是看專長，不過基本上都是參考為主。原因是因為可能上面會是「我會 Ruby、MySQL」之類的，或者是不知道何時流行起的「PhotoShop ★★★☆☆」這種模式，不過後者我也有幹過，但是現在絕對不是個好方案。</p><p>那麼要怎麼寫呢，當時我是問業界的前輩中間聊到後，推導出應該是像這樣。</p><p>Ruby on Rails</p><ul><li>做過五個以上正式上線的專案</li><li>參與過日本手遊伺服器專案升級</li><li>擔任三次以上 Rails Girls Taiwan 教練</li></ul><p>然後就把有辦法列一到兩個實績的技能列出來，至少大家可以快速分辨出會什麼。</p><blockquote><p>UI/UX 這方面就很難判斷，看履歷時我發現這兩個人同一組。有兩個包裝作品我都認為做得很好，而且他們兩個人都有放，所以我第一時間的疑問是「有沒有第三個人，其實是他做的」不過能跟這種高手一組，也算是一種實力吧，只是參考的點就會把其他作品比重看得比較重。</p></blockquote><p>履歷外觀跟自我介紹就不多說，履歷外觀乾淨整齊就好了。不過還是會有像前面提到的客製化到歪掉，或者明明 Word 的行高預設值明明不是這麼矮的，字卻擠成一團的那種，如果前面的評分一樣，我就會選履歷最整齊乾淨的那個⋯⋯</p><p>不然也不用客製化履歷了，關鍵時刻發揮作用給看履歷的人好印象啊！至於自我介紹，大概要到老闆說可以約面試我才會看，因為講再多還是不如面對面談一次。</p><h2 id="面試篇"><a href="#面試篇" class="headerlink" title="面試篇"></a>面試篇</h2><p>這部分我就不好講解了，因為目前的公司（五倍紅寶石）根本是被老闆問說要不要來，去聊天幾次被貓咪騙去的。其他公司大多也是去「聊天」為主，通常進去出來就是一個小時，面試的過程中到後面就會跟面試官聊起來（雖然還在面試的範圍內）</p><p>不過面試有一個基本的心理因素要滿足——要有自信。</p><p>如果你都不能相信自己的專業技能，要怎麼讓面試你的人相信你有這個能力呢？實際上，遇到你不會的問題，有時候不一定是「扣分」的，只是面試官在抓你的能力在哪裡。</p><blockquote><p>當時有一間公司是認識且厲害的前輩在那邊，去面試的第一階段是寫一份約兩到三頁的試題，一個小時過去大約是回答了五到七成左右。在面試結束時我問了答題的狀況，原來大部分的人連一半的沒辦法回答，有時候不是自己水準太低，而是公司水準太高（所以你有很多能學）保持自信是很重要的，因為你不能確定是哪個情況。</p></blockquote><p>回到面試過程，基本上就是這兩點。</p><ul><li>確認能力</li><li>檢查人品</li></ul><p>如果都已經被約面試，其實能力上來說是被公司認可了（除非沒得選）所以面試就是做兩件事情，先確認履歷跟現實是相符的。也許會出現在工程師界常聽到的白板考之類的，雖然碰過但是應該很少會問演算法之類的，而是要看思考的方式（除非你的工作很需要演算法）但是重點就只有一個，我們看到的東西是不是和實力相符。</p><blockquote><p>重申一次，如果因為沒自信而緊張，不小心忘記原本會的東西或者沒辦法用其他方式回答，就真的很吃虧了。</p></blockquote><p>最後是確認人品，簡單說就是看你的個性跟做事的方式，適不適合這間公司。這就很考驗面試者的看人能力，因為一個人到底能不能跟其他同事好好相處，或者在工作上能夠好好的調適自己內心等等，都會影響到未來工作的表現等等。</p><p>來舉幾個例子，可能會比較好懂。</p><p>有位朋友之前嘗試來應徵實習生，也通過履歷的階段來到面試階段。我跟他說「你一定可以上的，不用擔心」也跟老闆說「雖然不是那種實力很強的，但是很認真的學習，『態度』很好。」不過後來他還是決定去帶營隊，就這樣跟這個機會錯過。</p><p>另外一個是從老闆那邊聽說，客戶公司有一個員工。做了一段時間後，就光明正大的在上班時間找工作跟滑臉書，老闆過來請他不要這樣，還回嗆老闆。因為是客戶，所以我們老闆那段時間剛好還看到了那位員工寫程式的狀況，一行一個 Commit （版本管理存檔的單位）在送的，根本是湊數用。</p><p>很明顯的，這位員工在我們公司就是黑單。連老闆支援的一些社群活動，大概都不會有他出場的機會。</p><p>簡單來說，面試要有「自信」跟平常就要培養好的「態度」這個即使是短短半小時的交流，也可以透過平常的習慣被知道，想要隱藏是很難的。</p><blockquote><p>另外既然我們身處台灣，業界真的很小。大概就是換幾間公司就會遇到認識的人，你以為這間公司看起來不怎麼出名，結果搞不好現在的老闆和這間公司的老闆是好朋友也說不定。在公司的表現，很有可能會讓你在其他公司都沒辦法過關。</p></blockquote><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>履歷的重點其實就是怎樣讓你「被關注」方法不一定，畢竟每個人看的東西不太一樣。但是作品不會騙人，平常就要注意累積作品，作品多其實就是你平時有累積跟練習的證明。</p><p>至於面試，保持自信就不會吃虧。然後態度，這種東西雖然短時間可能改不了，但是可以培養跟訓練，如果態度一開始就很差，小心被黑單吧 XD</p><p>最後，關於自信我在用一個小故事總結。</p><p>以前小學剛學會寫程式的時候，卻被同學誤會說「我覺得你這個人很驕傲」<br>不過，我一直都不認同這一點。因為我是這樣認為的。</p><p>「有實力的叫自信，沒有實力的叫驕傲」</p><p>有實力就會相信自己做得到，沒有實力說自己做得到，就是驕傲跟自滿。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/05/14/About-my-first-time-interview-and-resume/#disqus_thread</comments>
    </item>
    
    <item>
      <title>部署你的第一個 Ruby on Rails 網站（六）</title>
      <link>https://blog.frost.tw/posts/2018/05/07/Getting-started-deploy-your-Ruby-on-Rails-Part-6/</link>
      <guid>https://blog.frost.tw/posts/2018/05/07/Getting-started-deploy-your-Ruby-on-Rails-Part-6/</guid>
      <pubDate>Mon, 07 May 2018 01:59:38 GMT</pubDate>
      <description>
      
        &lt;p&gt;經過前面五篇的教學，我們距離將 Ruby on Rails 部署到伺服器上越來越接近了。上一階段我們在本機段將部署的設定做完之後，這一篇文章會回到伺服器將部署所需的設定補齊，讓 Capistrano 可以正確的將程式碼部署到伺服器。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>經過前面五篇的教學，我們距離將 Ruby on Rails 部署到伺服器上越來越接近了。上一階段我們在本機段將部署的設定做完之後，這一篇文章會回到伺服器將部署所需的設定補齊，讓 Capistrano 可以正確的將程式碼部署到伺服器。</p><a id="more"></a><p>在<a href="https://blog.frost.tw/posts/2018/04/10/Getting-started-deploy-your-Ruby-on-Rails-Part-5/">上一篇</a>裡面，我們設定了部署到 Staging 的使用者為 <code>deploy</code> 所以我們要先在伺服器上增加這個使用者。</p><blockquote><p>我們會習慣開設一個沒有 <code>sudo</code> 權限和密碼的使用者，只用於部署。</p></blockquote><h2 id="新增部署用帳號"><a href="#新增部署用帳號" class="headerlink" title="新增部署用帳號"></a>新增部署用帳號</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">useradd deploy</div></pre></td></tr></table></figure><p>如果還記得我們在<a href="https://blog.frost.tw/posts/2018/04/10/Getting-started-deploy-your-Ruby-on-Rails-Part-1/">第一篇</a>裡面提到的新增使用者方法，後續的動作基本上是大同小異的。</p><blockquote><p>有些 Linux 系統不一定會在做完 <code>useradd</code> 後自動新增 <code>/home/deploy</code> 可以自己用 <code>mkdir /home/deploy</code> 後做 <code>chown -R deploy:deploy /home/deploy</code> 來手動設定。</p></blockquote><p>接下來，我們切換到 <code>deploy</code> 使用者，並且設定使用金鑰登入。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo su - deploy</div><div class="line">mkdir ~/.ssh</div><div class="line">chmod 700 ~/.ssh</div></pre></td></tr></table></figure><p>複製本機的 <code>id_rsa.pub</code> 內容，並且貼到伺服器上的 <code>~/.ssh/authorized_keys</code> 上，如果忘記步驟可以回第一篇看。</p><h2 id="安裝資料庫"><a href="#安裝資料庫" class="headerlink" title="安裝資料庫"></a>安裝資料庫</h2><p>一般情況下我們在 Ruby on Rails 專案大多採用 PostgreSQL 來做為資料庫，不過在 CentOS 上不一定會提供我們所希望的版本，所以需要先到 <a href="https://www.postgresql.org/download/linux/redhat/" target="_blank" rel="noopener">PostgreSQL 官網</a>取得對應的套件設定。</p><p><img src="quiver-image-url/947E30127205650F228B211EF7CFBE67.png =960x540" alt="螢幕快照 2018-04-22 下午9.02.44.png"></p><p>根據官網選擇所需的資料庫版本（目前大多是使用 9.5 ~ 9.7）然後取得安裝的指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 安裝 PostgreSQL 10 為例</span></div><div class="line"></div><div class="line">sudo yum install https://download.postgresql.org/pub/repos/yum/10/redhat/rhel-7-x86_64/pgdg-centos10-10-2.noarch.rpm</div><div class="line">sudo yum install postgresql10-server</div></pre></td></tr></table></figure><p>因為我們需要的是伺服器，所以就可以不安裝客戶端的部分。不過我們可能會使用一些 PostgreSQL 的 Extension 以及 Ruby 需要有 PostgreSQL 的部分原始碼來編譯，所以我們需要再額外追加另外幾個套件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum install postgresql-contrib postgresql-devel postgresql-client</div></pre></td></tr></table></figure><p>最後，將 PostgreSQL 伺服器開啟，並且設定為開機自動啟動。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo systemctl <span class="built_in">enable</span> postgresql-10</div><div class="line">sudo systemctl start postgresql-10</div></pre></td></tr></table></figure><h2 id="創建資料庫"><a href="#創建資料庫" class="headerlink" title="創建資料庫"></a>創建資料庫</h2><p>剛安裝好的狀況下，是只有 <code>postgres</code> 這個使用者可以使用的。而我們希望可以在不特別設定密碼的狀況下連上資料庫，所以我們可以透過以下的方法。</p><ul><li>建立 <code>deploy</code> 資料庫使用者</li><li>給予 <code>deploy</code> 使用者建立資料庫權限</li><li>由 <code>deploy</code> 使用者建立資料庫（等同擁有者）</li></ul><blockquote><p>其實應該是開好資料庫後指定 <code>deploy</code> 資料庫使用者為所有者，不過步驟會稍微複雜一些。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo su - postgres</div><div class="line">createuser --createdb deploy</div></pre></td></tr></table></figure><p>完成之後，我們就可以回到 <code>deploy</code> 使用者上開設資料庫。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo su - deploy</div><div class="line">createdb example_db</div></pre></td></tr></table></figure><blockquote><p><code>example_db</code> 記得替換成你的專案的名稱，像是 <code>mystore_production</code> 之類的。</p></blockquote><h2 id="準備設定檔"><a href="#準備設定檔" class="headerlink" title="準備設定檔"></a>準備設定檔</h2><p>在上一篇我們設定了 <code>config/secrets.yml</code> 為設定檔，所以我們需要先建立起來，以免在部屬的時候找不到。</p><p>舉例來說，如果我們設定了 <code>deploy_to</code> 為  <code>/home/deploy/staging</code> 的話，需要先建立好 <code>shared</code> 目錄並把檔案放進去。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo su - deploy</div><div class="line">mkdir -p /home/deploy/staging/shared/config</div></pre></td></tr></table></figure><p>然後用 Vim 編輯 <code>config/secrets.yml</code> 這個檔案，將必要的內容放進去。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attr">staging:</span></div><div class="line"><span class="attr">  secret_key_base:</span> <span class="string">SECRET_KEY_BASE</span></div></pre></td></tr></table></figure><blockquote><p><code>secret_key_base</code> 的值可以用 <code>rake secret</code> 指令產生。</p></blockquote><p>如果有使用資料庫的話，也別忘記將 <code>config/database.yml</code> 設定好放到 <code>/home/deploy/staging/shared/config</code> 目錄裡面。</p><blockquote><p>前面用的創建資料庫方法可以只寫下資料庫名稱，帳號跟密碼會自動被偵測到。</p></blockquote><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>到此為止，我們基本上已經將 Capistrano 設定完畢。下一篇我們要讓 GitHub （或是你自己的 Git 伺服器）允許我們的伺服器可以將專案下載下來，最後再將 Nginx 對應的 Passenger 設定補上，就可以完成第一次的部署了！</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/05/07/Getting-started-deploy-your-Ruby-on-Rails-Part-6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>RubyElixirConfTW 2018 會後感想</title>
      <link>https://blog.frost.tw/posts/2018/05/01/The-RubyElixirConfTW-2018-Experience/</link>
      <guid>https://blog.frost.tw/posts/2018/05/01/The-RubyElixirConfTW-2018-Experience/</guid>
      <pubDate>Mon, 30 Apr 2018 17:11:54 GMT</pubDate>
      <description>
      
        &lt;p&gt;Ruby Conference Taiwan 到今年已經是第七年了，印象中我大概是從 2013 年左右開始參加了，應該也有四五次。今年也加入了 Elixir 一起合辦，因為是&lt;a href=&quot;https://5xruby.tw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;五倍紅寶石&lt;/a&gt;的員工，所以也當了兩年的工作人員。&lt;/p&gt;
&lt;p&gt;那麼，就看看今年有什麼新鮮的事情吧！&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>Ruby Conference Taiwan 到今年已經是第七年了，印象中我大概是從 2013 年左右開始參加了，應該也有四五次。今年也加入了 Elixir 一起合辦，因為是<a href="https://5xruby.tw" target="_blank" rel="noopener">五倍紅寶石</a>的員工，所以也當了兩年的工作人員。</p><p>那麼，就看看今年有什麼新鮮的事情吧！</p><a id="more"></a><h2 id="籌備"><a href="#籌備" class="headerlink" title="籌備"></a>籌備</h2><p>因為在公司很多事情都喜歡參與一點，雖然不是主要的籌備人員不過還是默默的在籌備的群組觀察。最主要的大概還是 Ruby 研討會的贊助問題，除了相對小眾之外，這幾年很多研討會的出現，其實也瓜分了不少公司的贊助預算。而會採用 Ruby on Rails 的公司大多也是新創公司（畢竟以製作 MVP 來說基本上還是最快）所以就不容易取得贊助。</p><p>其他部分的話其實還是跟往年一樣，一個字形容「趕」各種設計物或者其他的東西，對上班族來說要準備這些其實<strong>壓力很大</strong>，不過總覺得這個坑是我自己在 SITCON 挖出來的，後來不少研討會又因為前端的技術進步，都默默的做這樣的規劃。</p><h2 id="Tamashii"><a href="#Tamashii" class="headerlink" title="Tamashii"></a>Tamashii</h2><p>當初 RubyConfTW 是跟 Python 社群借用一套利用 Raspberry Pi 的 NFC 感應打卡機，不過後來就沒有繼續維護。於是就只能自己開發，這也變成了五倍紅寶石的內部專案。不過一直到 2016 年的 RubyConfTW 都是蠻混亂的狀況，像是因為沒有 ActionCable 的客戶端只好用模擬器模擬之類的。</p><p>在 2016 年底我跟強者同事 <a href="https://lctseng.github.io/" target="_blank" rel="noopener">Henry</a> 一起開始了重寫計畫，我負責伺服端而 Henry 則是客戶端，並且在第一次測試的後就順利溝通。發展到 2018 年總算是可以穩定的在一些活動上使用，不過還有著一些硬體上的限制（鬆脫）之類的需要處理，但是整體上已經遠比 2016 年的狀況好上不少。</p><blockquote><p>後來 2017 年的兩位實習生加入這個專案，目前由我們四個人貢獻 <a href="https://tamashii.io" target="_blank" rel="noopener">Tamashii</a> 專案，主要是以容易使用為目標來設計，有興趣的話也歡迎送 Pull Request 或 Issue 給我們改進。</p></blockquote><h2 id="議程"><a href="#議程" class="headerlink" title="議程"></a>議程</h2><p>因為目前使用的錄影設備是跟<a href="https://ruydo.tw" target="_blank" rel="noopener">幕凡</a>一起利用開源的軟體搭配一些影像擷取卡土炮出來的，所以我大部分的時間都在主要的會議廳。不得不說付出了昂貴的場地費，使用張榮發國際會議中心的效果真的很好，至少作為主要會議廳的那一間，是配有專業的設備可以將所有聲音、影像都切進來，我們使用的土炮設備幾乎一半不需要就能做到相同效果。</p><p>不過議程上因為主要把精力花在錄影和關注會場的狀況，所以就沒有都完整的聽到。</p><h2 id="Ruby-after-25-years"><a href="#Ruby-after-25-years" class="headerlink" title="Ruby after 25 years"></a>Ruby after 25 years</h2><p>這麼多次的經驗後，其實大概知道 Matz 的演講大多是當年度象徵性的，今年的主題也很明確就是 Ruby 3x3 裡面的 Ruby 2.6 版。至少從出現 JIT 開始，今年有關 Ruby 的研討會大多會是討論 Ruby 2.6 為主。</p><p>不過這場幾乎沒有聽到內容（也有可能是酒喝多了），不過今年大概是拿到幾個新成就讓我比較興奮。</p><p>第一個是第一次發現跟外國人用英文交談，即使對單字不太能理解，但是說的部分已經不會嚴重卡住。<br>第二個是因為問 Matz 關於 mruby 的問題，順利的被記住而被打招呼。<br>最後一個是今年超容易跟 Matz 交談到，完全不知道為什麼 XD</p><h2 id="How-the-Rubyist-use-Blockchain"><a href="#How-the-Rubyist-use-Blockchain" class="headerlink" title="How the Rubyist use Blockchain"></a>How the Rubyist use Blockchain</h2><p>我自己的演講，因為有口譯的關係有嘗試放慢速度。另外一個點就是我認為「區塊鏈可以講的東西不多」所以也特意放慢一點，畢竟對工程師來說區塊鏈可以使用的方法就是那幾種。我們需要注意的是不要被這些東西迷惑，還有就是了解怎麼樣去創造應用。</p><p>區塊鏈本身是概念上的創新，所以我們製作應用也需要用改變概念的方式去嘗試會比較適合。</p><blockquote><p>有興趣的話可以讀看看我之前寫的<a href="https://blog.frost.tw/posts/2018/04/02/The-blockchain-I-know-about-in-2018/">在 2018 年我所知道的區塊鏈</a>基本上就是演講的內容，只是沒有後半段用 Ruby 跟 Ethereum 互動的部分。</p></blockquote><h2 id="Method-JIT-compiler-for-MRI"><a href="#Method-JIT-compiler-for-MRI" class="headerlink" title="Method JIT compiler for MRI"></a>Method JIT compiler for MRI</h2><p>這場其實也沒有聽到，不過因為剛好有對這方面比較了解的朋友有來，在會後的 Official Party 幫我稍微釐清了一些脈絡大方向。關於 Ruby 的 JIT 我是很關注的，就我自己認為 Ruby 3x3 的關鍵應該會落在 JIT 最後的表現。</p><p>大致上來說 Ruby 社群會希望「向下相容」再加上「不希望花時間在維護因為 LLVM 之類的升級造成的變動」所以才會採取「產生 C 語言程式碼」和以 Method 為單位的 JIT 來設計。</p><p>同時也有 YARV-JIT 和 RTL-JIT 兩種方案在執行，這次在 Ruby 2.6 加入的是 YARV-JIT 的版本，不過之後的發展還是不確定的。</p><h2 id="Inspecting-and-Crafting-Rails"><a href="#Inspecting-and-Crafting-Rails" class="headerlink" title="Inspecting and Crafting Rails"></a>Inspecting and Crafting Rails</h2><p>這場演講看似是在講怎麼調整 Rails 讓他運行的更快，不過其最有價值的反而是展示了怎麼應用像是 <code>ObjectSpace</code> 這類技巧，讓我們在開發 Ruby 專案遇到瓶頸的時候，可以用適合的方法去優化 Ruby 專案。</p><h2 id="Progress-report-of-“Ruby-3-Concurrency”"><a href="#Progress-report-of-“Ruby-3-Concurrency”" class="headerlink" title="Progress report of “Ruby 3 Concurrency”"></a>Progress report of “Ruby 3 Concurrency”</h2><p>這場也是我很專注的議題，關於 Ruby 中的 Concurrent 實現。之前其實有一篇文章介紹過了幾種 Concurrent 模型，不過在 Ruby 裡面其實都是不太適合的。</p><p>不過這場演講有大概交代了 Ruby 的 Concurrent 模型 Guild 的設計是受到什麼啟發，還有應用上可以透過怎樣的形式。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>今年覺得最大的收穫大概是去年在 RubyKaigi 聽得不少議程其實都沒有搞懂太多，不過經過這半年多的消化或者調整的思考方式，所以這次其實不少關於 Ruby 一些關於 C 語言的部分這次都能夠大概的理解。</p><p>大致上來說，從去年在考慮是不是要嘗試成為 Ruby 的 Commiter 這件事情，到這次的活動結束。讓我認為自己應該是適合成為 Ruby Commiter 的，雖然可能要花上好幾年才能完成，不過也許是我在追求作為自己理想中的開發者的必經之路。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/05/01/The-RubyElixirConfTW-2018-Experience/#disqus_thread</comments>
    </item>
    
    <item>
      <title>如何在 2018 年被詐騙</title>
      <link>https://blog.frost.tw/posts/2018/04/24/How-to-be-scammed-in-2018/</link>
      <guid>https://blog.frost.tw/posts/2018/04/24/How-to-be-scammed-in-2018/</guid>
      <pubDate>Tue, 24 Apr 2018 11:50:12 GMT</pubDate>
      <description>
      
        &lt;p&gt;這是關於某天晚上接到詐騙電話的分析，因為過程中太多細節的東西讓人掉入陷阱，跟同事聊過之後覺得還是寫一篇文章記錄會比較好，至少不會有人又踩到這樣的坑。&lt;/p&gt;
&lt;p&gt;這篇文章重點也很簡單，&lt;strong&gt;「不要以為你不會被騙」&lt;/strong&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>這是關於某天晚上接到詐騙電話的分析，因為過程中太多細節的東西讓人掉入陷阱，跟同事聊過之後覺得還是寫一篇文章記錄會比較好，至少不會有人又踩到這樣的坑。</p><p>這篇文章重點也很簡單，<strong>「不要以為你不會被騙」</strong></p><a id="more"></a><h2 id="先從結局開始"><a href="#先從結局開始" class="headerlink" title="先從結局開始"></a>先從結局開始</h2><p>很幸運的，繳了一點學費給詐騙集團。因為平常有管理存款的習慣，所以其實只讓對方成功了很小的金額，基本上就是這個月接近月底剩下的生活費。</p><p>雖然做了筆錄跟嘗試套對方話，但是基本上沒什麼效果就是了⋯⋯</p><h2 id="系統升級失敗"><a href="#系統升級失敗" class="headerlink" title="系統升級失敗"></a>系統升級失敗</h2><p>週末的晚上，我在電腦桌前打瞌睡醒來就接到一通電話。</p><p>「你在一月多訂的東西收到了嗎？」<br>「我是某某公司的會計，剛剛在對帳時發現了一點問題。」<br>「在一月多你從我們線上購物平台購買的商品，因為購物平台工程師升級造成的錯誤，多扣了兩次。」<br>「等一下我會幫你聯絡銀行，勁量爭取在 <strong>24:00</strong> 前取消。」</p><p>完美的起手式，但是我還是中招。主要是因為我清楚這幾點：</p><ul><li>會計有可能在這個時間點（十點）還有處理東西</li><li>系統升級失敗確實會有這種情況（身為工程師的經驗）</li></ul><p>不過，如果冷靜思考的話，其實也會有一些疑點在。</p><ul><li>銀行半夜會有人嗎？</li><li>已經過了三個多月扣款還能成功嗎？</li></ul><p>其實當時也有點懷疑，像是多扣到銀行應該會通知我（透過 APP）之類的，但是完全沒有通知，而且很剛好的是該銀行刷卡通知改成 APP 後有出包不一定會收到。</p><p>而且，對你的情報是<strong>恰到好處的含糊</strong>這時候如果能跟對方多確認一些細節，就可能不會中招。</p><blockquote><p>很剛好是上週末店家才跟我約週一送，週末就打來騙了⋯⋯<br>電話號碼也很用心，因為我記得店家是中南部的，顯示的號碼也是 07 之類的開頭。</p></blockquote><h2 id="友好的閒聊"><a href="#友好的閒聊" class="headerlink" title="友好的閒聊"></a>友好的閒聊</h2><p>前面為什麼要爭取在 24:00 之前呢，根據我找到的資訊銀行會統一在 24:00 的時候做一次統一結算，這時候要取消轉帳交易就變得很困難，所以通常會選擇<strong>接近午夜</strong>的時候行動。</p><blockquote><p>非上班時間接到都詐騙，如果真的很重要的話銀行應該會用各種方式聯絡到你，晚上不接這種最安心拉。</p></blockquote><p>前面其實有跟我詢問<strong>銀行客服</strong>電話，是假裝要真的去聯絡銀行。不過我跟他說我是用「虛擬卡」所以沒有實體卡片可以看，不過其實對方從一開始就沒打算認真問就是了。</p><p>「剛剛你說的那個『虛擬卡』是什麼？」<br>「我跟同事討論了一下，第一次聽到，可以跟我解釋一下嗎？」</p><p>然後我就稍微解釋一下，因為是中年大媽的聲音，所以我以為就是沒用過的大媽。</p><p>「喔喔，謝謝你啊！我跟同事應該會去辦來看看。」</p><p>超溫馨的有沒有，這時候防備的戒心已經開始消失了，你會心想<strong>這麼好的人應該不是詐騙吧</strong>。</p><p>接下來我就開始等銀行電話，中間其實一直有<strong>奇怪</strong>的感覺，但是都沒注意到已經踩到陷阱。</p><blockquote><p>其實我妹有聽到我講電話，但是我妹一開始是以為在跟朋友聊天。</p></blockquote><h2 id="銀行的服務"><a href="#銀行的服務" class="headerlink" title="銀行的服務"></a>銀行的服務</h2><p>大概是晚上快十一點了，只要這一波騙到他們就爽賺拉！</p><p>「請問是 X 先生嗎？我是 XX 銀行專員。」<br>「剛剛我們收到 XX 公司的通知，知道您有兩筆刷卡需要取消。」<br>「因為<strong>24:00</strong>後就會成立，我們會為了您的權益盡力在這之前完成處理。」<br>「<strong>因為購物是透過第三方公正平台，郵局來處理的，所以我們需要您的郵局帳號前四碼來確認</strong>」</p><p>這段對話蠻多的，我省略掉了一些地方。其實他是在問你「有多少帳戶」而帳戶前四或六碼基本上都是分行的代碼。</p><blockquote><p>我完全忘記<strong>郵局應該沒在管金流</strong>這件事情。</p></blockquote><p>「是 XX 分行開戶的對吧？」<br>「很可惜我們連線失敗了，<strong>您的帳戶似乎有個資保護。</strong>」<br>「是不是開戶時都有勾選呢？」<br>「要不要換其他銀行的帳戶看看？」</p><p>中間會不斷這樣的確認，而且你都會以為「應該是真的有系統連線吧！」其實他只是要盡力多套幾個帳戶出來，不過似乎數量多到一個程度就會停止（大概三個）</p><p>以我的習慣來說，有「個資保護」我當然會勾選是。所以很明顯他這樣「含糊」的說明就讓我中招，尤其是<strong>你只瞭解部分</strong>的狀況下。</p><blockquote><p>以前研究過這種晶片卡，基本上裡面確實可以存資料跟加密（Ex. 悠遊卡）但是銀行卡是怎麼運作的並不清楚，所以就被騙到。</p></blockquote><p>「那你用查詢餘額的方式看看？」<br>「點開 XX 銀行，然後查看餘額試試看。」<br>「你把時間跟餘額告訴我，這樣我才能針對這個時間點做查詢。」</p><p>這邊被我耗掉不少時間，因為以工程師的「篩選資料」來看，這個方法有點不靠譜跟精準。但是給的條件其實又「足夠調出可以人工選取的量」</p><blockquote><p>我跟他爭論很久為什麼 APP 餘額查詢沒顯示交易時間可以用手機時間，對方有點生氣（這就是疑點啊！！）</p></blockquote><p>之後基本上因為我還是覺得他檢查的方法<strong>似真似假</strong>所以卡了不少時間，因為越來越接近十二點，對方就開始出招。</p><h2 id="強制解除"><a href="#強制解除" class="headerlink" title="強制解除"></a>強制解除</h2><p>接下來對方就會裝出遇到困難的樣子，然後說要請主管幫忙。</p><blockquote><p>這其實也超可疑，銀行是什麼血汗公司嗎？半夜都在上班的？下午三點半就要關門都是假的？</p></blockquote><p>「我問一下我們技術主管看看，還有什麼方式處理。」<br>「主管因為怎樣怎樣，所以我們需要用強制解除晶片加密的方式。」</p><p>後來打 165 的時候，是被秒回說不存在這個功能。</p><p>這邊其實也有幾個疑點：</p><ul><li>前面說資料是存在晶片裡面，但是現在卻能透過轉帳解除？</li><li>全世界的銀行都是他們的，資料隨便查耶？</li></ul><p>「那你先打開手機的轉帳介面，然後到轉帳的地方輸入 822 中國信託」<br>「因為 #$&amp;*#$@#%# 所以是透過中國信託解除」<br>「帳戶就填寫身分證字號後九碼，金額就填寫 2 然後轉帳就可以了」</p><p>一樣疑點很多，其實到這邊我已經開始懷疑，但是離十二點大概才剩下二十分鐘⋯⋯</p><blockquote><p>大疑點：到底為何 A 銀行客服會教我用 B 銀行轉帳到 C 銀行去解除呢？</p></blockquote><p><strong>我超想睡</strong></p><p>其實我有問「咦，要輸入簡訊驗證碼？」</p><p>這時候對方其實有點著急，然後再催我了⋯⋯</p><p>「對，按下繼續後就會失敗！」<br>「然後錯誤代碼是不是 4507 怎樣怎樣」</p><p>這邊會先讓你「失敗」一次，所以你不會覺得奇怪。</p><p>「好了，剛剛解鎖後我們已經順利從郵局取消這兩筆刷卡。」<br>「現在我們要幫您恢復加密，因為如果沒有恢復一過 <strong>24:00 可能會被當作異常帳戶歸零餘額</strong>」<br>「現在離十二點不久，我們趕緊將帳戶恢復。」<br>「接下來我們會產生一組恢復加密的代碼，請你一樣用轉帳的方式輸入後，就可以恢復。」</p><blockquote><p>跟新手教學一樣，先示範後再來真的，很貼心對吧 XD</p></blockquote><p>「銀行一樣選 822 中國信託，帳戶就輸入 12345667」<br>「金額就輸入 11223 就可以了」</p><p>其實到這邊我開始猶豫要不到照做，但是想到「結束後我就可以躺到床上」就繼續下去了。</p><p>另外金額不會剛好等於餘額，因為剛剛已經問過餘額，所以會給一個「接近餘額」的數字，用來混淆。</p><p>這時候我又再問「又出現簡訊驗證碼了，要按嗎？」</p><p><strong>然後當然是很興奮的叫我按下去拉⋯⋯</strong></p><p>我就很順利的<strong>中招完畢</strong>了！</p><h2 id="其他帳戶還要恢復"><a href="#其他帳戶還要恢復" class="headerlink" title="其他帳戶還要恢復"></a>其他帳戶還要恢復</h2><p>接下來他就跟我說其他帳戶也要恢復，就開始要我重複前面的動作進行 SOP 流程。</p><ul><li>查餘額</li><li>轉帳</li><li>被騙</li></ul><p>不確定是對方可能來自遙遠的中國，或者我家的訊號不好。中間斷訊好幾次，來自 Whoscall 的「紅字提示」讓我稍微清醒了一點。</p><p><strong>此號碼曾被變造過，預防詐騙請撥打 165</strong></p><p>於是，我就開始假裝配合，順便給我妹手勢（因為我電腦讀卡機又讀不到，所以去跟我妹借電腦）</p><p>我：「比出 一 六 五 （使眼色」<br>妹：「？？？」<br>我：「比出 一 六 五 （使眼色」<br>妹：「？？？」</p><p>我妹到現在還以為我在跟朋友聊天，主要是因為「對方會一直提醒你不要其他人講」雖然我很淡定的開擴音很久，但是我妹也沒有發現有問題。</p><blockquote><p>所以說，遇到這種除了自己清醒之外。你的朋友或家人清醒也超重要⋯⋯</p></blockquote><p>我：「我可以掛一下電話嗎？我朋友傳訊息說有急事找我⋯⋯」<br>「這樣不好，我們要盡快幫你處理」</p><p>中間就是在找藉口，最後是跟他說我不掛電話，到我的房間先回一下朋友訊息。然後用我妹的電話直接打 165 報案。</p><p>妹：「他在叫你了⋯⋯」</p><p>對，離開太久還會把你找回來，還好我妹能幫我回答一些基本資料，讓流程繼續跑。</p><blockquote><p>可惜轉過去的帳戶沒能先讓我妹幫我登記，不然應該能搶在對方之前處理。</p></blockquote><p>之後就是一樣嘗試要轉掉郵局的錢，因為郵局主要是放我給爸媽的錢，而且爸媽幾乎也不會用，所以筆剛剛吧騙的多好幾倍，對方當然是想要馬上得手⋯⋯</p><p>運氣不錯的是剛好郵局顯示「00:00 ~ 1:30 為每日系統維護」我就用這個當藉口，請他明天跟我約時間再處理。</p><blockquote><p>中間 165 回撥我好幾次都沒成功，因為對方一直「不肯掛電話」提醒在提醒「不要跟朋友講」</p></blockquote><h2 id="筆錄"><a href="#筆錄" class="headerlink" title="筆錄"></a>筆錄</h2><p>接到電話後就馬上把剛剛的銀行帳戶那些給 165 負責的專員，並且對該帳戶做一些處理。之後就是接到附近的警察問說能不能過去做筆錄，我想這種冬東西早點處理會比較好，就在半夜走到警察局。</p><p>做完紀錄後，原本不清楚「警示帳戶」是什麼，隔天早上才知道是凍結對方帳戶。</p><p>不過警察表示「他們這種都會馬上領出，一班沒什麼效果」</p><p>後來也給我一些宣導文宣（真的是他們常處理的業務）不過我看了之後發現<strong>宣導的內容我都很注意，但是在發生的當下都因為一些小細節反而沒有注意到</strong></p><p>所以才會說「不要以為不會被騙」很多時候太信任一個陌生人，可能不是一件好事啊。</p><blockquote><p>大概是同事平常太好，活在溫馨的世界太久 XD</p></blockquote><p>進去警察局的時候，前面也有一個人在做筆錄，聽到的對話也是「被詐騙」尤其時我好一陣子都在捷運的 ATM 看到警察局貼的「警告標語」想說這一陣子沒有貼了，一鬆懈馬上中招。</p><h2 id="第二回合"><a href="#第二回合" class="headerlink" title="第二回合"></a>第二回合</h2><p>既然帳戶被凍結，我想最晚一早也會處理。至於約好的隔天晚上七點，到底會不會打來呢？到底會不會被發現，就跳過？</p><p>看起來沒被發現，所以就嘗試「演戲」配合對方。</p><p>不過，在這個階段又發現了更多<strong>詐騙集團很可惡</strong>的地方。</p><ul><li>會盡可能選接近 24:00 的時間，約七點就推托忙到九點</li><li>他們很熟悉所有銀行的流程<ul><li>我假裝登入網銀都騙不到對方，直到我去找教學截圖描述一致才能繼續</li><li>確認時間跟錯誤代碼是為了辨識使用的銀行跟是否有真實操作</li></ul></li></ul><p>簡單說，如果是假的操作馬上會被對方識破。不過對方也不是能馬上反應過來，基本上過程中勁量假裝是個「電腦白痴」一步一步操作就可以了。</p><p>而且說詞會不斷變化，像是發現我可能有「警覺」上鎖的動作就從轉帳又回到身分證字號的 SOP 先讓你「確認會失敗，很安全」才繼續。</p><p>比較可惜的就是沒有順利騙到其他的帳戶，雖然是人頭帳戶，但是多鎖一個幫對方找麻煩也是不錯。</p><blockquote><p>當你要電話跟分行位置的時候，基本上就會被發現，而且號碼都是裝成銀行的很難區分。</p></blockquote><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>後來有去找到一篇流程跟我幾乎一樣的詐騙網誌文章，不過差別在於相較 2012 年的過程，現在 2018 年的細節已經非常精細，許多地方是完全貼近真實狀況的，所以才難以防範（不過都不信就解決拉，真有問題銀行會想辦法，雖然有點對不起辛苦的行員）</p><p>至於嚴格來說到底會不會被騙這件事情，我覺得就是「不要太在意」跟「臨櫃能處理」就好了。</p><ul><li>直接去銀行櫃台處理，讓他扣再說</li><li>晚上堅持不處理轉帳</li><li><strong>轉帳就只會出現轉帳的效果</strong></li></ul><p>大概只要抓到上面幾點，應該就能防止這種類型的詐騙發生。這次的經驗就當繳學費，順便就是我有完整的參考資料，可以在下次遇到的時候認真地跟對方玩。</p><p>另外談談金融科技，我認為這類詐騙會在普及之後消失，轉變為資安類的問題。國外很多銀行都已經導入 AI 來偵測異常刷卡，像這種異常轉帳或者詐騙，應該會在之後普及金融科技慢慢消失，主要就是網路銀行電子化之後，帳單跟處理錯誤的刷卡都能透過網路進行，就比較不會有機會透過電話來處理，畢竟上網點一下就解決。</p><p>最後，希望大家不會中招。雖然我猜看到這篇文章的時候，就跟我看到 2012 年那篇文章一樣，是中招後了⋯⋯</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/04/24/How-to-be-scammed-in-2018/#disqus_thread</comments>
    </item>
    
    <item>
      <title>部署你的第一個 Ruby on Rails 網站（五）</title>
      <link>https://blog.frost.tw/posts/2018/04/15/Getting-started-deploy-your-Ruby-on-Rails-Part-5/</link>
      <guid>https://blog.frost.tw/posts/2018/04/15/Getting-started-deploy-your-Ruby-on-Rails-Part-5/</guid>
      <pubDate>Sun, 15 Apr 2018 14:04:14 GMT</pubDate>
      <description>
      
        &lt;p&gt;到&lt;a href=&quot;https://blog.frost.tw/posts/2018/04/10/Getting-started-deploy-your-Ruby-on-Rails-Part-4/&quot;&gt;第四篇&lt;/a&gt;為止，我們已經有了可以運行 Ruby on Rails 的環境，不過到底該怎麼在伺服器上跑起來呢？&lt;/p&gt;
&lt;p&gt;絕對不是&lt;strong&gt;把程式碼複製到伺服器&lt;/strong&gt;這種簡單的做法，或者說這樣的做法在更新上是很沒有效率的！&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>到<a href="https://blog.frost.tw/posts/2018/04/10/Getting-started-deploy-your-Ruby-on-Rails-Part-4/">第四篇</a>為止，我們已經有了可以運行 Ruby on Rails 的環境，不過到底該怎麼在伺服器上跑起來呢？</p><p>絕對不是<strong>把程式碼複製到伺服器</strong>這種簡單的做法，或者說這樣的做法在更新上是很沒有效率的！</p><a id="more"></a><p>在 Ruby 中，有一個非常好用的 Ruby Gem 叫做 Capistrano 可以自動地幫我們完成網站部署。運作起來其實也很簡單，就是幫我們 SSH 到伺服器上，執行相對應的指令。</p><p>這跟自己複製到伺服器上有什麼差別呢？假設我們現在要部署到四五十台的伺服器，難道要一台一台複製嗎？</p><p>有這些工具的輔助，就能夠下完指令就去泡咖啡等部署完成拉 XD</p><blockquote><p>最近打算學一下 Ansible 怎麼使用，也許下次會分享用 Ansible 部署多台 Ruby on Rails 伺服器的方法。</p></blockquote><h2 id="安裝-Capistrano"><a href="#安裝-Capistrano" class="headerlink" title="安裝 Capistrano"></a>安裝 Capistrano</h2><p>首先，先在我們的 <code>Gemfile</code> 加上</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">group <span class="symbol">:development</span> <span class="keyword">do</span></div><div class="line">  gem <span class="string">'capistrano'</span>, <span class="string">'~&gt; 3.10'</span>, <span class="symbol">require:</span> <span class="literal">false</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>因為 Capistrano 可能會因為版本升級而改變一些設定，所以大多會限制版本。另外就是這是一個擴充的指令，所以可以設定為 <code>require: false</code> 來避免在運行 Ruby on Rails 的時候將它讀取進來。</p><p>接下來，我們要執行 <code>install</code> 指令，將 Capistrano 所需的設定檔生成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bundle <span class="built_in">exec</span> <span class="built_in">cap</span> install</div></pre></td></tr></table></figure><p>當我們看到多出了 <code>Capfile</code> 和一些檔案後，就算是將 Capistrano 安裝完畢了！</p><h2 id="設定-Capistrano"><a href="#設定-Capistrano" class="headerlink" title="設定 Capistrano"></a>設定 Capistrano</h2><p>雖然安裝好了 Capistrano 但是我們還沒有針對 Capistrano 設定該如何取得原始碼、上傳到哪台伺服器上面。</p><p>首先，因為是 Ruby on Rails 專案，所以我們先在 <code>Capfile</code> 裡面做一些修改，讓 Capistrano 能夠自動幫我們針對一些 Ruby on Rails 特有的行為做處理。</p><p>下面這些是預設被註解掉的選項，我們在部署的時候會需要用到，所以都將他取消註解。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">require</span> <span class="string">"capistrano/bundler"</span></div><div class="line"><span class="keyword">require</span> <span class="string">"capistrano/rails/assets"</span></div><div class="line"><span class="keyword">require</span> <span class="string">"capistrano/rails/migrations"</span></div><div class="line"><span class="keyword">require</span> <span class="string">"capistrano/passenger"</span></div></pre></td></tr></table></figure><p>然後我們需要設定要部署的伺服器，預設 Capistrano 會區分 Production（正式）和 Staging（測試）環境，所以我們需要對這兩個環境個別設定。</p><blockquote><p>不過現實上我們可能還是很小的專案，只有一台伺服器。也是可以設定在同一台上的，這篇文章也會示範部署在同一台的方式。</p></blockquote><p>首先，我們先針對 Staging 環境做設定，打開 <code>config/deploy/staging.rb</code> 這個檔案，修改成下面這樣。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">server <span class="string">'伺服器 IP'</span>, <span class="symbol">user:</span> <span class="string">'deploy'</span>, <span class="symbol">roles:</span> <span class="string">%w&#123;app web db&#125;</span></div><div class="line">set <span class="symbol">:deploy_to</span>, <span class="string">'/home/deploy/staging'</span></div></pre></td></tr></table></figure><p>如果忘記 IP 的話可以到 Digital Ocean 找看看，因為要分別部署 Production 和 Staging 兩個網站，所以我們針對 <code>deploy_to</code> 做設定，讓他複製到不同的資料夾下面。</p><blockquote><p>一般這種我會習慣用網址當資料夾名稱，像是 <code>/home/deploy/beta.rookie.works</code> 這樣子，比較好區分。</p></blockquote><p>至於 <code>config/deploy/production.rb</code> 的設定，基本上就是複製 Staging 設定後做修改。</p><p>接下來，我們需要設定如何部署。</p><p>打開 <code>config/deploy.rb</code> 來進行設定，我們先將原始碼的位置指定給 Capistrano。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">set <span class="symbol">:application</span>, <span class="string">'deploy-example'</span></div><div class="line">set <span class="symbol">:repo_url</span>, <span class="string">'git@github.com:elct9620/deploy-example.git'</span></div></pre></td></tr></table></figure><p>最重要的是 <code>repo_url</code> 需要正確的設定，如果還不知道怎麼使用 Git 跟上傳自己的專案到 Github 的話，可以參考像是<a href="https://gitbook.tw/" target="_blank" rel="noopener">為你自己學 Git</a> 這類書籍來了解。</p><p>最後，我們要針對 Ruby on Rails 一些共用的設定檔做一些設定。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Default value for :linked_files is []</span></div><div class="line">append <span class="symbol">:linked_files</span>, <span class="string">'config/secrets.yml'</span></div><div class="line"></div><div class="line"><span class="comment"># Default value for linked_dirs is []</span></div><div class="line">append <span class="symbol">:linked_dirs</span>, <span class="string">'log'</span>, <span class="string">'tmp/pids'</span>, <span class="string">'tmp/cache'</span>, <span class="string">'tmp/sockets'</span>, <span class="string">'node_modules'</span>, <span class="string">'public/shared'</span>, <span class="string">'public/uploads'</span></div><div class="line"></div><div class="line"><span class="comment"># Default value for default_env is &#123;&#125;</span></div><div class="line">set <span class="symbol">:default_env</span>, &#123; <span class="symbol">path:</span> <span class="string">'/usr/local/ruby-2.4.3/bin:$PATH'</span> &#125;</div></pre></td></tr></table></figure><p>首先，因為 <code>config/secrets.yml</code> 會影響到 Rails 的加密機制，所以我們都會先在伺服器上放好 <code>config/secrets.yml</code> 這個檔案，並預先寫死在裡面，以免被其他人直接取得。</p><blockquote><p>像是 Github 偶爾還是能找到一些帳號密碼，像是這類敏感資訊要記得不要 Commit 到 Git 裡面。</p></blockquote><p>至於 <code>linked_dirs</code> 則是針對一些常用的資料夾，像是上傳檔案的目錄、紀錄檔等等。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>整體上來說 Capistrano 的設定還是相對簡單的，不過前面在設定伺服器的時候可能還會看到像是 <code>role</code> 之類的設定，這是在不同伺服器扮演網頁伺服器或者資料庫伺服器時，可以個別執行不同動作的設計。</p><p>下一篇文章我們會回到伺服器上的設定，將使用 Capistrano 部署到伺服器上的必要條件設定起來。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/04/15/Getting-started-deploy-your-Ruby-on-Rails-Part-5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>部署你的第一個 Ruby on Rails 網站（四）</title>
      <link>https://blog.frost.tw/posts/2018/04/10/Getting-started-deploy-your-Ruby-on-Rails-Part-4/</link>
      <guid>https://blog.frost.tw/posts/2018/04/10/Getting-started-deploy-your-Ruby-on-Rails-Part-4/</guid>
      <pubDate>Tue, 10 Apr 2018 08:54:22 GMT</pubDate>
      <description>
      
        &lt;p&gt;從&lt;a href=&quot;https://blog.frost.tw/posts/2018/03/20/Getting-started-deploy-your-Ruby-on-Rails-Part-1/&quot;&gt;第一篇&lt;/a&gt;到&lt;a href=&quot;https://blog.frost.tw/posts/2018/03/23/Getting-started-deploy-your-Ruby-on-Rails-Part-2/&quot;&gt;第二篇&lt;/a&gt;的說明，加上&lt;a href=&quot;https://blog.frost.tw/posts/2018/03/23/Getting-started-deploy-your-Ruby-on-Rails-Part-3/&quot;&gt;第三篇&lt;/a&gt;我想大家已經對編譯自己的環境稍為熟悉。&lt;/p&gt;
&lt;p&gt;為了要可以用 Passenger 作為網站伺服器，我們需要自行編譯 Nginx 讓他可以使用 Passenger 模組。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>從<a href="https://blog.frost.tw/posts/2018/03/20/Getting-started-deploy-your-Ruby-on-Rails-Part-1/">第一篇</a>到<a href="https://blog.frost.tw/posts/2018/03/23/Getting-started-deploy-your-Ruby-on-Rails-Part-2/">第二篇</a>的說明，加上<a href="https://blog.frost.tw/posts/2018/03/23/Getting-started-deploy-your-Ruby-on-Rails-Part-3/">第三篇</a>我想大家已經對編譯自己的環境稍為熟悉。</p><p>為了要可以用 Passenger 作為網站伺服器，我們需要自行編譯 Nginx 讓他可以使用 Passenger 模組。</p><a id="more"></a><p>不過因為 Passenger 已經針對這方面做好對應的處置，所以我們只需要按照 Passenger 提供的解決方案一步一步的進行編譯即可。</p><blockquote><p>Passenger 提供了從原始碼安裝跟透過 Ruby Gem 安裝兩種，為了好維護跟升級，這篇文章會採取從原始碼安裝的方式。</p></blockquote><h2 id="取得原始碼"><a href="#取得原始碼" class="headerlink" title="取得原始碼"></a>取得原始碼</h2><p>Passenger 除了開放原始碼的版本，也有企業版。從<a href="https://www.phusionpassenger.com/" target="_blank" rel="noopener">官網</a>可以找到開放原始碼版本的下載點，而且貼心的提供了像下面截圖的安裝指南。</p><p><img src="https://blog.frost.tw/images/getting-started-deploy-your-ruby-on-rails-part-4/screenshot1.jpg" alt="螢幕快照 2018-04-10 上午12.13.04.png"></p><p>因為要從原始碼安裝，所以要先選擇其他作業系統。</p><p><img src="https://blog.frost.tw/images/getting-started-deploy-your-ruby-on-rails-part-4/screenshot2.jpg" alt="螢幕快照 2018-04-10 上午12.13.30.png"></p><p>因為要和 Nginx 搭配，要記得將 <code>Standalone</code> 改為 <code>Nginx</code> 才能得到正確的安裝指南。</p><blockquote><p>不過 Standalone 模式似乎也會變編譯一個 Nginx 來運行，只是不會顯示給使用者。</p></blockquote><p>對頁面上的「Download tarball」按鈕點選右鍵複製連結，會得到類似下面的連結。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://www.phusionpassenger.com/latest_stable_tarball</div></pre></td></tr></table></figure><p>因為 Passenger 不像 Ruby 安裝完畢後會複製到某個指定的資料夾，所以我們可以參考 Homebrew 的方式，在 <code>/usr/local/passenger</code> 裡面放置檔案。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir /usr/<span class="built_in">local</span>/passenger</div><div class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/passenger</div><div class="line">wget https://www.phusionpassenger.com/latest_stable_tarball</div></pre></td></tr></table></figure><blockquote><p>這邊建議用 <code>root</code> 來進行這個動作，因為 Passenger 安裝過程會需要 <code>root</code> 權限之外，<code>/usr/local</code> 目錄要新增資料夾也是需要有 <code>root</code> 權限的。</p></blockquote><h2 id="安裝-Passenger"><a href="#安裝-Passenger" class="headerlink" title="安裝 Passenger"></a>安裝 Passenger</h2><p>首先把我們下載回來的 Passenger 解壓縮。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -zxvf latest_stable_tarball</div></pre></td></tr></table></figure><blockquote><p>用 <code>wget</code> 不知道原因並沒有自動轉成檔名，不過能夠解壓縮就就不需要太在意細節。</p></blockquote><p>解壓縮後應該會得到一個最新版的 Passenger 目錄（本文撰寫時是 5.2.3 版）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@deploy-example passenger]<span class="comment"># ls</span></div><div class="line">latest_stable_tarball  passenger-5.2.3</div></pre></td></tr></table></figure><p>接著進入 <code>passenger-5.2.3</code> 這個目錄，執行 Passenger 的安裝程式。因為 Passenger 是有使用 Ruby 的，如果上一篇文章介紹的設定沒有正確的話，可能會無法執行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/passenger/passenger-5.2.3/bin:<span class="variable">$PATH</span></div><div class="line">passenger-install-nginx-module</div></pre></td></tr></table></figure><p>依照文件，我們跟上次設定 Ruby 的時候一樣先暫時讓 Passenger 的執行檔都可以執行。安裝中途也會嘗試呼叫這個目錄的其他執行檔，所以在安裝階段先這樣設定會讓後續流暢不少。</p><blockquote><p>執行 <code>passenger-install-nginx-module</code> 會中斷好幾次，主要是 Passenger 會建議我們把一些設定改善後再繼續。</p></blockquote><p>開始後，會先出現類似下面的詢問訊息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[root@deploy-example passenger-5.2.3]<span class="comment"># passenger-install-nginx-module</span></div><div class="line">Welcome to the Phusion Passenger Nginx module installer, v5.2.3.</div><div class="line"></div><div class="line">This installer will guide you through the entire installation process. It</div><div class="line">shouldn<span class="string">'t take more than 5 minutes in total.</span></div><div class="line"></div><div class="line">Here's what you can expect from the installation process:</div><div class="line"></div><div class="line"> 1. This installer will compile and install Nginx with Passenger support.</div><div class="line"> 2. You<span class="string">'ll learn how to configure Passenger in Nginx.</span></div><div class="line"> 3. You'll learn how to deploy a Ruby on Rails application.</div><div class="line"></div><div class="line">Don<span class="string">'t worry if anything goes wrong. This installer will advise you on how to</span></div><div class="line">solve any problems.</div><div class="line"></div><div class="line">Press Enter to continue, or Ctrl-C to abort.</div></pre></td></tr></table></figure><p>因為有好幾次詢問，所以如果後面沒有特別提醒的話，請自己按 Enter 繼續執行即可。</p><p>開始後會先詢問要支援哪些語言，因為 Passenger 後來陸續增加了 Python 和 Node.js 的支援，如果需要的話，也可以用方向鍵和空白鍵選取起來。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Which languages are you interested <span class="keyword">in</span>?</div><div class="line"></div><div class="line">Use &lt;space&gt; to select.</div><div class="line">If the menu doesn<span class="string">'t display correctly, press '</span>!<span class="string">'</span></div><div class="line"></div><div class="line"> ‣ ⬢  Ruby</div><div class="line">   ⬡  Python</div><div class="line">   ⬡  Node.js</div><div class="line">   ⬡  Meteor</div></pre></td></tr></table></figure><p>下一步會檢查相依性，如果出現類似下面的訊息，就表示有缺少一些程式。按下 Enter 之後 Passenger 會給出安裝指令，我們再複製來使用即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">Checking <span class="keyword">for</span> required software...</div><div class="line"></div><div class="line"> * Checking <span class="keyword">for</span> C compiler...</div><div class="line">      Found: yes</div><div class="line">      Location: /usr/bin/cc</div><div class="line"> * Checking <span class="keyword">for</span> C++ compiler...</div><div class="line">      Found: no</div><div class="line"> * Checking <span class="keyword">for</span> A download tool like <span class="string">'wget'</span> or <span class="string">'curl'</span>...</div><div class="line">      Found: yes</div><div class="line">      Location: /usr/bin/wget</div><div class="line"> * Checking <span class="keyword">for</span> Curl development headers with SSL support...</div><div class="line">      Found: no</div><div class="line">      Error: Cannot find the `curl-config` <span class="built_in">command</span>.</div><div class="line"> * Checking <span class="keyword">for</span> OpenSSL development headers...</div><div class="line">      Found: yes</div><div class="line">      Location: /usr/include/openssl/ssl.h</div><div class="line"> * Checking <span class="keyword">for</span> Zlib development headers...</div><div class="line">      Found: yes</div><div class="line">      Location: /usr/include/zlib.h</div><div class="line"> * Checking <span class="keyword">for</span> Rake (associated with /usr/<span class="built_in">local</span>/ruby-2.4.3/bin/ruby)...</div><div class="line">      Found: yes</div><div class="line">      Location: /usr/<span class="built_in">local</span>/ruby-2.4.3/bin/ruby /usr/<span class="built_in">local</span>/ruby-2.4.3/bin/rake</div><div class="line"> * Checking <span class="keyword">for</span> OpenSSL support <span class="keyword">for</span> Ruby...</div><div class="line">      Found: yes</div><div class="line"> * Checking <span class="keyword">for</span> RubyGems...</div><div class="line">      Found: yes</div><div class="line"> * Checking <span class="keyword">for</span> Ruby development headers...</div><div class="line">      Found: yes</div><div class="line">      Location: /usr/<span class="built_in">local</span>/ruby-2.4.3/include/ruby-2.4.0/ruby.h</div><div class="line"> * Checking <span class="keyword">for</span> rack...</div><div class="line">      Found: no</div><div class="line"></div><div class="line">Some required software is not installed.</div><div class="line">But don<span class="string">'t worry, this installer will tell you how to install them.</span></div><div class="line">Press Enter to continue, or Ctrl-C to abort.</div></pre></td></tr></table></figure><p>提示的安裝指令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">--------------------------------------------</div><div class="line"></div><div class="line">Installation instructions <span class="keyword">for</span> required software</div><div class="line"></div><div class="line"> * To install C++ compiler:</div><div class="line">   Please install it with yum install gcc-c++</div><div class="line"></div><div class="line"> * To install Curl development headers with SSL support:</div><div class="line">   Please install it with yum install libcurl-devel</div><div class="line"></div><div class="line"> * To install rack:</div><div class="line">   Please make sure RubyGems is installed, <span class="keyword">then</span> run /usr/<span class="built_in">local</span>/ruby-2.4.3/bin/ruby /usr/<span class="built_in">local</span>/ruby-2.4.3/bin/gem install rack</div><div class="line"></div><div class="line">If the aforementioned instructions didn<span class="string">'t solve your problem, then please take</span></div><div class="line">a look at our documentation for troubleshooting tips:</div><div class="line"></div><div class="line">  https://www.phusionpassenger.com/library/install/nginx/</div><div class="line">  https://www.phusionpassenger.com/library/admin/nginx/troubleshooting/</div></pre></td></tr></table></figure><p>既然缺少了，那們我們就先執行對應的指令將缺少的套件安裝完成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">yum install gcc-c++ libcurl-devel</div><div class="line">gem install rack</div></pre></td></tr></table></figure><p>完成之後，我們重新執行 <code>passenger-install-nginx-module</code> 指令，前面的檢查選項就可以通過。這時候就會詢問我們要自己將 Passenger 加入 Nginx 編譯，還是讓 Passenger 幫我們自動編譯 Nginx。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">Automatically download and install Nginx?</div><div class="line"></div><div class="line">Nginx doesn<span class="string">'t support loadable modules such as some other web servers do,</span></div><div class="line">so in order to install Nginx with Passenger support, it must be recompiled.</div><div class="line"></div><div class="line">Do you want this installer to download, compile and install Nginx for you?</div><div class="line"></div><div class="line"> 1. Yes: download, compile and install Nginx for me. (recommended)</div><div class="line">    The easiest way to get started. A stock Nginx 1.12.2 with Passenger</div><div class="line">    support, but with no other additional third party modules, will be</div><div class="line">    installed for you to a directory of your choice.</div><div class="line"></div><div class="line"> 2. No: I want to customize my Nginx installation. (for advanced users)</div><div class="line">    Choose this if you want to compile Nginx with more third party modules</div><div class="line">    besides Passenger, or if you need to pass additional options to Nginx's</div><div class="line">    <span class="string">'configure'</span> script. This installer will  1) ask you <span class="keyword">for</span> the location of</div><div class="line">    the Nginx <span class="built_in">source</span> code,  2) run the <span class="string">'configure'</span> script according to your</div><div class="line">    instructions, and  3) run <span class="string">'make install'</span>.</div><div class="line"></div><div class="line">Whichever you choose, <span class="keyword">if</span> you already have an existing Nginx configuration file,</div><div class="line"><span class="keyword">then</span> it will be preserved.</div><div class="line"></div><div class="line">Enter your choice (1 or 2) or press Ctrl-C to abort: 1</div></pre></td></tr></table></figure><p>輸入 1 之後按下 Enter 就會開始把 Nginx 下載並且安裝摟！如果被詢問安裝目錄，基本上保持預設值就好，只是會跟透過 yum 安裝的位置不太一樣，所以要稍微記一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Where <span class="keyword">do</span> you want to install Nginx to?</div><div class="line"></div><div class="line">Please specify a prefix directory [/opt/nginx]:</div></pre></td></tr></table></figure><blockquote><p>要注意的是如果選用的主機規格太小 Passenger 會建議換大一點的主機，至少要有 1G 以上的記憶體比較適合。</p></blockquote><p>如果中間都沒有出錯的話，我們會看到像下面這樣的訊息，也就表示安裝成功了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Nginx with Passenger support was successfully installed.</div><div class="line"></div><div class="line">The Nginx configuration file (/opt/nginx/conf/nginx.conf)</div><div class="line">must contain the correct configuration options <span class="keyword">in</span> order <span class="keyword">for</span> Phusion Passenger</div><div class="line">to <span class="keyword">function</span> correctly.</div><div class="line"></div><div class="line">This installer has already modified the configuration file <span class="keyword">for</span> you! The</div><div class="line">following configuration snippet was inserted:</div><div class="line"></div><div class="line">  http &#123;</div><div class="line">      ...</div><div class="line">      passenger_root /usr/<span class="built_in">local</span>/passenger/passenger-5.2.3;</div><div class="line">      passenger_ruby /usr/<span class="built_in">local</span>/ruby-2.4.3/bin/ruby;</div><div class="line">      ...</div><div class="line">  &#125;</div><div class="line"></div><div class="line">After you start Nginx, you are ready to deploy any number of Ruby on Rails</div><div class="line">applications on Nginx.</div><div class="line"></div><div class="line">Press ENTER to <span class="built_in">continue</span>.</div></pre></td></tr></table></figure><h2 id="開啟-Nginx"><a href="#開啟-Nginx" class="headerlink" title="開啟 Nginx"></a>開啟 Nginx</h2><p>不過到目前為止，我們其實只是把 Passenger 和 Nginx 編譯完成，但是並沒有把 Nginx 打開。也因此，其他人是無法連上這台伺服器上的網站。</p><p>為了方便管理，我們可以使用 <code>systemd</code> 功能，透過撰寫設定檔，來使用 <code>systemctl</code> 指令觀看狀態，或者重新啟動。</p><p>在 Nginx 官網有提供一份<a href="https://www.nginx.com/resources/wiki/start/topics/examples/systemd/" target="_blank" rel="noopener">範例</a>，基本上只要修改範例上的路徑到正確的位置，我們就可以使用 <code>systemctl</code> 來控制 Nginx 的開啟跟關閉。</p><p>透過 <code>vi</code> 編輯 <code>/lib/systemd/system/nginx.service</code> 這個檔案。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /lib/systemd/system/nginx.service</div></pre></td></tr></table></figure><p>然後把下面的內容貼上，如果有修改 Nginx 的安裝路徑，要把 <code>/opt/nginx</code> 替換掉。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="section">[Unit]</span></div><div class="line"><span class="attr">Description</span>=The NGINX HTTP and reverse proxy server</div><div class="line"><span class="attr">After</span>=syslog.target network.target remote-fs.target nss-lookup.target</div><div class="line"><span class="section"></span></div><div class="line">[Service]</div><div class="line"><span class="attr">Type</span>=forking</div><div class="line"><span class="attr">PIDFile</span>=/opt/nginx/logs/nginx.pid</div><div class="line"><span class="attr">ExecStartPre</span>=/opt/nginx/sbin/nginx -t</div><div class="line"><span class="attr">ExecStart</span>=/opt/nginx/sbin/nginx</div><div class="line"><span class="attr">ExecReload</span>=/bin/kill -s HUP <span class="variable">$MAINPID</span></div><div class="line"><span class="attr">ExecStop</span>=/bin/kill -s QUIT <span class="variable">$MAINPID</span></div><div class="line"><span class="attr">PrivateTmp</span>=<span class="literal">true</span></div><div class="line"><span class="section"></span></div><div class="line">[Install]</div><div class="line"><span class="attr">WantedBy</span>=multi-user.target</div></pre></td></tr></table></figure><blockquote><p>還記得怎麼編輯嗎？按下 <code>i</code> 進入插入模式，貼上後用 <code>Esc</code> 退出，然後用 <code>:wq</code> 指令存檔離開。</p></blockquote><p>完成之後，我們就可以用 <code>systemctl</code> 指令來開啟或者關閉 Nginx 了，不過在這之前我們會希望在意外當機後重開機時，能夠自動地把 Nginx 啟動。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl <span class="built_in">enable</span> nginx</div></pre></td></tr></table></figure><p>利用 <code>enable</code> 功能，把 Nginx 設定為開機自動啟動的項目。</p><p>接下來用 <code>start</code> 指令把 Nginx 打開，並且用 <code>status</code> 指令看看是不是變成 <code>running</code> 的運行狀態。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">systemctl start nginx</div><div class="line">systemctl status nginx</div></pre></td></tr></table></figure><p>如果想檢查看看能不能連上，可以利用 <code>curl</code> 指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl localhost</div></pre></td></tr></table></figure><p>如果有 HTML 語法出現，基本上就是安裝成功了！</p><blockquote><p>如果找不到 <code>curl</code> 指令可以執行，嘗試看看自己用 <code>yum</code> 安裝吧！</p></blockquote><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>其實文章到這邊，安裝伺服器的部分就告一段落。下一階段會介紹怎麼設定 Ruby on Rails 專案，用 Capistrano 這個 Gem 幫助你把網站部署到這台伺服器。</p><p>不過，伺服器的設定其實還沒有完成，只是這些小問題會讓你在維護上不太方便。在後面的教學中，會陸續介紹跟提供解決的方案。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/04/10/Getting-started-deploy-your-Ruby-on-Rails-Part-4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>在 2018 年我所知道的區塊鏈</title>
      <link>https://blog.frost.tw/posts/2018/04/02/The-blockchain-I-know-about-in-2018/</link>
      <guid>https://blog.frost.tw/posts/2018/04/02/The-blockchain-I-know-about-in-2018/</guid>
      <pubDate>Mon, 02 Apr 2018 03:08:28 GMT</pubDate>
      <description>
      
        &lt;p&gt;上週同事突然在公司的聊天群組中討論起區塊鏈到底是不是屬於分散式系統（Distributed System）因為去年年底爆紅的關係，我也稍微了解了一下區塊鏈的運作，就被同事說會不會晚上就有文章出來了。&lt;/p&gt;
&lt;p&gt;雖然不是當天晚上就在寫，不過了解區塊鏈的運作倒是很有幫助我們冷靜下來對應這個新名詞。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>上週同事突然在公司的聊天群組中討論起區塊鏈到底是不是屬於分散式系統（Distributed System）因為去年年底爆紅的關係，我也稍微了解了一下區塊鏈的運作，就被同事說會不會晚上就有文章出來了。</p><p>雖然不是當天晚上就在寫，不過了解區塊鏈的運作倒是很有幫助我們冷靜下來對應這個新名詞。</p><a id="more"></a><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>其實最開始是跟同事有買了一些 BTC/ETH 來放著，在 2018 年底爆紅之後發現加密貨幣被當作金融商品在操作，而自己對他一點都不了解，反而沒有抓住恰當的時機，所以就開始研究他的可能性。</p><p><strong>不過我感覺，搞懂了只會讓你想趕快賣掉而已</strong></p><h2 id="新技術？"><a href="#新技術？" class="headerlink" title="新技術？"></a>新技術？</h2><p>因為不了解，所以我們會會認為他是一種全新的技術。實際上其實完全不是，都是靠「已知」的技術來實現的。也因為這樣，區塊鏈在運作起來還算是可靠的，因為有很多已知的問題都被研究過，而且使用的都是經過好幾年檢驗沒問題的技術。</p><p>所以，與其說是新技術，不如看作是一種<strong>新概念</strong>會比較恰當，在比特幣開始使用的 Proof of Work（工作證明）機制，經過長時間的驗證後，發現是一種有效的方法，所以才會被認同跟使用。</p><h2 id="區塊跟鏈"><a href="#區塊跟鏈" class="headerlink" title="區塊跟鏈"></a>區塊跟鏈</h2><p>從工程師的角度去看區塊鏈這個東西，大概會先連結到 Linked List 這種結構。實際上很明顯的，所謂的區塊鏈就是一種 Linked List 的資料結構，將一個接著一個的 Block（區塊）來練接起來。</p><p>所以，實際上一個區塊鏈很難實作嗎？其實不算困難。</p><p>要製作出簡單的區塊連結構，大概會像這樣。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Ruby</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Block</span></span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(prev, data)</span></span></div><div class="line">    @prev = prev</div><div class="line">    @data = data</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chain</span></span></div><div class="line">  GENESIS = Block.new(<span class="literal">nil</span>, <span class="string">''</span>)</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></div><div class="line">    @blocks = [GENESIS]</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(data)</span></span></div><div class="line">    @blocks.push(Block.new(@blocks.last, data))</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">chain = Chain.new</div><div class="line">chain.add(<span class="string">'Hello World'</span>)</div></pre></td></tr></table></figure><p>不過，光靠這些事不足以構成完善的區塊鏈本身。</p><h2 id="產生區塊"><a href="#產生區塊" class="headerlink" title="產生區塊"></a>產生區塊</h2><p>如果光是像前面所述的去生成新的區塊，很明顯的是沒有被驗證的。那就代表說任何人都可以隨意的去產生新的區塊，而且這並不是我們所期望的結果。</p><p>所以要放入 PoW（Proof of Work）這樣的機制在裡面，用來檢驗產生區塊是否合理。</p><p>於是，產生一個區塊的流程被拆分為幾個階段。</p><p><img src="https://blog.frost.tw/images/the-blockchain-i-know-about-in-2018/flow.png" alt="Untitled Diagram (1).png"></p><p>簡單來看，我們在原本直接產生區塊鏈的機制中，增加了一個叫做「工作證明」的動作，先讓作為礦工（節點）的角色耗費一定資源來進行運算，等到達成條件之後，再送給其他人檢查，如果結果都相同，那麼就接受這次的區塊打包，反之則拒絕讓對方重新開始。</p><h2 id="工作證明"><a href="#工作證明" class="headerlink" title="工作證明"></a>工作證明</h2><p>為了要證明工作，我們必須讓所有人都可以快速的取得相同的結果。但是證明者需要花費對應的資源才能取得結果，而其他人則需要可以用最短的時間內檢驗。</p><p>這時候加密演算法（Cryptography）剛好就可以解決這個問題。為了符合這個條件，我們需要先對區塊鏈的「區塊」本身做一些結構上的調整，這樣我們才能夠去驗證。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Block</span></span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(prev, hash, data)</span></span></div><div class="line">    @prev = prev</div><div class="line">    @parent = hash</div><div class="line">    @data = data</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>簡單來說，我們要先對區塊中的「區塊資料」先做一次加密的動作，獲得一個 Hash 值，來確保每一個區塊的資料是有一致性的。比較常見的案例，就是在下載檔案時會提供一個叫做 MD5 的 Hash 值，讓我們來驗證跟提供者提供的檔案是相同的。</p><p>基於這樣的原理，我們就可以透過這個 Hash 值來確認跟其他節點的區塊對應到的是相同的一個。</p><p>不過為了要證明工作，所以整個網路會一起提出一個問題，然後由所有參與運算的節點一起來處理。例如我們使用 MD5 來進行運算，會得到一個 32 個字元長度的字串。</p><p>那麼題目就可能會是「前三個字必須是 <code>000</code>」的題目」不過，因為原本只對資料做 Hash 是不可能改變結果的，所以我們會再加入一個叫做 <code>proof</code> 的資料欄位。</p><p>原本我們的 Hash 值可能會是 <code>md5(data)</code> 改變為 <code>md5(proof + data)</code> 這樣的計算，如此一來運算節點只需要一直修改 <code>proof</code> 的值來達到 Hash 結果為 <code>000</code> 開頭，那麼就算是完成工作證明了。</p><p>接下來提交給其他節點，他們只要執行 <code>md5(proof + data)</code> 就可以馬上驗證這個區塊是否為正確的區塊。</p><blockquote><p>出題目的情況其實就是挖礦時的難度調整，當大家都很容易算出來的時候，就會調整題目的難度，讓他更難以嘗試出來。</p></blockquote><p>像這樣透過產生隨機字串去試到成功為止這件事情，就跟「挖礦」的行為很像，這也就是為什麼我們會用「挖礦」和「礦工」來形容。</p><blockquote><p>至於像是比特幣有 51% 攻擊問題，礙於篇幅就不多做討論。</p></blockquote><h2 id="儲存問題"><a href="#儲存問題" class="headerlink" title="儲存問題"></a>儲存問題</h2><p>不過，隨著儲存的資料增長，每次更新都需要下載非常大量的交易紀錄，對一般使用者來說其實是一種負擔。所以我們再次利用密碼學的特性，將節點分成 Full Node 和 Light Node 兩種，前者會保存完整的資料，而後者則在有需要時才到網路上詢問其他節點。</p><p>以比特幣的情況來看，他採用了 Merkle Tree（默克爾樹）這個機制，我們將一個 Key-Value 儲存的資料，透過加密演算法，產生為一個 Hash 不斷合併後會得到一個最終的 Root Hash 作為參考，而這樣的機制可以讓我們在 Light Node 中只需要保存 Root Hash 就可以了。</p><p>透過這樣的機制，我們也得以在像是手機運行錢包，否則手機可能會連過往的交易資料都沒辦法完整儲存。</p><blockquote><p>Merkle Tree 的父結點會是子結點的資料相加後的 Hash 值，然後不斷合併後達到跟節點。</p></blockquote><h2 id="受限的功能"><a href="#受限的功能" class="headerlink" title="受限的功能"></a>受限的功能</h2><p>經過前面的解說，我們已經大致上的對區塊鏈的基本雛形有一個了解。簡單的來回推這些機制，其實會發現就是為了要儲存「可信且一致」的資料，所以才會有著「分散式帳本」這樣的名稱。</p><p>我們從 CAP 的定理來看，一般的資料庫大多會將 Consistence （一致性）的要求降低，來加快資料儲存的速度。但是在區塊鏈的世界，對一致性的要求是 100% 的，也讓我們在這些取捨中，失去的運算的速度。</p><p>這也是為什麼加密貨幣沒辦法做非常及時的交易，而每秒的處理量也無法達到一些金融應用的標準。</p><p>用簡單的角度去看區塊鏈，其實就是一套 NoSQL 資料庫。但是他本身有著非常好的一致性，一但資料被寫入之後就不會和其他人有所差異。</p><p>不過一個可信的區塊鏈就必須建立在下面幾種條件都建立的情況下：</p><ul><li>適當的加密演算法</li><li>足夠多的使用者（Proof of Work）</li></ul><p>這也是目前比特幣目前最大的優勢所在，因為大部分的礦工都參與這個區塊鏈，對檢查資料一致來說是非常嚴格的（不過還有 51% 攻擊問題）</p><h2 id="可能的應用"><a href="#可能的應用" class="headerlink" title="可能的應用"></a>可能的應用</h2><p>透過前面這些情報，其實我們會發現基本上在區塊鏈是基於「儲存資料」的前提下運作的。像是以太坊在區塊鏈上提供了圖靈完備的機制，我們放一段可執行的程式碼是可行的。這也構成了 DApp 和 Token（代幣）體系得以實現。</p><p>不過回到可應用的層面，因為我們都是在操作這些儲存的資料，能做的事情其實並不多。而跟這些特性相符的事情，又更少了。</p><p>適應性最高的就是加密貨幣的應用，也就是資產類型的管理和轉移。另一方面則是力用擁有圖靈完備機能的區塊鏈，在鏈上進行一些操作。</p><p>如此一來，加密貨幣的應用就顯而易見了。也因此，發展方向不外乎就是基於區塊鏈的一致性特性來輔助管理，所以才會有像是醫療、物聯網等等應用，用來追蹤資訊的變化跟脈絡。</p><p>另一方面則是強化區塊鏈本身，所以才會有側鏈、新的工作證明機制等等方法的提出，或者去開發全新的區塊鏈來改善等等。</p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>從技術的角度去觀察區塊鏈本身，其實會發現「能做的事情不多」也就是為什麼大家都在等待所謂的「殺手級應用」出現。</p><p>至於像是交易所、ICO 這類應用，只能說是在商業上的成功。至於該怎麼使用區塊鏈來改善生活，到目前為止都還沒有看到一個明確的方向。</p><p>這也是為什麼文章一開始會認為「搞懂了反而想賣掉」的原因，作為投資理財的角度，加密貨幣確實是這幾年值得一試的金融商品。但是從技術面來看，到目前為止都還沒有非常明朗的結果，也因為這樣，就代表說加密貨幣一直有資金流入，但是卻一直沒有實質上的產出。</p><p>這就跟泡沫化的跡象一樣，他很熱門但是還沒有實質的用途。</p><p>這才是大家擔心的泡沫，不過即使泡沫破了，工程師們大概還是會在這個方向上繼續努力。所以該買加密貨幣嗎？</p><p>作為研究用圖，或者期待哪一天工程師們可以找到正確得應用方案，那麼在「可接受的範圍內」買一點放著，偶爾可以拿來嘗試一些有趣的應用（Ex. 加密貓）之類的，倒是不錯。</p><blockquote><p>不過到這邊為止，我想大家應該是可以很冷靜的看待區塊鏈了吧！</p></blockquote>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/04/02/The-blockchain-I-know-about-in-2018/#disqus_thread</comments>
    </item>
    
    <item>
      <title>部署你的第一個 Ruby on Rails 網站（三）</title>
      <link>https://blog.frost.tw/posts/2018/03/27/Getting-started-deploy-your-Ruby-on-Rails-Part-3/</link>
      <guid>https://blog.frost.tw/posts/2018/03/27/Getting-started-deploy-your-Ruby-on-Rails-Part-3/</guid>
      <pubDate>Tue, 27 Mar 2018 13:30:15 GMT</pubDate>
      <description>
      
        &lt;p&gt;經過&lt;a href=&quot;https://blog.frost.tw/posts/2018/03/20/Getting-started-deploy-your-Ruby-on-Rails-Part-1/&quot;&gt;第一篇&lt;/a&gt;和&lt;a href=&quot;https://blog.frost.tw/posts/2018/03/23/Getting-started-deploy-your-Ruby-on-Rails-Part-2/&quot;&gt;第二篇&lt;/a&gt;的說明，我想大家現在應該都有辦法順利的透過 SSH 進入自己的伺服器。&lt;/p&gt;
&lt;p&gt;在第二篇的最後，我們針對 Ruby 環境預先做了準備，接下來就是安裝 Ruby 環境的時候了！&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>經過<a href="https://blog.frost.tw/posts/2018/03/20/Getting-started-deploy-your-Ruby-on-Rails-Part-1/">第一篇</a>和<a href="https://blog.frost.tw/posts/2018/03/23/Getting-started-deploy-your-Ruby-on-Rails-Part-2/">第二篇</a>的說明，我想大家現在應該都有辦法順利的透過 SSH 進入自己的伺服器。</p><p>在第二篇的最後，我們針對 Ruby 環境預先做了準備，接下來就是安裝 Ruby 環境的時候了！</p><a id="more"></a><h2 id="計畫"><a href="#計畫" class="headerlink" title="計畫"></a>計畫</h2><p>隨著專案的發展，我們通常都會需要更新 Ruby 版本。這次我們選擇使用的是 Passenger + Ruby  的解決方案，好處是可以透過設定檔指定 Ruby 版本。為了這個優點，我們可以透過自行編譯 Ruby 來管理多個版本的 Ruby。</p><p>如果覺得自行編譯麻煩的話，也可以選擇 RVM 或者 rbenv 這兩套常見的 Ruby 版本管理工具，不過在經驗上編譯 Ruby 環境其實非常的容易，所以也就不一定需要了！</p><blockquote><p>使用這種方法是需要管理的主機不多，或者是自己使用（需要放多個網站）的情況才會這樣做，當主機多的時候，採用 Chef / Ansible 這種部署工具，一台機器針對一個網站配置，更新版本時就採取直接安裝新的伺服器後轉移過去，反而會比較好管理。</p></blockquote><h2 id="編譯-Ruby"><a href="#編譯-Ruby" class="headerlink" title="編譯 Ruby"></a>編譯 Ruby</h2><p>首先，我們要確定是在自己的使用者下執行，而非 <code>root</code> 使用者。看一下輸入指令的地方是顯示類似 <code>elct9620@deploy-example</code> 而不是 <code>root@deploy-example</code> 就能夠分辨現在使用的帳號是哪一個。</p><p><code>@</code> 前面是「使用者」後面的部分叫做 Hostname（主機名稱）可以用來分辨是在哪一台伺服器上，所以在設定的時候好好取名是很重要的。</p><blockquote><p>不論是寫程式或設定伺服器，用容易理解的命名都是一個好習慣。</p></blockquote><p>這次的範例會編譯 Ruby 2.4 版本，我們要先到 Ruby 官方網站的<a href="https://www.ruby-lang.org/zh_tw/downloads/" target="_blank" rel="noopener">下載頁面</a>來取得原始碼的壓縮檔。</p><p><img src="https://blog.frost.tw/images/getting-started-deploy-your-ruby-on-rails-part-3/screenshot.jpg" alt="螢幕快照 2018-03-26 下午10.17.13.png"></p><p>如圖上顯示的一樣，目前最新的 Ruby 2.4.3 是我們想安裝的版本，所以對他點選右鍵後選擇「複製連結網址」就可以取得像是下面的下載位址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://cache.ruby-lang.org/pub/ruby/2.4/ruby-2.4.3.tar.gz</div></pre></td></tr></table></figure><p>接下來我們到伺服器上用 <code>wget</code>（WWW Get）指令來下載檔案，除了 <code>curl</code> 這個之後會介紹的指令外，是在 Linux 上很常用來下載檔案的指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget https://cache.ruby-lang.org/pub/ruby/2.4/ruby-2.4.3.tar.gz</div></pre></td></tr></table></figure><blockquote><p>如果發現沒有 <code>wget</code> 指令的話，可以利用上次介紹過的 <code>sudo yum install wget -y</code> 來安裝。</p></blockquote><p>下載完畢後，如果不確定操作是否正確，我們可以用 <code>ls</code> (List) 指令來看看現在這個目錄（資料夾）下面有沒有這個檔案。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls</div></pre></td></tr></table></figure><p>結果會類似下面這樣</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[elct9620@deploy-example ~]$ ls</div><div class="line">ruby-2.4.3.tar.gz</div></pre></td></tr></table></figure><p>既然這是一個壓縮檔，我們理所當然的要下指令對他解壓縮了！</p><p>在 Linux 中，我們通常會把檔案做成一個 <code>tar</code> 格式的檔案，然後再搭配上一個壓縮的格式（例如 Gzip 或者 Bzip2）所以才會有叫做 <code>.tar.gz</code> 或者 <code>.tgz</code> 這樣的副檔名。</p><p>而 <code>tar</code> 也是 Linux 中的一個指令，可以用來壓縮或者解壓縮檔案。下面的指令同時做了 <code>-z</code> （用 Gzip 壓縮格式）<code>-x</code>（解壓縮）<code>-v</code>（顯示檔案內容）<code>-f</code>（指定檔案）來進行解壓縮，統合起來就是「用 Gzip 格式解壓縮 <code>ruby-2.4.3.tar.gz</code> 這個檔案，並顯示內容」</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -zxvf ruby-2.4.3.tar.gz</div></pre></td></tr></table></figure><p>執行完畢後，再次用 <code>ls</code> 看一次，會發現多出了 <code>ruby-2.4.3</code> 這個資料夾。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[elct9620@deploy-example ~]$ ls</div><div class="line">ruby-2.4.3  ruby-2.4.3.tar.gz</div></pre></td></tr></table></figure><p>為了編譯 Ruby 方便下指令，我們要先用 <code>cd</code>（Change Directory）指令，切換到 <code>ruby-2.4.3</code> 這個目錄下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> ruby-2.4.3</div></pre></td></tr></table></figure><p>同時可能會發現原本輸入指令左方的 <code>~</code> 符號變成了 <code>ruby-2.4.3</code>，這是表示你目前所在的資料夾，透過這樣的方式就不怕迷失在 Linux 的資料夾中。</p><blockquote><p><code>~</code> 符號是一個代號，表示這個使用者的家目錄，一般 Linux 的使用者都會在 <code>/home</code> 資料夾下面有一個對應自己帳號的資料夾。</p></blockquote><p>預設的 Ruby 會安裝到 <code>/usr/local</code> 這個位置，但是如果我們希望能管理多個版本的 Ruby 就需要明確的指定位置。</p><p>我們可以透過執行 <code>configure</code> 這個檔案來對 Ruby 編譯時的行為做設定。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./configure --prefix=/usr/<span class="built_in">local</span>/ruby-2.4.3</div></pre></td></tr></table></figure><p>不同的軟體會有不同的設定選項，如果有興趣的話可以去研究看除了指定資料夾之外還有哪些選擇。</p><blockquote><p>如果沒有跑出任何東西，麻煩回到第二篇（有修正過指令）目前 DigitalOcean 上面的 gcc 似乎只有舊版的 4 但是一樣可以使用。</p></blockquote><p>接下來，就是編譯 Ruby 了，因為 Ruby 採用了大部分 Linux 都會有的 <code>make</code>（類似 <code>rake</code> 可以幫我們自動執行各種指令） 所以我們就不需要另外的去安裝像是 <code>CMake</code> 或者 <code>Ninja</code> 之類的編譯工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make</div></pre></td></tr></table></figure><p>這邊會比較花時間，完成之後我們可以用 <code>install</code> 動作請 <code>make</code> 幫我們放到正確的位置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make install</div></pre></td></tr></table></figure><p>不過這樣操作實際上是會發生錯誤的，因為 <code>/usr/local</code> 實際上還是所屬 <code>root</code> 我們可以用 <code>sudo</code> 指令提升權限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo make install</div></pre></td></tr></table></figure><p>如此一來就能順利的在系統中把 Ruby 安裝進去了！</p><p>可以透過手動執行 <code>ruby</code> 這個執行檔來確認 <code>ruby</code> 是正確執行的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/<span class="built_in">local</span>/ruby-2.4.3/bin/ruby -v</div></pre></td></tr></table></figure><p>如果能看到版本號，就是我們正確的安裝 Ruby 了。不過每次都要指定位置是很不方便的，我們可以透過改變 <code>PATH</code> 環境設定來簡化操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/ruby-2.4.3/bin:<span class="variable">$PATH</span></div></pre></td></tr></table></figure><p>上面的 <code>export</code> 指令表示「從此之後都套用」後面我們將 <code>/usr/local/ruby-2.4.3/bin</code> 放在原本的 <code>PATH</code> 前面，表示優先從這個目錄開始找。</p><p>如此一來就能用 <code>ruby -v</code> 直接執行 Ruby 進行操作，不過當下次登入 SSH 因為沒有執行這段指令，就會無法使用這個功能。</p><p>如果大部分的情況都會採用 Ruby 2.4.3 的話，可以在 <code>/etc/profile.d</code> 這個資料夾放一個叫做 <code>ruby.sh</code> 的檔案。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo vi /etc/profile.d/ruby.sh</div></pre></td></tr></table></figure><p>進入 Vim 後按下 <code>i</code> 進入編輯模式，輸入以下指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export PATH=/usr/local/ruby-2.4.3/bin:$PATH</div></pre></td></tr></table></figure><p>再按下 <code>:wq</code> 進行存檔，如此一下下次預設就會採用 Ruby 2.4.3 做為預設的 Ruby 執行了。</p><blockquote><p>在 <code>/etc</code> 目錄下面的變更是對整個伺服器的修改，以後不管是誰打開都會預設使用 Ruby 2.4.3 這點需要注意。</p></blockquote><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>這篇文章花了不少時間在處理編譯上，不過當掌握了編譯的方法後，不論是 Nginx 或者 PHP 還是其他的程式，都能夠用相同的方式編譯出來。</p><p>在遇到無法使用套件的情況下，會是非常有用的技巧。</p><p>下一篇會開始把 Passenger 和 Nginx 安裝起來，因為是透過 Passenger 提供的安裝工具，所以會比這一篇輕鬆很多。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/03/27/Getting-started-deploy-your-Ruby-on-Rails-Part-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>使用 Turbolinks 時 Google Analytics 並沒有正確運作</title>
      <link>https://blog.frost.tw/posts/2018/03/24/Google-Analytics-not-correct-when-using-turbolinks/</link>
      <guid>https://blog.frost.tw/posts/2018/03/24/Google-Analytics-not-correct-when-using-turbolinks/</guid>
      <pubDate>Sat, 24 Mar 2018 02:28:21 GMT</pubDate>
      <description>
      
        &lt;p&gt;最近因為在&lt;a href=&quot;https://5xruby.tw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;五倍紅寶石&lt;/a&gt;配合同事做官網的 SEO 優化，比較常見的行銷工具像是 Google Analytics 之類的就一起拿出來玩。&lt;/p&gt;
&lt;p&gt;實驗的對象首選當然是自己的網站，不過在調整的時候卻發現有一些情況有點異常。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>最近因為在<a href="https://5xruby.tw" target="_blank" rel="noopener">五倍紅寶石</a>配合同事做官網的 SEO 優化，比較常見的行銷工具像是 Google Analytics 之類的就一起拿出來玩。</p><p>實驗的對象首選當然是自己的網站，不過在調整的時候卻發現有一些情況有點異常。</p><a id="more"></a><p>當我使用 <a href="https://chrome.google.com/webstore/detail/google-analytics-debugger/jnkmfdileelhofjcijamephohjechhna?hl=zh-TW" target="_blank" rel="noopener">Google Analytics Debugger</a> 去看我的部落格（這個網站）的時候，換頁完全沒有任何事件被紀錄進去。</p><p>很明顯的，這是 Google Analytics 的 PageView 事件沒有被偵測到。而第一個應該要被檢查的，就是很多人在 Ruby on Rails 推出 Turbolinks 因為<strong>不會使用</strong>通常會搶先關掉的這個功能。</p><p>Turbolinks 本身是一個對 UX（使用者體驗）改善的套件，可以將網頁的切換變得比較平順。簡單來說，就是<strong>利用 Ajax 載入</strong>新頁面後，再替換掉改變的內容。</p><p>也就是說，實際上我們並沒有觸發真實的換頁行為。也就不會將 Google Analytics 的 JavaScript 重新讀取，自然就不存在紀錄頁面瀏覽事件（PageView）這件事情。</p><p>解決方案其實很簡單，我們只需要像處理最多人不太熟悉的 jQuery + Turbolinks 無法搭配運作的問題一樣，正確的設定頁面讀取事件即可。</p><p>也就是從普通的綁定 <code>DOMContentLoaded</code> 事件，改為</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// jQuery Version</span></div><div class="line">$(<span class="built_in">document</span>).on(<span class="string">'turbolinks:load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// Pure JavaScript Version</span></div><div class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'turbolinks:load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>因為 JavaScript 已經正確載入了，所以只需要重新把 Google Analytics 的行為重現出來。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'turbolinks:load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  ga(<span class="string">'create'</span>, <span class="string">'UA-XXXXXXX'</span>);</div><div class="line">  ga(<span class="string">'set'</span>, <span class="string">'location'</span>, location.pathname);</div><div class="line">  ga(<span class="string">'send'</span>, <span class="string">'pageview'</span>);</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>不過，假設還想加上像是 Facebook Pixel 之類的追蹤程式碼，每個都設定大概是找到頭暈。所以比較好的方式，其實是改用 Google Tag Manager 來處理。</p><p>先讓每次 Turbolinks 讀取後，都發送一個自訂事件給 Google Tag Manager 來統一觸發事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'turbolinks:load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> dataLayer !== <span class="string">"undefined"</span> &amp;&amp; dataLayer !== <span class="literal">null</span>) &#123;</div><div class="line">        dataLayer.push(&#123;</div><div class="line">            <span class="string">'event'</span>:<span class="string">'turbolinks:load'</span>,</div><div class="line">            <span class="string">'virtualUrl'</span>: event.data.url</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>接著在 Google Tag Manager 上面新增 Trigger 追蹤 <code>turbolinks:load</code>（這是自訂事件的名字）並把有需要紀錄頁面瀏覽的 Tag 加上這個 Trigger 即可。</p><p>另外現在回去看目前這個使用 Turbolinks 的網站版本，在換上去後轉換率有明顯的往下降，可能就是這個關係。</p><p><img src="https://blog.frost.tw/images/google-analytics-not-correct-when-using-turbolinks/ratio.png" alt="Google Analytics 分析資料"></p><p>最近會再關注一下轉換率有沒有提高，或者跳出率下降之類的。如果跳出率是下降，還是會蠻傷心的 XD</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/03/24/Google-Analytics-not-correct-when-using-turbolinks/#disqus_thread</comments>
    </item>
    
    <item>
      <title>自由的 Ruby 類別（二）</title>
      <link>https://blog.frost.tw/posts/2018/03/23/The-ruby-s-object-is-free-Part-2/</link>
      <guid>https://blog.frost.tw/posts/2018/03/23/The-ruby-s-object-is-free-Part-2/</guid>
      <pubDate>Fri, 23 Mar 2018 09:32:19 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;a href=&quot;https://blog.frost.tw/posts/2017/10/22/The-ruby-s-class-is-free-Part-1/&quot;&gt;上一篇文章&lt;/a&gt;已經討論過關於 Ruby 中的類別是怎樣運作的，這篇文章則會來討論如何拓展 Ruby 類別。&lt;/p&gt;
&lt;p&gt;大部分的人寫 Ruby 有很大的原因是因為 Rails 但是上面像是 &lt;code&gt;has_many&lt;/code&gt; 跟 &lt;code&gt;before_action&lt;/code&gt; 這些可以直接在類別上做的事情，很明顯不是 Ruby 內建的，到底是怎麼運作的呢？&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="https://blog.frost.tw/posts/2017/10/22/The-ruby-s-class-is-free-Part-1/">上一篇文章</a>已經討論過關於 Ruby 中的類別是怎樣運作的，這篇文章則會來討論如何拓展 Ruby 類別。</p><p>大部分的人寫 Ruby 有很大的原因是因為 Rails 但是上面像是 <code>has_many</code> 跟 <code>before_action</code> 這些可以直接在類別上做的事情，很明顯不是 Ruby 內建的，到底是怎麼運作的呢？</p><a id="more"></a><h2 id="Class-Method"><a href="#Class-Method" class="headerlink" title="Class Method"></a>Class Method</h2><p>我們先來看一段範例</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">my_name_is</span><span class="params">(str)</span></span></div><div class="line">     puts str</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line"> my_name_is <span class="string">'A'</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>到這邊，大家可能已經猜到 <code>has_many</code> 這類 DSL 擴充是怎麼實做出來的。只是，背後的運作原理是什麼？</p><h2 id="Class-Eval"><a href="#Class-Eval" class="headerlink" title="Class Eval"></a>Class Eval</h2><p>上一篇文章我們有提到，下面兩段程式碼會是等價的。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">A = Class.new <span class="keyword">do</span></div><div class="line"> <span class="comment"># ...</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="comment"># 上下兩段都是相同意思</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></div><div class="line">  <span class="comment"># ...</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>也因此推測出 <code>class A; end</code> 中間的那個區塊，其實是一個 Block。不過我們並沒有討論這個 Block 是怎麼被運行的。</p><p>在 Ruby 的 <code>Class</code> 類別說明上，針對 <code>Class.new</code> 有提到「If a block is given, it is passed the class object, and the block is evaluated in the context of this class using class_eval.」這一段文字。</p><p>簡單來說，就是中間這段 Block 是透過 <code>class_eval</code> 方法來執行的，所以我們可以再繼續推導出以下的行為。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">A = Class.new <span class="keyword">do</span></div><div class="line"> <span class="keyword">attr_accessor</span> <span class="symbol">:name</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>相等於</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span> <span class="keyword">end</span></div><div class="line">A.class_eval &#123; <span class="keyword">attr_accessor</span> <span class="symbol">:name</span> &#125;</div></pre></td></tr></table></figure><h2 id="Instance-Method-of-Class"><a href="#Instance-Method-of-Class" class="headerlink" title="Instance Method of Class"></a>Instance Method of Class</h2><p>至於 <code>attr_accessor</code> 實際上是 <code>Class</code> 類別的實例方法。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class.instance_methods.<span class="keyword">include</span>?(<span class="symbol">:attr_accessor</span>)</div><div class="line"><span class="comment"># =&gt; false</span></div></pre></td></tr></table></figure><p>怎麼會沒有？實際上 <code>Class</code> 類別已經 <code>include</code> 了 <code>Module</code>，而 <code>attr_accessor</code> 其實是 <code>Module</code> 類別的實例方法。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Module.private_instance_methods.<span class="keyword">include</span>?(<span class="symbol">:attr_accessor</span>)</div><div class="line"><span class="comment"># =&gt; true</span></div></pre></td></tr></table></figure><p>其實我們在 <code>Class</code> 上用 <code>private_instance_methods</code> 也可以找到 <code>attr_accessor</code> 這個方法，不過這其實是我們思考上的漏洞。因為 <code>attr_accessor</code> 是私有方法，所以我們沒辦法直接在 <code>instance_methods</code> 取得。</p><h2 id="DSL-in-Class"><a href="#DSL-in-Class" class="headerlink" title="DSL in Class"></a>DSL in Class</h2><p>回到正題，關於 <code>has_many</code> 是如何定義的？</p><p>既然我們已經知道：</p><ul><li>所有類別都是 <code>Class</code> 的實例</li><li>定義類別呼叫的是父類別的實例方法</li></ul><p>這樣回到第一個範例的程式</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">my_name_is</span><span class="params">(str)</span></span></div><div class="line">    puts str</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>實際上是在定義類別 <code>A</code> 的時候， 同時對叫做 <code>A</code> 的類別 <code>Class</code> 物件實例，動態的追加 <code>my_name_is</code> 這個方法。也因此能夠讓 <code>A</code> 類別在進行 <code>class_eval</code> 的時候，提供 <code>my_name_is</code> 這個方法。</p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>每一種語言都有其特別的地方，在討論 DSL 的時候 Ruby 也經常會被拿出來討論。主要就是因為 Ruby 擁有這樣的性質，讓我們能夠動態的去定義類別和物件上的行為，進而讓實現 DSL 變的相對的容易。</p><p>雖然是一些相對冷門的知識，不過在必要的時候善用這些技巧可以幫助你用更優雅的方式去寫程式。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/03/23/The-ruby-s-object-is-free-Part-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>部署你的第一個 Ruby on Rails 網站（二）</title>
      <link>https://blog.frost.tw/posts/2018/03/23/Getting-started-deploy-your-Ruby-on-Rails-Part-2/</link>
      <guid>https://blog.frost.tw/posts/2018/03/23/Getting-started-deploy-your-Ruby-on-Rails-Part-2/</guid>
      <pubDate>Fri, 23 Mar 2018 01:15:32 GMT</pubDate>
      <description>
      
        &lt;p&gt;延續&lt;a href=&quot;https://blog.frost.tw/posts/2018/03/20/Getting-started-deploy-your-Ruby-on-Rails-Part-1/&quot;&gt;上一篇&lt;/a&gt;文章的內容，我們需要先在伺服器上進行設定，讓伺服器可以正確的安裝 Ruby 環境。如此一來，我們才能夠將 Ruby on Rails 部署到伺服器上面。&lt;/p&gt;
&lt;p&gt;為了完成這些前置作業，我們還需要針對伺服器的設定進行完善的準備才行。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>延續<a href="https://blog.frost.tw/posts/2018/03/20/Getting-started-deploy-your-Ruby-on-Rails-Part-1/">上一篇</a>文章的內容，我們需要先在伺服器上進行設定，讓伺服器可以正確的安裝 Ruby 環境。如此一來，我們才能夠將 Ruby on Rails 部署到伺服器上面。</p><p>為了完成這些前置作業，我們還需要針對伺服器的設定進行完善的準備才行。</p><a id="more"></a><h2 id="無密碼使用-Sudo"><a href="#無密碼使用-Sudo" class="headerlink" title="無密碼使用 Sudo"></a>無密碼使用 Sudo</h2><p>在完成上一篇的操作後，大家可能會發現用自己的帳號登入伺服器後，使用 <code>sudo</code> 指令是需要輸入密碼的。但是我們再新增使用者的時候，並沒有對這個帳號設定密碼，也因此無法使用。</p><p>一般來說，我們會選擇：</p><ul><li>設定密碼</li><li>讓沒有密碼也可以做 <code>sudo</code></li></ul><p>如果想要設定密碼，我們可以先用 <code>root</code> 連線到伺服器，使用下面的指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">passwd elct9620</div></pre></td></tr></table></figure><p>透過 <code>passwd</code> (Password) 指令，針對 <code>elct9620</code> 這個使用者進行密碼設定，如此一來就可以使用密碼來進行 <code>sudo</code> 的動作。</p><p>如果想要使用無密碼的模式，我們可以讓所有屬於 <code>wheel</code> 這個群組的使用者賦予 <code>NOPASSWD</code> 的設定，讓所有指令都可以在不輸入密碼的狀態下使用。</p><p>我們會需要用 Vim 模式進入 <code>sudo</code> 設定</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">visudo</div></pre></td></tr></table></figure><p>找下面這行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># %wheel  ALL=(ALL)       NOPASSWD: ALL</span></div></pre></td></tr></table></figure><p>對 <code>#</code> 按 <code>x</code>（Delete）鍵再連續按下 <code>:wq</code> 存檔，就可以把註解刪掉，讓 <code>NOPASSWD</code> 的設定被啟用。</p><p>接下來用自己的帳號 SSH 到伺服器，就可以利用 <code>sudo</code> 下達任何指令，而不需要輸入密碼。</p><blockquote><p>為什麼不直接在 <code>root</code> 狀態下管理，主要是因為使用 <code>sudo</code> 指令可以提醒我們現在做的操作會「影響系統」，同樣的道理也可以適用在關閉密碼確認這件事情上。如何方便的管理伺服器，又不失安全性是作為一名伺服器管理員需要仔細考慮的事情。</p></blockquote><h2 id="安裝套件"><a href="#安裝套件" class="headerlink" title="安裝套件"></a>安裝套件</h2><p>在 Linux 中，沒有任何 GUI（圖形介面）的情況下該如何安裝軟體呢？那就要透過 Linux 的套件管理程式，這跟我們平常使用的 <code>gem</code> 指令類似。如果是使用 Mac 的話也許會用過 Homebrew 來幫忙安裝開發環境，簡單說就是「幫忙安裝軟體」的工具。</p><p>在不同的 Linux 作業系統中，用來安裝套件的工具也有所差異，以下簡單列出幾種我知道的類型。</p><ul><li>RedHat / CentOS / Fedora - <code>yum</code></li><li>Debian / Ubuntu - <code>apt</code>(<code>apt-get</code>)</li><li>Arch Linux - <code>pacman</code></li></ul><p>不同的套件管理工具有不一樣的指令，類似於我們用 <code>gem</code> 和 <code>npm</code> 會有一些指令上的差距一樣，這系列文章使用的 CentOS 是採用 <code>yum</code> 來安裝。不過就使用上的容易程度來說，其實 <code>apt-get</code> 算是比較簡單的，不過這些安裝指令在網路上其實都能找到，即使忘記怎麼使用只要善用 Google 也還是能很快的瞭解怎麼使用。</p><p>為了要能夠在伺服器上運行 Ruby 我們除了可以透過 <code>yum</code> 安裝之外，也能夠自行下載 Ruby 的原始碼來編譯。不同的做法有不同的優缺點，以這次的計畫，我們希望能夠自行管理 Ruby 版本。所以採取自行編譯 Ruby 原始碼的方式來安裝環境，因此我們需要先有可以編譯 Ruby 環境的套件。</p><p>參考 <a href="https://github.com/rbenv/ruby-build/wiki" target="_blank" rel="noopener">rbenv/ruby-build</a> 上面的說明，我們可以透過下面的指令簡單地將編譯 Ruby 所需套件找出來。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install -y gcc bzip2 openssl-devel libyaml-devel libffi-devel readline-devel zlib-devel gdbm-devel ncurses-devel</div></pre></td></tr></table></figure><p>上述安裝的 <code>gcc</code> 套件是用來編譯的，而 <code>-devel</code> 結尾的套件是讓程式「編譯」的時候能夠找到原始碼資訊的對應資訊。</p><blockquote><p>一般安裝軟體的時候我們會希望儘可能節省空間，所以只會把 Binary（二進位可執行檔）的部分安裝進來。但是當我想要自行編譯某個程式的時候，就需要有一個參考去對應他的功能，而這些參考（ex. Header）就可以透過 <code>devel</code> 類型的套件來補足。</p></blockquote><p>當執行完成這個指令後，我們就算是準備好編譯 Ruby 了！</p><blockquote><p>如果你使用 AWS EC2 練習的話，上面的指令可能不會運作。因為 Amazon Linux 2 提供支援的 <code>gcc</code> 已經是 <code>gcc-7</code> 了！</p></blockquote><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>到目前為止，我們基本上算是將安裝伺服器的「前置動作」完成。下一篇文章就會正式的開始把 Ruby 和 Passenger 透過最簡單的方式進行手動編譯，將它安裝到我們的伺服器上。</p><p>如此一來，就算是擁有一個可以執行 Ruby 程式的伺服器了！</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/03/23/Getting-started-deploy-your-Ruby-on-Rails-Part-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>部署你的第一個 Ruby on Rails 網站（一）</title>
      <link>https://blog.frost.tw/posts/2018/03/20/Getting-started-deploy-your-Ruby-on-Rails-Part-1/</link>
      <guid>https://blog.frost.tw/posts/2018/03/20/Getting-started-deploy-your-Ruby-on-Rails-Part-1/</guid>
      <pubDate>Tue, 20 Mar 2018 12:44:52 GMT</pubDate>
      <description>
      
        &lt;p&gt;最近在公司發現其實不少同事都還沒有實際部署過一台伺服器的經驗，在有人負責 DevOps 的情況下，也許真的不太需要。又或者因為還是初級工程師的關係，沒有那個權限可以去安裝一次伺服器。甚至其實一直都使用著 Heroku 或者 AWS CodeDeploy 等服務的便利性，而沒有嘗試自己安裝一次。&lt;/p&gt;
&lt;p&gt;不管是基於甚麼原因，總之先來安裝一次吧！&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>最近在公司發現其實不少同事都還沒有實際部署過一台伺服器的經驗，在有人負責 DevOps 的情況下，也許真的不太需要。又或者因為還是初級工程師的關係，沒有那個權限可以去安裝一次伺服器。甚至其實一直都使用著 Heroku 或者 AWS CodeDeploy 等服務的便利性，而沒有嘗試自己安裝一次。</p><p>不管是基於甚麼原因，總之先來安裝一次吧！</p><a id="more"></a><h2 id="VPS-主機"><a href="#VPS-主機" class="headerlink" title="VPS 主機"></a>VPS 主機</h2><p>在我學習架站的時候，除了是個窮學生之外，就是伺服器的成本其實相對的高。一個月最低的租用方案至少是 20 美元起跳，能用的資源也不高。</p><p>不過很幸運的是，隨著雲端相關的技術興起，我們現在可以用 5 美元左右就能租到一台適合的 VPS （Virtual Private Server） 主機，來放一些自己寫的小工具，或者個人網站。</p><p>下面推薦幾家台灣開發者比較常用的主機商：</p><ul><li><a href="https://vultr.com/" target="_blank" rel="noopener">Vultr</a></li><li><a href="https://linode.com" target="_blank" rel="noopener">Linode</a></li><li><a href="https://digitalocean.com/" target="_blank" rel="noopener">DigitalOcean</a></li></ul><p>除了 DigitalOcean 沒有東京的機房之外，選擇東京（Tokyo）機房再連線速度上會是最適合的。不過 DigitalOcean 的新加坡機房其實也不慢，如果需要比較多的功能 DigitalOcean 在這方面表現的就相對其他好上很多。</p><blockquote><p>效能表現上都有些微差異，不過者幾家在台灣連線過去的操作大多不會有卡頓的感覺。</p></blockquote><h2 id="SSH-Key"><a href="#SSH-Key" class="headerlink" title="SSH Key"></a>SSH Key</h2><p>在把第一台伺服器開始之前，我們要先來談談 <code>SSH</code> 和 <code>SSH Key</code> 這兩個東西。簡單來說 <code>SSH</code> (Secure Shell) 是一種可以讓我們在遠端電腦上執行 Shell （打指令的地方）的工具，透過成對的 <code>SSH Key</code> 來進行加密傳輸。</p><p>目前的 VPS 主機商大多會支援讓我們預先把 Public Key （兩組鑰匙可以公開的那一組）登記到主機商那邊，以便在開啟新伺服器的時候能夠預先的安裝進去。</p><p>下面這個指令在 macOS 或是 Linux 上都可以執行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa</div></pre></td></tr></table></figure><p>中間會有一些問題，一般來說只要按 Enter 按鍵繼續執行即可。</p><blockquote><p>如果你已經設定過 git 並且能夠上傳到 Github 的話，就代表你已經產生過小心不要覆蓋掉摟！</p></blockquote><p>我們會在下面的路徑得到兩個檔案：</p><ul><li>~/.ssh/id_rsa</li><li>~/.ssh/id_rsa.pub</li></ul><p>其中下面檔名為 <code>id_rsa.pub</code> 的檔案，就是公開的金鑰。在開始之前可以先把他設定到 VPS 主機商自己的帳號上，以利後續的動作。</p><blockquote><p>兩個都是純文字檔案，如果不清楚怎麼複製可以用 <code>cat ~/.ssh/id_rsa.pub</code> 顯示檔案內容後複製。</p></blockquote><h2 id="開設伺服器"><a href="#開設伺服器" class="headerlink" title="開設伺服器"></a>開設伺服器</h2><p>設定上來說參考這張截圖即可。</p><p><img src="https://blog.frost.tw/images/getting-started-deploy-your-ruby-on-rails-part-1/new_droplet.png" alt="DigitalOcean - Create Droplets.png"></p><p>這次我們要用的是 CentOS 這套作業系統，算是我最早接觸架設伺服器的時候所使用的作業系統。原型是 RedHat 這套商用作業系統，可以視為開源版本。</p><p>唯一要注意的是 SSH Key 的部分有確實的被新增進去，現在的伺服器為了安全會盡可能的使用 SSH Keys 來登入，而不是使用密碼。密碼有可能會被猜出來，但是 SSH Key 保存在你的電腦，也不容易直接推算出來，所以相對的安全不少。</p><blockquote><p>圖上的機房位置是選錯的，要記得選成 Singapore（新加坡）操作起來才會比較順暢。</p></blockquote><h2 id="進入伺服器"><a href="#進入伺服器" class="headerlink" title="進入伺服器"></a>進入伺服器</h2><p>當伺服器呈現 Ready 或者其它表示「開機完畢」的狀態時，我們就可以透過顯示在網頁上的 IP 位置來連上伺服器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh root@172.31.1.1</div></pre></td></tr></table></figure><blockquote><p>上面指令的 <code>172.31.1.1</code> 記得換成你的 IP 位置。</p></blockquote><p>上面推薦的 Vultr、Linode 和 DigitalOcean 預設帳號都會是 <code>root</code>（系統管理員）透過這個帳號，我們就可以進入伺服器進行所有操作。</p><h2 id="建立使用者"><a href="#建立使用者" class="headerlink" title="建立使用者"></a>建立使用者</h2><p>不過，直接使用 <code>root</code> 帳號來操作是非常危險的，所以我們會開設一個屬於自己的帳號，並且透過 <code>sudo</code> （Super User Do）這指令來表示「透過 <code>root</code> 的權力執行指令」</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">useradd elct9620 -G wheel</div></pre></td></tr></table></figure><p>上面的指令表示新增一個 <code>elct9620</code> 的使用者，並且加入 <code>wheel</code> 這個群組。</p><blockquote><p><code>wheel</code> 這個群組在 CentOS 7 通常會視為「有權限執行 <code>sudo</code> 指令」的使用者們</p></blockquote><h2 id="透過新使用者登入"><a href="#透過新使用者登入" class="headerlink" title="透過新使用者登入"></a>透過新使用者登入</h2><p>為了要可以透過新使用者登入，我們需要先對這個使用者設定 SSH Key 才行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">su - elct9620</div></pre></td></tr></table></figure><p>因為是管理員，所以我們可以用 <code>su</code> (Switch User) 來切換到 <code>elct9620</code> 這個帳號。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir ~/.ssh</div></pre></td></tr></table></figure><p>接著透過 <code>mkdir</code>（Make Directory）指令對 <code>elct9620</code> 這個帳號產生儲存 SSH 資訊的資料夾。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim ~/.ssh/authorized_keys</div></pre></td></tr></table></figure><p>這邊會透過 <code>vim</code> 來編輯檔案，因為操作對入門者有點困難，但是在管理伺服器上的時候卻很方便，所以建議大家至少熟悉可以插入內容。</p><p>按下 <code>i</code> 進入 Insert Mode 後，可以直接用 Ctrl + V 把前面我們複製過的 <code>id_rsa.pub</code> 貼上，之後按 ESC 離開 Insert Mode 再依序按下鍵盤的 <code>:wq</code> 進行 Write and Quit （存檔並離開）</p><p>最後，需要對檔案設定正確的權限（限定自己可以使用）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chmod 700 ~/.ssh</div><div class="line">chmod 600 ~/.ssh/authorized_keys</div></pre></td></tr></table></figure><p>如此一來，我們就可以改成 <code>ssh elct9620@172.31.1.1</code> 來連上伺服器了！</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>到此為止，我們僅是能夠簡單的連上伺服器，並且以正確的使用者來進行操作。距離安裝伺服器還有一段距離，這系列的文章會盡可能的針對操作「詳細」的解釋。如果大家有注意到的話，會發現 Linux 的指令其實是把對應動作的單字重組，透過這樣的方式我們就可以「稍微容易」的記起常用的幾個操作。</p><p>下一篇文章我們會稍微對伺服器做一些簡單的設定，並且熟悉基本操作。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/03/20/Getting-started-deploy-your-Ruby-on-Rails-Part-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Apartment 與 Globalize 隱藏在方便背後的陷阱</title>
      <link>https://blog.frost.tw/posts/2018/03/18/The-easy-way-not-best-way-learn-from-Apartment-and-Globalize/</link>
      <guid>https://blog.frost.tw/posts/2018/03/18/The-easy-way-not-best-way-learn-from-Apartment-and-Globalize/</guid>
      <pubDate>Sun, 18 Mar 2018 15:59:56 GMT</pubDate>
      <description>
      
        &lt;p&gt;手邊有一個專案剛好是需要滿足「多網站」並且每個網站都能夠「多語言切換」這兩個條件，在這兩個解決方案中最好處理的就是 Apartment 和 Globalize 這兩個 Ruby Gem 了。&lt;/p&gt;
&lt;p&gt;不過，在某些情況卻變成了問題。幸好運氣不錯的是還在開發階段，還有辦法將這個問題透過替換 Gem 進行修正。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>手邊有一個專案剛好是需要滿足「多網站」並且每個網站都能夠「多語言切換」這兩個條件，在這兩個解決方案中最好處理的就是 Apartment 和 Globalize 這兩個 Ruby Gem 了。</p><p>不過，在某些情況卻變成了問題。幸好運氣不錯的是還在開發階段，還有辦法將這個問題透過替換 Gem 進行修正。</p><a id="more"></a><p>首先，我們先來大概了解 Apartment 和 Globalize 這兩個 Ruby Gem 是擔任怎樣的任務。</p><h2 id="Apartment"><a href="#Apartment" class="headerlink" title="Apartment"></a>Apartment</h2><p>Apartment 是一個 Multi-Tenancy (多租戶) 的套件，可以協助我們利用同樣的程式碼架設功能完全相同的多個網站。在一般的解決方案來說，就是自動切換連接的資料庫來達成這個效果。</p><p>另外，在 PostgreSQL 中則有 <a href="https://www.postgresql.org/docs/9.5/static/ddl-schemas.html" target="_blank" rel="noopener">Schema</a> 這個機制，可以讓我們在同一個資料庫做出類似 Namespace （命名空間）的效果。</p><p>透過 <code>SET SEARCH_PATH = &#39;site1, public&#39;</code> 的設定後，當我們嘗試 <code>SELECT * FROM users</code> 的時候，就會先去找 <code>site1.users</code> 再去找 <code>public.users</code> （預設）的資料表，這對開發多用戶類型的系統有相當大的優勢。</p><blockquote><p>不過這在大規模的網站（像是 Shopify 之類服務）在 Ruby on Rails 上就不會是個好選擇，會有效能和記憶體上的瓶頸。所以在設計上要考量應用的情境和規模。</p></blockquote><h2 id="Globalize"><a href="#Globalize" class="headerlink" title="Globalize"></a>Globalize</h2><p>Globalize 可以幫助我們對 Model 設定，讓特定幾個欄位的值能夠依照當下 <code>I18n.locale</code> 設定的數值來自動反映出不同語言的呈現。原理上來說其實也相當簡單，他會產生一個 <code>post_translations</code> 資料表，並且記錄語言和需要翻譯的欄位。</p><p>使用方法如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Post</span> &lt; ApplicationRecord</span></div><div class="line">  translates <span class="symbol">:title</span>, <span class="symbol">:content</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>如此一來就能夠自動的呈現出對應的語言（如果有存到對應語言的資料）</p><h2 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h2><p>會發生問題其實是稍微特殊的案例，因為這個專案需要針對每次的活動產生一個新網站，但是又需要支援多語言。原本想要支援多語言，其實我們可以單純用 Apartment 去開設不同語言的網站。</p><p>但是因為這個「機制」被開設活動網站所佔用，所以我們只好借用 Globalize 的功能來完成多語言的呈現。</p><p>一般的使用上並不會有問題，不過當我們碰到「共用」的資料表（不管在哪個網站都會用這張資料表），就會發生問題。</p><p>因為是多網站，所以需要有一張表儲存目前存在的網站：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Apartment.configure <span class="keyword">do</span> <span class="params">|config|</span></div><div class="line">  config.excluded_models = <span class="string">%w[Site]</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>因為每個網站的名稱都需要有中文和英文版本，所以很自然的補上了翻譯的設定：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Site</span> &lt; ApplicationRecord</span></div><div class="line"> translates <span class="symbol">:name</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>還有將 Migration 資訊也設定後，嘗試運行 <code>rake db:migrate</code> <strong>表現上</strong>是正常的。不過這是在<strong>完全沒有 Site 資料</strong>的情況下。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">up</span></span></div><div class="line">  Site.create_translation_table!(</div><div class="line">    &#123;</div><div class="line">      <span class="symbol">name:</span> <span class="symbol">:string</span>,</div><div class="line">    &#125;,</div><div class="line">    <span class="symbol">migrate_data:</span> <span class="literal">true</span></div><div class="line">  )</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>當我們在做 Migrate 的時候，是不希望遺失資料。所以會將 <code>migrate_data</code> 選項開啟，不過這也造成了第一個我們發現第一個問題——Globalize 生成的 <code>CREATE TABLE</code> 是錯誤的。</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>從 Globalize 的<a href="https://github.com/globalize/globalize/blob/master/lib/globalize/active_record/migration.rb#L81" target="_blank" rel="noopener">原始碼</a>可以看到下面這段：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">t.references table_name.sub(<span class="regexp">/^<span class="subst">#&#123;table_name_prefix&#125;</span>/</span>, <span class="string">''</span>).singularize, <span class="symbol">:null</span> =&gt; <span class="literal">false</span>, <span class="symbol">:index</span> =&gt; <span class="literal">false</span>, <span class="symbol">:type</span> =&gt; column_type(model.primary_key).to_sym</div></pre></td></tr></table></figure><p>他會依據對應的 Model 來取出 <code>table_name</code> 這個參數，但是 <code>table_name</code> 因為 Apartment 要確保他是切換在正確的網站上，所以會從 <code>sites</code> 變成了 <code>public.sites</code> 來避免出問題。</p><p>基於這樣的設計，原本應該是要叫做 <code>site_id</code> 的欄位名稱，就變成了 <code>public.site_id</code> 存在於資料庫上。當 Globalize 嘗試把原本在 <code>sites</code> 資料表上的 <code>name</code> 欄位複製到翻譯的資料表上時，運行的 SQL 查詢就會恢復正常。</p><p>因為 Apartment 是對資料表層級的調整，所以在這樣的狀態下，在 Ruby on Rails 中的 ActiveRecord 預期會有的 <code>site_id</code> 欄位變成了 <code>public.site_id</code> 就會發生「找不到欄位」的錯誤。</p><p>不過這個問題並沒有想像中的困難，從原始碼可以看到清除 <code>table_name_prefix</code> 的機制。我們可以善加利用這個特性，在執行 Migrate 的階段暫時性的設定 <code>table_name_prefix</code> 在 Model 上就能正常運行。</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>不過，當 <code>Site</code> 是跨網站的資料表時，我們也預期 <code>Site::Translation</code> 這個由 Globalize 動態生成的 Model 也應該要是跨網站的（否則 Apartment 會因為沒有指定到共用資料表，而無法取得正確的翻譯資訊。）</p><p>所以我們理所當然的增加了這樣的設定：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Apartment.configure <span class="keyword">do</span> <span class="params">|config|</span></div><div class="line">  config.excluded_models = <span class="string">%w[Site Site::Translation]</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>這時候我們再次執行 <code>rake db:migrate</code> 卻發現出現了「資料表已存在」的錯誤。仔細一看，又是 Globalize 生成錯誤的 <code>CREATE TABLE</code> 查詢。</p><blockquote><p>注意，這是在 Site 有存在資料的情況下，因為 Apartment 在已存在的 Schema 會採取跑 Migrate 的方式更新資料結構。</p></blockquote><p>來去追查原因，原來在產生翻譯資料表 <code>site_translations</code> 的時候，資料表名稱是透過一個叫做 <code>translations_table_name</code> 的方法所定義，而這個方法則源自於 Globalize 對 Model 的擴充。</p><p>從 Globalize <a href="https://github.com/globalize/globalize/blob/master/lib/globalize/active_record/class_methods.rb#L51" target="_blank" rel="noopener">原始碼</a>可以發現：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">translation_class</span></span></div><div class="line">  @translation_class <span class="params">||</span>= <span class="keyword">begin</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.const_defined?(<span class="symbol">:Translation</span>, <span class="literal">false</span>)</div><div class="line">      klass = <span class="keyword">self</span>.const_get(<span class="symbol">:Translation</span>, <span class="literal">false</span>)</div><div class="line">    <span class="keyword">else</span></div><div class="line">      klass = <span class="keyword">self</span>.const_set(<span class="symbol">:Translation</span>, Class.new(Globalize::ActiveRecord::Translation))</div><div class="line">    <span class="keyword">end</span></div><div class="line"></div><div class="line">    klass.belongs_to <span class="symbol">:globalized_model</span>,</div><div class="line">      <span class="symbol">class_name:</span> <span class="keyword">self</span>.name,</div><div class="line">      <span class="symbol">foreign_key:</span> translation_options[<span class="symbol">:foreign_key</span>],</div><div class="line">      <span class="symbol">inverse_of:</span> <span class="symbol">:translations</span>,</div><div class="line">      <span class="symbol">touch:</span> translation_options.fetch(<span class="symbol">:touch</span>, <span class="literal">false</span>)</div><div class="line">    klass</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">translations_table_name</span></span></div><div class="line">  translation_class.table_name</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>他會透過剛剛動態生成的 <code>Site::Translation</code> Model 來推斷該用什麼當做資料表的名稱。在正常的狀況下，我們會理所當然的認為是 <code>site_translations</code>。</p><p>不過，我們使用的是 Apartment 來產生多網站的效果，也就是說名稱會變成 <code>site1.site_translations</code> 但是因為我們剛剛又設定了這是一張「共用資料表」所以就被改為 <code>public.site_translations</code> 了。</p><p>到目前為止其實都沒有問題，不過 Apartment 為了讓維護資料表是簡單的，所以實際上每一個網站的資料表會是完全一樣（直接重複所有 Migrate 動作，即使沒用到）</p><p>假設我們有 10 筆 Site 資料，那們就會變成嘗試 <code>CREATE TABLE</code> 10 次 <code>public.site_translations</code> 這個資料表，也就理所當然地會出現「資料表已存在」的錯誤。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>身為 Ruby on Rails 開發者，我們通常習慣於採取「已知可行」的現有解決方案，透過社群的力量共同維護一份穩定的套件來對應各種不同的情況。也因此，我們經常性地將很多細節封裝起來，造成許多人並不了解其底層的運作原理。</p><p>這也是為什麼會踩到這個陷阱的原因，因為即使是兩個知名的 Ruby Gem 兩邊的團隊也不見得會預想到「有人會想這樣使用」也不會去採取對應的措施。</p><p>可以的話，盡可能的進行事前的評估和測試（雖然本文的案例其實有點極端），就可以避免不少方法。</p><blockquote><p>最後的解法是替換成使用 PostgreSQL JSON 欄位特性的 Gem 避開產生新資料表的問題，更換後的成本需要擔心的大概是 SQL 查詢受影響的程度。</p></blockquote>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/03/18/The-easy-way-not-best-way-learn-from-Apartment-and-Globalize/#disqus_thread</comments>
    </item>
    
    <item>
      <title>管理 Ruby on Rails 外部 Assets 的小技巧</title>
      <link>https://blog.frost.tw/posts/2018/03/18/A-tips-for-manage-ruby-on-rails-s-vendor-assets/</link>
      <guid>https://blog.frost.tw/posts/2018/03/18/A-tips-for-manage-ruby-on-rails-s-vendor-assets/</guid>
      <pubDate>Sun, 18 Mar 2018 08:53:59 GMT</pubDate>
      <description>
      
        &lt;p&gt;在工作的時候經常會需要套用一些佈景主題，主要大多是因為客戶還在 MVP (最小可行產品) 的階段，只需要可以表現其商業價值運作的系統即可。不過，如果我們依照 Ruby on Rails 預設的方式把外部的佈景相關檔案分類後放到 &lt;code&gt;vendor/assets&lt;/code&gt; 目錄下，反而會變得難以管理。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>在工作的時候經常會需要套用一些佈景主題，主要大多是因為客戶還在 MVP (最小可行產品) 的階段，只需要可以表現其商業價值運作的系統即可。不過，如果我們依照 Ruby on Rails 預設的方式把外部的佈景相關檔案分類後放到 <code>vendor/assets</code> 目錄下，反而會變得難以管理。</p><a id="more"></a><p>一般來說，我們在一些佈景主題網站上購買的佈景，如果狀況不錯的話一般都會有以下這些資料夾。</p><ul><li><code>css</code> （或 <code>stylesheets</code>）</li><li><code>js</code> (或 <code>javascripts</code>)</li><li><code>img</code> (或 <code>images</code>)</li></ul><p>不過，如果把這些目錄分別的放到 <code>vendor/assets</code> 下面的話，佈景主題要更新的時候會出現問題。而當我們需要支援多套佈景主題的時候，也會受到限制。</p><p>所以，相對應的處理方式是透過直接將完整的目錄放到 <code>vendor</code> 目錄下。</p><p>舉例來說，假設有一個佈景主題叫做 <code>material</code> 我們就放到 <code>vendor/material</code> 這個位置，裡面則包含了前面提到的三種目錄。</p><p>路徑就會變成像這樣：</p><ul><li><code>vendor/material/css</code></li><li><code>vendor/material/js</code></li><li><code>vendor/material/images</code></li></ul><p>在 Rails 5 之後，為了能夠支援 Webpack 來進行前端相關的編譯，會增加 <code>config/initializers/assets.rb</code> 這個檔案。</p><p>我們就可以透過這個檔案對這些目錄設定，讓 Ruby on Rails 上的 Assets Pipeline 可以正確地讀取到。</p><p>只要對 <code>config/initialize/assets.rb</code> 做一些設定。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Add additional assets to the asset load path.</span></div><div class="line">Rails.application.config.assets.paths += [</div><div class="line">  Rails.root.join(<span class="string">'vendor'</span>, <span class="string">'material'</span>, <span class="string">'css'</span>),</div><div class="line">  Rails.root.join(<span class="string">'vendor'</span>, <span class="string">'material'</span>, <span class="string">'js'</span>),</div><div class="line">  Rails.root.join(<span class="string">'vendor'</span>, <span class="string">'material'</span>, <span class="string">'images'</span>)</div><div class="line">]</div></pre></td></tr></table></figure><p>這種類型的情況是用在網站只需要套用一種佈景主題，所以我們可以明確地把 CSS / JS 等路徑都完整的指定出來，如此一來在 <code>application.css</code> 和 <code>application.js</code> 就可以透過下面這樣的方式將它讀取進來。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// application.js</span></div><div class="line"><span class="comment">//= require jquery.select2.js</span></div></pre></td></tr></table></figure><p>未來假設佈景主題需要更新，我們就可以透過刪除以及重新放置 <code>vendor/material</code> 目錄的方式來更動，而不容易和其他外部的 Assets 混在一起，而變得難以處理。</p><p>這算是一個蠻實用的小技巧，在開發網站的時候要如何讓原始碼乾淨以及相依的套件容易維護一直都是個值得討論的題目。之後也會不時的更新 Ruby on Rails 的小技巧，除了因為最近太久沒有寫網誌之外。就是發現如果想分享一些很有趣的技術文章，還需要先讓讀者能夠透過過去的文章資料，一步步的了解脈絡才行。</p><p>也因此，會先累積一部分偏向入門者的文章，來幫助讀者瞭解其他文章的背景是怎樣的狀況，才會採取這樣的行動或者做法。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/03/18/A-tips-for-manage-ruby-on-rails-s-vendor-assets/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Ruby 中該如何 Raise 一個錯誤</title>
      <link>https://blog.frost.tw/posts/2018/01/09/How-ruby-raise-an-error/</link>
      <guid>https://blog.frost.tw/posts/2018/01/09/How-ruby-raise-an-error/</guid>
      <pubDate>Tue, 09 Jan 2018 09:28:13 GMT</pubDate>
      <description>
      
        &lt;p&gt;前幾天的晚上朋友在 Facebook 上問了一個問題。&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;raise HTTPError, &lt;span class=&quot;string&quot;&gt;&#39;Not Found&#39;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;和&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;raise HTTPError.new(&lt;span class=&quot;string&quot;&gt;&#39;Not Found&#39;&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;哪個比較快？也因為這樣，我們意外的發現 Ruby 對上面兩段程式碼的定義上其實是不太一樣的。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>前幾天的晚上朋友在 Facebook 上問了一個問題。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">raise HTTPError, <span class="string">'Not Found'</span></div></pre></td></tr></table></figure><p>和</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">raise HTTPError.new(<span class="string">'Not Found'</span>)</div></pre></td></tr></table></figure><p>哪個比較快？也因為這樣，我們意外的發現 Ruby 對上面兩段程式碼的定義上其實是不太一樣的。</p><a id="more"></a><p>在 Ruby 中 <code>raise</code> 一般情況下有以下幾種運作方式。</p><h2 id="預設情況"><a href="#預設情況" class="headerlink" title="預設情況"></a>預設情況</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Case 1</span></div><div class="line">raise <span class="comment"># =&gt; #&lt;RuntimeError&gt;</span></div><div class="line"></div><div class="line"><span class="comment"># Case 2</span></div><div class="line">raise <span class="string">'NotFound'</span> <span class="comment"># =&gt; #&lt;RuntimeError: "Not Found"&gt;</span></div></pre></td></tr></table></figure><h2 id="一般用法"><a href="#一般用法" class="headerlink" title="一般用法"></a>一般用法</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Case 3</span></div><div class="line">raise HTTPError, <span class="string">'Not Found'</span></div><div class="line"></div><div class="line"><span class="comment"># Case 4</span></div><div class="line">raise HTTPError.new(<span class="string">'Not Found'</span>)</div></pre></td></tr></table></figure><p>不過，上面這兩段程式碼的差異在哪裡呢？從 Ruby 的原始碼可以看到 <code>.new</code> 的行為會多做一次檢查。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> VALUE</span></div><div class="line"><span class="title">make_exception</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> VALUE *argv, <span class="keyword">int</span> isstr)</span></div><div class="line">&#123;</div><div class="line">    VALUE mesg, exc;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line"></div><div class="line">    mesg = Qnil;</div><div class="line">    <span class="keyword">switch</span> (argc) &#123;</div><div class="line">      <span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">        exc = argv[<span class="number">0</span>];</div><div class="line">        <span class="keyword">if</span> (NIL_P(exc))</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="comment">// 檢查了是否為字串</span></div><div class="line">        <span class="keyword">if</span> (isstr) &#123;</div><div class="line">            mesg = rb_check_string_type(exc);</div><div class="line">            <span class="keyword">if</span> (!NIL_P(mesg)) &#123;</div><div class="line">                mesg = rb_exc_new3(rb_eRuntimeError, mesg);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        n = <span class="number">0</span>;</div><div class="line">        <span class="comment">// 繼續跟 raise HTTPError, 'Not Fonud' 一樣的行為</span></div><div class="line">        <span class="keyword">goto</span> exception_call;</div><div class="line"></div><div class="line">      <span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">      <span class="keyword">case</span> <span class="number">3</span>:</div><div class="line">        exc = argv[<span class="number">0</span>];</div><div class="line">        n = <span class="number">1</span>;</div><div class="line">      exception_call:</div><div class="line">        mesg = rb_check_funcall(exc, idException, n, argv+<span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span> (mesg == Qundef) &#123;</div><div class="line">            rb_raise(rb_eTypeError, <span class="string">"exception class/object expected"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        rb_check_arity(argc, <span class="number">0</span>, <span class="number">3</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (!rb_obj_is_kind_of(mesg, rb_eException))</div><div class="line">            rb_raise(rb_eTypeError, <span class="string">"exception object expected"</span>);</div><div class="line">        <span class="keyword">if</span> (argc &gt; <span class="number">2</span>)</div><div class="line">            set_backtrace(mesg, argv[<span class="number">2</span>]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> mesg;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>從這個角度看，我們會發現差異其實只是「多一次檢查」的程度，甚至不太影響運行的效能。不過從 <a href="ruby-doc.com/docs/ProgrammingRuby/html/tut_exceptions.html">Programming Ruby</a> 這本書中的範例，卻發現了一個稍微意想不到的使用方法。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">readData</span><span class="params">(socket)</span></span></div><div class="line">  data = socket.read(<span class="number">512</span>)</div><div class="line">  <span class="keyword">if</span> data.<span class="literal">nil</span>?</div><div class="line">    raise RetryException.new(<span class="literal">true</span>), <span class="string">"transient read error"</span></div><div class="line">  <span class="keyword">end</span></div><div class="line">  <span class="comment"># .. normal processing</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="comment"># ...</span></div><div class="line"></div><div class="line"><span class="keyword">begin</span></div><div class="line">  stuff = readData(socket)</div><div class="line">  <span class="comment"># .. process stuff</span></div><div class="line"><span class="keyword">rescue</span> RetryException =&gt; detail</div><div class="line">  <span class="keyword">retry</span> <span class="keyword">if</span> detail.okToRetry</div><div class="line">  raise</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>仔細一看，明明應該是 <code>@message</code> 的數值，被放入了非字串的數值，而且這個錯誤還提供了 <code>#okToRetry</code> 這樣的方法讓我們可以獲取到這個數值。</p><p>回到剛剛 Ruby 中 <code>make_exception</code> 的原始碼，在 2 ~ 3 個參數的情況下，回傳的 <code>mesg</code> 變數是透過呼叫一個透過 <code>idException</code> 指標定義的方法來產生的，而傳入的參數剛好是 <code>raise</code> 的第二個參數。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="number">2</span>:</div><div class="line"> <span class="keyword">case</span> <span class="number">3</span>:</div><div class="line">   exc = argv[<span class="number">0</span>];</div><div class="line">   n = <span class="number">1</span>;</div><div class="line"> exception_call:</div><div class="line">   mesg = rb_check_funcall(exc, idException, n, argv+<span class="number">1</span>); <span class="comment">// 呼叫 idException 指標對應的某個方法</span></div><div class="line">   <span class="keyword">if</span> (mesg == Qundef) &#123;</div><div class="line">       rb_raise(rb_eTypeError, <span class="string">"exception class/object expected"</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">break</span>;</div></pre></td></tr></table></figure><blockquote><p><code>idException</code> 對應的其實是呼叫物件上的 <code>#exception</code> 方法，是所有 <code>Error</code> 類型物件必須存在的方法。</p></blockquote><p>也就是說，實際上我們可以讓我們的 <code>Error</code> 附帶一些額外資訊，在一些情況下處理錯誤的時候可以用來輔助我們。</p><p>不過，既然第一個參數已經被我們自訂的錯誤資訊替換了，那麼 Ruby 是怎麼設定錯誤訊息的？</p><p>實際上，在 <code>idException</code> 對應的 <code>#exception</code> 方法上，會複製現有的物件，件並且把錯誤訊息放進去。</p><p>在 <code>#exception</code> 的原始碼是這樣實作的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> VALUE</span></div><div class="line"><span class="title">exc_exception</span><span class="params">(<span class="keyword">int</span> argc, VALUE *argv, VALUE self)</span></div><div class="line">&#123;</div><div class="line">    VALUE exc;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (argc == <span class="number">0</span>) <span class="keyword">return</span> self;</div><div class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span> &amp;&amp; self == argv[<span class="number">0</span>]) <span class="keyword">return</span> self;</div><div class="line">    exc = rb_obj_clone(self);</div><div class="line">    exc_initialize(argc, argv, exc);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> exc;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> VALUE</span></div><div class="line"><span class="title">exc_initialize</span><span class="params">(<span class="keyword">int</span> argc, VALUE *argv, VALUE exc)</span></div><div class="line">&#123;</div><div class="line">    VALUE arg;</div><div class="line"></div><div class="line">    rb_scan_args(argc, argv, <span class="string">"01"</span>, &amp;arg);</div><div class="line">    rb_ivar_set(exc, id_mesg, arg);</div><div class="line">    rb_ivar_set(exc, id_bt, Qnil);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> exc;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>也就是說，我們實際上 <code>raise</code> 出來的例外，其實是被重新修改過的，不過這也讓我們在使用 Ruby 的錯誤上可以更加的彈性。</p><p>這也是為什麼像是 Rubocop 之類的軟體，會建議使用下面這種方式產生錯誤的原因。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">raise NotFoundError</div><div class="line"></div><div class="line">raise NotFoundError, <span class="string">'Current page is unavailable'</span></div></pre></td></tr></table></figure><blockquote><p>關於 <code>#exception</code> 的部分感謝五倍的同事在討論的時候提出來，才發現還有後續的處理將 <code>#message</code> 設定上去。</p></blockquote>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/01/09/How-ruby-raise-an-error/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Stripe 的 Idempotency Key 設計機制</title>
      <link>https://blog.frost.tw/posts/2017/10/30/The-design-of-Stripe-s-Idempotency-Keys/</link>
      <guid>https://blog.frost.tw/posts/2017/10/30/The-design-of-Stripe-s-Idempotency-Keys/</guid>
      <pubDate>Mon, 30 Oct 2017 14:46:43 GMT</pubDate>
      <description>
      
        &lt;p&gt;週末看到一篇 Stripe 工程師所寫的文章，是一篇關於 Idempotency Key （幂等鍵）的設計機制。因為是一篇非常棒的文章，而且裡面的概念除了可以應用在 API 設計之外，很多程式設計上需要解決的問題都可以透過這個概念來處理。&lt;/p&gt;
&lt;p&gt;原文非常的長而且很詳細，這篇文章只會做簡單的重點整理。&lt;/p&gt;
&lt;p&gt;有興趣的話可以打開&lt;a href=&quot;https://brandur.org/idempotency-keys&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;來讀，是一篇很有用的文章。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;作者是很厲害的工程師，部落格上的文章都是非常精實的技術文。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>週末看到一篇 Stripe 工程師所寫的文章，是一篇關於 Idempotency Key （幂等鍵）的設計機制。因為是一篇非常棒的文章，而且裡面的概念除了可以應用在 API 設計之外，很多程式設計上需要解決的問題都可以透過這個概念來處理。</p><p>原文非常的長而且很詳細，這篇文章只會做簡單的重點整理。</p><p>有興趣的話可以打開<a href="https://brandur.org/idempotency-keys" target="_blank" rel="noopener">原文</a>來讀，是一篇很有用的文章。</p><blockquote><p>作者是很厲害的工程師，部落格上的文章都是非常精實的技術文。</p></blockquote><a id="more"></a><p>在 API 的設計中，我們可能會遭遇到一些問題而讓操作失敗。像是<code>網路連線中斷</code>、<code>第三方服務異常</code>等等情況，此時就會需要客戶端進行重新嘗試的動作。</p><p>不過，如果是類似於 Stripe 這類金流服務，我們就不得不重視「重新呼叫」的問題，也就是「如果重複扣款」該怎麼處理，這就是 Idempotency Key 機制的由來。</p><blockquote><p>目前中文對「Idempotency Key 」是叫做幂等鍵，而 Stripe 表示這是他們自己發明的詞，所以後面都以原文稱呼。</p></blockquote><h2 id="Idempotency-Key-是什麼？"><a href="#Idempotency-Key-是什麼？" class="headerlink" title="Idempotency Key  是什麼？"></a>Idempotency Key  是什麼？</h2><p>所以 Idempotency Key 到底是什麼？簡單來說就是一種類似於 ID 的機制，用來區分某個 API 請求是同一個。</p><p>像是下面這個 API 請求，就會帶有 Idempotency Key 的 Header 來表示是哪個請求。</p><blockquote><p>POST /api/chargs<br>…<br>Idempotency-Key: 0ccb7813-e63d-4377-93c5-476cb93038f3<br>…<br>amount=100&amp;currency=TWD</p></blockquote><p>同時，也會透過驗證傳入的 <code>amount</code> 和 <code>currency</code> 等「參數」來確保同一個 API 請求的內容是完全相同的。</p><h2 id="實際應用"><a href="#實際應用" class="headerlink" title="實際應用"></a>實際應用</h2><p><a href="https://brandur.org/idempotency-keys" target="_blank" rel="noopener">原文</a>中用「火箭背包版 Uber」的範例專案來實作，在 Stripe 的 Github 上面可以找到原始碼。</p><p>這個 App 會在你發射火箭後向你收費，中間會有幾個步驟。</p><ul><li>產生駕駛紀錄</li><li>向 Stripe 呼叫收費 API</li><li>更新駕駛紀錄</li><li>透過 Mailgun 發送收據</li></ul><p>加入 Idempotency Key 機制之後，則會轉變成這樣。</p><ul><li>產生 Idempotency Key</li><li>產生駕駛紀錄</li><li>產生「駕駛紀錄產生」的操作記錄</li><li>向 Stripe 呼叫收費 API</li><li>更新駕駛紀錄</li><li>透過 Mailgun 發送收據</li><li>更新 Idempotency Keys</li></ul><p>看起來多了一些東西，但是這些的影響是怎樣的呢？</p><blockquote><p>原文有繪製成圖片，對照的時候會比較方便。</p></blockquote><h3 id="Idempotency-Key"><a href="#Idempotency-Key" class="headerlink" title="Idempotency Key"></a>Idempotency Key</h3><p>首先，我們需要一個 Idempotency Keys 表來紀錄最近的 API 操作。</p><table><thead><tr><th>Column</th><th>Type</th></tr></thead><tbody><tr><td><strong>idempotency_key</strong></td><td>TEXT (max length &lt;= 100)</td></tr><tr><td><strong>locked_at</strong></td><td>datetime</td></tr><tr><td></td></tr><tr><td><strong>request_method</strong></td><td>TEXT (max length &lt;= 100)</td></tr><tr><td><strong>request_params</strong></td><td>JSONB</td></tr><tr><td><strong>request_path</strong></td><td>TEXT (max length &lt;= 100)</td></tr><tr><td></td></tr><tr><td><strong>response_code</strong></td><td>INTEGER</td></tr><tr><td><strong>response_body</strong></td><td>JSONB</td></tr><tr><td><strong>recovery_point</strong></td><td>TEXT (max length &lt;= 100)</td></tr><tr><td><strong>user_id</strong></td><td>BIGINT</td></tr></tbody></table><blockquote><p>UNIQUE INDEX (idempotency_key, user_ud)</p></blockquote><p>PS. 上面只列了比較重要的欄位。</p><p>首先，我們要確定我們有一組 Key 他可能是 UUID 或者其他形式，因為是跟 <code>user_id</code> 綁定在一起的，所以實際上交給 Client 生成似乎也不影響 API 的操作。</p><p>接下來我們要儲存這次 API 操作的完整資訊，這是用來<strong>確認是相同 API 操作</strong>的保護機制。</p><p>最後是在這個 API 操作完成後，不論成功失敗都紀錄操作的結果。如果再次收到相同的 API 查詢時，我們可以回復完全樣的結果給這個呼叫者，達到快取的效果。</p><p>比較特別的是 <code>recovery_point</code> 這個欄位，為什麼會有這個欄位呢？</p><p>因為在前面我們可能會在 Stripe 扣款或者 Mailgun 發信時發生錯誤，此時就可以讓 API 從這一個操作步驟重新開始，而不會影響到原本已經成功地操作。</p><blockquote><p>原文裡面有提到資料庫的原子性，而這個就是為了讓我們的 API 也擁有原子性。</p></blockquote><h3 id="其他資料表"><a href="#其他資料表" class="headerlink" title="其他資料表"></a>其他資料表</h3><p>主角  Idempotency Keys 介紹完之後，還有像是騎乘資料表、操作紀錄等等，就不另外介紹。</p><p>只是需要注意的是，被操作的「騎乘紀錄」表中，會對應某一個  Idempotency Key 來提供查詢，畢竟不一定是每一次的 API 操作都是一次性成功的，此時就要透過這個  Idempotency Key 來找回正在操作的騎乘紀錄。</p><blockquote><p>反過來說，如果資料表上的  Idempotency Key 是有值得狀況下，就代表有其他人正在操作。也可以被視為一種「上鎖」的機制。</p></blockquote><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>原作提供了一個方法的實作，來輔助每一個原子操作。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">atomic_phase</span><span class="params">(key, &amp;block)</span></span></div><div class="line">  error = <span class="literal">false</span></div><div class="line">  <span class="keyword">begin</span></div><div class="line">    DB.transaction(<span class="symbol">isolation:</span> <span class="symbol">:serializable</span>) <span class="keyword">do</span></div><div class="line">      ret = block.call</div><div class="line">      <span class="comment"># 根據 block 傳回值產生回應</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">rescue</span></div><div class="line">     error = <span class="literal">true</span></div><div class="line">    <span class="comment"># 處理各種錯誤</span></div><div class="line">  <span class="keyword">ensure</span></div><div class="line">      <span class="keyword">if</span> error &amp;&amp; key.present?</div><div class="line">        <span class="keyword">begin</span></div><div class="line">          key.update(<span class="symbol">locked_at:</span> <span class="literal">nil</span>)</div><div class="line">          <span class="comment"># 操作失敗，解鎖</span></div><div class="line">        <span class="keyword">rescue</span></div><div class="line">          <span class="comment"># 無法解鎖（記錄到 Log 中）</span></div><div class="line">        <span class="keyword">end</span> </div><div class="line">      <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>原文中定義了三種回應：</p><ul><li>NoOp - 不做事（初次產生）</li><li>RecoveryPoint - 更新紀錄點（原子操作成功）</li><li>Response - 回應（API 操作完全成功）</li></ul><h3 id="Idempotency-Key-初始化"><a href="#Idempotency-Key-初始化" class="headerlink" title="Idempotency Key 初始化"></a>Idempotency Key 初始化</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">key = <span class="literal">nil</span></div><div class="line">atomic_phase(key) <span class="keyword">do</span></div><div class="line">  key = IdempotencyKey.find_by(<span class="symbol">user_id:</span> current_user.id, <span class="symbol">idempotency_key:</span> params[<span class="symbol">:key</span>])</div><div class="line">  </div><div class="line">  <span class="keyword">if</span> key</div><div class="line">    <span class="comment"># 1. 檢查 params 是否一致</span></div><div class="line">    <span class="comment"># 2. 檢查上鎖時間是否超時（時間內回傳操作中錯誤）</span></div><div class="line">    <span class="comment"># 3. 操作如果未完成，更新上鎖時間</span></div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="comment"># 產生新的 Idempotency Key</span></div><div class="line">    <span class="comment"># `locked_at` 是現在時間（因為是馬上開始操作，所以立刻上鎖）</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>透過上述的程式碼，我們可以產生出一把需要使用的 key 供我們使用。並且在每次 API 呼叫時，確保上一次的 API 操作不會被影響，而運行過久的時候又可以透過從客戶端的 API 重新請求延續原本的操作直到完成。</p><h3 id="後續操作"><a href="#後續操作" class="headerlink" title="後續操作"></a>後續操作</h3><p>有了初始的 Idempotency Key 之後，就可以繼續把後面的 API 行為完成。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">loop <span class="keyword">do</span></div><div class="line">  <span class="keyword">case</span> key.recovery_point</div><div class="line">  <span class="keyword">when</span> RECOVER_POINT_START</div><div class="line">    atomic_phase(key) <span class="keyword">do</span></div><div class="line">      <span class="comment"># ...</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">when</span> RECOVERY_POINT_RIDE_CREATED</div><div class="line">    atomic_phase(key) <span class="keyword">do</span></div><div class="line">      <span class="comment"># ...</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">when</span> RECOVERY_POINT_FINISHED</div><div class="line">    <span class="keyword">break</span></div><div class="line">  <span class="comment">#...</span></div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="comment"># 未知的 RecoveryPoint 丟出錯誤</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="comment"># 回傳結果</span></div></pre></td></tr></table></figure><p>如此一來，我們就可以將每一個 API 的細部操作都切割成一個「原子」並且建構一個可恢復並且繼續運行的 API 了。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>這篇文章省略了不少細節，指把重點的部分拉出來討論，可以的話還是希望大家能去閱讀原文（雖然很長）</p><p>簡單來說，這個機制讓我們可以得到：</p><ul><li>不怕重複呼叫的 API 服務</li><li>呼叫失敗也可以恢復運作</li><li>能夠有效的定位 API 運作問題發生的時機點</li></ul><p>除此之外，文章最後還有提到一些像是「完成器」的技巧。</p><blockquote><p>完成器是因為有些用戶端達到重試最大次數後，就會放棄運行。此時這些「即將完成」的操作就會變得無法完成，所以由伺服器定時拉出來重現 API 操作讓這個 API 操作得以完全完成。</p></blockquote><p>另一方面，這個機制可以應用在很多地方。像是表單送出的時候，用來檢查是不是重複表單的送出等等，雖然是以 API 設計的方式呈現，但是背後的概念卻非常值得思考，我們如何讓程式能夠更加的健壯。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2017/10/30/The-design-of-Stripe-s-Idempotency-Keys/#disqus_thread</comments>
    </item>
    
    <item>
      <title>在 PostgreSQL 中使用遞迴查詢來找尋父節點</title>
      <link>https://blog.frost.tw/posts/2017/10/23/Use-PostgreSQL-s-recursive-query-to-find-ancestors/</link>
      <guid>https://blog.frost.tw/posts/2017/10/23/Use-PostgreSQL-s-recursive-query-to-find-ancestors/</guid>
      <pubDate>Mon, 23 Oct 2017 10:00:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;老爸的公司在去年設計了一個紅利積點的消費回饋機制，裡面採用了樹狀的結構。用來改善傳統多層次傳銷造成的下線提供好處給上線，而下線卻需要去找更多下線來獲取回饋的異常機制。&lt;/p&gt;
&lt;p&gt;不過這個設計有一個問題，就是他比傳統的樹成長的速度還會再更快些。也就表示在 Rails 裡面現有用來解決樹狀結構的一些套件並不適合使用。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>老爸的公司在去年設計了一個紅利積點的消費回饋機制，裡面採用了樹狀的結構。用來改善傳統多層次傳銷造成的下線提供好處給上線，而下線卻需要去找更多下線來獲取回饋的異常機制。</p><p>不過這個設計有一個問題，就是他比傳統的樹成長的速度還會再更快些。也就表示在 Rails 裡面現有用來解決樹狀結構的一些套件並不適合使用。</p><a id="more"></a><p>建構一個樹狀結構，一般在資料庫中會這樣設計。</p><table><thead><tr><th>id</th><th>name</th><th>parent_id</th></tr></thead><tbody><tr><td>1</td><td>Jimmy</td><td></td></tr><tr><td>2</td><td>John</td><td>1</td></tr><tr><td>3</td><td>Alice</td><td>1</td></tr><tr><td>4</td><td>Alex</td><td>2</td></tr></tbody></table><p>在指查詢一代的情況下，可以直接使用 Rails 的 <code>belongs_to</code> 和 <code>has_many</code> 來解決。</p><p>但是如果想知道 <code>Alex</code> 的父代有哪些，就必須先找到 <code>John</code> 再繼續往回找。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ancestors</span><span class="params">(user, path = [])</span></span></div><div class="line">  <span class="keyword">return</span> path <span class="keyword">if</span> user.parent.<span class="literal">nil</span>?</div><div class="line">  path &lt;&lt; user.parent</div><div class="line">  ancestors(user.parent, path)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">ancestors(User.find_by(<span class="symbol">name:</span> <span class="string">'Alex'</span>))</div><div class="line"><span class="comment"># =&gt; [User&lt;<span class="doctag">@name</span>="John"&gt;, User&lt;<span class="doctag">@name</span>="Jimmy"&gt;]</span></div></pre></td></tr></table></figure><p>很明顯的，這會執行 N 次的 SQL 查詢，稍微有經驗就會注意到這樣是非常沒有效率的。</p><p>於是，就會出現幾種常見的解法。</p><ul><li>Adjacency List</li><li>Path Enumeration</li><li>Nested Sets</li><li>Closure Table</li></ul><p>關於上述這幾種解法的說明，可以參考 Percona 這<a href="https://www.slideshare.net/billkarwin/models-for-hierarchical-data" target="_blank" rel="noopener">這份簡報</a>。</p><h2 id="Closure-Table"><a href="#Closure-Table" class="headerlink" title="Closure Table"></a>Closure Table</h2><p>在 Rails 中，速度最快的是 Closure table 這個解法，可以使用 <code>closure_tree</code> gem 來實作，不過在文章一開始描述的情境，卻是一個噩夢。</p><ul><li>每個交易是一個節點</li><li>回饋會往上追溯（但不往下）</li><li>節點的世代增長會很快</li><li>樹可以無限成長</li></ul><p>而 Closure table 是空間換時間的方法，所以假設當發展到 300,00 代的時候，因為 Closure Tree 會把每一個節點跟所有父代做一次關聯來加速查詢，所以在第 300,00 代基本上是需要插入 <code>300,00 - 1</code> 條紀錄的。</p><p>所以，這個解法會在後期出現效能貧頸。</p><h2 id="Path-Enumeration"><a href="#Path-Enumeration" class="headerlink" title="Path Enumeration"></a>Path Enumeration</h2><p>在 PostgreSQL 內，有一個叫做 <code>ltree</code> 的 Extension 可以使用。</p><p>因為紅利回饋的往回追溯會有極限制，畢竟是基於交易的金額來計算可用的回饋，所以受到影響的父代是有限的。</p><p>在 Path Enumeration 的特性中，是利用建立「路徑」來記錄的。</p><table><thead><tr><th>id</th><th>name</th><th>path</th></tr></thead><tbody><tr><td>1</td><td>Jimmy</td><td></td></tr><tr><td>2</td><td>John</td><td>Jimmy</td></tr><tr><td>3</td><td>Alice</td><td>Jimmy</td></tr><tr><td>4</td><td>Alex</td><td>Jimmy.John</td></tr></tbody></table><p>也就是說，當 <code>Alex</code> 想知道有多少父代只需要從 <code>path</code> 這個 <code>ltree</code> 類型的欄位下查詢就可以了！</p><p>這個解法看起來一切完美，但是卻有一個問題。</p><blockquote><p>欄位的內容有上限，也就是說當發展到一定的世代到達極限後，就無法再繼續下去。</p></blockquote><p>這很適合用來儲存多層的文章分類，但是卻不適合無限成長的樹。</p><h3 id="限制世代數"><a href="#限制世代數" class="headerlink" title="限制世代數"></a>限制世代數</h3><p>不論是 Closure Table 或者 Path Enumeration 的情況，其實只要限制紀錄的世代數就可以解決這個問題。</p><blockquote><p>畢竟追訴的世代有上限，只要存需要的部分就好了！</p></blockquote><p>這個方法聽起來不錯，不過對 Path Enumeration 來說，當 Path 不完整的時候，查詢就會失去準確度（無法用標準的 Path 查詢去問路徑）</p><p>至於 Closure Table 看似這樣做是沒有問題的，但是一樣會失去關於深度的正確數值。</p><p>在考慮一些細節之後，發現這並不是恰當的方法。</p><h2 id="Adjacency-List"><a href="#Adjacency-List" class="headerlink" title="Adjacency List"></a>Adjacency List</h2><p>回到 Adjacency List 的方法上，在 Rails 中使用會產生類似下面的 SQL 查詢。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">4</span>;</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">2</span>;</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</div><div class="line">...</div></pre></td></tr></table></figure><p>一般來說我們應該用 <code>WHERE id IN(1, 2, 3)</code> 來查詢才對。</p><p>在這邊 PostgreSQL 提供了叫做 Recursive Query 的功能，官網的範例長這樣。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">WITH RECURSIVE t(n) AS (</div><div class="line">    VALUES(1)</div><div class="line">  UNION ALL</div><div class="line">    <span class="keyword">SELECT</span> n+<span class="number">1</span> <span class="keyword">FROM</span> t</div><div class="line">    <span class="keyword">WHERE</span> n &lt; <span class="number">100</span></div><div class="line">)</div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">sum</span>(n) <span class="keyword">FROM</span> t;</div></pre></td></tr></table></figure><p>然後就可以做出 1 + 2 + … + 100 的效果。</p><p>在 Ruby, PHP, JavaScript 等語言中，遞迴已經不容易理解，在 SQL 中實現這件事情，其實也並不容易。</p><p>先來理解一下範例的意思。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">WITH RECURSIVE 遞迴結果表(回傳欄位) AS (</div><div class="line">    初始值</div><div class="line">  UNION ALL</div><div class="line">    遞迴查詢</div><div class="line">)</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 遞迴結果表;</div></pre></td></tr></table></figure><p>也就是說，官網範例的 SQL 是給了初始值 <code>1</code> 並且不斷的 <code>SELECT n + 1</code> 後重新呼叫自己，直到 <code>n &lt; 100</code> 才停止。</p><h3 id="建構-SQL-查詢"><a href="#建構-SQL-查詢" class="headerlink" title="建構 SQL 查詢"></a>建構 SQL 查詢</h3><p>接下來，以這張表來建構查詢。</p><table><thead><tr><th>id</th><th>name</th><th>parent_id</th></tr></thead><tbody><tr><td>1</td><td>Jimmy</td><td></td></tr><tr><td>2</td><td>John</td><td>1</td></tr><tr><td>3</td><td>Alice</td><td>1</td></tr><tr><td>4</td><td>Alex</td><td>2</td></tr></tbody></table><p>按照前面的原則，撰寫下面這張表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">WITH RECURSIVE ancestors(id, parent_id, name) AS (</div><div class="line">    <span class="keyword">SELECT</span> users.id, users.parent_id, users.name</div><div class="line">    <span class="keyword">FROM</span> <span class="keyword">users</span></div><div class="line">    <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">4</span></div><div class="line">  <span class="keyword">UNION</span> ALL</div><div class="line">    <span class="keyword">SELECT</span> users.id, users.parent_id, users.name</div><div class="line">    <span class="keyword">FROM</span> <span class="keyword">users</span></div><div class="line">    <span class="keyword">JOIN</span> ancestors <span class="keyword">ON</span> ancestors.parent_id = users.id</div><div class="line">)</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ancestors;</div></pre></td></tr></table></figure><p>如此一來我們就會得到如下的結果</p><table><thead><tr><th>id</th><th>parent_id</th><th>name</th></tr></thead><tbody><tr><td>4</td><td>2</td><td>Alex</td></tr><tr><td>2</td><td>1</td><td>John</td></tr><tr><td>1</td><td></td><td>Jimmy</td></tr></tbody></table><p>首先，我們將 <code>id = 4</code> 的 Alex 選出來，作為第一筆資料。</p><blockquote><p>實務上，應該是將 John (<code>id = 2</code>) 直接帶入（父代預設不包含自己）</p></blockquote><p>接下來，我們的下一筆資料的 <code>users.id</code> 必須等於上一筆資料的 <code>users.parent_id</code> 才行。</p><p>這邊簡單的使用 <code>JOIN</code> 將 <code>ancestors</code> 跟現有的 <code>users</code> 連接起來。</p><blockquote><p><code>JOIN ancestors ON ancestors.parent_id = users.id</code> 可能會讓你有點疑惑。<br>這邊的 <code>ancestors</code> 是指「上一個找到的父代」也就是說上面這句 <code>JOIN</code> 查詢，是找下一個父代的查詢，用上一個的父代 <code>id</code> 去比對是意思正確的。</p></blockquote><p>至於效能上，目前在 800,00 rows 狀態下，用 <code>JOIN</code> 還是單純 <code>FROM users, ancestors</code> 是差不多的耗時跟解析 SQL 之後可能還需要多觀察是否有改進空間。</p><blockquote><p>相對於 Closure Table 還是慢上不少。</p></blockquote><h3 id="轉換成-Model"><a href="#轉換成-Model" class="headerlink" title="轉換成 Model"></a>轉換成 Model</h3><p>既然是使用 Rails 的專案，那麼就需要封裝成 Model 的方法才行。</p><p>在這之前，我們要先知道幾個前提。</p><ul><li><code>WITH RECURSIVE ancestors(...) AS (...)</code> 裡面給的欄位，是回傳的欄位。</li><li><code>UNION</code> 所 <code>SELECT</code> 的欄位必須一至，不可使用 <code>*</code> 符號。</li></ul><p>因為有以上的限制，我們的 Model 會呈現這樣的狀態。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> &lt; ApplicationRecord</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">ancestors</span><span class="params">(<span class="symbol">max_depth:</span> <span class="number">10</span>)</span></span></div><div class="line">    return_columns = User.column_names.join(<span class="string">', '</span>)</div><div class="line">    select_columns = column_names_for_recursive_query.join(<span class="string">', '</span>)</div><div class="line">    table_name = User.table_name</div><div class="line"></div><div class="line">    query = <span class="string">&lt;&lt;-SQL</span></div><div class="line">      WITH RECURSIVE ancestors(<span class="subst">#&#123;return_columns&#125;</span>, depth) AS (</div><div class="line">        SELECT <span class="subst">#&#123;select_columns&#125;</span>, 1</div><div class="line">        FROM <span class="subst">#&#123;table_name&#125;</span></div><div class="line">        WHERE <span class="subst">#&#123;table_name.id&#125;</span> = <span class="subst">#&#123;parent_id&#125;</span></div><div class="line">      UNION ALL</div><div class="line">        SELECT <span class="subst">#&#123;select_columns&#125;</span>, depth + 1</div><div class="line">        FROM <span class="subst">#&#123;table_name&#125;</span></div><div class="line">        JOIN ancestors ON ancestors.parent_id = <span class="subst">#&#123;table_name&#125;</span>.id</div><div class="line">        WHERE depth &lt; <span class="subst">#&#123;max_depth&#125;</span></div><div class="line">      )</div><div class="line">      SELECT * FROM ancestors ORDER BY depth</div><div class="line">    SQL</div><div class="line">    User.find_by_sql(query)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  private</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">column_names_for_recursive_query</span></span></div><div class="line">    @column_names <span class="params">||</span>= User.column_names.map <span class="params">|name|</span></div><div class="line">      [User.table_name, name].join(<span class="string">'.'</span>)</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>如此一來，我們就可以用 <code>User.last.ancestors</code> 取得對應的 Model 物件回傳。</p><p>不過，上面的查詢也還有不少限制，像是無法繼續加上 <code>order</code> <code>limit</code> 等其他透過 ORM 產生的 SQL 查詢。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>其實整體看下來，所謂樹狀的結構解法，是要看當時的情境。</p><p>以文章一開始的案例來看，選用 Adjacency List by SQL 的方式最為適合，理由如下。</p><ul><li>產生節點要快</li><li>世代只會不斷成長</li><li>樹狀結構的追溯有上限<ul><li>每個節點只會運行一次追溯</li></ul></li></ul><p>以這個案例來看，耗費在 <code>Recursive Query</code> 的成本每個節點只有一次，相比 Closure Table 會因為世代成長造成的消耗，或者 Path Enumeration 的儲存限制，這個成本是很低的。</p><blockquote><p>下一步是封裝成 Concern 方便取用，畢竟這類型的系統有時候很仰賴樹狀結構的查詢。</p></blockquote><p>另外，樹狀結構比較常拿去查詢子代，畢竟子代數量不確定的時候非常難以管理。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2017/10/23/Use-PostgreSQL-s-recursive-query-to-find-ancestors/#disqus_thread</comments>
    </item>
    
    <item>
      <title>自由的 Ruby 類別（一）</title>
      <link>https://blog.frost.tw/posts/2017/10/22/The-ruby-s-class-is-free-Part-1/</link>
      <guid>https://blog.frost.tw/posts/2017/10/22/The-ruby-s-class-is-free-Part-1/</guid>
      <pubDate>Sun, 22 Oct 2017 15:15:03 GMT</pubDate>
      <description>
      
        &lt;p&gt;以前還在讀書的時候，常常會思考所謂的「自由」是什麼，想著以後一定要過著自由的生活。不過現實就是到了社會，依舊還是有許多限制讓你無法自由自在。&lt;/p&gt;
&lt;p&gt;不過，在 Ruby 中的類別卻是非常自由的。&lt;/p&gt;
&lt;p&gt;有稍微接觸過 Ruby 的人應該都知道幾個特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;物件導向語言&lt;/li&gt;
&lt;li&gt;一切都是物件&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>以前還在讀書的時候，常常會思考所謂的「自由」是什麼，想著以後一定要過著自由的生活。不過現實就是到了社會，依舊還是有許多限制讓你無法自由自在。</p><p>不過，在 Ruby 中的類別卻是非常自由的。</p><p>有稍微接觸過 Ruby 的人應該都知道幾個特性：</p><ul><li>物件導向語言</li><li>一切都是物件</li></ul><a id="more"></a><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>在 Ruby 裡面，所有的類別的類別都是 <code>Class</code> 這個類別。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Object.<span class="keyword">class</span></div><div class="line"><span class="comment"># =&gt; Class</span></div><div class="line"></div><div class="line">Kernel.<span class="keyword">class</span></div><div class="line"><span class="comment"># =&gt; Module</span></div><div class="line">Module.<span class="keyword">class</span></div><div class="line"><span class="comment"># =&gt; Class</span></div></pre></td></tr></table></figure><p>即使是 <code>Module</code> (模組) 也是屬於類別的一種，也就是說萬物都源自於 <code>Class</code> 這個類別。</p><blockquote><p>至於 <code>Class.class</code> 還是會得到 <code>Class</code> 自己本身</p></blockquote><h2 id="Anonymous-Class"><a href="#Anonymous-Class" class="headerlink" title="Anonymous Class"></a>Anonymous Class</h2><p>至於一個類別是怎樣出生的呢？我們可以先從沒有名字的類別來看。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class.new</div><div class="line"><span class="comment"># =&gt; #&lt;Class:0x007f85fc30ea88&gt;</span></div></pre></td></tr></table></figure><p>現在我們得到了一個新的類別（物件）而且也可以對他進行一個產生實例的動作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">klass = Class.new</div><div class="line">klass.new</div><div class="line"># =&gt; &lt;#&lt;Class:0x007f85fc30ea88&gt;:0x007f85fc2efa98&gt;</div></pre></td></tr></table></figure><p>因為這種類別很可憐，他連名字都沒有，所以他的名字就是物件本身的 <code>#&lt;Class:0x007f85fc30ea88&gt;</code></p><p>那麼，該怎麼讓他們獲得名字呢？</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Klass = Class.new</div><div class="line">Klass.new</div><div class="line"><span class="comment"># =&gt; #&lt;Klass:0x007f85fc2d7510&gt;</span></div></pre></td></tr></table></figure><p>實際上，所有類別的名字都是一個常數。<br>所以才會在撰寫類別名稱的時候，必須以大寫開頭（定義為常數）才能運作。</p><p>不過，類別的繼承跟方法該怎麼辦呢？</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Klass = Class.new(Object) <span class="keyword">do</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">(text)</span></span></div><div class="line">    puts text</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">Klass.new.echo <span class="string">'Hello World'</span></div><div class="line"><span class="comment"># =&gt; Hello World</span></div></pre></td></tr></table></figure><p>實際上就是把一個 Block 在初始化類別的時候傳進去，讓他做一些事情。</p><p>上面的類別定義等價於下面的程式碼：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Klass</span></span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">(text)</span></span></div><div class="line">    puts text</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>所以，我們在這邊發現我們在 <code>class</code> 到 <code>end</code> 所寫的，可能是一個 Block。</p><h2 id="Class-Methods"><a href="#Class-Methods" class="headerlink" title="Class Methods"></a>Class Methods</h2><p>這個段落會討論的是 <code>Class</code> 類別的方法，有趣的是他剛好也是其他類別的類別方法。</p><p>物件導向中，我們知道有兩種方法的定義。</p><ul><li>類別方法 <code>Klass.instance</code></li><li>實例方法 <code>Klass.new.echo</code></li></ul><p>差別在於實例方法需要先把類別用 <code>.new</code> 初始化之後，才能存取到這些方法。</p><p>首先，我們可以先看看 <code>Class</code> 類別有哪些類別方法可以使用。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class.methods</div><div class="line"><span class="comment"># =&gt; [:include, ...,:instance_exec, :__id__]</span></div></pre></td></tr></table></figure><p>省略了一些方法，不過看到了 <code>include</code> 這個熟悉的關鍵字。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Klass</span></span></div><div class="line">  <span class="keyword">include</span> Mod</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>沒錯，我們所看到的 <code>include</code> 就是我們在 <code>include</code> 某個模組的那一個。</p><p>所以，下面的這些動作其實是等價的。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Klass = Class.new <span class="keyword">do</span></div><div class="line">  <span class="keyword">include</span> Mod</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Klass</span></span></div><div class="line">  <span class="keyword">include</span> Mod</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># class Klass; end</span></div><div class="line"><span class="comment"># or</span></div><div class="line"><span class="comment"># Klass = Class.new</span></div><div class="line"></div><div class="line">Klass.<span class="keyword">include</span> Mod</div></pre></td></tr></table></figure><p>透過以上的探索，是不是發現大多數 Rubyist 都可能接觸過的 Rails 中，有很多這樣的應用方式呢？</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> &lt; ApplicationRecord</span></div><div class="line">  has_many <span class="symbol">:posts</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>從上面的例子來看 <code>has_many</code> 是一個類別方法，並且可能是屬於 <code>ApplicationRecord</code> 或者其上層的某一個物件。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在 Ruby 的世界中，所有的類別其實都是 <code>Class</code> 這個類別的實體表現而已。<br>而父類別的的類別方法，則可以作為在定義新類別時的 Block 中使用，用來拓展一個類別的多樣性。</p><p>下一篇文章會來討論 <code>has_many</code> 的實際應用是怎樣的。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2017/10/22/The-ruby-s-class-is-free-Part-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>在 RubyKaigi 2017 年後的反思</title>
      <link>https://blog.frost.tw/posts/2017/10/09/The-RubyKaigi-2017-let-me-reflection/</link>
      <guid>https://blog.frost.tw/posts/2017/10/09/The-RubyKaigi-2017-let-me-reflection/</guid>
      <pubDate>Mon, 09 Oct 2017 08:24:58 GMT</pubDate>
      <description>
      
        &lt;p&gt;在這幾個月，感覺到自己好像快要突破這一階段的瓶頸，所以做了一些調整試試看能不能順利的突破，同時也到了每年公司參與 RubyKaigi 的時期。&lt;/p&gt;
&lt;p&gt;要說的話，今年的 RubyKaigi 整體的方向對我來說很不一樣，因為有不少關於 RubyKaigi 底層的議程被提出來，這在台灣舉辦研討會需要照顧到不同客群的人總會需要有一些取捨。&lt;/p&gt;
&lt;p&gt;不過，對日本——Ruby 的發源地來說，因為有不同類型的研討會互補，反而可以在不同的研討會上，著重不同的情境來討論。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>在這幾個月，感覺到自己好像快要突破這一階段的瓶頸，所以做了一些調整試試看能不能順利的突破，同時也到了每年公司參與 RubyKaigi 的時期。</p><p>要說的話，今年的 RubyKaigi 整體的方向對我來說很不一樣，因為有不少關於 RubyKaigi 底層的議程被提出來，這在台灣舉辦研討會需要照顧到不同客群的人總會需要有一些取捨。</p><p>不過，對日本——Ruby 的發源地來說，因為有不同類型的研討會互補，反而可以在不同的研討會上，著重不同的情境來討論。</p><a id="more"></a><p>今年舉辦的地點在廣島，附近比較著名的景點就是「嚴島神社」不過因為遭遇了颱風，我就沒有像同事一樣在轉移到福岡觀光前衝過去看。</p><blockquote><p>據說早中晚的風景都不同，也許哪天有空去那邊逛個一天會是不錯的選擇。</p></blockquote><h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><p>第一天因為是週日，就和同事趁颱風還未接近的時候，先趕緊到海事博物館看了一下大和戰艦的介紹跟模型。</p><p><img src="/images/the-rubykaigi-2017-let-me-reflection/day1.jpg" alt=""></p><p>博物館本身有提供特殊的導覽裝置，可以講中文。並且會在對應的地點自動觸發解說，所以逛起來基本上沒什麼問題，唯一可惜的地方大概就是被颱風催促需要在風雨接近之前趕回旅館。</p><p>晚上風雨非常大，不過運氣很好的是旅館旁邊有一間小店的炒麵非常好吃，就用短跑衝刺的方式跑過去吃。</p><p><img src="/images/the-rubykaigi-2017-let-me-reflection/day1-2.jpg" alt=""></p><p>不過回旅館的時候大家因為風太大差點跑不回去，不過雨傘在這時候其實也完全發揮不了作用就是了！</p><p>颱風其實走得很快，晚上大約十點多就離開暴風半徑。在這段時間，我們把原本 RubyKaigi 慣例的 Pre-Party 取消報名，畢竟冒著風雨過去太危險，反而在旅館跟同事開始喝起酒來。</p><p><img src="/images/the-rubykaigi-2017-let-me-reflection/day1-3.jpg" alt=""></p><p>去年已經稍微習慣這樣的節奏，也開始學怎麼喝酒，所以今年也是很淡定的喝了不少。</p><blockquote><p>RubyKaigi 基本上就是 3 + 1 天左右全身 24 小時都有酒精的活動。</p></blockquote><h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><p>今年是先參加 RubyKaigi 再進行觀光，所以第二天（下飛機那天大家買完防颱的食物就休息了）馬上就是 RubyKaigi。</p><p><img src="/images/the-rubykaigi-2017-let-me-reflection/day2.jpg" alt=""></p><p>紀念品很有趣，每年 RubyKaigi 的紀念品都是自取的。早知道就帶三份，紀念、自用跟送禮之類的，好像很不錯。</p><blockquote><p>不知道為什麼第一天的議程我完全失去記憶了，今年其實有不少雷的議程，然後好像都剛好聽到⋯⋯</p></blockquote><p>晚上的官方 Party 也出現了去年沒看過的木桶裝清酒⋯⋯</p><p><img src="/images/the-rubykaigi-2017-let-me-reflection/day2-1.jpg" alt=""></p><p>不過這個其實蠻刺激的，另外就是今年似乎因為講日文的人比較多（大概是平日的關係）比去年還難以去跟其他人聊天，即使在目前的案子訓練下已經比較習慣用英文對談。</p><p>因為廣島其實沒有太多的景點，所以一結束後我們馬上會到福岡，只能把握時間趕緊吃一下當地美食。</p><p><img src="/images/the-rubykaigi-2017-let-me-reflection/day2-2.jpg" alt=""></p><p>廣島燒，雖然對外國人來說無法分辨跟大阪燒的差異，總之我們就叫他廣島燒吧。</p><blockquote><p>可惜份量蠻大的，當晚上的宵夜還是分攤來吃比較適合。</p></blockquote><p>今年也剛好碰到日本球隊比賽的結果，廣島這邊的隊伍因為好幾年（沒記錯是八年）沒有得到冠軍，所以正在狂歡。</p><p><img src="/images/the-rubykaigi-2017-let-me-reflection/day2-3.jpg" alt=""></p><p>這張照片是我們在旁邊圍觀的畫面（前面是商店街）不過後面馬上就發生同事被醉漢襲擊的事件，原本以為是同事的日本友人，但是下一秒就被淋了滿身酒。</p><p>接下來就是五個男生呈現一個隨時可以逃跑的隊形，選沒有人的小路逃回旅館的狀態。</p><blockquote><p>日本人狂起來好可怕喔（抖</p></blockquote><p>比較特別的是，今年有一個贊助商是做珠寶的，只是因為網站用 Ruby 開發就贊助（真希望台灣也有這種的贊助商）神秘的攤位禮品則是這個。</p><p><img src="/images/the-rubykaigi-2017-let-me-reflection/day2-4.jpg" alt=""></p><p>真正的紅寶石，其實不大而且據說要老闆高興才會給，這樣說起來我還蠻幸運的（因為老闆英文似乎比我還好，讓我卡住了 XD）</p><h2 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h2><p>因為 RubyKaigi 大家都很努力喝酒，所以其實清醒的時間並不多（問題發言）</p><p>不過這場演講大概是我三天裡面最清醒的一場。</p><p><img src="/images/the-rubykaigi-2017-let-me-reflection/day3.jpg" alt=""></p><p>「<a href="http://rubykaigi.org/2017/presentations/shioyama.html" target="_blank" rel="noopener">The Ruby Module Builder Pattern</a>」是在討論 Ruby 裡面的 Module 可以怎樣使用，是一場非常有用的應用技術演講。</p><p>講者的公司是日本 Steam 的金流代理商，另外講者自己的網誌也是很多很技術文章可以讀。</p><blockquote><p>而且我剛好在寫關於 Module 的文章，這場演講算是提醒大家在使用上有一個盲點的演講，整體上不困難，但是很有用。</p></blockquote><p>今年沒有提供午餐（去年的餐盒超好吃）所以放生大家到附近的餐廳去吃，前一天是跟團吃到一直想吃的燒肉，今天則是西餐廳。</p><p><img src="/images/the-rubykaigi-2017-let-me-reflection/day3-1.jpg" alt=""></p><p>因為時間限制，第一天有經驗後就放棄下午第一場的演講。這間餐廳雖然不是日式的食物，但是都非常好吃而且精緻，所以其實把附近同事的餐點也都拍了一遍。</p><p>今天有安排 Lightning Talk 有不少精采的技術分享，雖然主要都是圍繞在今年對 Ruby 效能的主題有關。</p><p><img src="/images/the-rubykaigi-2017-let-me-reflection/day3-2.jpg" alt=""></p><p>有趣的是像是 Niconico 和 Pixiv 其實都有使用 Ruby 讓人覺得格外的親切。</p><blockquote><p>對一個寫 Ruby 的宅宅來說很輕切⋯⋯</p></blockquote><p>晚上的贊助商 Party 據說是超稀有級，因為去年沒有。而負責人據說是酒神等級，選的酒都非常厲害。</p><p><img src="/images/the-rubykaigi-2017-let-me-reflection/day3-3.jpg" alt=""></p><p>一整排的清酒，不管喝哪種都算是非常好喝。不過因為後勁很強，我大概在第三杯（小杯）的時候就開始覺得有暈，只能慢慢喝。</p><blockquote><p>大家到日本的時候如果要跟日本人喝酒，請小心我們預設值是不一樣的，不要喝太拼。</p></blockquote><h2 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a>Day4</h2><p>經過兩天的議程，今天終於到了 RubyKaigi 的最後一天，也是強者同事 Henry 上台分享 <a href="https://tamashii.io" target="_blank" rel="noopener">Tamashii</a> 專案的日子。</p><p><img src="/images/the-rubykaigi-2017-let-me-reflection/day4.jpg" alt=""></p><p>這個專案原本是 PyCon 結合 Raspberry Pi 所開發的研討會報到系統，不過後來因為棄坑就被我們公司接手，並且用 Ruby 重新開發。</p><blockquote><p>目前主要是我跟 Henry 兩個人在維護，我加入的時候剛好是 Rails 在 ActionCable 支援比較完善的時期，不過 Ruby 的 WebSocket Client 並不成熟，所以就跟 Henry 做了不少改良，成為目前的狀態。運氣好的話，之後大概會發展成 IoT 的套件組吧。</p></blockquote><p>中午跑去吃台灣要排隊才能吃到的一蘭。</p><p><img src="/images/the-rubykaigi-2017-let-me-reflection/day4-1.jpg" alt=""></p><p>跟吃過的日本拉麵比起來，一蘭的湯頭很好入口，算是很容易喝完的類型。後面因為同事發現貓咪咖啡廳，就翹掉議程跑進去了 XD</p><p>最後一天的晚上是 Pixiv 所贊助的 Party 在 SOGO 頂樓，進去的時候覺得超誇張。</p><p><img src="/images/the-rubykaigi-2017-let-me-reflection/day4-2.jpg" alt=""></p><p>一個頂樓小吃區包場的概念，在台灣也不容易看到這樣的形式，有些東西果然要在日本才能看到啊⋯⋯</p><p>晚上跟同事到廣島的商店街逛了一下，順便買點衣服就回去旅館休息，等明天搭車轉乘。</p><blockquote><p>其實原本沒有要買，不過因為前面提到的球隊贏球，衣服大概是 2000 JPY -&gt; 500 JPY 這種瘋狂的折扣，就默默拿出錢包了⋯⋯</p></blockquote><h2 id="Day5"><a href="#Day5" class="headerlink" title="Day5"></a>Day5</h2><p>上午除了衝去宮島的同事之外，基本上就是大家悠哉起床後等中午搭 JR 到福岡。</p><p>下午先到友社 Nulab 拜訪，竟然是把整棟公寓租下來改裝，讓我們超羨慕（不過在台灣大概不可能）</p><p><img src="/images/the-rubykaigi-2017-let-me-reflection/day5.jpg" alt=""></p><p>最上面那一層是休息區，有迷你桌球桌跟射飛鏢這些設備，希望有一天公司也可以升級到這樣。</p><p>傍晚的時間就是先在附近探路一下，看看後面幾天有沒有適合玩的地方。</p><blockquote><p>不過很可惜的是福岡旅館附近都是百貨公司之類的，很適合敗家呢！</p></blockquote><p>晚上由日本分社的社長大偉哥準備的聚餐，大家一起先怒吃一波。</p><p><img src="/images/the-rubykaigi-2017-let-me-reflection/day5-1.jpg" alt=""></p><p>在日本基本上很難不吃到生魚片，在台灣因為我很怕腥味基本上是沒有吃海鮮。今年在日本碰到的，基本上都沒有腥味（不愧是日本）不然這餐其實很難把它吃完⋯⋯</p><blockquote><p>這間應該算是居酒屋，總而言之後面都是在喝酒。大偉哥也向我們展示了在日本住八年之後怎麼跟日本人喝酒，公司一半的人都一度陣亡。<br>這邊再次跟大家強調，我們不是專業的日本人，喝酒請自制⋯⋯</p></blockquote><h2 id="Day6"><a href="#Day6" class="headerlink" title="Day6"></a>Day6</h2><p>這一天開始就是自由活動的行程，中午先跟了一團迴轉壽司。</p><p><img src="/images/the-rubykaigi-2017-let-me-reflection/day6.jpg" alt=""></p><p>雖然坐在等待區的時候才被發現有個不吃海鮮的人混入，不過因為前幾天根本就是宿醉狀態其實沒有打算吃很多。再加上我對日本的生魚片很有信心就淡定進去了。</p><blockquote><p>因為福岡也是冠軍（另一區，之後要跟廣島打），連壽司店都有特殊的牛舌壽司出現（不過好吃的是其他的，忘記拍了⋯⋯）</p></blockquote><p>下午則是去附近一間專賣老遊戲的店逛逛，運氣蠻不好的是前幾天才搬店，不過還好都在附近的區域。</p><p><img src="/images/the-rubykaigi-2017-let-me-reflection/day6-1.jpg" alt=""></p><p>裡面太多遊戲都是我沒看過的，而 Game Boy / GBA / NES 時代我則是沒有機會玩到這些遊戲，裡面最有感覺的大概就是這款。大學因為同學的關係有玩 GTA 5 這款則是 GTA 一代。</p><p>逛完之後就慢慢往旅館方向前進，意外的發現⋯⋯</p><p><img src="/images/the-rubykaigi-2017-let-me-reflection/day6-2.jpg" alt=""></p><p>原來日本也有少林寺呢 XD</p><blockquote><p>而且裡面的神像是昆沙門天，沒記錯是戰神⋯⋯</p></blockquote><p>傍晚的時候到遊戲中心晃晃，因為老闆想找看看有沒有他想打的機台（日本也幾乎沒有了⋯⋯）</p><p><img src="/images/the-rubykaigi-2017-let-me-reflection/day6-3.jpg" alt=""></p><p>在旁邊發現了鋼彈駕駛艙，就進去體驗了一下。</p><blockquote><p>不過日本目前大多數機台都最好要綁定卡片，非日本人去玩都蠻可惜的。</p></blockquote><p>晚上原本想吃福岡比較有名的「水炊」但是因為比較好的餐廳訂不到位置，只好改成吃串燒。</p><p><img src="/images/the-rubykaigi-2017-let-me-reflection/day6-4.jpg" alt=""></p><p>九州一代的食物真的相對便宜，我們吃完均分之後還發現大概在 2500 日幣以內，一般這種單點通常會點爆。</p><p>晚上則是回旅館休息，因為我們得到情報隔天有賣場要釋出 Switch 啊！</p><h2 id="Day7"><a href="#Day7" class="headerlink" title="Day7"></a>Day7</h2><p>大概五點多我們就起床準備，到福岡車車站的ヨドバシ去排隊。運氣很好的是以為日本人應該會夜排，結果前面大概不到二十人。</p><p><img src="/images/the-rubykaigi-2017-let-me-reflection/day7.jpg" alt=""></p><p>於是順利入手了一台 Switch 呢！目測覺得大概有 100 ~ 200 台釋出，覺得應該也算是一次性釋出的情況中少見的。</p><blockquote><p>釋出理由？球隊冠軍啊，當然要慶祝一下！另外沒有人大概是消息沒有傳開，我在 Twitter 上面幾乎沒有看到有人發推。</p></blockquote><p>下午就躲回旅館打 MHXX 了，以及睡死。早起排隊超累的，附近又是百貨公司對於不常逛街買東西的人來說其實沒什麼吸引力。</p><p>晚上又揪一團燒肉，我對在日本吃燒肉似乎很執著啊 XD</p><p><img src="/images/the-rubykaigi-2017-let-me-reflection/day7-1.jpg" alt=""></p><p>不過還是要看燒肉的等級，在日本吃普通燒肉大概除了是日本口味之外，跟在台灣吃好像差不多⋯⋯</p><h2 id="Day8"><a href="#Day8" class="headerlink" title="Day8"></a>Day8</h2><p>扣掉到日本的當天，這是最後一天了！</p><p>早上好像跑去再開幾次鋼彈的樣子，總之沒什麼印象。中午則是去吃「華味鳥」的拉麵，原本是想去吃他們水炊，但是就是很難吃到。</p><p><img src="/images/the-rubykaigi-2017-let-me-reflection/day8.jpg" alt=""></p><p>不過他們的湯頭似乎是跟水炊一樣的，吃起來超讚。旁邊會有飯糰，讓我們放進去拌勻來吃，我超喜歡這點。因為我一直覺得以拉麵湯頭的濃度，配飯應該會超好吃。</p><p>下午因為要等飛機，所以只能在附近晃晃。最後變成跑去遊戲中心夾娃娃（日幣剩很多⋯⋯）</p><p><img src="/images/the-rubykaigi-2017-let-me-reflection/day8-1.jpg" alt=""></p><p>雖然經過三十次以上的失敗，但是終於發現我比較擅長的類型勉強夾到一個。</p><blockquote><p>不知道為什麼其他同事都會突然神手一次就中⋯⋯</p></blockquote><p>之後就是接近半夜回台灣，才發現機場捷運十一點半就是最後一班（差點睡機場呢！）不過總覺得機場附近不好找住宿的地方，機場捷運再加開幾班也許會比較方便一點。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>前面講了一堆在日本這幾天怎麼玩，幾乎沒講到為什麼是「反思」的一年。</p><p>一開始有提到，因為感覺可以再進一步，所以有在調整一些狀態。也因為這樣，我想這次我第一次這麼認真的玩，寫這篇文章的時候才發現，雖然沒有去逛什麼景點，不過整體上來說算是很好的放鬆一次。</p><p>也因為該放鬆的放鬆玩了，我覺得我可以好好的收心起來專注在技術上。另一方面是今年的 RubyKaigi 讓我慢慢瞭解了一些方向，很多時候我們使用 Ruby 或者其他比較高階的語言，很少會去考慮底層的問題。</p><p>雖然大多數時候不需要考慮，但是如果想要更了解這個語言、在網站/軟體開發上更進一步。那就必須更加熟悉語言、框架的特性，還有嘗試去參與這些語言背後設計的過程。</p><p>所以，就像是看到一個方向。覺得自己可以進一步的時候，其實是有感覺但是不知道該往哪邊走。但是聽完今年的議程後會發現，很多以前受限於能力的事情在目前的狀態是可以「嘗試的」也就意味著當我熟悉這些原本還不夠能力去做的事情的時候，大概就是我再更進一步的時候。</p><p>雖然還有一個問題就是，就跟遊戲的技能樹一樣，越高階會出現越多選項分歧。但是必須專注在少數幾個項目發展才行，雖然有很多有趣的項目可以選擇，但是受限於時間跟體力等等因素，最後還是得慢慢收束到某幾個領域。</p><p>最後，就是要戒一下挖坑的習慣，因為前面超放鬆所以一不小心又挖了一大堆坑⋯⋯</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2017/10/09/The-RubyKaigi-2017-let-me-reflection/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
