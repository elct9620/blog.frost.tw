<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>弦而時習之</title>
    <link>https://blog.frost.tw/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    
    <description>蒼時弦也的個人網誌，專注在前端、後端以及遊戲開發，大多使用 Ruby 和 Ruby on Rails 以及 Golang、JS 和 C 語言。</description>
    <pubDate>Sun, 20 Oct 2019 09:11:11 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>COSCUP 2019 - 演講後談復活的頁遊 - Unlight （二）</title>
      <link>https://blog.frost.tw/posts/2019/10/20/COSCUP-2019-Talk-about-the-browser-game-Unlight-which-I-revived-it-Part-2/</link>
      <guid>https://blog.frost.tw/posts/2019/10/20/COSCUP-2019-Talk-about-the-browser-game-Unlight-which-I-revived-it-Part-2/</guid>
      <pubDate>Sun, 20 Oct 2019 09:09:31 GMT</pubDate>
      <description>
      
        &lt;p&gt;寫完&lt;a href=&quot;https://blog.frost.tw/posts/2019/09/03/COSCUP-2019-Talk-about-the-browser-game-Unlight-which-I-revived-it/&quot;&gt;上篇&lt;/a&gt;後就開始員工旅遊、鐵人賽（&lt;a href=&quot;https://ithelp.ithome.com.tw/users/20065771/ironman/2734&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;從讀遊戲原始碼學做連線遊戲&lt;/a&gt;）反而一直都沒有時間把下篇寫完，離 COSCUP 都已經過了一個多月自己都忘記還剩什麼沒有寫在文章裡面。&lt;/p&gt;&lt;p&gt;中間在鐵人賽的部分花了一些時間把目前理解到關於 Unlight 的一些基本設計整理出來，後面則是實作。至於近期也已經開始在搭建 HTML5 版本的底層設計，還有 mruby 的&lt;a href=&quot;https://github.com/elct9620/mruby.wasm&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;整合&lt;/a&gt;（因為想提供 Mod 功能到遊戲中）等等東西都在進行中，十一月還要飛日本一趟參加 &lt;a href=&quot;https://2019.rubyworld-conf.org/en/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Ruby World Conference&lt;/a&gt;，可以說是完全都閒不下來。&lt;/p&gt;&lt;p&gt;總之，讓我們在來看看 COSCUP 這場演講的後續吧 XD&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>寫完<a href="https://blog.frost.tw/posts/2019/09/03/COSCUP-2019-Talk-about-the-browser-game-Unlight-which-I-revived-it/">上篇</a>後就開始員工旅遊、鐵人賽（<a href="https://ithelp.ithome.com.tw/users/20065771/ironman/2734" rel="external nofollow noopener noreferrer" target="_blank">從讀遊戲原始碼學做連線遊戲</a>）反而一直都沒有時間把下篇寫完，離 COSCUP 都已經過了一個多月自己都忘記還剩什麼沒有寫在文章裡面。</p><p>中間在鐵人賽的部分花了一些時間把目前理解到關於 Unlight 的一些基本設計整理出來，後面則是實作。至於近期也已經開始在搭建 HTML5 版本的底層設計，還有 mruby 的<a href="https://github.com/elct9620/mruby.wasm" rel="external nofollow noopener noreferrer" target="_blank">整合</a>（因為想提供 Mod 功能到遊戲中）等等東西都在進行中，十一月還要飛日本一趟參加 <a href="https://2019.rubyworld-conf.org/en/" rel="external nofollow noopener noreferrer" target="_blank">Ruby World Conference</a>，可以說是完全都閒不下來。</p><p>總之，讓我們在來看看 COSCUP 這場演講的後續吧 XD</p><a id="more"></a><h2 id="營運"><a href="#營運" class="headerlink" title="營運"></a>營運</h2><p>前面基本上已經把整個遊戲能緊急處理的都做過一遍了，因此後需要繼續的明顯就是要怎麼讓遊戲可以持續的運作。最初基本上都是用看 Log 的方式在觀察玩家，連上線人數都要開一個 SSH 連線到伺服器刷 Log 來看，很明顯是不太 OK 的做法。</p><p>因此就開始評估有什麼解法比較適合，因為大量的改動不熟悉的程式碼（遊戲量很大）是一件危險很高的事情，尤其是雖然專案看起來有測試但是卻完全找不到。</p><p>所以最後決定的做法就是在某些特定檔案做小規模的修改，先以「增加監控」能力為主，因此我們先做的就是讓上線人數可以到 CloudWatch 上面被看到，至少能統計 DAU (Daily Active User) 來評估遊戲是否該做調整之類的。</p><p>解決方案也是簡單粗暴，因為只有 Auth Server 在連上的狀態遊戲才能正常遊玩，因此直接對 Auth Server 吐線上玩家統計 Log 的地方用同樣的方式 Hack 出一個定時把資料吐回 CloudWatch 的功能。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">EM::PeriodicTimer.new(<span class="number">60</span>, proc &#123;</span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">    SERVER_LOG.info(<span class="string">"AuthServer: [cloud_watch:] updated online number"</span>)</span><br><span class="line">    CLOUD_WATCH.put_metric_data(&#123;</span><br><span class="line">      <span class="symbol">namespace:</span> <span class="string">'Unlight'</span>,</span><br><span class="line">      <span class="symbol">metric_data:</span> [&#123;</span><br><span class="line">        <span class="symbol">metric_name:</span> <span class="string">'OnlineNumber'</span>,</span><br><span class="line">        <span class="symbol">dimensions:</span> [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="symbol">name:</span> <span class="string">'Hostname'</span>,</span><br><span class="line">            <span class="symbol">value:</span> ENV[<span class="string">'SERVER_NAME'</span>] <span class="params">||</span> <span class="string">'unlight.app'</span></span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="symbol">timestamp:</span> Time.now,</span><br><span class="line">        <span class="symbol">value:</span> AuthServer.class_variable_get(<span class="symbol">:</span>@@online_list).size,</span><br><span class="line">        <span class="symbol">unit:</span> <span class="string">'Count'</span></span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="keyword">rescue</span> =&gt;e</span><br><span class="line">    SERVER_LOG.fatal(<span class="string">"AuthServer: [cloud_watch:] fatal error <span class="subst">#&#123;e&#125;</span>:<span class="subst">#&#123;e.backtrace&#125;</span>"</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>除此之外我們也盡量使用像是 Google Analytics 等工具追蹤一些我們額外掛上去的功能，不過受限於 Flash 很多東西還是追不到的狀態。</p><h2 id="客製化"><a href="#客製化" class="headerlink" title="客製化"></a>客製化</h2><p>不過想要加額外的東西是會影響到我們目前在 <a href="https://github.com/open-unlight/legacy-unlight-docker" rel="external nofollow noopener noreferrer" target="_blank">GitHub</a> 公開的版本，這個版本是基於 CPA 釋出的原始碼建構並且修正一些有問題的小地方。如果去調整的話會造成所有人都需要跟我們使用一樣的架構。</p><p>但是這很明顯不應該出現在一個 Open Source 專案上，從設計的角度看也應該提供選擇才對，所以最後的作法就是增加一個 <code>customize</code> 目錄來放這些客製化的東西。</p><p>在 Docker 的建置過程中，我們可以使用多次 <code>ADD</code> 來加入檔案，如果是重複的檔案就會被覆蓋掉，利用這樣的特性就可以做到類似這樣的客製化調整。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原始 Gemfile -&gt; 自訂 Gemfile -&gt; 原始檔案 -&gt; 自訂檔案</span><br></pre></td></tr></table></figure><p>如此一來最後整合出來的專案就會是被客製化修改過的，利用這樣的特性我們就把 CloudWatch 的線上玩家監控，還有遊戲中透過 API 方式開放的課金道具商店給實作出來。</p><h2 id="Rack"><a href="#Rack" class="headerlink" title="Rack"></a>Rack</h2><p>不過在 Unlight 這樣的 TCP 專案上要怎麼擴充出 API 呢？因為本質上他還是一個 Ruby 專案，因此我們只需要時做一個符合 Rack 介面的標準就可以任意讓 Web Server 啟動他跑起來。實際上在這方面 Unlight 做得還算不錯，整體專案上分為幾個大區塊</p><ul><li><code>model/</code> - 資料相關，通常會連接資料庫</li><li><code>controller/</code> 邏輯相關，遊戲的運作本體</li><li>其他大多是輔助的工具，還有比較特殊的是遊戲規則定義（Rule 目錄）</li></ul><p>因為操作的部分已經被封裝到 Model 裡面，像是「發放給玩家一個道具」這樣的動作是封裝好的，因此我們可以在 API 透過這樣的方式直接發放道具給玩家。</p><blockquote><p>在 Controller 裡面會是「檢查玩家是否符合條件，然後發放道具」的組合動作。</p></blockquote><h2 id="客服"><a href="#客服" class="headerlink" title="客服"></a>客服</h2><p>這段基本上很難做，我們後來的作法就是搭配各種工具。像是 <a href="https://help.unlight.com.tw/hc/zh-tw" rel="external nofollow noopener noreferrer" target="_blank">Zendesk</a> 這類工具來提供玩家回報問題的地方，網頁右下角直接會有能回報錯誤的按鈕可以查詢 FAQ 或者回報問題。</p><p>內部的話則是用 Discord 和 Asana 等工具溝通跟討論下一階段更新要做什麼、有什麼事情要優先處理等等。</p><blockquote><p>幫助按鈕後來改左邊，因為我們加上了 Discord Widget 讓玩家可以透過 Chatbot 在我們的玩家群組裡面發言而不需要登入或者註冊。</p></blockquote><h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><p>最後是 HTML5 改版，考慮到只有 WebSocket 可以使用的情況下勢必要去改伺服器來實現 WebSocket 不然就無法使用。不過運氣不錯的是這件事情剛好因為 Unlight 是使用 EventMachine 來處理 TCP 連線的，因此我把 WebSocket 套件加上去之後做一些簡單的修改，就勉強可以使用 WebSocket 來作為伺服器。</p><blockquote><p>Ruby 目前的 WebSocket Gem 是基於 EventMachine 開發的，因此在連線處理上幾乎沒有太大的變化。</p></blockquote><p>不過還是缺失了不少功能，演講當時基本上就簡單分享了一下 WebSocket 的機制跟目前的進度。寫這篇文章的時候已經透過 Electron.js 製作桌機版讓 Flash 續命時間增加了一定程度，又發現能夠直接透過 Node.js 做 TCP 連線，因此目前的主力已經先轉移到將 HTML5 Client 開發出來後先直接使用原有伺服器來運行，等到 Client 穩定後再去修改伺服器的作法。</p><p>在這之前，因為 Unlight 的指令是很用 Byte 去組合而成的結構在 JavaScript 上也很難處理。因此又開了一個 <a href="https://github.com/open-unlight/go-ul" rel="external nofollow noopener noreferrer" target="_blank">Go UL</a> 的專案想利用 Golang 來解析，在轉換成 WebAssembly 整合到 JavaScript 上面來改善這方面的處理問題（SPR 的密碼加密計算用 Golang 也會比 JavaScript 容易處理，畢竟 BigInt 在 JavaScript 上也需要額外的支援）</p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>這場演講基本上算是一個過程上的紀錄，在短短一到兩週內的時間怎麼去讓一款遊戲可以運行、營運，以及我們是怎樣慢慢的改造跟重構一個古老的遊戲專案讓他變得容易維護。</p><p>不過實際上當時評估如果要繼續做下去的話，絕對是花上一兩年都跑不到的大工程，雖然不知道能堅持到什麼時候但至少每一個階段都能發現有趣的東西，應該是還可以繼續在努力很久。反而是關於 IP 上的問題，也就是遊戲的內容本身因為並沒有實際的完全開放，反而讓未來改版完畢後遊戲想要進入新的階段變得非常受限⋯⋯</p><p>不過也因為這款遊戲，讓我自己在遊戲開發上有很多不確定的東西有了一個大概知道能怎麼做的方案，以及很多新的想法可以嘗試。</p><p>那麼，就請大家期待在不久的未來我們重新開發過的 Unlight 會是怎樣的面貌了 XD</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2019/10/20/COSCUP-2019-Talk-about-the-browser-game-Unlight-which-I-revived-it-Part-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>COSCUP 2019 - 演講後談復活的頁遊 - Unlight （一）</title>
      <link>https://blog.frost.tw/posts/2019/09/03/COSCUP-2019-Talk-about-the-browser-game-Unlight-which-I-revived-it/</link>
      <guid>https://blog.frost.tw/posts/2019/09/03/COSCUP-2019-Talk-about-the-browser-game-Unlight-which-I-revived-it/</guid>
      <pubDate>Tue, 03 Sep 2019 11:44:11 GMT</pubDate>
      <description>
      
        &lt;p&gt;在 &lt;a href=&quot;https://coscup.org/2019/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;COSCUP&lt;/a&gt; 分享了這兩週左右（8/3 ~ 8/17）把一款決定開放原始碼的網頁遊戲，從無法啟動到恢復伺服器開始運作的一些經驗跟大家分享。&lt;br&gt;不過看起來還是有很多人沒有機會來聽，雖然之後因為會把一部分重心放在這款遊戲上，所以應該還是有不少機會，但還是簡單的來彙整一下今天講的東西。&lt;/p&gt;&lt;p&gt;上一篇&lt;a href=&quot;https://blog.frost.tw/posts/2019/08/04/Fast-review-the-Unlight-game-s-source-code/&quot;&gt;快速閱讀 Unlight 原始碼&lt;/a&gt;大致上有提到了我在當時看到原始碼的看法跟概觀。有興趣的話可以搭配&lt;a href=&quot;https://speakerdeck.com/elct9620/2019-coscup-fu-huo-ge-browser-game-unlight-kai-yuan-shi-jian&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;演講簡報&lt;/a&gt;一起讀這篇文章。&lt;/p&gt;&lt;p&gt;另外，這次整個遊戲運作起來除了我自己本身對 Ruby / ActionScript 有一定的了解外，也要感謝一下我們這個團隊（&lt;a href=&quot;https://unlight.app&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Open Unlight&lt;/a&gt;）的初期成員 Poka 和舞鶴，給我硬體上的支援跟對其他玩家的客服支援，不然有時候真的很難同時處理這些事情。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>在 <a href="https://coscup.org/2019/" rel="external nofollow noopener noreferrer" target="_blank">COSCUP</a> 分享了這兩週左右（8/3 ~ 8/17）把一款決定開放原始碼的網頁遊戲，從無法啟動到恢復伺服器開始運作的一些經驗跟大家分享。<br>不過看起來還是有很多人沒有機會來聽，雖然之後因為會把一部分重心放在這款遊戲上，所以應該還是有不少機會，但還是簡單的來彙整一下今天講的東西。</p><p>上一篇<a href="https://blog.frost.tw/posts/2019/08/04/Fast-review-the-Unlight-game-s-source-code/">快速閱讀 Unlight 原始碼</a>大致上有提到了我在當時看到原始碼的看法跟概觀。有興趣的話可以搭配<a href="https://speakerdeck.com/elct9620/2019-coscup-fu-huo-ge-browser-game-unlight-kai-yuan-shi-jian" rel="external nofollow noopener noreferrer" target="_blank">演講簡報</a>一起讀這篇文章。</p><p>另外，這次整個遊戲運作起來除了我自己本身對 Ruby / ActionScript 有一定的了解外，也要感謝一下我們這個團隊（<a href="https://unlight.app" rel="external nofollow noopener noreferrer" target="_blank">Open Unlight</a>）的初期成員 Poka 和舞鶴，給我硬體上的支援跟對其他玩家的客服支援，不然有時候真的很難同時處理這些事情。</p><a id="more"></a><h2 id="動機"><a href="#動機" class="headerlink" title="動機"></a>動機</h2><p>最開始只是我想自己研究，主要是這幾點原因在。</p><p>第一點是日本的遊戲公司很少會放出原始碼，至少以現在很熱門的手遊大家幾乎是沒機會看到開放原始碼的專案，不過即使是歐美也是，所以變得很難有機會學習怎麼做。<br>第二點則是因為他用了 Ruby 和 ActionScript 這兩個語言，前者是我工作用的語言也是我個人很喜歡的語言，後者是我大學寫過一陣子的語言，兩個我都蠻熟悉的。</p><p>後來發現伺服器用 DigitalOcean<br>沒辦法支撐後，朋友 Poka 就把家裡閒置的機器拉出來提供給我使用，所以又再加上把一些工作上很少有機會用到的理論套上去，因為玩家數夠多了！</p><blockquote><p>注意：不是每個朋友家裡都剛好會有空的機櫃、伺服器跟有冷氣的機房！</p></blockquote><h2 id="復原"><a href="#復原" class="headerlink" title="復原"></a>復原</h2><p><img src="https://blog.frost.tw/images/2019-09-03-coscup-2019-talk-about-the-browser-game-unlight-which-i-revived-it/screenshot.png" alt="遊戲畫面"></p><p>其實伺服器部分本身沒有什麼大問題，基本上就是缺幾個檔案。不過這些檔案只是被改成 <code>_orig</code> 的形式，把檔名改回去後就好了，基本上是一些設定檔像是伺服器的 IP 位置、資料庫設定等等。</p><p>至於 Flash 客戶端的部分，因為想說是 Flash 所以就跑去想把 Flash IDE 裝回來，畢竟一般來說都是靠 IDE 來處理的。不過因為看起來像是用 Flex 就選擇安裝 Flash Builder 來跑，結果就直接噴出 <code>Failed to create Java Virtual Machine</code> 的錯誤，這是因為新版的 macOS 用的 Java 已經新太多。</p><p>而且 Adobe 還把這些 IDE 都下架，所以光是想要取得就有不少困難在。</p><p>不過因為是用 Flex 所以還有 Flex SDK 可以替代，至少能用 Command Line 的方式去編譯，結果當時（週五晚上）由 CPA 釋出的原始碼裡面缺少了最重要的 <code>src/</code> 目錄，也就是客戶端本體的實作部分。<br>大概過了兩天，到週一的時候才發現少上傳補上到 GitHub 上面，此時就能透過 <code>mxmlc</code> 這個指令去編譯。</p><blockquote><p>回頭來看，我們會認為 Flash 就是用 IDE 用 GUI 去寫這個專案，但其實 Unlight 幾乎是直接用 ActionScript 寫的，除了美術的部分合理推測會使用 Flash 的 IDE 之外，其實遊戲本身大概是沒有使用的。</p></blockquote><h3 id="缺少的-as-檔案"><a href="#缺少的-as-檔案" class="headerlink" title="缺少的 as 檔案"></a>缺少的 as 檔案</h3><p>不過即使取得了完整原始碼，還是發現這樣子還是有缺檔案的樣子。經過追查之後，發現缺少的 <code>FontLoader.as</code> 和 <code>Constants.as</code> 應該都是由 Ruby 的腳本生成。</p><p>所以找了一下，發現在伺服器端確實有腳本需要執行過才能正常生成客戶端。</p><p><code>Constants.as</code> - 一些文本資料或不影響平衡的都可以塞到客戶端，這個檔案基本上應該就是將 DB 的資料直接整到客戶端的主要方式。<br><code>FontLoader.as</code> - Unlight 當時算是非常熱門的遊戲，所以至少有五到六種語言的翻譯，為了遊戲美術表現的品質所以會把字體內嵌，因此會使用 Ruby 負責掃瞄出這個語言客戶端所需的 Unicode 來告訴 Flex Compiler 需要內嵌哪些字體檔案。</p><blockquote><p>基本上是蠻合理的設計，不過因為我們大部分都是做 Web 習慣的，可能會不太理解吧 XD</p></blockquote><h3 id="語言切換"><a href="#語言切換" class="headerlink" title="語言切換"></a>語言切換</h3><p>令一方面因為多國語言，所以其實有很多 <code>.swf</code> 檔案都會用像是 <code>_tc.swf</code> <code>_ja.swf</code> 這樣的形式命名，假設原始檔案叫做 <code>tutorial.swf</code> 的話，一開始是不會有這個檔案的，因為你需要利用一個叫做 <code>switch_resouce.rb</code> 的檔案，幫你從 <code>tutorial_tc.swf</code> 重新命名成 <code>tutorial.swf</code> 才行。</p><p>但是因為他是用 Git 的方式讓大家下載的，所以最後就會讓整個 Repo 裡面充滿各種沒有被追蹤的檔案，也會非常混亂。</p><blockquote><p>除此之外部署的時候如果沒有切換的話，在遊戲過程中還會因為抓不到對應的 swf 造成許多地方無法正常運作。</p></blockquote><h2 id="Docker-化"><a href="#Docker-化" class="headerlink" title="Docker 化"></a>Docker 化</h2><p>基於前面這些編譯客戶端的問題，最簡單的方法就是用 Docker 來處理。另一方面就是要部署起來其實需要不少額外的補丁，而這些處理目前是否能 PR 回官方的版本，或者直接修改維護都還是問題。雖然 Docker 不是一個萬用的解決方案，但是在想要有一個乾淨的編譯環境來說，反而是一個相對適合的做法。</p><p>在編譯客戶端的時候，只需要將圖檔這些東西都複製進去 Docker 裡面，然後將前面設定 Java 環境（Flex 是基於 Java）、Flex SDK 設定以及各種補丁和我自己修改過的檔案，全部加入到容器裡面，再用做一次性的編譯環境就可以很方便的產生客戶端。</p><blockquote><p>某方面來說可以用時間換來一定程度相對乾淨的專案環境</p></blockquote><p>令一方面因為 Unlight 的設計很適合讓思考 SOA / Microservice 之類的架構設計思考方式，因為它將登入伺服器、任務伺服器等等都切割開來，所以要部署伺服器起來其實也要做不少動作，但假設我們使用 Docker Compose 的話，就可以透過設定檔去解決這些問題。</p><h2 id="登入失敗"><a href="#登入失敗" class="headerlink" title="登入失敗"></a>登入失敗</h2><p>經過幾天的努力總算是有能執行的客戶端以及可以運行的伺服器，不過在修復客戶端時使用了網路上下載的 <code>as3crypto.swc</code> 這個套件，結果卻一直無法登入。</p><blockquote><p>理論上加密演算法不應該不一樣，但是因為各種理由使用 CPA 後來（一週後）提供的檔案，就能正成使用。</p></blockquote><p>Unlight 使用了一個叫做 <strong>Secure Remote Passwor</strong> 的機制，在做簡報的時候發現他的實作裡面有一個叫做 OpenSSL 所以還蠻好懂的，我們在開發網站很熟悉的 SSL 憑證基本上也基於這個 <a href="http://srp.stanford.edu/design.html" rel="external nofollow noopener noreferrer" target="_blank">Stanford 的論文</a>來實現的，不過中間遭遇了很多問題。</p><p>因為遊戲使用的是「論文版本」也就是完全參照論文去實現，但是網路上像是 1Password 的 Golang 版本或者 Mozilla 的 Node.js 版本，都是基於 RFC5054 的版本差異上來說就是 Salt 在客戶端的先後順序。</p><p>論文版本是由客戶端先發送 Public Key 到伺服器換取 Salt 跟伺服器的 Public Key 在繼續後面的運算，但是 RFC 版本使用的則是客戶端先發送請求初始化連線，再從伺服器拿到 Public Key 和 Salt 這些資訊，最後再生成 Public Key 發給伺服器後做後續的運算。</p><p>兩個版本順序剛好是相反的，也讓我很難用其他語言實作來驗證看看。</p><blockquote><p>其實 RFC 還有其他版本，不過目前主流的應該是 RFC5054 的這個版本。另外還有一個好處是當伺服器更改了計算的基準（N, g）的時候，因為伺服器發回來的也包含這兩個數值，所以就不需要修改客戶端，至少在安全性跟方便性都有所提高。</p></blockquote><h2 id="效能調校"><a href="#效能調校" class="headerlink" title="效能調校"></a>效能調校</h2><p>因為 Poka 支援了伺服器，所以我們實際上是有 24 Core &amp; 24G RAM 的伺服器，連硬碟都是用有著 98K IOPS 的 SSD 理論上是不應該卡頓的⋯⋯</p><p>不過根據我前兩天在 Digital Ocean 用 $5 和 $15 的機器測試的狀況，大概是 60 人跟 300 人會明顯卡頓，但是換到了 Poka 的機器上硬體至少提升了有十幾倍，卻還是卡在 500 多人就很不合理。</p><p>中間我們做了很多嘗試，像是利用 Docker 可以限制使用的 CPU 核心之類的設定將 DB 集中在某個 CPU 上之類，還有調整記憶體限制等等，最後才發現了一筆異常的數值。</p><p>因為 SSD 的關係遊戲每個 SQL 操作大概是在 0.0001s 左右，但是有一個很頻繁的 SQL 操作大概花上 0.2s 左右經過補上 Index 的處理後，遊戲直接達到 1000 人左右都不卡頓的狀況。</p><blockquote><p>當時有玩家還在猜該不會當初遊戲公司死掉也跟這個少掉的 Index 有關吧？不過理論上以當時的玩家數量，不太可能少處理這點。</p></blockquote><p>就我跟 Poka 的評估，目前使用的伺服器即使到了 3000 多人也應該能支撐住才對。不過到了最近玩家人數開始穩定的減少，推測差不多應該會停在一個負擔不太大的數值上吧 XD</p><blockquote><p>畢竟很多玩家都是來懷舊的⋯⋯</p></blockquote><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>雖然已經盡量寫的簡單，但是似乎文章還是有點太長 XD</p><p>下一篇會再聊一下後續的處理，也就是經過我修改過的 Docker 版本提供了選擇性客製化的功能以及我們怎麼在經營遊戲上處理盡量讓玩家有一個相對好的體驗、以及對 HTML5 化的規劃跟實驗。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2019/09/03/COSCUP-2019-Talk-about-the-browser-game-Unlight-which-I-revived-it/#disqus_thread</comments>
    </item>
    
    <item>
      <title>快速閱讀頁遊 Unlight 開源後的原始碼</title>
      <link>https://blog.frost.tw/posts/2019/08/04/Fast-review-the-Unlight-game-s-source-code/</link>
      <guid>https://blog.frost.tw/posts/2019/08/04/Fast-review-the-Unlight-game-s-source-code/</guid>
      <pubDate>Sun, 04 Aug 2019 10:44:09 GMT</pubDate>
      <description>
      
        &lt;p&gt;最近一款有點年紀的頁遊 &lt;a href=&quot;https://zh.wikipedia.org/zh-tw/Unlight&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Unlight&lt;/a&gt; 在停止營運後幾年，突然公佈說要開放原始碼跟圖片素材。&lt;/p&gt;&lt;p&gt;這款遊戲嚴格說起來並沒有像我們熟悉的端遊、手遊之類的那樣華麗，但是非常有特色的人物設計跟對戰系統倒是讓很多玩家即使在好幾年後仍然在期待他能復活。&lt;/p&gt;&lt;p&gt;作為一個曾經的玩家，其實也是非常期待的，不過這次的開放原始碼路線大概是復活無望。不過從這幾天公開的資料來看，圖片、音效到客戶端和伺服端都公開的狀況下，還是很有希望被熱血的玩家復活的。&lt;/p&gt;&lt;p&gt;另一方面，既然伺服器是透過 Ruby 撰寫的，身為使用 Ruby 的開發者在遊戲類應用不常見的狀況下，能可以作為學習素材肯定是要看過一遍的。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>最近一款有點年紀的頁遊 <a href="https://zh.wikipedia.org/zh-tw/Unlight" rel="external nofollow noopener noreferrer" target="_blank">Unlight</a> 在停止營運後幾年，突然公佈說要開放原始碼跟圖片素材。</p><p>這款遊戲嚴格說起來並沒有像我們熟悉的端遊、手遊之類的那樣華麗，但是非常有特色的人物設計跟對戰系統倒是讓很多玩家即使在好幾年後仍然在期待他能復活。</p><p>作為一個曾經的玩家，其實也是非常期待的，不過這次的開放原始碼路線大概是復活無望。不過從這幾天公開的資料來看，圖片、音效到客戶端和伺服端都公開的狀況下，還是很有希望被熱血的玩家復活的。</p><p>另一方面，既然伺服器是透過 Ruby 撰寫的，身為使用 Ruby 的開發者在遊戲類應用不常見的狀況下，能可以作為學習素材肯定是要看過一遍的。</p><a id="more"></a><h2 id="概觀"><a href="#概觀" class="headerlink" title="概觀"></a>概觀</h2><p>大概是在七月底的時候 Unlight 的 <a href="https://unlight-world.com" rel="external nofollow noopener noreferrer" target="_blank">官網</a> 突然復活，並且出現了一些開放素材的資訊。大約在昨天半夜（8/3 ~ 8/4）有人貼出了 <a href="https://github.com/unlightcpa" rel="external nofollow noopener noreferrer" target="_blank">Unlight 的 GitHub</a> 就此大家就開始期待是否有人能夠將他重建出來。</p><p>開始使用之前，需要先確認授權的形式。</p><ul><li>原始碼 - MIT 授權</li><li>素材（圖片、音樂）- CC BY-ND 4.0</li></ul><p>以原始碼來說基本上算是可以自由使用跟修改，算是很寬鬆的條款。而圖片素材部分則是需要註明作者，主要受限的地方是「禁止改作」的部分，因為目前釋出的檔案大多以 SWF 為主（裡面含有一些動畫檔案）所以如果想要抽取出圖片後修改為適合手遊、HTML5 的應用時，是否不會跟授權牴觸就是需要注意的部分。</p><h2 id="架構、語言"><a href="#架構、語言" class="headerlink" title="架構、語言"></a>架構、語言</h2><p>原始碼部分包含了 <a href="https://zh.wikipedia.org/zh-tw/ActionScript" rel="external nofollow noopener noreferrer" target="_blank">ActionScript 3.0</a> 和 <a href="https://www.ruby-lang.org/zh_tw/" rel="external nofollow noopener noreferrer" target="_blank">Ruby</a> 兩個部分，AS3 的部分主要是用於客戶端，而 Ruby 則是提供伺服器。</p><blockquote><p>考慮到 Unlight 的時代背景，採用 Flash + Ruby 的方式其實跟目前大家熟悉的 HTML5 頁遊是比較不一樣的，他比較接近於端遊的類型在伺服器和客戶端之間溝通，網頁部分可以視為下載客戶端的載體。</p></blockquote><p>客戶端部分目前推測「缺少非常多檔案」因為看起來有使用一些第三方的套件，官方也沒有提供任何文件說明，所以看起來是暫時無法「產出客戶端」的情況。而伺服端就看起來比較容易設定起來，至少有 <code>Gemfile</code> 描述了需要安裝的 Ruby 套件，可以輕鬆的設定起來。</p><h2 id="客戶端"><a href="#客戶端" class="headerlink" title="客戶端"></a>客戶端</h2><p>目前從 <code>app/client</code> 目錄下看到的資訊來看，是一些原始的 ActionScript 原始碼，但是假設要編譯的話基本上會需要透過像是 <a href="https://zh.wikipedia.org/zh-tw/Adobe_Flash_Builder" rel="external nofollow noopener noreferrer" target="_blank">Flash Builder</a> 或者 <a href="https://www.adobe.com/devnet/flex/flex-sdk-download.html" rel="external nofollow noopener noreferrer" target="_blank">Flex SDK</a> 來做編譯，但是前者目前基本上是無法正常取得（可以透過 Creative Cloud 的知識庫找到載點）後者雖然可以取得，但是只能編譯單個 ActionScript 檔案。</p><p>但是目錄下目前並沒有關於如何編譯的說明，唯一知道的是在 GitHub 上的 <a href="https://github.com/unlightcpa/Unlight/issues/2" rel="external nofollow noopener noreferrer" target="_blank">Issue</a>（推測是原作者）表示無法在比較新版的 Flex 編譯，不過實際上要怎麼編譯還是未知的。</p><blockquote><p>我在我自己的 macOS 上安裝了 Flash Builder 但是 Java 版本已經過新無法啟動，網路上提供的手動指定 JVM 路徑的方式也無法正常開啟，網路上有一個說法是透過 Flash Builder 打開專案之後就能夠自動編譯。</p></blockquote><p>另外一個疑點是 Client 端裡面的檔案，像是 <code>Config.as</code> 或者 <code>News.as</code> 這類檔案，都可以看到讀取某些 XML 設定檔的資訊，像是下面這段節錄。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> <span class="keyword">extends</span> <span class="title">XMLData</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">const</span> _TRANS_CONFIG_URL:String = <span class="string">"/public/config.xml"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">const</span> __URL:String = _TRANS_CONFIG_URL</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">const</span> __VERSION:String = <span class="string">"multi_servers_111003"</span></span><br></pre></td></tr></table></figure><p>這些檔案我們都會看到像是 <code>import flash.net.URLRequest;</code> 的片段，明顯是用來抓取某些資料的，不過目前卻不知道這些 XML 資料需要提供哪些資訊，以及似乎沒有實際呼叫的地方，表示可能有一些行為是還未完善的。</p><blockquote><p>在寫這篇文章時發現是從 <code>XMLData</code> 繼承來的，不過即使能夠呼叫並讀取設定檔等資訊，實際上要怎麼運行還是個問題。</p></blockquote><p>另一方面是在伺服器端（待會會提到）的地方有設計一個加密機制，玩家跟伺服器交換資料的時候是會經過加密的（保護及防止作弊）而實際上玩家的每一個動作都會被轉會成 Command（指令）的概念去跟伺服器互動，但是目前在客戶端裡面找不到任何編碼指令的程式碼。</p><blockquote><p>前面提到 Unlight 比較類似傳統端遊的做法是因為他不是透過 HTTP 請求（網頁）的方式連線，而是直接透過 TCP 連線對伺服器連線後互動，考慮這種方式在 Flash 遊戲還盛行的時期，還算是合理且常見的作法。</p></blockquote><p>另外就是客戶端理論上要有讀取前面素材包裡面的 SWF 檔案的片段，目前看起來也暫時還沒有發現是在哪裡定義的（也可能是透過使用的外部套件）</p><h3 id="伺服端"><a href="#伺服端" class="headerlink" title="伺服端"></a>伺服端</h3><p>這部分算是我比較熟悉的部分，目前工作大部分時間都是使用 Ruby 來開發，所以把它跑起來算是相對客戶端輕鬆的。</p><p>先看 <code>Gemfile</code> 這個檔案，我們可以大概知道他使用了哪些技術（從目錄結構上可以馬上判斷出不是採用 Ruby on Rails 開發的）</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">source <span class="symbol">:rubygems</span></span><br><span class="line">gem <span class="string">'dalli'</span>, <span class="string">'~&gt;2.0.2'</span></span><br><span class="line">gem <span class="string">'eventmachine'</span></span><br><span class="line">gem <span class="string">'mysql2'</span>,<span class="string">'~&gt;0.3.7'</span></span><br><span class="line">gem <span class="string">'oauth'</span>,<span class="string">'~&gt;0.4.5'</span></span><br><span class="line">gem <span class="string">'RocketAMF'</span>,<span class="string">'~&gt;0.2.1'</span></span><br><span class="line">gem <span class="string">'rspec'</span>,<span class="string">'~&gt;2.11.0'</span></span><br><span class="line">gem <span class="string">'sequel'</span>,<span class="string">'~&gt;4.0'</span></span><br><span class="line">gem <span class="string">'RubyInline'</span>,<span class="string">'~&gt;3.12.4'</span></span><br><span class="line">gem <span class="string">'sqlite3'</span>,<span class="string">'~&gt;1.3.11'</span></span><br><span class="line">gem <span class="string">'daemons'</span></span><br><span class="line">gem <span class="string">'gmp'</span></span><br></pre></td></tr></table></figure><p>寫法上來說很明顯是相對舊版本的 Ruby 所開發的，不過 Ruby 核心團隊對於「向下相容性」的堅持，我們使用較新的 Ruby 2.6.3 都還是能正常使用。</p><p>裡面大概可以看出來使用了 Memcached / MySQL / OAuth 等技術，實際上用的第三方套件不多，這點我個人就蠻佩服日本的遊戲開發者，他們在這類技術上都是很扎實的一點一點製作出來。</p><blockquote><p>不過以比較商業的角度上來看，善用套件是很有用的，有不少日本手遊公司都是使用 Ruby on Rails 來開發。不過礙於遊戲相關的程式碼在技術圈是相對封閉的，所以很多時候都會依賴很多電腦科學的基礎知識來架構出遊戲。</p></blockquote><p>因為是快速導讀，所以就不贅述這些套件的應用。從 <code>Gemfile</code> 我們是可以大致上看出來使用的資料庫、優化技術跟串些的應用（Ex. OAuth 大概是跟當年跑在 Facebook 上用來串接的機制有關）</p><p>接下來看一下目錄結構</p><ul><li><code>bin/</code> - 各種啟動伺服器的指令</li><li><code>data/</code> - 遊戲的資料（伺服器的紀錄檔也會在這）</li><li><code>db/</code> - 空的，根據原始碼的說明使用 <code>csv</code> 模式當資料庫會放在這</li><li><code>lib/</code> - 空的，專案中有一些計算是利用 C 輔助的，他會在執行時產生一些 C 相關的檔案置入</li><li><code>script/</code> - 一些輔助腳本，像是匯入遊戲資料（Ex. 道具、角色素質等）</li><li><code>src/</code> - 伺服器的本體</li></ul><p>一般來說我會先找可以描述整個資料結構的目錄看，所以先稍微看了一下 <code>data/</code> 和 <code>src/model</code> 兩個目錄，裡面大致上就是描述了 Unlight 這款遊戲是怎樣做數值設定跟紀錄玩家的操作，根據我工作的經驗設計的好壞其實很大的影響整個系統的穩定和維護，另外最重要的是這是最快可以大致瞭解作者想法的方式。</p><h2 id="目錄：bin"><a href="#目錄：bin" class="headerlink" title="目錄：bin/"></a>目錄：bin/</h2><p>裡面看起來很多檔案，但是不要被嚇到，大部分的檔案機制都是類似的。會這樣設定可能是方便在不同伺服器上面開設不同的服務，或者做簡易的分流用的。</p><blockquote><p>印象中當時停止營運的時候我有用當時負責的客戶（手遊公司）的營運花費，用等比例的方式推算 Unlight 的遊戲規模，大概推算是一個月營運大概會是花費 100 ~ 200 萬台幣左右，這個目錄下大概有 100 個檔案左右，假設每個檔案都是獨立一台伺服器我們用 <a href="https://aws.amazon.com/tw/" rel="external nofollow noopener noreferrer" target="_blank">Amazon AWS</a> 上面的雲端伺服器數字非常不精確的推算一下，用一般正式伺服器可能會選用的 m 系列機器的 m4.large 規格，大概會花到 20 萬左用（<a href="https://calculator.s3.amazonaws.com/index.html?nc2=h_ql_pr#r=NRT&s=EC2&key=files/calc-8d0494a1ee2ae3d0f1a990397358bd3f1e581769&v=ver20190731tO" rel="external nofollow noopener noreferrer" target="_blank">試算</a>）這可能還不包過資料庫、當時的伺服器單價相對高等問題，加上人事跟營運成本，一個月營運的花費確實有機會接近到 100 萬台幣。</p></blockquote><p>那麼這些檔案內容是怎樣的，我們用登入伺服器（<code>authserver</code>）這個檔案看看。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/local/bin/ruby</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'rubygems'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'daemons'</span></span><br><span class="line">  options = &#123; </span><br><span class="line">    <span class="symbol">:app_name</span>   =&gt; <span class="string">"ul_authserver"</span>,</span><br><span class="line">    <span class="symbol">:dir_mode</span>   =&gt; <span class="symbol">:normal</span>,</span><br><span class="line">    <span class="symbol">:dir</span>        =&gt; <span class="string">'pids'</span>,</span><br><span class="line">    <span class="symbol">:backtrace</span>  =&gt; <span class="literal">true</span>,</span><br><span class="line"><span class="comment">#     :monitor    =&gt; true,</span></span><br><span class="line">    <span class="symbol">:log_output</span>    =&gt; <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">f =  File.join(File.expand_path(__FILE_<span class="number">_</span>).gsub!(<span class="string">"/bin/authserver"</span>,<span class="string">""</span>), <span class="string">"/src"</span>)</span><br><span class="line">Dir.chdir(File.join(File.expand_path(__FILE_<span class="number">_</span>).gsub!(<span class="string">"authserver"</span>,<span class="string">""</span>)))</span><br><span class="line">Daemons.run(<span class="string">"<span class="subst">#&#123;f&#125;</span>/authentication.rb"</span>,options)</span><br></pre></td></tr></table></figure><p>基本上結構的規則都是差不多的，提供這個伺服器的基本設定，然後用 <code>Daemons</code> 這個套件把伺服器啟動（常駐執行）而執行的檔案就是裡面指定的像是 <code>authentication.rb</code> 這些檔案，等一下我們會再討論 <code>src/</code> 目錄時一起看。</p><h2 id="目錄：script"><a href="#目錄：script" class="headerlink" title="目錄：script/"></a>目錄：script/</h2><p>我們把非程式的部分跳過，因為那些都是一些數據資料，雖然人類直接閱讀會有點吃力。但是習慣之後還是能閱讀的部分，大多數遊戲公司的企劃應該都有能力閱讀和修改。</p><p>這部分主要是維運需要的的腳本，因為比較雜亂就不特別討論，我們稍微看一下 <code>import_csv_data.rb</code> 這個檔案，假設我們想要將遊戲設定起來，就需要將 <code>data/</code> 目錄下面的遊戲資料匯入，就會需要呼叫這個檔案。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">`pwd`</span>.chomp == <span class="string">"/home/unlight/svn/trunk/app/server"</span></span><br><span class="line">  puts <span class="string">"このスクリプトはここで使用してはいけません"</span></span><br><span class="line">  exit</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">opt = OptionParser.new</span><br><span class="line"></span><br><span class="line">$VER_OVERWRITE = <span class="literal">false</span></span><br><span class="line">$VER_NUMBERING = <span class="literal">false</span></span><br><span class="line">$VER_RESTART = <span class="literal">false</span></span><br><span class="line">over_text = <span class="string">"（ドロップモード：すべて捨てて作り直します。時間がかかりますが正確です ）"</span></span><br><span class="line">opt.on(<span class="string">'-n'</span>, <span class="string">'--numbering'</span>) &#123;<span class="params">|v|</span></span><br><span class="line">  $VER_NUMBERING = <span class="literal">true</span></span><br><span class="line">  over_text = <span class="string">"（ナンバリングモード：数値で指定されたファイルのみ更新します）"</span></span><br><span class="line">&#125;</span><br><span class="line">opt.on(<span class="string">'-r'</span>, <span class="string">'--restart'</span>) &#123;<span class="params">|v|</span></span><br><span class="line">  $VER_RESTART = <span class="literal">true</span></span><br><span class="line">  over_text = <span class="string">"（再開モード：数値で指定されたファイル以降を更新します）"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">opt.parse!(ARGV)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> $VER_NUMBERING &amp;&amp; $VER_RESTART</span><br><span class="line">  puts <span class="string">"Option n, r は同時に指定出来ません。"</span></span><br><span class="line">  exit</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">$arg = ARGV.shift</span><br><span class="line">puts <span class="string">"serverに存在するcsvdataでインポートしますか (sb)"</span>+over_text</span><br><span class="line">$arg = gets.chomp</span><br><span class="line">@m_set = []</span><br><span class="line">LANGUAGE_SET = <span class="regexp">/_tcn$|_en$|_scn$|_kr$|_fr$|_ina$|_thai$/</span></span><br><span class="line">MESSAGES=&#123; <span class="string">"sb"</span> =&gt; <span class="string">"SandBox"</span>&#125;</span><br><span class="line">DATABASES=&#123;</span><br><span class="line">  <span class="string">"192.168.1.14:5001"</span>=&gt;<span class="string">"SandBox"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面這段主要只是一些讀取匯入設定相關的資訊，我在試跑的時候遇到的問題其實是說明跟描述都不太明確，反而沒有搞懂操作，之後詳細閱讀之後再細看。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csv_import</span><span class="params">(dir, local)</span></span></span><br><span class="line"></span><br><span class="line">  Find.find(<span class="string">'./data/csv'</span>) <span class="keyword">do</span> <span class="params">|f|</span></span><br><span class="line">    <span class="keyword">next</span> <span class="keyword">if</span> File.directory?(f)</span><br><span class="line">  <span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>這段就是匯入的本體，會將檔案找出來後匯入，基本上匯入程式大多大同小異就是了⋯⋯</p><blockquote><p><code>script/</code> 目錄下的東西大多很雜，其實也不會試運行伺服器馬上會需要的部分，實際上可以先略過，除了匯入資料的部分。不過經過測試發現過程中會呼叫某個方法，而這個方法目前是找不到的，這也表示有可能除了匯入會失敗之外，遊戲運行在某些情況下也會失敗。</p></blockquote><h2 id="目錄：src"><a href="#目錄：src" class="headerlink" title="目錄：src/"></a>目錄：src/</h2><p>這個目錄下還有不少資料夾，我們可以稍微看一下</p><ul><li><code>constants/</code> - 遊戲中的常數，也就是一些固定的數值（Ex. 新手任務的編號）</li><li><code>controller/</code> - 遊戲的控制器，目前還不確定用途，不過主要是跟玩家操作有關（Ex. 發送聊天訊息）</li><li><code>model/</code> - 遊戲資料的處理程式，用來讀取玩家、怪物等資料，以及數值的更新（Ex. 等級提升）</li><li><code>net/</code> - 伺服器跟客戶端溝通的機制，基本上只是處理一段加密的操作</li><li><code>protocol/</code> - 伺服器的本體，裡面定義了各種類型的伺服器 Ex. 登入伺服器、戰鬥伺服器等</li><li><code>rule/</code> - 遊戲的規則，基本上是描述一些像是 AI、抽卡的機制</li></ul><p>基本上蠻多檔案內容都蠻多的，這邊只簡單介紹伺服器啟動的部分（目前有讀的部分）</p><p>基本上不管是哪種伺服器，都會繼承 <code>Unlight</code> 這個物件（<code>src/protocol/unlight.rb</code>）</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Unlight</span></span></span><br><span class="line">  <span class="class"><span class="keyword">module</span> <span class="title">Protocol</span></span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ULServer</span> &lt; EventMachine::Connection</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># これ以上前に反応していなかった切る</span></span><br><span class="line">      CONNECT_LIVE_SEC = <span class="number">3600</span>   <span class="comment"># 1時間</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 何回のコマンドエラーで切断するか</span></span><br><span class="line">      COMMAND_ERROR_MAX = <span class="number">3</span>   <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">attr_accessor</span> <span class="symbol">:player</span>,<span class="symbol">:last_connect</span></span><br><span class="line">      <span class="comment"># クラスの初期化</span></span><br></pre></td></tr></table></figure><p>Unlight 使用的是當時 Ruby 用來做一些連線機制常用的 <code>EventMachine</code> 套件，所以會直接繼承 <code>EventMachine::Connection</code> 實作，基本上是為了借用 EventMachine 的一些機制。</p><blockquote><p>因為筆者本身沒有使用 EventMachine 所以無法太詳細描述，不過以當時的時間點來看，使用 EventMachine 是一個很不錯的選擇，因為能負擔的玩家數量是遠比其他方式更高，而且也更好用。</p></blockquote><p>在 <code>unlight.rb</code> 檔案中會看到這段</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># データの受信</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receive_data</span> <span class="title">data</span></span></span><br><span class="line">  a = data2command(data)</span><br><span class="line">  @command_list += a <span class="keyword">unless</span> a.empty?</span><br><span class="line">  do_command</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>簡單說不管是哪種伺服器，在收到資料後會做一個「解碼」的動作將客戶端傳輸的指令（Command）轉換成像是 <code>[:register, &#39;xxx@example.com&#39;, &#39;Aotoki&#39;]</code> 的格式，再由不同伺服器（Ex. AuthServer）來處理。</p><p>我們在看到 <code>src/</code> 目錄下的這些 Ruby 檔案，其實大多是將前面提到的 <code>EventMachine</code> 啟動的部分（也就是前面 <code>bin/</code> 呼叫的檔案）以「大廳（Lobby）」這個檔案為例子（<code>src/lobby.rb</code>）</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Unlight</span></span></span><br><span class="line">  <span class="keyword">include</span> Protocol</span><br><span class="line"></span><br><span class="line">  port = <span class="number">12002</span></span><br><span class="line">  EM.set_descriptor_table_size(<span class="number">10000</span>) <span class="comment"># ソケットMaxを設定</span></span><br><span class="line">  EM.epoll                            <span class="comment"># Epollを使用するように設定。</span></span><br><span class="line">  EM.run <span class="keyword">do</span></span><br><span class="line">    LobbyServer.setup</span><br><span class="line">    EM.start_server <span class="string">"0.0.0.0"</span>, SV_PORT, LobbyServer</span><br><span class="line">    SERVER_LOG.info(<span class="string">"LobbyServer Start: port[<span class="subst">#&#123;SV_PORT&#125;</span>]"</span>)</span><br><span class="line">    <span class="comment"># タイマの制度を上げる</span></span><br><span class="line">    EM.set_quantum(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1分に一回でソケットの生き死にをチェック</span></span><br><span class="line">    EM::PeriodicTimer.new(<span class="number">60</span>, proc &#123;</span><br><span class="line">                            <span class="keyword">begin</span></span><br><span class="line">                              LobbyServer.check_connection</span><br><span class="line">                            <span class="keyword">rescue</span> =&gt;e</span><br><span class="line">                              SERVER_LOG.fatal(<span class="string">"LobbyServer: [check_connection:] fatal error <span class="subst">#&#123;e&#125;</span>:<span class="subst">#&#123;e.backtrace&#125;</span>"</span>)</span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                                   &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> DB_CONNECT_CHECK</span><br><span class="line">      <span class="comment"># 7時間に一回でDBとの接続をチェック</span></span><br><span class="line">      EM::PeriodicTimer.new(<span class="number">60</span>*<span class="number">60</span>*<span class="number">7</span>, proc &#123;</span><br><span class="line">                              <span class="keyword">begin</span></span><br><span class="line">                                LobbyServer.check_db_connection</span><br><span class="line">                              <span class="keyword">rescue</span> =&gt;e</span><br><span class="line">                                SERVER_LOG.fatal(<span class="string">"LobbyServer: [check_db_connection:] fatal error <span class="subst">#&#123;e&#125;</span>:<span class="subst">#&#123;e.backtrace&#125;</span>"</span>)</span><br><span class="line">                              <span class="keyword">end</span></span><br><span class="line">                            &#125;)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>這段就是將 EventMachine 跑起來，然後根據伺服器類型（Ex. LobbyServer）去做呼叫，並且執行對應的任務。</p><p>最後我們看一下 <code>src/net</code> 下面的檔案，裡面用了一個叫做 <a href="http://srp.stanford.edu/design.html" rel="external nofollow noopener noreferrer" target="_blank">SRP</a> 的演算法實作，他會用在登入伺服器的時候加密玩家的登入密碼，而其他一般指令則會用 <code>crypt.rb</code> 這個檔案做編碼處理，如果想要保護伺服器的互動避免外掛或者惡意玩家，可以嘗試改變這個檔案的計算機制。</p><h2 id="運作"><a href="#運作" class="headerlink" title="運作"></a>運作</h2><p>大致上看過一輪伺服器跟客戶端之後，我們來總結一下整個伺服器的運作。</p><ul><li><code>bin/authserver</code> =&gt; 啟動伺服器，呼叫 <code>authentication.rb</code> 等待連線</li><li><code>authentication.rb</code> =&gt; 等待連線，有資料的話透過 <code>AuthServer</code> 處理</li><li><code>AuthServer</code> =&gt; 收到操作後基於指令轉換為方法（一般定義在 Controller 裡面）</li><li>Controller =&gt; 根據指令執行動作，可能會呼叫 Model / Rule 協助處理</li><li><code>AuthServer</code> =&gt; 發送結果給玩家</li></ul><blockquote><p><code>AuthServer</code> 因為指令比較少所以沒有定義 Controller 但是像是 LobbyServer 之類的就有定義</p></blockquote><p>到此為止我們大致上對伺服端有一個概念，另外值得一提的是前面在看 <code>Gemfile</code> 看到的 <code>RocketAMF</code> 套件，似乎可以直接轉換 Ruby 的資料變成 Flash 可以讀取的格式，不過目前還暫時看不出來在哪裡有被使用，也可能是透過指令帶入給客戶端值些呼叫（類似伺服器的行為）</p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>雖然是很粗略的掃過一次原始碼，不過大致上對整個伺服器的運作已經有一個大致上的概念。回到現實面來看，以目前公開的資訊想要用現有的檔案去重新建置一個 Unlight 伺服器大概是蠻困難的，但是如果基於目前已知的程式跟運作，重新開發過一套有類似或者改進的系統，應該已經是有可能的。</p><p>跟單機遊戲不同的地方是連線遊戲為了保證公平性，需要將遊戲的規則判定都坐在伺服器上面，即使目前看起來不管是伺服端還是客戶端都有缺少部分檔案，但是整體上來說伺服器已經算是最接近完整的部分，至少大部分遊戲的邏輯跟機制都能夠被找到。</p><p>九月左右還有鐵人賽，最近應該會評估一下 30 天左右要寫什麼主題，也許基於 Unlight 的伺服器來討論開發遊戲伺服器會是個不錯的題目。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2019/08/04/Fast-review-the-Unlight-game-s-source-code/#disqus_thread</comments>
    </item>
    
    <item>
      <title>你大概沒機會遇到的 Bug - 跟 Ruby Committer 聊 Enumerator 跟 Fiber</title>
      <link>https://blog.frost.tw/posts/2019/07/30/Talk-with-the-Ruby-Committer-about-Enumerator-and-Fiber-the-bug-you-may-never-touch/</link>
      <guid>https://blog.frost.tw/posts/2019/07/30/Talk-with-the-Ruby-Committer-about-Enumerator-and-Fiber-the-bug-you-may-never-touch/</guid>
      <pubDate>Tue, 30 Jul 2019 06:11:31 GMT</pubDate>
      <description>
      
        &lt;p&gt;今年 &lt;a href=&quot;https://2019.rubyconf.tw/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;RubyConf Taiwan&lt;/a&gt; 嘗試辦了 After Hack 這個活動，也因此有機會可以跟 Ruby 語言的 Commiter 聊一些有趣的問題。&lt;/p&gt;&lt;p&gt;當天我的預定是把活動這幾天寫的 Gem 認真的補完測試，不過沒想到還剩下一個多小時就做完了，那就順便來思考一下 &lt;a href=&quot;https://tamashii.io&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Tamashii&lt;/a&gt; 專案能怎樣去改進，在今年的演講中大家應該都對 Fiber 有一個認識，而這個也許是一個不錯的選項。&lt;/p&gt;&lt;p&gt;所以就馬上去看了一下講者（Samuel）的 &lt;a href=&quot;https://github.com/socketry/async&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Async&lt;/a&gt; 這個 Gem 做了些什麼事情，因為剛講完關於 Enumerator 的演講，所以自然地看到了一段引起我興趣的說明。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Due to limitations within Ruby and the nature of this library, it is not possible to use to_enum on methods which invoke asynchronous behavior. We hope to fix this issue in the future.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;既然作者本人就在現場，而且 Issue 的內容也看不太出來發生什麼問題，那麼就直接問吧！&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>今年 <a href="https://2019.rubyconf.tw/" rel="external nofollow noopener noreferrer" target="_blank">RubyConf Taiwan</a> 嘗試辦了 After Hack 這個活動，也因此有機會可以跟 Ruby 語言的 Commiter 聊一些有趣的問題。</p><p>當天我的預定是把活動這幾天寫的 Gem 認真的補完測試，不過沒想到還剩下一個多小時就做完了，那就順便來思考一下 <a href="https://tamashii.io" rel="external nofollow noopener noreferrer" target="_blank">Tamashii</a> 專案能怎樣去改進，在今年的演講中大家應該都對 Fiber 有一個認識，而這個也許是一個不錯的選項。</p><p>所以就馬上去看了一下講者（Samuel）的 <a href="https://github.com/socketry/async" rel="external nofollow noopener noreferrer" target="_blank">Async</a> 這個 Gem 做了些什麼事情，因為剛講完關於 Enumerator 的演講，所以自然地看到了一段引起我興趣的說明。</p><blockquote><p>Due to limitations within Ruby and the nature of this library, it is not possible to use to_enum on methods which invoke asynchronous behavior. We hope to fix this issue in the future.</p></blockquote><p>既然作者本人就在現場，而且 Issue 的內容也看不太出來發生什麼問題，那麼就直接問吧！</p><a id="more"></a><h2 id="關於-Fiber"><a href="#關於-Fiber" class="headerlink" title="關於 Fiber"></a>關於 Fiber</h2><p>詳細的部分可以參考之前寫過的 <a href="https://blog.frost.tw/posts/2018/06/26/Talk-about-ruby-s-fiber-Part-1/">Fiber 簡介</a> 以下只做簡單的介紹方便跟上這篇文章的內容，另外因為這幾年很多語言都在努力的更新，雖然 Ruby 是一個相容性非常好的語言，但是還是有不少變化是隱含的。</p><blockquote><p>以文章中的 4K 堆疊為例，今年另一位講者（<a href="https://github.com/dsh0416" rel="external nofollow noopener noreferrer" target="_blank">Delton Ding</a>）在 <a href="https://twitter.com/DeltonDing/status/1155853101586214918" rel="external nofollow noopener noreferrer" target="_blank">Twitter</a> 提醒我這個特性在 2010 年和 2017 年都修改過，在 Ruby 2.5 之後的版本是不會產生，而改用指標的方式來處理。</p></blockquote><p>Fiber 機制用很簡單的方式說明，就是我們可以在單一的 Thread 下面，再做一次切割來切換執行順序。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f = Fiber.new <span class="keyword">do</span></span><br><span class="line">  <span class="comment"># A: 做某些事情</span></span><br><span class="line">  Fiber.<span class="keyword">yield</span> <span class="comment"># I/O Blocking 先跳出給其他人做事</span></span><br><span class="line">  <span class="comment"># B: 繼續做事情</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 執行 Fiber (A 區塊）</span></span><br><span class="line">f.resume</span><br><span class="line"><span class="comment"># 繼續執行（B 區塊）</span></span><br><span class="line">f.resume</span><br></pre></td></tr></table></figure><p>以前我們會需要用切分 Thread 的方式來對應 I/O Blocking 的情況，現在我們可以用一些 Non-Blocking 的操作來判斷是否有賭塞現象，進而控制執行的流程。</p><h2 id="Enumerator-中的-Fiber"><a href="#Enumerator-中的-Fiber" class="headerlink" title="Enumerator 中的 Fiber"></a>Enumerator 中的 Fiber</h2><p>今年我自己的演講主要是著重在 Enumerator 的生成與運作上，所以討論了 Ruby 能用哪些技巧去做到讓 <code>yield</code> 行為暫時不發生，以及讓某些動作能夠被「延遲（<code>#lazy</code>）」執行。</p><p>當我跟 Samuel 聊到這個 Enumerator 的 Bug 時候，我問了一句「Which ruby version this will happen?」得到的是「All versions」的解答，然後我馬上就知道這是我「沒有讀」的那一個部分，也就是關於 Enumerator 如何去迭代數值的部分。</p><blockquote><p>寫這篇文章的時候我再去看了一次 <code>enumerator.c</code> 裡面有出現 Fiber 的區段，基本上應該是有使用到 <code>#next</code> 的情況會發生，如果是一些 <code>#zip</code> 和 <code>#map</code> 的情況，因為不一定會去呼叫到 <code>#next</code> 就不會產生問題。</p></blockquote><p>那麼，到底是在哪裡產生了 Fiber 呢？</p><p><code>enumerator.c</code>（Ruby 2.6.2）裡面只有一個 <code>fiber_new</code> 我們照呼叫的順序去來追蹤，首先會看到 <code>enumerator_next</code> 這個實作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> VALUE</span><br><span class="line">enumerator_next(VALUE obj)</span><br><span class="line">&#123;</span><br><span class="line">    VALUE vs = enumerator_next_values(obj);</span><br><span class="line">    <span class="keyword">return</span> ary2sv(vs, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這邊會把 <code>enumerator_next_values</code> 回傳的數值找出第一個（如果是陣列）或者直接回傳，基本上就是把下一個元素找出來。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> VALUE</span><br><span class="line">enumerator_next_values(VALUE obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">enumerator</span> *<span class="title">e</span> = <span class="title">enumerator_ptr</span>(<span class="title">obj</span>);</span></span><br><span class="line">    VALUE vs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e-&gt;lookahead != Qundef) &#123;</span><br><span class="line">        vs = e-&gt;lookahead;</span><br><span class="line">        e-&gt;lookahead = Qundef;</span><br><span class="line">        <span class="keyword">return</span> vs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> get_next_values(obj, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然後這邊會拿當下作用的 Enumerator 來去找接下來會出現的數值，所以我們再繼續往下看到 <code>get_next_values</code> 這個方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> VALUE</span><br><span class="line">get_next_values(VALUE obj, struct enumerator *e)</span><br><span class="line">&#123;</span><br><span class="line">    VALUE curr, vs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e-&gt;stop_exc)</span><br><span class="line">      rb_exc_raise(e-&gt;stop_exc);</span><br><span class="line"></span><br><span class="line">    curr = rb_fiber_current();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!e-&gt;fib || !rb_fiber_alive_p(e-&gt;fib)) &#123;</span><br><span class="line">      next_init(obj, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vs = rb_fiber_resume(e-&gt;fib, <span class="number">1</span>, &amp;curr);</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;stop_exc) &#123;</span><br><span class="line">      e-&gt;fib = <span class="number">0</span>;</span><br><span class="line">      e-&gt;dst = Qnil;</span><br><span class="line">      e-&gt;lookahead = Qundef;</span><br><span class="line">      e-&gt;feedvalue = Qundef;</span><br><span class="line">      rb_exc_raise(e-&gt;stop_exc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到了這段，我們終於發現了 Fiber 的蹤跡，稍微來看一下發生了哪些事情。</p><ol><li>呼叫 <code>Fiber.current</code> 取得當下作用中的 Fiber</li><li><strong>如果 Enumerator 的 Fiber 不存在或者執行完畢</strong>，就做 <code>next_init</code> 這個動作</li><li>對 Enumerator 的 Fiber 呼叫 <code>#resume</code></li></ol><p>因為 <code>#resume</code> 的回傳值是 <code>Fiber.yield</code> 傳入的參數，所以我們只要再找到 Enumerator 的 Fiber 就能了解是怎樣運作的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">next_init(VALUE obj, struct enumerator *e)</span><br><span class="line">&#123;</span><br><span class="line">    VALUE curr = rb_fiber_current();</span><br><span class="line">    e-&gt;dst = curr;</span><br><span class="line">    e-&gt;fib = rb_fiber_new(next_i, obj);</span><br><span class="line">    e-&gt;lookahead = Qundef;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到 <code>next_init</code> 這段，我們會發現 Ruby 將 <code>next_i</code> 的方法當作是 Fiber 執行的區段來呼叫（就是我們 Fiber.new 給的 Block）</p><p>繼續往下追會看到 <code>next_i</code> 和 <code>next_ii</code> 兩個方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> VALUE</span><br><span class="line">next_ii(RB_BLOCK_CALL_FUNC_ARGLIST(i, obj))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">enumerator</span> *<span class="title">e</span> = <span class="title">enumerator_ptr</span>(<span class="title">obj</span>);</span></span><br><span class="line">    VALUE feedvalue = Qnil;</span><br><span class="line">    VALUE args = rb_ary_new4(argc, argv);</span><br><span class="line">    rb_fiber_yield(<span class="number">1</span>, &amp;args);</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;feedvalue != Qundef) &#123;</span><br><span class="line">        feedvalue = e-&gt;feedvalue;</span><br><span class="line">        e-&gt;feedvalue = Qundef;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> feedvalue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> VALUE</span><br><span class="line">next_i(VALUE curr, VALUE obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">enumerator</span> *<span class="title">e</span> = <span class="title">enumerator_ptr</span>(<span class="title">obj</span>);</span></span><br><span class="line">    VALUE nil = Qnil;</span><br><span class="line">    VALUE result;</span><br><span class="line"></span><br><span class="line">    result = rb_block_call(obj, id_each, <span class="number">0</span>, <span class="number">0</span>, next_ii, obj);</span><br><span class="line">    e-&gt;stop_exc = rb_exc_new2(rb_eStopIteration, <span class="string">"iteration reached an end"</span>);</span><br><span class="line">    rb_ivar_set(e-&gt;stop_exc, id_result, result);</span><br><span class="line">    <span class="keyword">return</span> rb_fiber_yield(<span class="number">1</span>, &amp;nil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看 <code>next_i</code> 這個方法，他會去呼叫我們定義的 Enumerator 的 <code>#each</code> 方法來做迭代，跟我們對 Enumerator 的理解上是一致的，而迭代的行為（給 <code>#each</code> 的 Block）就是 <code>next_ii</code> 本身。<br>繼續看到 <code>next_ii</code> 這個方法，可以理解為他就是單純的呼叫 <code>Fiber.yield</code> 而已，所以我們可以把這段轉換成下面的 Ruby 來理解。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>..<span class="number">10</span>).each <span class="keyword">do</span> <span class="params">|item|</span></span><br><span class="line">  Fiber.<span class="keyword">yield</span> item</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>也就是說，每次我們用 <code>#next</code> 的時候，Ruby 會產生一個 Fiber 然後每執行一次迭代就用 <code>Fiber.yield</code> 跳出來，直到都沒有任何元素可以被迭代後，再產生 <code>StopIteration</code> 的 Exception 同時做最後一次的 <code>Fiber.yield</code></p><p>我們可以用 Ruby簡單模擬這個行為</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frozen_string_literal: true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">require</span> <span class="string">'fiber'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># :nodoc:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FiberNext</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(items)</span></span></span><br><span class="line">    @items = items</span><br><span class="line">    @fiber = create_fiber</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">next</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">unless</span> @fiber.alive?</span><br><span class="line"></span><br><span class="line">    @fiber.resume</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  private</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">create_fiber</span></span></span><br><span class="line">    Fiber.new <span class="keyword">do</span></span><br><span class="line">      @items.each <span class="keyword">do</span> <span class="params">|item|</span></span><br><span class="line">        Fiber.<span class="keyword">yield</span> item</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      Fiber.<span class="keyword">yield</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">enum = FiberNext.new(%i[apple water flashlight])</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.times <span class="keyword">do</span></span><br><span class="line">  puts <span class="string">"Next: <span class="subst">#&#123;enum.<span class="keyword">next</span>&#125;</span>"</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>讀到這裡，不得不感嘆一下 Ruby Commiter 們用如此漂亮的方式設計了一個機能，我們都知道 Enumerator 對應的 <code>#each</code> 裡面只要給了 <code>yield</code> 基本上就是一個無法停止的狀態，他會不斷呼叫我們給的 Block 直到沒有 <code>yield</code> 再被呼叫，所以在 Ruby 裡面這算是一種「迭代」</p><p>但是想要控制迭代的進度，用步進的方式進行呢？如果採用一般的方式可能要做很多動作才能達成，此時 Fiber 這種可以暫停某個位置的執行跳去做其他任務，再跳回去的機制就變得非常實用。以應用案例來說，我想這大概也是非常漂亮的一個學習參考，以我過去對 Fiber 的理解是沒辦法想到這樣的使用方式的。</p><h2 id="被少考慮的情境"><a href="#被少考慮的情境" class="headerlink" title="被少考慮的情境"></a>被少考慮的情境</h2><p>前情提要終於結束了，回到我們的主題，那個你不會遇到的 Bug 到底是什麼？</p><p>在 Samuel 對 Ruby 的 <a href="https://github.com/ruby/ruby/pull/2002#issuecomment-515749562" rel="external nofollow noopener noreferrer" target="_blank">PR</a> 中你可以看到一段使用 <code>#to_enum</code> 和 <code>Fiber</code> 的程式碼，這段是當天再向我解釋時給的一個範例。</p><p>我稍微整理一下，讓大家比較好看到問題</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">items</span><span class="params">(&amp;block)</span></span></span><br><span class="line">  <span class="keyword">yield</span> <span class="symbol">:apple</span></span><br><span class="line">  Fiber.<span class="keyword">yield</span> <span class="comment"># 我想在這跳出我的 Fiber</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="symbol">:water</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="symbol">:flashlight</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">enum = to_enum(<span class="symbol">:items</span>)</span><br><span class="line"></span><br><span class="line">f = Fiber.new <span class="keyword">do</span></span><br><span class="line">  <span class="number">3</span>.times <span class="keyword">do</span></span><br><span class="line">    puts <span class="string">"Next: <span class="subst">#&#123;enum.<span class="keyword">next</span>&#125;</span>"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">f.resume</span><br></pre></td></tr></table></figure><p>執行的結果卻是這樣的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[elct9620] Desktop % ruby fiber.rb</span><br><span class="line">Next: apple</span><br><span class="line">Next:</span><br><span class="line">Next: water</span><br></pre></td></tr></table></figure><p>照正常的迭代器運作，不應該是把 <code>:apple</code>, <code>:water</code> 和 <code>:flashlight</code> 印出來，為什麼多了一個 <code>nil</code> 的數值呢？</p><p>如果我們把 <code>Fiber.yield</code> 改成 <code>Fiber.yield :oops</code> 執行看看</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[elct962<span class="number">0</span>] Desktop % ruby fiber.rb</span><br><span class="line"><span class="symbol">Next:</span> apple</span><br><span class="line"><span class="symbol">Next:</span> oops</span><br><span class="line"><span class="symbol">Next:</span> water</span><br></pre></td></tr></table></figure><p>問題就出在 <code>Fiber.yield</code> 竟然變得跟 <code>yield</code> 一樣，這是怎麼一回事？</p><p>回想一下前面介紹 Enumerator 在做 <code>#next</code> 的時候，是不是會產生一個新的 Fiber 然後用那個 Fiber 去做事情？</p><p>我們把前面那段產生 <code>#next</code> 的 Fiber 區段找出來，然後代入 <code>#items</code> 方法，會變成怎樣呢？</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line">    Fiber.new <span class="keyword">do</span></span><br><span class="line">      <span class="comment"># <span class="doctag">@items</span>.each do |item|</span></span><br><span class="line">        items <span class="keyword">do</span> <span class="params">|item|</span></span><br><span class="line">          <span class="comment"># 第一次 =&gt; item = (yield :apple)</span></span><br><span class="line">          <span class="comment"># 第一次 =&gt; Fiber.yield :oops</span></span><br><span class="line">          <span class="comment"># 第二次 =&gt; item = (yield :water)</span></span><br><span class="line">          <span class="comment"># 第三次 =&gt; item = (yield :flashlight)</span></span><br><span class="line">          Fiber.<span class="keyword">yield</span> item</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      Fiber.<span class="keyword">yield</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>大家有沒有發現，我們在第一次到第二次迭代的時候，被偷做了一次 <code>Fiber.yield</code> 然後他就跑回去變成 <code>#resume</code> 的回傳值，然後 <code>#next</code> 行為的次數就大亂了，歸咎原因在於他在執行的時候被 Ruby 判斷為「屬於 Enumerator 的 Fiber」</p><p>所以如果我們修改成像下面這樣執行，反而就不會出問題</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">items</span><span class="params">(&amp;block)</span></span></span><br><span class="line">  <span class="keyword">yield</span> <span class="symbol">:apple</span></span><br><span class="line">  Fiber.<span class="keyword">yield</span> <span class="comment"># 我想在這跳出我的 Fiber</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="symbol">:water</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="symbol">:flashlight</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">enum = to_enum(<span class="symbol">:items</span>)</span><br><span class="line"></span><br><span class="line">f = Fiber.new <span class="keyword">do</span></span><br><span class="line">  items <span class="keyword">do</span> <span class="params">|item|</span></span><br><span class="line">    puts <span class="string">"Next: <span class="subst">#&#123;item&#125;</span>"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">f.resume</span><br><span class="line">f.resume <span class="comment"># 因為被正確 `Fiber.yield` 所以要再做一次讓他能繼續</span></span><br></pre></td></tr></table></figure><p>因為沒有使用 <code>#next</code> 所以不會產生一個 Fiber 也就不會有被判斷錯誤的問題。</p><h2 id="解決方案與-Fiber-的切換機制"><a href="#解決方案與-Fiber-的切換機制" class="headerlink" title="解決方案與 Fiber 的切換機制"></a>解決方案與 Fiber 的切換機制</h2><p>目前我們看到的 PR 算是一個暫時性的解法，Samuel 告訴我這跟目前 Fiber 的設計有關係，所以只能先處理掉這個問題（大概會是 2.7 or 2.8 之類的會好）目前 PR 上已經是另一個版本，也就是最後展示給我會動的版本。中間也還有使用像是 <code>Fiber.transfer</code> 之類的方式做切換，就能指定應該要跳回哪一個 Fiber 上。</p><p>不過 Samuel 告訴我的想法我還不太清楚他想表達的是哪一個，不過只能說目前大致上有一個解決方法可以用。</p><ol><li>Enumerator 的 Fiber 要能跟普通的 Fiber 區分開來</li><li>Fiber 要加入一些類似 Call Stack 的機制，用來判斷要跳回去的 Fiber（以解釋來說比較像是多存一個指標）</li></ol><p>最後，我們來談談目前（Ruby 2.6.2）的 Fiber 切換機制是怎樣的。</p><p>目前已知 <code>Fiber.yield</code> <code>Fiber.transfer</code> 和 <code>#resume</code> 三個方法可以做切換，那麼來看一下這三個的實作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">VALUE</span><br><span class="line">rb_fiber_resume(VALUE fibval, <span class="keyword">int</span> argc, <span class="keyword">const</span> VALUE *argv)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">rb_fiber_t</span> *fib = fiber_ptr(fibval);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fib-&gt;prev != <span class="number">0</span> || fiber_is_root_p(fib)) &#123;</span><br><span class="line">      rb_raise(rb_eFiberError, <span class="string">"double resume"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fib-&gt;transferred != <span class="number">0</span>) &#123;</span><br><span class="line">      rb_raise(rb_eFiberError, <span class="string">"cannot resume transferred Fiber"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fiber_switch(fib, argc, argv, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VALUE</span><br><span class="line">rb_fiber_yield(<span class="keyword">int</span> argc, <span class="keyword">const</span> VALUE *argv)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> fiber_switch(return_fiber(), argc, argv, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VALUE</span><br><span class="line">rb_fiber_transfer(VALUE fibval, <span class="keyword">int</span> argc, <span class="keyword">const</span> VALUE *argv)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> fiber_switch(fiber_ptr(fibval), argc, argv, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔細一看，除了 <code>#resume</code> 有做一些檢查去避免重複執行之外，基本上都是做同樣的事情。（也就是文章前面提到的在新版的 Fiber 已經採用指標切換）</p><p>而 <code>Fiber.yield</code> 和 <code>Fiber.transfer</code> 的差異幾乎是只剩下「是否能指定 Fiber」這點，這也是 Samuel 有提到可能可以用 <code>Fiber.transfer</code> 去解決 Enumerator 裡面的 Fiber 問題的原因，因為我們可以利用這樣的方式「手動指定」而不是交由 Ruby 自己判斷，那麼就能讓我們指定正確的 Fiber 去繼續執行。</p><p>至於為什麼會選到錯誤的 Fiber 執行，我們看一下 <code>fiber_siwtch</code> 和 <code>return_fiber</code> 大概就可以猜到原因。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> VALUE</span><br><span class="line">fiber_switch(<span class="keyword">rb_fiber_t</span> *fib, <span class="keyword">int</span> argc, <span class="keyword">const</span> VALUE *argv, <span class="keyword">int</span> is_resume)</span><br><span class="line">&#123;</span><br><span class="line">    VALUE value;</span><br><span class="line">    <span class="keyword">rb_context_t</span> *cont = &amp;fib-&gt;cont;</span><br><span class="line">    <span class="keyword">rb_thread_t</span> *th = GET_THREAD();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_resume) &#123;</span><br><span class="line">      fib-&gt;prev = fiber_current();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">rb_fiber_t</span>*</span><br><span class="line">return_fiber(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">rb_fiber_t</span> *fib = fiber_current();</span><br><span class="line">    <span class="keyword">rb_fiber_t</span> *prev = fib-&gt;prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!prev) &#123;</span><br><span class="line">      <span class="keyword">rb_thread_t</span> *th = GET_THREAD();</span><br><span class="line">      <span class="keyword">rb_fiber_t</span> *root_fiber = th-&gt;root_fiber;</span><br><span class="line"></span><br><span class="line">      VM_ASSERT(root_fiber != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (root_fiber == fib) &#123;</span><br><span class="line">        rb_raise(rb_eFiberError, <span class="string">"can't yield from root fiber"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">return</span> root_fiber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      fib-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>簡單說當我們呼叫 <code>#resume</code> 的時候，會把當下的 Fiber 標記成前一個 Fiber，而做 <code>Fiber.yield</code> 的時候就會因為有紀錄，就把這個 Fiber 當作前一個目標做切換。</p><p>過程大概像是這樣：</p><ol><li>Fiber.new （我們的）</li><li>#resume （我們的）</li><li>#next （產生 Enumerator 的 Fiber）</li><li>Fiber.yield =&gt; 找到的是 Enumerator 的 Fiber</li></ol><p>所以在這中間，我們的 Fiber 已經不被我們自定義的迭代方法中的 <code>Fiber.yield</code> 認識。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在 After Hack 回到家之後，才發現原來是被 Commiter 直接一對一教學了一個多小時，算是很不錯的經驗。大概也是因為克服了這類心理上的障礙，所以即使聽得蠻吃力的但還是能夠繼續嘗試，我想之後的活動大概不會有不敢用英文對話的困擾了吧！</p><p>最大的收穫大概是有 Commiter 帶你看了一部分的原始碼，還有去理解這些國外的高手是怎樣思考問題的。至少以台灣人來說算是不錯的經驗，以比例來看台灣人不多的狀況下能遇到的高手是固定的但是如果有像是研討會這類活動，我們就有機會接觸到篩選出來的高手，把握機會跟這些人交流就能很快地學到新東西跟進步，畢竟算是短時間的讓台灣的高手比例上升吧 XD</p><p>雖然會覺得能早點突破心理障礙就能更快接觸到，不過有時候很多知識還沒準備齊全（像是嘗試過 Fiber 和了解基本原理等等）也蠻難能問對問題，可以的話真的蠻需要平常多準備一些問題或者寫下來，才不會遇到機會都沒辦法問。</p><blockquote><p>不過我自己也沒有這個習慣，但是看起來還是要準備一點會比較好呢 XD</p></blockquote>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2019/07/30/Talk-with-the-Ruby-Committer-about-Enumerator-and-Fiber-the-bug-you-may-never-touch/#disqus_thread</comments>
    </item>
    
    <item>
      <title>RubyConf Taiwan 2019 會後感想、議程概覽</title>
      <link>https://blog.frost.tw/posts/2019/07/29/My-experience-after-RubyConf-Taiwan-2019/</link>
      <guid>https://blog.frost.tw/posts/2019/07/29/My-experience-after-RubyConf-Taiwan-2019/</guid>
      <pubDate>Mon, 29 Jul 2019 07:03:01 GMT</pubDate>
      <description>
      
        &lt;p&gt;跟前幾年一樣基本上就是工作人員，這幾年參加研討會也都比較沒有在仔細聽了，所以大多是邊顧邊寫點程式。&lt;/p&gt;&lt;p&gt;比較不一樣的大概是今年更累了，從週四下午場佈到 Pre Party 然後兩天的活動、Official Party 最後到今年嘗試的 After Hack 幾乎是四天左右的連續接力，每天早上醒來都要先懷疑自己是否能撐過這一天。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>跟前幾年一樣基本上就是工作人員，這幾年參加研討會也都比較沒有在仔細聽了，所以大多是邊顧邊寫點程式。</p><p>比較不一樣的大概是今年更累了，從週四下午場佈到 Pre Party 然後兩天的活動、Official Party 最後到今年嘗試的 After Hack 幾乎是四天左右的連續接力，每天早上醒來都要先懷疑自己是否能撐過這一天。</p><a id="more"></a><p>基本上就跟之前差不多，照時間來看整個活動。</p><h2 id="Pre-Party"><a href="#Pre-Party" class="headerlink" title="Pre Party"></a>Pre Party</h2><p>今年是由 <a href="https://piccollage.com/" rel="external nofollow noopener noreferrer" target="_blank">PicCollage</a> 贊助 Pre Party 的活動，去到活動場地的時候很確定以前去過幾次，但是一直沒有想起來是到哪間公司。不過以前有一次的 RubyConf Taiwan 也是在這棟大樓的某間公司辦過 Party 的樣子。</p><p>PicCollage 準備的食物真的好評，非常好吃。然後 Ruby 社群舉辦這種 Party 活動的重點是跟人交流，這場除了有抓新同事去跟 Matz 打個招呼之外，基本上就都還是講中文。蠻意外的是兩年前跟女人迷合作的聊天機器人講座來參加的人，都已經畢業變成 PicCollage 的員工，看起來我離學生時代越來越遠了⋯⋯</p><p>第一天晚上基本上算是暖身，大概就是稍微閒聊，然後跟一些認識的朋友打個招呼就這樣結束了。</p><h2 id="The-Future-of-Ruby"><a href="#The-Future-of-Ruby" class="headerlink" title="The Future of Ruby"></a>The Future of Ruby</h2><p>這場因為早上狀況蠻多的所以沒有聽到太多，尤其是 <a href="https://tamashii.io" rel="external nofollow noopener noreferrer" target="_blank">Tamashii</a> 打卡機遇到了一些狀況，雖然都是很好排除的問題，不過大概也凸顯了過去一年都沒有維護的情況，幾乎都是平常沒有使用跟調整造成的問題。</p><p>Matz 這幾年講的 Keynote 都偏向 Ruby 3 的目標跟方向，還有 Ruby Commiter 努力的成果。這次有投稿 <a href="https://2019.rubyworld-conf.org" rel="external nofollow noopener noreferrer" target="_blank">Ruby World Conference</a> 所以就看看能不能在十一月再聽一次。</p><h2 id="Rethinking-the-View-Layer-with-Components"><a href="#Rethinking-the-View-Layer-with-Components" class="headerlink" title="Rethinking the View Layer with Components"></a>Rethinking the View Layer with Components</h2><p>這場因為<a href="https://ryudo.tw/" rel="external nofollow noopener noreferrer" target="_blank">慕凡</a>在今年 <a href="https://rubykaigi.org/2019" rel="external nofollow noopener noreferrer" target="_blank">RubyKaigi</a> 有跟我提過，所以大概是有一個概念的。今年感覺都沒有很集中，但是又感覺都大概懂，很微妙的狀態。</p><p>簡單來說是在討論 Rails 在 View 層的實作，目前我們的測試都是仰賴 Feature 之類的去驗證畫面是否正常的。<br>這邊是將 View 分解成 Component（元件）的形式，將一些細碎的部分用 Ruby 來實作，有點類似 Decorator 的感覺，但更接近 React 的元件概念。</p><p>利用這種方式我們就可以針對性地對 View 做單元測試，以後端來說算是很先進的想法。</p><h2 id="Ruby-with-types"><a href="#Ruby-with-types" class="headerlink" title="Ruby with types"></a>Ruby with types</h2><p>因為我在 1001 負責錄影，所以都是聽這間的。這場主要在討論對 Ruby 增加型別支援會是怎樣子的，雖然有考慮蠻多東西的。不過我覺得整體上跟 Stripe 提出的 <a href="https://sorbet.org/" rel="external nofollow noopener noreferrer" target="_blank">Sorbet</a> 比起來讓 Ruby 的語法整個變複雜難懂很多。反而是 Sorbet 這種有點選用類型的 DSL 能保有一定程度的相容性，又可以改善一些開發上的問題。</p><blockquote><p>不過 Sorbet 的難點可能會變成在一些 IoT 類型的應用要導入需要一些 Cross Compile 的處理，有可能會變成卡住的點。但是這方面又是 IoT 應用的一個尷尬的地方，很多地方都是需要利用 C Extension 去做才能盡可能的在 Ruby 裡面做事情。</p></blockquote><h2 id="Protect-Your-Copyrighted-Ruby-Code-in-Distribution"><a href="#Protect-Your-Copyrighted-Ruby-Code-in-Distribution" class="headerlink" title="Protect Your Copyrighted Ruby Code in Distribution"></a>Protect Your Copyrighted Ruby Code in Distribution</h2><p>這場我沒怎麼跟上，反正後面就變成瑪力歐了，大致上是在講有什麼方式可以讓 Ruby 原始碼不會被直接的看到這件事情。</p><p>不過我個人是認為這算是一種一體兩面的東西吧，尤其是現在很多應用都轉到 Web 和雲端的情況下，這種套裝軟體的模式是否是合適的。</p><blockquote><p>對一些商用的 Gem 可能會有影響，不過沒有聽很詳細所以就這樣吧 XD</p></blockquote><h2 id="Scalable-Applications-with-JRuby"><a href="#Scalable-Applications-with-JRuby" class="headerlink" title="Scalable Applications with JRuby"></a>Scalable Applications with JRuby</h2><p>這場我沒在聽（印象薄弱）不過感覺有點是在介紹 JRuby 之後的一些發展吧，像是會要把 Fiber 之類的加進去支援。</p><h2 id="Road-to-white-mages"><a href="#Road-to-white-mages" class="headerlink" title="Road to white mages"></a>Road to white mages</h2><p>到這個時候我已經開始在寫新的 Gem 了，這場主要是在講怎麼 Debug 程式。其實 Ruby 在這幾年針對 Debug 的輔助增加了不少特性，用來解決一些問題的時候是真的滿重要的技巧。</p><p>比較簡單的就是現在大多數時候可以直接問 Ruby 某個 Method 是在哪裡定義的（尤其是接手專案又被魔改 Patch 的情況）</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method(<span class="symbol">:puts</span>).source_location</span><br></pre></td></tr></table></figure><p>用法大概像這樣，這場介紹不少這類技巧，我大概要之後補看影片了 XD</p><h2 id="The-Journey-to-One-Million"><a href="#The-Journey-to-One-Million" class="headerlink" title="The Journey to One Million"></a>The Journey to One Million</h2><p>聽說很精彩，因為我也沒在聽所以不太清楚發生什麼事情。不過講者 Samuel 大概是我今年講最多話的外國人了 XD</p><p>主要是在講用 Ruby Fiber 機制開發的 Web Server 能達到處理 100 萬連線的過程，這幾天仔細看 Ruby Core 的 Mailing List 才發現是 Commiter 等級的超級大大。</p><p>裡面有一段是一結束就被慕凡問，我後面跑去問了好幾個熟人也都不知道。</p><p>Fiber 我當初會有興趣是因為他跟 Goroutine 很類似，所以我就跑去研究，去年到日本員工旅遊的時候有去參加 <a href="https://asakusarb.doorkeeper.jp/" rel="external nofollow noopener noreferrer" target="_blank">Asakusa.rb</a> 活動的時候有問了一下那邊的大大，然後再經過幾個月的整理歸納出一個大概的概念，才剛好能搞懂這段問題。</p><blockquote><p>去年是寫了好幾篇關於 <a href="https://blog.frost.tw/posts/2018/06/26/Talk-about-ruby-s-fiber-Part-1/">Fiber</a> 的文章，不過現在回去看其實我的了解還是很不足的。</p></blockquote><p>其實 Fiber 有一個問題是他要做 Context Switch 而做這件事情是有代價的，這種機制（在一個 Thread 內做切換）叫做 Coroutine（協程）在 C 或是 C++ 都能實作出來，而他的特色是會把 Context 保存下來，因為要這樣才能確保切換回去的時候還是在同一個狀態下繼續執行。</p><p>而這件事情就會跟記憶體使用有關係，如果頻繁地切換就會有效能問題，也就是這樣切換的代價是否比開 Thread 還低。</p><p>像是 Context 是怎麼保存的（Ruby 有一個 context 資料結構，他可能不是整個 Ruby 保存而是以 Block 為單位之類的）還有要在什麼時機點做切換，如果我們都沒有 I/O Blocking 的狀況下，切換是否有效益等等。</p><p>簡單來說就是你使用 Fiber 跑出來的效果好不好，取決於你對 Process / Thread 這些東西的機制了解有多少，然後因為 Fiber 還很不成熟，所以你要自己做一些原本 OS 會幫你做的事情，才能讓 Fiber 跑得很快。</p><h2 id="Official-Party"><a href="#Official-Party" class="headerlink" title="Official Party"></a>Official Party</h2><p>今年感覺已經完全可以無視語言障礙，反正聽不懂就乾杯，所以可以比較順的跟外國人交流。</p><p>比較特別的大概是以前的同時有的已經是掛 Director、主管或是跑去 Google 這種看起來就超厲害的公司工作，相比起來我好像蠻普通的（笑）</p><p>這場有跟 Pixiv 的 CTO 稍微聊到天，不過有點可惜大概是對不太到點所以沒能聊起來，但這大概也跟我英文聽力還不夠好有關係，不然感覺應該都是能聊技術才對。</p><p>另外就是有去找 Samuel 問關於 Fiber 的問題，因為之前做的 <a href="https://blog.frost.tw/posts/2018/08/21/Does-the-Fiber-have-any-benefit-for-Ruby/">Fiber 改善 HTTP 效能</a> 測試，我後來做了很多檢驗都跟我預期的結果差異不少。</p><p>這次綜合了前面的演講和我的猜測，算是獲得一個驗證就是之前少測試了一個情況，而這個情況應該才是 Fiber 表現最好的情況。之後有空大概還是得再次實作出來做一次測試，才能檢驗我的假設是否正確。</p><h2 id="Compacting-GC-for-MRI"><a href="#Compacting-GC-for-MRI" class="headerlink" title="Compacting GC for MRI"></a>Compacting GC for MRI</h2><p>網站上的講題不知道是不是當天的講題，因為這次很忙所以我只能在這個時間對口譯所以是完全沒聽到的。</p><blockquote><p>聽說有人在 Offical Party 跟大神許願，所以題目是早上突然改變的⋯⋯</p></blockquote><h2 id="從-Enumerator-看-Ruby-的迭代器"><a href="#從-Enumerator-看-Ruby-的迭代器" class="headerlink" title="從 Enumerator 看 Ruby 的迭代器"></a>從 Enumerator 看 Ruby 的迭代器</h2><p>我的講題，其實當我完成簡報最後的部分（在前一天晚上）我就知道這場大概是要絕望了 XD</p><p>整體上來說有一種 JavaScript 到處亂跳的 Callback 的感覺，所以我很難解釋，又沒有時間讓我思考怎樣畫圖才能動作，所以最後就是台下大家一臉呆滯。</p><p>簡單說就是討論 Enumerator 是怎麼來的，然後 Enumerator::Generator 和 Enumerator::Yielder 為什麼要存在，以及 Enumerator::Lazy 是怎樣應運用跟運作，結束後還好有 <a href="https://medium.com/@c9s" rel="external nofollow noopener noreferrer" target="_blank">c9s</a> 大大提問，雖然只是確認一些細節，但是至少讓我感覺到安慰，畢竟後面這種混亂的狀態還有人能搞懂⋯⋯</p><blockquote><p>總而言之，之後我會想辦法再寫幾篇文章討論這個，然後盡可能的詳細一點。</p></blockquote><h2 id="開拓者們建立鐵道的辛酸血淚史"><a href="#開拓者們建立鐵道的辛酸血淚史" class="headerlink" title="開拓者們建立鐵道的辛酸血淚史"></a>開拓者們建立鐵道的辛酸血淚史</h2><p>這場我沒有很認真聽，不過講者的公司真的是蠻拼的去嘗試這些東西。</p><blockquote><p>其實我覺得 Trailblazer 的問題是他的文件停留在 1.0 版，然後又蠻囉唆的，其實能適用的情況不一定是我們想像那麼美好。但是想法上是很不錯的，很值得學習。</p></blockquote><h2 id="Suit-up-for-frontend-and-backend-development"><a href="#Suit-up-for-frontend-and-backend-development" class="headerlink" title="Suit up for frontend and backend development"></a>Suit up for frontend and backend development</h2><p>大概是一場不用認真聽也知道在講什麼的演講，因為這就是目前我在做的專案辛酸血淚史的統合。雖然演講中沒有提到太多那個專案，不過裡面大部分的經驗跟技巧都是從那個專案學到很多教訓後整理出來的。</p><p>主要就是在討論怎麼拆分 Form / Presenter 等物件，之前才寫一篇的<a href="https://blog.frost.tw/posts/2019/05/28/How-to-use-Form-Object-and-others-for-Rails/">關於 Rails 中的 Form Object / Presenter 這些物件該怎麼用</a>系列文章其實也是在講這個，只是看的角度不太一樣，之後也會繼續的補完這系列。</p><blockquote><p>關於那個很崩潰的專案，給我的感覺是太久沒寫超糟的程式，所以回去反思到底是怎樣變糟的。雖然客戶方面的問題蠻多的，但是也反過來讓我把很多過去難以釐清跟不知道怎麼判斷的東西理解出來，算是把整個架構技能向上提升了一個等級吧 XD</p></blockquote><h2 id="Using-AWS-Lambda-with-Ruby-on-a-large-scale-system"><a href="#Using-AWS-Lambda-with-Ruby-on-a-large-scale-system" class="headerlink" title="Using AWS Lambda with Ruby on a large-scale system"></a>Using AWS Lambda with Ruby on a large-scale system</h2><p>我沒認真聽，大致上就是在想說在 Lambda 上跑 Ruby 的故事。</p><h2 id="What’s-new-in-Rails-6"><a href="#What’s-new-in-Rails-6" class="headerlink" title="What’s new in Rails 6?"></a>What’s new in Rails 6?</h2><p>一樣沒認真聽，雖然原本是想要認真聽一下 Rails 6 有什麼新功能的，不過跟前面那一場差不多都是我心流狀態，已經完全集中在寫 Gem 了 XD</p><h2 id="Virtual-Machines-their-common-parts-and-what-makes-them-special"><a href="#Virtual-Machines-their-common-parts-and-what-makes-them-special" class="headerlink" title="Virtual Machines: their common parts and what makes them special"></a>Virtual Machines: their common parts and what makes them special</h2><p>最後一場，這場我就有比較專注一點在聽。我覺得厲害的地方是能把蠻難搞懂的概念，用很簡單的例子舉出來。不過蠻可惜的是這段知識因為前幾年的 RubyKaigi 有在討論 Register Based VM 應用在 Ruby 上的可能性，所以我算是有去補充了這塊知識，嚴格說起來就是演講的內容剛好都在我懂的範圍內。</p><p>不過有拿 PHP7 改善效能後的設計來跟 Ruby 比較我覺得是很好的，因為我們大多只關注 Ruby 本身，但是也許其他語言有相同的問題需要解決，而且已經找到一個好方案如果沒有去看看的話，可能就浪費時間在某些沒有太大意義的地方上。</p><h2 id="After-Hack-Day"><a href="#After-Hack-Day" class="headerlink" title="After Hack Day"></a>After Hack Day</h2><p>這場活動主要是希望讓台灣的開發者可以多嘗試開發一些東西，或者對 Ruby 相關專案做貢獻。另外就是藉由這次機會，讓大家可以跟國外的開發者做技術上的交流，很多都是在台灣不容易遇到的高手。</p><p>上午主要是自我介紹跟簡單展示一下專案，雖然完全沒有照我跟 <a href="https://medium.com/@st0012" rel="external nofollow noopener noreferrer" target="_blank">Stan</a> 預想的情況進行，不過我覺得因為算是一個非正式活動，大家能交流跟互動是最好的。就結果上來說，我個人認為是還不錯的，大家都有稍微跟身邊的外國人互動、提問。</p><p>因為 RubyConf Taiwan 兩天我都在寫 Gem 但是還沒有測試，所以我今天大部分時間都在把 <a href="https://github.com/elct9620/hahamut" rel="external nofollow noopener noreferrer" target="_blank">Hahamut</a> 這個 Gem 的測試補完，主要是發現如果設計得夠好，其實測試會很容易寫。這大概也驗證了我開始了解測試怎麼寫的時候，認為如果測試發現很難測，那就一定是設計上有問題要改進。</p><p>後面大概四點快五點，我跑去翻 Samuel 寫的 Async Gem 裡面有一個關於 Enumerator 的問題被特別提出來，因為我的主題就是討論 Enumerator 所以就打開來看了一下，但是又沒有跟上討論的點就只好去問本人。</p><p>然後就這樣得到了一個半小時的 Commiter 一對一教學的機會，這個問題是一個在所有 Ruby 版本（1.9 之後有 Fiber）都會有的問題，他又很剛好是我在讀 Enumerator 原始碼的時候被我跳過的部分，簡單說就是 Enumerator 其實是有用 Fiber 的。</p><p>但是，因為 Ruby 目前的 Fiber 機制不夠完善，造成了下面的情況</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">iterate</span><span class="params">(&amp;block)</span></span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  Fiber.<span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">f = Fiber.new <span class="keyword">do</span></span><br><span class="line">  to_enum(<span class="symbol">:iterate</span>).to_a</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">f.resume</span><br></pre></td></tr></table></figure><p>照 Fiber 的邏輯，應該是要 <code>#to_a</code> 得到 <code>[1]</code> 然後 <code>f.resume</code> 得到一個 <code>2</code> 的回傳值，但是因為 <code>to_enum</code> 會產生一個 Fiber 區段，造成 <code>Fiber.yield</code> 實際上是跟 <code>yield 1</code> 的效果一樣，結果就變成 <code>#to_a</code> 得到 <code>[1, 2]</code> 然後 <code>f.resume</code> 是 <code>nil</code> 的狀況。</p><p>後面的討論（應該是單方面聽解說）就是圍繞在這個情境下要怎麼處理，還有 Samuel 的 <a href="https://github.com/ruby/ruby/pull/2002" rel="external nofollow noopener noreferrer" target="_blank">PR</a> 怎麼暫時性的解決，而這個解法其實不算好。就再講到 <code>Fiber.yield</code> 和 <code>#resume</code> 的行為是怎樣實作的，以及目前 Ruby 缺少了怎樣的機制才造成這個問題的發生等等。</p><p>非常有趣，不過我想大概也不是我目前能幫忙解決的 XD</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>整體上來說，經過這幾年參加國外研討會跟在台灣能有跟外國人交流的機會。其實有慢慢體會到 Ruby 社群文化的優點，這大概是相比其他語言社群一個很棒的優點。就是我們是盡量嘗試去跟外國的工程師接觸跟交流的，雖然還是要看個人，不過至少以<a href="https://5xruby.tw" rel="external nofollow noopener noreferrer" target="_blank">五倍紅寶石</a>本身公司文化來說，我們內部員工會盡量做這件事情是好的。</p><p>其實這樣說起來，以前大學參加研討會會嘗試跟講者、外國人交流，也許是從 RubyConf Taiwan 學來的，雖然整體下來我可能花了五六年才能達到完全不怕去跟外國人對話，但是就結果上來說是很棒的。而且能跟參與語言本身開發的工程師討論技術，收穫是遠比自己研究多上非常多的。</p><p>另外就是解釋技術的技巧，外國講者在解釋上我認為都有不少很用心的地方，盡可能讓這些東西能更容易被理解。至少相比之下，我的簡報跟演講大概就沒有這麼好懂了⋯⋯</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2019/07/29/My-experience-after-RubyConf-Taiwan-2019/#disqus_thread</comments>
    </item>
    
    <item>
      <title>巴哈姆特 Chatbot 之亂：用 Ruby on Rails 接收 Webhook</title>
      <link>https://blog.frost.tw/posts/2019/07/26/The-bahamut-chatbot-receiving-the-webhook/</link>
      <guid>https://blog.frost.tw/posts/2019/07/26/The-bahamut-chatbot-receiving-the-webhook/</guid>
      <pubDate>Fri, 26 Jul 2019 06:44:28 GMT</pubDate>
      <description>
      
        &lt;p&gt;六月底的時候發現巴哈姆特似乎想為他們推出的 Messaging APP （哈哈姆特）舉辦一個聊天機器人的比賽，看到之後想說還算蠻有趣的，所以我就跟朋友很隨意的組成一個團隊來開發。&lt;/p&gt;&lt;p&gt;跟大多數我們熟悉串接 Chatbot 的機制是類似的，我們可以用 Webhook 的方式接收一個來自使用者發送的訊息，然後再透過程式處理後回傳訊息給使用者。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>六月底的時候發現巴哈姆特似乎想為他們推出的 Messaging APP （哈哈姆特）舉辦一個聊天機器人的比賽，看到之後想說還算蠻有趣的，所以我就跟朋友很隨意的組成一個團隊來開發。</p><p>跟大多數我們熟悉串接 Chatbot 的機制是類似的，我們可以用 Webhook 的方式接收一個來自使用者發送的訊息，然後再透過程式處理後回傳訊息給使用者。</p><a id="more"></a><h2 id="了解-Webhook-機制"><a href="#了解-Webhook-機制" class="headerlink" title="了解 Webhook 機制"></a>了解 Webhook 機制</h2><p>在程式設計中，我們常常會使用一種叫做「Hook（鉤子）」或者「Callback（回呼）」的機制，用比較好懂的角度去說明，他是一個在「程式執行中插入額外動作」</p><p>舉例來說，我們會有像這樣的程式</p><ul><li>接收訊息</li><li>顯示訊息</li></ul><p>假設我們要增加一個 Hook 就會變成像這樣</p><ul><li>接收訊息</li><li>Hooks （可能有多個）</li><li>顯示訊息</li></ul><p>而 Webhook 就是指這個 Hook 利用 Web（網站）的方式執行，所以當這些 Messaging APP 收到訊息後，會利用 Webhook 做一些事情（像是發送給我們自己的伺服器）然後再繼續動作。</p><h2 id="了解-Signature-機制"><a href="#了解-Signature-機制" class="headerlink" title="了解 Signature 機制"></a>了解 Signature 機制</h2><p>不過當我們收到一段訊息的時候，要怎麼知道這段訊息是來是正確的使用者？</p><p>這就要靠 Signature 機制來幫助我們，透過一個共用的密鑰（Token）來對訊息內容加密，當我們收到訊息的時候只要用同樣的密鑰對訊息加密，就會獲得一段驗證碼，當我們比對驗證碼跟發送者提供給我們相同時，就可以假設這是可信的訊息。</p><blockquote><p>有些網站提供檔案下載時會提供 MD5 校驗碼也是同樣的原理。</p></blockquote><p>以哈哈姆特的 Webhook 為例子，我們會從哈哈姆特收到一個 Webhook 請求，這個請求會包含類似下面的資訊。</p><ul><li>X-BAHA-DATA-SIGNATURE 標頭（Header）</li><li>內容（Ex. 某段訊息）</li></ul><p>巴哈使用的是 SHA1 演算法（MD5 是另外一種），所以我們就要把內容用 SHA1 計算，再比對巴哈給我們的 <code>X-BAHA-DATA-SIGNATURE</code> 來驗證是否是來自巴哈，因為加密的密碼理論上只會有我們自己跟巴哈知道。</p><h2 id="接收請求"><a href="#接收請求" class="headerlink" title="接收請求"></a>接收請求</h2><p>如果你還沒有用過 Ruby on Rails 的話，可以參考<a href="https://kaochenlong.com/" rel="external nofollow noopener noreferrer" target="_blank">龍哥</a>所寫的<a href="https://railsbook.tw/" rel="external nofollow noopener noreferrer" target="_blank">為你自己學 Ruby on Rails</a> 這本書，在網站上看到的部分就足夠你入門。</p><p>首先，我們希望有一個網址（Endpoint）可以接收請求，所以要在 <code>config/routes.rb</code> 定義一個控制器（Controller）來處理。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Rails.application.routes.draw <span class="keyword">do</span></span><br><span class="line"> <span class="comment"># ...</span></span><br><span class="line"> </span><br><span class="line"> post <span class="symbol">:bahamut</span>, <span class="symbol">to:</span> <span class="string">'webhook#bahamut'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>透過 Ruby 的 DSL 特性，我們就可以定義出一個叫做 <code>/bahamut</code> 的位址，用來接收巴哈姆特的 Webhook。然後在上面定義要使用 Webhook 控制器上面的 <code>#bahamut</code> 方法來處理這個位址的動作。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app/controllers/webhook_controller.rb</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebhookController</span> &lt; ActionController::API</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bahamut</span></span></span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> Implement Chatbot Handler</span></span><br><span class="line">    render <span class="symbol">plain:</span> <span class="string">'Hello World'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在這邊我們可能需要下一點指令才能測試，或者你可以使用 <a href="https://www.getpostman.com/" rel="external nofollow noopener noreferrer" target="_blank">Postman</a> 這套軟體來模擬 POST 請求。</p><blockquote><p>POST 請求一般是我們送出表單的操作，所以無法直接用打開網頁的方式開啟。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST http://localhost:3000/bahamut</span><br></pre></td></tr></table></figure><p>然後我們就能看到我們的終端機（Terminal）出現了 <code>Hello World</code> 字樣。</p><p>如果我們希望巴哈能發送訊息到我們自己的本機電腦（localhost）就必須讓我們的電腦能在網路上被找到，這可以利用 <a href="https://ngrok.com/" rel="external nofollow noopener noreferrer" target="_blank">Ngrok</a> 這套軟體達成，透過 Ngrok 我們可以得到一個暫時性的網址，如此一來就能將本機測試的網站被巴哈呼叫到。</p><blockquote><p>我想大家可能有疑問，就是是不是一定要用 Ruby on Rails 才能做到，實際上因為 Ruby on Rails 對初學者來說是最容易搭建出網站的選項，才會選擇使用。不然只要是任何能處理網的程式語言，都是可以直接用來寫 Chatbot 的，只不過像是 Ruby on Rails 這類網站開發框架，能幫我們省下學習這些基礎知識的時間。</p></blockquote><h2 id="驗證-Signature"><a href="#驗證-Signature" class="headerlink" title="驗證 Signature"></a>驗證 Signature</h2><p>因為處理簽章（Signature）的機制比較複雜，在物件導向類型的語言中，我們會設計一個 Class 來專門處理這件事情。</p><p>所以我們來製作一個服務物件（Service Object）叫做 Signature Verifer （簽章驗證器）來專們針對巴哈姆特傳入的簽章做驗證。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app/services/signature_verifer.rb</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SignatureVerifer</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(request)</span></span></span><br><span class="line">    @request = request</span><br><span class="line">    <span class="comment"># 讀取內容</span></span><br><span class="line">    @body = @request.body.read</span><br><span class="line">    <span class="comment"># 讀取 Signature Header</span></span><br><span class="line">    @signature = request.headers[<span class="string">'x-baha-data-signature'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 把內容退回開頭（避免其他人讀取不到資料）</span></span><br><span class="line">    @request.body.rewind</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>第一個步驟我們要設計驗證器的「初始化（Initialize）」階段要做什麼，我們預期會收到一個 HTTP 請求（<code>request</code>）然後將裡面的簽章（<code>x-baha-data-signature</code>）取出來，以及內容（對話訊息）取出來，這是我們在前面提到驗證是否是由巴哈發出的訊息所需要的資訊。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app/services/signature_verifer.rb</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SignatureVerifer</span></span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">  </span><br><span class="line">  private</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">verify_signature</span></span></span><br><span class="line">    @verify_signature <span class="params">||</span>=</span><br><span class="line">      <span class="string">"sha1=<span class="subst">#&#123;OpenSSL::HMAC.hexdigest(<span class="string">'SHA1'</span>, ENV[<span class="string">'BAHA_SECRET'</span>], @body)&#125;</span>"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>這個步驟是根據巴哈的<a href="https://sites.google.com/gamer.com.tw/hahamut-bot/%E6%8E%A5%E6%94%B6webhook%E4%BA%8B%E4%BB%B6?authuser=0" rel="external nofollow noopener noreferrer" target="_blank">文件</a>將剛剛抓到的訊息跟聊天機器人的 Secret（秘鑰）做 SHA1 運算產生出我們自己計算的簽章，如此一來跟巴哈提供的比對，就會知道內容是不是一樣沒有被人偷偷竄改。</p><blockquote><p>要特別注意的是 <code>ENV[&#39;BAHA_SECRET&#39;]</code> 這邊我是使用「環境變數」<code>來儲存密鑰，這樣只有安裝伺服器的人會知道，就可以避面將這類敏感資訊放到程式碼之中。 在 Rails 5 之後，我們可以用</code>rails credentials:edit` 這個指令編輯一個加密的檔案，並把密鑰放到裡面，使用方法可以參考 <a href="https://guides.rubyonrails.org/configuring.html" rel="external nofollow noopener noreferrer" target="_blank">Ruby on Rails 文件</a></p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SignatureVerifer</span></span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">valid?</span></span></span><br><span class="line">      @signature == verify_signature</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  private</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>最後再提供一個 <code>valid?</code> 方法，用來讓我們查詢是否正確就可以了！</p><p>我們修改一下 <code>WebhookController</code> 來做一個簡單的檢查。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebhookController</span> &lt; ActionController::API</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bahamut</span></span></span><br><span class="line">    <span class="keyword">return</span> unathorized_error <span class="keyword">unless</span> valid_signature?</span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> Implement Chatbot Handler</span></span><br><span class="line">    render <span class="symbol">plain:</span> <span class="string">'Hello World'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  private</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">valid_signature?</span></span></span><br><span class="line">    SignatureVerifer.new(request).valid?</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unauthorized_error</span></span></span><br><span class="line">    render <span class="symbol">json:</span> &#123; <span class="symbol">error:</span> <span class="string">'Unauthorized'</span> &#125;, <span class="symbol">status:</span> <span class="symbol">:unauthorized</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>假設我們透過 <code>SignatureVerifer</code> 驗證失敗的話，就回傳一個 JSON 資訊表示未驗證，並且設定 HTTP 的狀態碼為 401（未授權）的狀態。</p><blockquote><p>JSON 是一種資料格式，常常用在不同伺服器溝同時當作交歡資料的格式，我們從巴哈收到的訊息也是 JSON 格式。</p></blockquote><h2 id="發送回應"><a href="#發送回應" class="headerlink" title="發送回應"></a>發送回應</h2><p>既然我們已經可以接收訊息，如果使用者都沒有辦法收到任何回應的話肯定會覺得奇怪，所以下一步就是要能發送訊息給使用者。</p><p>哈哈姆特目前支援文字、圖片、貼圖跟事件幾種類型，其中事件是最容易做的，打好基底後也會變得更容易修改成支援其他類型的發送程式。</p><p>我們先來看一下從巴哈接收到的訊息會是怎樣的格式（JSON）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="attr">"botid"</span>:&lt;BOT_ID&gt;,</span><br><span class="line"> <span class="attr">"time"</span>:<span class="number">1512353744843</span>,</span><br><span class="line"> <span class="attr">"messaging"</span>:[</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="attr">"sender_id"</span>:&lt;SENDER_ID&gt;,</span><br><span class="line">     <span class="attr">"message"</span>:&#123;</span><br><span class="line">       <span class="attr">"text"</span>:<span class="string">"Hello~"</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我們需要關注的只有 <code>messaging</code> 區塊的部分，裡面描述了「多個訊息」而每個訊息都會有「發送者」和「內容」兩個資訊。在上面這從官方文件複製的訊息範例中，使用者發送的內容是一段「文字（text）」</p><p>在 Rails 接收到之後，會自動的做好 JSON 解析的處理，所以我們可以直接像這樣使用。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 照每一個訊息處理</span></span><br><span class="line">params[<span class="string">'messaging'</span>].each <span class="keyword">do</span> <span class="params">|message|</span></span><br><span class="line"> <span class="comment"># 解析訊息跟回覆</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在開始處理之前，我們需要先能夠發送訊息到哈哈姆特。因為步驟也是比較多的，所以我們需要製作一個 Sender （發送器）物件來處理。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'net/http'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># app/services/text_sender.rb</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextSender</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(recipient, message)</span></span></span><br><span class="line">    @receipient = receipient</span><br><span class="line">    @message = message</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>首先我們在初始化階段要把「接收者」跟想要發送出去的「訊息」記錄起來。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'net/http'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># app/services/text_sender.rb</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextSender</span></span></span><br><span class="line">  ENDPOINT = <span class="string">'https://us-central1-hahamut-8888.cloudfunctions.net/'</span> \</span><br><span class="line">             <span class="string">"messagePush?access_token=<span class="subst">#&#123;ENV[<span class="string">'BAHA_TOKEN'</span>]&#125;</span>"</span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">perform</span></span></span><br><span class="line">    <span class="comment"># 發送訊息</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">uri</span></span></span><br><span class="line">    @uri <span class="params">||</span>= URI(ENDPOINT)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">ssl?</span></span></span><br><span class="line">    uri.scheme == <span class="string">'https'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">  private</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">request</span></span></span><br><span class="line">    <span class="comment"># 製作一個 HTTP 請求</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>接下來我們將巴哈文件上所提供的位置，以及一些發送請求需要的一些資訊製作出來。</p><blockquote><p>像是 <code>URI</code> 這類轉換是用於 Ruby 處理發送 HTTP 請求所需要的，所以我們都先做好處理方便使用。而 <code>ENV[&#39;BAHA_TOKEN&#39;]</code> 跟前面的 <code>ENV[&#39;BAHA_SECRET&#39;]</code> 用途是一樣的，都是需要避免直接寫在程式內的數值。</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'net/http'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># app/services/text_sender.rb</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextSender</span></span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">  </span><br><span class="line">  private</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">request</span></span></span><br><span class="line">    <span class="keyword">return</span> @request <span class="keyword">if</span> @request.present?</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 產生一個 HTTP Post 請求</span></span><br><span class="line">    @request = Net::HTTP::Post.new(uri)</span><br><span class="line">    <span class="comment"># 使用 JSON 格式（指定內容類型）</span></span><br><span class="line">    @request[<span class="string">'Content-Type'</span>] = <span class="string">'application/json'</span></span><br><span class="line">    <span class="comment"># 把要傳輸的內容轉換成 JSON 格式的資料</span></span><br><span class="line">    @request.body = body.to_json</span><br><span class="line">    @request</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>因為我們要將訊息發給巴哈，巴哈再將訊息發給指定的使用者。</p><blockquote><p>如果是 LINE 或者 Facebook Messenger 我們想對同一個人發訊息，在不同的 Chatbot 有不同的編號（ID）這樣就可以保護使用者不會被沒有授權的 Chatbot 騷擾，所以不論是發送還是接收，都需要透過巴哈的伺服器。</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'net/http'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># app/services/text_sender.rb</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextSender</span></span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">perform</span></span></span><br><span class="line">    http = Net::HTTP.new(uri.host, uri.port)</span><br><span class="line">    http.use_ssl = ssl?</span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> 處理回應</span></span><br><span class="line">    <span class="comment"># 發送請求給巴哈</span></span><br><span class="line">    http.request(request)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">body</span></span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="symbol">recipient:</span> &#123;</span><br><span class="line">        <span class="symbol">id:</span> @recipient</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="symbol">message:</span> &#123;</span><br><span class="line">        <span class="symbol">text:</span> @message</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  private</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>最後我們只需要將請求的內容（文字訊息）定義好，然後讓他可以發送出去，我們就能對使用者發送回應。</p><blockquote><p>這邊的 <code>recipient</code> 通常會是我們收到的 <code>sender_id</code></p></blockquote><p>我們可以在 Rails Console 裡面像這樣簡單測試是否可以發送訊息</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TextSender.new(<span class="string">'巴哈帳號'</span>, <span class="string">'Hello!'</span>)</span><br></pre></td></tr></table></figure><h2 id="自動回應相同訊息"><a href="#自動回應相同訊息" class="headerlink" title="自動回應相同訊息"></a>自動回應相同訊息</h2><p>我們將前面的程式整合後，可以改寫 <code>WebhookController</code> 讓他可以自動回應跟使用者相同的訊息。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebhookController</span> &lt; ActionController::API</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bahamut</span></span></span><br><span class="line">    <span class="keyword">return</span> unathorized_error <span class="keyword">unless</span> valid_signature?</span><br><span class="line">    </span><br><span class="line">    process_messages</span><br><span class="line">    render <span class="symbol">json:</span> &#123; <span class="symbol">message:</span> <span class="string">'OK'</span> &#125;, <span class="symbol">status:</span> <span class="symbol">:ok</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  private</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">process_messages</span></span></span><br><span class="line">    params[<span class="string">'messaging'</span>].each <span class="keyword">do</span> <span class="params">|message|</span></span><br><span class="line">      TextSender.new(</span><br><span class="line">        message[<span class="string">'sender_id'</span>],</span><br><span class="line">        <span class="string">"PONG: <span class="subst">#&#123;message[<span class="string">'message'</span>][<span class="string">'text'</span>]&#125;</span>"</span></span><br><span class="line">      )</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我們透過將每一條訊息（<code>messaging</code>）取出來，然後將接收者設定為發送者（<code>sender_id</code>）並把訊息內容前面加上 <code>PONG:</code> 用來區別，確保確實是經過我們的 Chatbot 處理後才回應的。</p><blockquote><p>PING/PONG 跟 Hello World 都有點像是一個習慣，通常我們用來測試一個伺服器是否有正常運作，就會透過發送 PING 然後確認伺服器有回應 PONG 來當判斷，如果想換成任何想要的訊息都是沒問題的。</p></blockquote><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>其實這些步驟在大多數情況應該被製作成一個 Gem （Ruby 的套件，可以想像成 Mod 之類的東西）直接使用，不過最近比較忙就沒有時間好好設計並且封裝成 Gem。</p><p>不過這篇文章的概念在處理各種類型的 Chatbot 是很好用的，如果有興趣的話也蠻推薦大家詳細了解一下。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2019/07/26/The-bahamut-chatbot-receiving-the-webhook/#disqus_thread</comments>
    </item>
    
    <item>
      <title>用 CloudFlare Workers 製作簡單的 Uptime Status 頁面</title>
      <link>https://blog.frost.tw/posts/2019/07/09/Build-a-simple-uptime-status-page-use-CloudFlare-Workers/</link>
      <guid>https://blog.frost.tw/posts/2019/07/09/Build-a-simple-uptime-status-page-use-CloudFlare-Workers/</guid>
      <pubDate>Tue, 09 Jul 2019 11:09:08 GMT</pubDate>
      <description>
      
        &lt;p&gt;最近跟朋友弄了一個透過 Chatbot 做出手遊效果的專案，沒出什麼意外的話大概能在九月看到一個雛形。不過既然是手遊類型的遊戲，更新資料跟維護其實就會遇到一些困難點。&lt;/p&gt;&lt;p&gt;如果是線上遊戲或者手遊，大多數只要在公告後把玩家切斷連線然後升級過程中避免玩家連上就好。不過因為是 Chatbot 所以除非能做到不停機升級，不然是很困難的。&lt;br&gt;如此一來，讓玩家知道遊戲（機器人）正在更新，處於無法使用的狀態，就是一個重要的關鍵。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>最近跟朋友弄了一個透過 Chatbot 做出手遊效果的專案，沒出什麼意外的話大概能在九月看到一個雛形。不過既然是手遊類型的遊戲，更新資料跟維護其實就會遇到一些困難點。</p><p>如果是線上遊戲或者手遊，大多數只要在公告後把玩家切斷連線然後升級過程中避免玩家連上就好。不過因為是 Chatbot 所以除非能做到不停機升級，不然是很困難的。<br>如此一來，讓玩家知道遊戲（機器人）正在更新，處於無法使用的狀態，就是一個重要的關鍵。</p><a id="more"></a><p>不過因為算是業餘的作品，玩家數量可能也不會到預期的那樣多。最簡單的方法就是開一個網頁，或者把流量都倒去一個暫時的伺服器就可以。<br>直覺想到的就是利用一些 Uptime Monitor 服務的狀態頁面，不過市面上能選的不多，有些方案即使最簡單的也要 $20/月，其實對小專案來說不太划算。</p><blockquote><p>其實還是有不少服務商能選，不過因為用量可能小到不忍直視就放棄這個念頭。</p></blockquote><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>回來思考我們的需求，其實很簡單：</p><ol><li>伺服器出現任何問題時還能被查詢</li><li>只需要最基本的正常或不正常的狀態呈現</li></ol><p>這種時候其實可以考慮人工用 GitHub Pages 的方式人工更新，不過身為工程師還是會想要偷懶一點，看看有沒有辦法自動化。</p><h2 id="CloudFlare-Workers"><a href="#CloudFlare-Workers" class="headerlink" title="CloudFlare Workers"></a>CloudFlare Workers</h2><p>評估了一下這類 Uptime Mointer 服務，做法都是簡單地去戳某個網站看看是否正常。不過因為只需要知道伺服器是否還在線上，所以直接由伺服器回報狀態其實也是個不錯的方法。<br>考量了像是 AWS Lambda / GCP Cloud Functions / Firebase 等等選項，意外想到 CloudFlare Workers 也許是一個選擇。</p><p>其實大家都很清楚使用雲端服務的花費是相對高的，但是整個服務互相串連整合的方便性就很難是一般虛擬主機服務可以比擬的。</p><p>不過像是簡單的應用情境，用一些簡單的服務反而能在性價比上得到一個不錯的結果。以 CloudFlare Workers 來看，光是基本的服務用量其實就足夠我們使用。<br>但是要保存狀態，所以我們還需要儲存資料的地方，而 CloudFlare Workers KV 也剛好提供了類似 NoSQL 的 Key-Value 儲存機制。</p><p>以花費來看，每個月 $5 美金可以換到 1000 萬次的請求額度，跟至少 10 萬次寫入以作為 Uptime Status 服務來說，基本上要監控上百台機器都沒問題。</p><blockquote><p>不過上百台機器的話，還是乖乖買服務比較實在⋯⋯</p></blockquote><h2 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h2><p>至於實作非常簡單，不過就是剛好因為 CloudFlare 正在改這個服務，所以 UI 有點混亂，要先做好以下的設定。</p><ol><li>付費啟用 CloudFlare Workers Pro 方案</li><li>到任一一個 Domain 下面的 Workers 分頁啟用 KV 功能</li></ol><h3 id="產生-Namespace"><a href="#產生-Namespace" class="headerlink" title="產生 Namespace"></a>產生 Namespace</h3><p>我們可以把 CloudFlare Workers KV 當作是一個超巨大的 Key-Value 儲存庫，而我們要在自己的資料庫下面切出一個區塊來存放特定資料。</p><blockquote><p>正確啟用後不用透過 API 直接在後台手動新增，拿到 Namespace Key 就好，會比打 API 方便很多</p></blockquote><h3 id="上傳資訊"><a href="#上傳資訊" class="headerlink" title="上傳資訊"></a>上傳資訊</h3><p>因為是 Ruby on Rails 專案，所以我簡單的封裝了一個物件讓我的 Rake Task 可以透過呼叫這個物件上傳伺服器的狀態。之後搭配 Whenever 就能以每分鐘的頻率去回報資訊。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Updater</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:hostname</span></span><br><span class="line"></span><br><span class="line">  API = <span class="string">'https://api.cloudflare.com/client/%&lt;version&gt;s/accounts'</span></span><br><span class="line">  ENDPOINT = <span class="string">'/%&lt;account&gt;s/storage/kv/namespaces/%&lt;namespace&gt;s/values/%&lt;node&gt;s'</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></span><br><span class="line">    @node_name = ENV[<span class="string">'NODE_NAME'</span>] <span class="params">||</span> Socket.gethostname</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">update!</span></span></span><br><span class="line">    Net::HTTP.start(uri.host, uri.port, <span class="symbol">use_ssl:</span> ssl?) <span class="keyword">do</span> <span class="params">|http|</span></span><br><span class="line">      http.request request</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">request</span></span></span><br><span class="line">    request = Net::HTTP::Put.new(uri)</span><br><span class="line">    request[<span class="string">'X-Auth-Email'</span>] = ENV[<span class="string">'CF_EMAIL'</span>]</span><br><span class="line">    request[<span class="string">'X-Auth-Key'</span>] = ENV[<span class="string">'CF_TOKEN'</span>]</span><br><span class="line">    request.body = body.to_json</span><br><span class="line">    request</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">ssl?</span></span></span><br><span class="line">    uri.scheme == <span class="string">'https'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">uri</span></span></span><br><span class="line">    @uri <span class="params">||</span>=</span><br><span class="line">      URI(format(<span class="string">"<span class="subst">#&#123;API&#125;</span><span class="subst">#&#123;ENDPOINT&#125;</span>"</span>, options))</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">options</span></span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="symbol">version:</span> <span class="string">'v4'</span>,</span><br><span class="line">      <span class="symbol">account:</span> ENV[<span class="string">'CF_ACCOUNT_ID'</span>],</span><br><span class="line">      <span class="symbol">namespace:</span> ENV[<span class="string">'CF_NAMESPACE_ID'</span>],</span><br><span class="line">      <span class="symbol">node:</span> @node_name</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">body</span></span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="symbol">status:</span> <span class="symbol">:online</span>,</span><br><span class="line">      <span class="symbol">timestamp:</span> Time.now.to_i</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>這段實作只是很簡單的 HTTP Client 而已，最重要的主要是要把 <code>timestamp</code> 上傳上去，我們才能夠過這個時間戳記去推斷最後一次有反應是什麼時候。</p><blockquote><p>理論上關機或者停止這個指令，就不會被更新伺服器狀態上去。不過這實際上還是不太精確的，應該包含像是 CPU 和記憶體的資訊，才能知道伺服器是否過度忙碌而無法提供服務。</p></blockquote><h3 id="回傳資訊"><a href="#回傳資訊" class="headerlink" title="回傳資訊"></a>回傳資訊</h3><p>接下來我們就利用 CloudFlare Workers 來把存進去的資料抓出來呈現，如果有興趣綁定到特定 Domain 之類的，請利用他的 CLI 工具設定好之後，再繼續操作。</p><blockquote><p>主要是目前 KV 功能還無法用 CLI 工具設定，會互相蓋掉（而綁定 Domain / Path 則是都得靠 CLI 工具）</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">addEventListener(<span class="string">'fetch'</span>, event =&gt; &#123;</span><br><span class="line">    event.respondWith(handleRequest(event.request))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Fetch <span class="keyword">and</span> log a request</span><br><span class="line"> * @param &#123;Request&#125; request</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">async function handleRequest(request) &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ Response as JSON</span></span><br><span class="line"><span class="regexp">    let responseInit = &#123;</span></span><br><span class="line"><span class="regexp">        status: 200,</span></span><br><span class="line"><span class="regexp">        headers: &#123;</span></span><br><span class="line"><span class="regexp">            'Content-Type': 'application/json</span>;charset=UTF-<span class="number">8</span><span class="string">'</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // Find all request nodes</span></span><br><span class="line"><span class="string">    let url = new URL(request.url)</span></span><br><span class="line"><span class="string">    let nodes = url.searchParams.getAll('</span>node[]<span class="string">')</span></span><br><span class="line"><span class="string">    let status = await getAllNodeStatus(nodes);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return new Response(JSON.stringify(status), responseInit)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// Read nodes status from KV</span></span><br><span class="line"><span class="string">async function getAllNodeStatus(nodes) &#123;</span></span><br><span class="line"><span class="string">    let status = &#123;&#125;;</span></span><br><span class="line"><span class="string">    await Promise.all(nodes.map(async (node) =&gt; &#123;</span></span><br><span class="line"><span class="string">        var nodeStatus = await Status.get(node, '</span>json<span class="string">');</span></span><br><span class="line"><span class="string">        if (nodeStatus) &#123;</span></span><br><span class="line"><span class="string">            status[node] = nodeStatus</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;));</span></span><br><span class="line"><span class="string">    return status;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>因為會有多個服務，所以我設計了一個很簡單的機制去抓取 GET 請求的 Search Params 然後把抓到的 Hostname （當作 Key 的數值）拿去問 Store 是否有存過 JSON 資訊，然後把它組合成新的 JSON 回傳出來。</p><h3 id="顯示資訊"><a href="#顯示資訊" class="headerlink" title="顯示資訊"></a>顯示資訊</h3><p>接下來就是隨意的做一個頁面，把狀態呈現出來。<br>因為是很前期的東西，所以我先找了一個 Open Source 的佈景，然後用 Jekyll 部署到 GitHub Pages 上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> STATUS_API = <span class="string">'https://status.basaltic.tw/api/status.json'</span>;</span><br><span class="line">  <span class="keyword">var</span> $nodes = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.node'</span>)</span><br><span class="line">  <span class="keyword">var</span> nodes = &#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> uri = <span class="keyword">new</span> URL(STATUS_API)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Load Nodes on Page</span></span><br><span class="line">  $nodes.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hostname = node.dataset.hostname;</span><br><span class="line">    <span class="comment">// Cache DOM</span></span><br><span class="line">    nodes[hostname] = &#123;</span><br><span class="line">      $el: node,</span><br><span class="line">      $color: node.querySelector(<span class="string">'.legend__color'</span>),</span><br><span class="line">      $status: node.querySelector(<span class="string">'.legend__value'</span>),</span><br><span class="line">      hostname: hostname</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// Add for Query</span></span><br><span class="line">    uri.searchParams.append(<span class="string">'node[]'</span>, hostname);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> currentTime = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime() / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Refactor</span></span><br><span class="line">  fetch(uri)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123; <span class="keyword">return</span> res.json() &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">statuses</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> node = &#123;&#125;</span><br><span class="line">      <span class="keyword">var</span> $color = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">var</span> $status = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> hostname <span class="keyword">in</span> statuses) &#123;</span><br><span class="line">        node = statuses[hostname];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( node &amp;&amp; nodes[hostname] ) &#123;</span><br><span class="line">          $color = nodes[hostname][<span class="string">'$color'</span>];</span><br><span class="line">          $status = nodes[hostname][<span class="string">'$status'</span>];</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Online</span></span><br><span class="line">          <span class="keyword">if</span> ((currentTime - node.timestamp) / <span class="number">60</span> &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">            $color.style.cssText = <span class="string">"--color: var(--color-online)"</span>;</span><br><span class="line">            $status.innerText = <span class="string">"Online"</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $color.style.cssText = <span class="string">"--color: var(--color-offline)"</span>;</span><br><span class="line">            $status.innerText = <span class="string">"Offline"</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure><p>主要是這段 JavaScript 我們利用 <code>data-</code> 這類 Data Attribute 去把想顯示的 Hostname 抓取出來，然後統一發一次 API 請求出去查詢。</p><blockquote><p>CloudFlare Workers 有查詢限制 10ms (Free) 50ms (Pro) 但是以 Key-Value Store 來說一次查幾百個大概都沒什麼影響吧⋯⋯</p></blockquote><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>大家想看成果的話可以到 <a href="https://status.basaltic.tw/" rel="external nofollow noopener noreferrer" target="_blank">Basaltic Studio Status</a> 這個頁面看看，這是我以前大學跟朋友做畢業專題的團隊名稱（Basaltic Studio）至於前面的兩段程式碼都放在 <a href="https://gist.github.com/elct9620/fc1c75ac7fb9a447bbd1993e840e8eba" rel="external nofollow noopener noreferrer" target="_blank">Gits</a> 不過直接複製文章的也沒問題就是了。</p><p>前幾天剛好跟同事聊到，不是用技術去解決問題，而是要看問題選對的技術去解決。雖然說起來很簡單，不過對工程師來說大概是很困難的。所以最容易做好的就是有技術就玩，別太糾結在「去解決某個問題」這件事情，而是要去了解技術的性質，在未來碰到問題的時候有「解決問題的方案」</p><p>以這個小東西來說，大部分時候都是沒用的。不過這也讓我了解 CloudFlare Workers 的應用，而且變化起來其實還能做不少事情。像是 Servier Discovery 其實就跟這個機制很像（服務回報自己節點資訊，給其他人查詢）在某些奇怪的應用狀況下，說不定也是個可以應用的方向（不過我猜不會有人會想把這個功能丟在第三方服務上⋯⋯）</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2019/07/09/Build-a-simple-uptime-status-page-use-CloudFlare-Workers/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Ruby 中 Constant 和 Class 的關係</title>
      <link>https://blog.frost.tw/posts/2019/06/18/The-relationship-between-constant-and-class-in-ruby/</link>
      <guid>https://blog.frost.tw/posts/2019/06/18/The-relationship-between-constant-and-class-in-ruby/</guid>
      <pubDate>Tue, 18 Jun 2019 11:13:17 GMT</pubDate>
      <description>
      
        &lt;p&gt;下班前&lt;a href=&quot;https://kaochenlong.com/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;龍哥&lt;/a&gt;說在 Mailing List 看到了一段 Code 很有趣。&lt;/p&gt;&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;a = Class.new&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p a        &lt;span class=&quot;comment&quot;&gt;#=&amp;gt; #&amp;lt;Class:0x0000558d34f68b48&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p a.name   &lt;span class=&quot;comment&quot;&gt;#=&amp;gt; nil&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;B = a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p a.name   &lt;span class=&quot;comment&quot;&gt;#=&amp;gt; &#39;B&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;C = a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p C.name   &lt;span class=&quot;comment&quot;&gt;#=&amp;gt; &#39;B&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;裡面 &lt;code&gt;C = a&lt;/code&gt; 到底發生了什麼事情，是很值得討論的，因為有了線索是 &lt;code&gt;rb_const_set&lt;/code&gt; 可以找到原因，所以就利用下班時間來讀看看這段。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;關於前面的用法可以參考之前寫過的&lt;a href=&quot;https://blog.frost.tw/posts/2017/10/22/The-ruby-s-class-is-free-Part-1/&quot;&gt;自由的 Ruby 類別&lt;/a&gt;來了解原因。&lt;/p&gt;&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>下班前<a href="https://kaochenlong.com/" rel="external nofollow noopener noreferrer" target="_blank">龍哥</a>說在 Mailing List 看到了一段 Code 很有趣。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = Class.new</span><br><span class="line"></span><br><span class="line">p a        <span class="comment">#=&gt; #&lt;Class:0x0000558d34f68b48&gt;</span></span><br><span class="line">p a.name   <span class="comment">#=&gt; nil</span></span><br><span class="line"></span><br><span class="line">B = a</span><br><span class="line">p a.name   <span class="comment">#=&gt; 'B'</span></span><br><span class="line"></span><br><span class="line">C = a</span><br><span class="line">p C.name   <span class="comment">#=&gt; 'B'</span></span><br></pre></td></tr></table></figure><p>裡面 <code>C = a</code> 到底發生了什麼事情，是很值得討論的，因為有了線索是 <code>rb_const_set</code> 可以找到原因，所以就利用下班時間來讀看看這段。</p><blockquote><p>關於前面的用法可以參考之前寫過的<a href="https://blog.frost.tw/posts/2017/10/22/The-ruby-s-class-is-free-Part-1/">自由的 Ruby 類別</a>來了解原因。</p></blockquote><a id="more"></a><p>我大致上翻了一下 Ruby 的原始碼，這段程式主要是定義在 <code>variable.c</code> 這個檔案，在 Ruby 裡面我們可以簡單把 Constant（常數）理解為一種特殊的變數，跟一些語言在使用了 <code>const</code> 關鍵字後無法更改的概念上是不太一樣。</p><h2 id="常數如何被賦值"><a href="#常數如何被賦值" class="headerlink" title="常數如何被賦值"></a>常數如何被賦值</h2><p>因為 <code>rb_const_set</code> 接受了一些參數我們不好理解，所以先看看是由誰來呼叫他。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">rb_define_const(VALUE klass, <span class="keyword">const</span> <span class="keyword">char</span> *name, VALUE val)</span><br><span class="line">&#123;</span><br><span class="line">    ID id = rb_intern(name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!rb_is_const_id(id)) &#123;</span><br><span class="line">true      rb_warn(<span class="string">"rb_define_const: invalid name `%s' for constant"</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">    rb_const_set(klass, id, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">rb_define_global_const(<span class="keyword">const</span> <span class="keyword">char</span> *name, VALUE val)</span><br><span class="line">&#123;</span><br><span class="line">    rb_define_const(rb_cObject, name, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Ruby 裡面我們要定義一個常數 <code>A = x</code> 是透過 <code>rb_define_const</code> 來實現的，如果是 Global 的話，就會直接定義在 <code>Object</code> 下面，而我們提供給 <code>rb_const_set</code> 的三個參數裡面 <code>ID</code> 這個數值可以先來看一下 <code>rb_intern</code> 的用法。</p><p>現在我們在 Ruby 裡面會經常使用 <code>:name</code> 這樣的寫法，表示他是一種 Symbol 而在 Ruby 裡面的實作，都會透過 <code>rb_intern</code> 這個方法來從 <code>char*</code> 轉換過去，基本上我們可以理解 Ruby 所有物件、常數的命名，都會被統一記錄起來，方便之後重複使用。</p><p>不過這邊有趣的地方其實是他會檢查這個 <code>ID</code> 類型，往下追之後會看到像這樣的檢查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> is_const_id(id) (id_type(id)==ID_CONST)</span></span><br></pre></td></tr></table></figure><blockquote><p>不過關於這段稍微追了下發現又是一個有點長的過程，這邊簡單解釋就是在定義 Symbol 的時候 Ruby 會依照這個 Symbol 的特性去區分出他的類型，像是 <code>$</code> 開頭會標記成 Golbal Variable 這樣的感覺</p></blockquote><h2 id="常數賦值的過程"><a href="#常數賦值的過程" class="headerlink" title="常數賦值的過程"></a>常數賦值的過程</h2><p>接下來我們就可以往 <code>rb_const_set</code> 深入來看，因為整體是相對長的，我們就針對需要的部份重點式的閱讀。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rb_const_entry_t</span> *ce;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_id_table</span> *<span class="title">tbl</span> = <span class="title">RCLASS_CONST_TBL</span>(<span class="title">klass</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (NIL_P(klass)) &#123;</span><br><span class="line"> rb_raise(rb_eTypeError, <span class="string">"no class/module to define constant %"</span>PRIsVALUE<span class="string">""</span>, QUOTE_ID(id));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check_before_mod_set(klass, id, val, <span class="string">"constant"</span>);</span><br><span class="line"><span class="keyword">if</span> (!tbl) &#123;</span><br><span class="line">  <span class="comment">// PART1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// PART2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一階段 Ruby 會先去看看這個 Class 裡面是不是已經初始化過紀錄下面所屬的常數的一個表格，如果沒有的話就初始化一個出來。已經存在的話則是做 Autoload 動作，如果有讀取到對應的常數，那就會跳出錯誤警告，沒有的話就跟前面產生表的行為一樣，把這個常數插入進去。</p><p>看起來常數的賦值應該就這樣結束了，不過為了處理一些特殊情況，所以往下會看到一段註解。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Resolve and cache class name immediately to resolve ambiguity</span></span><br><span class="line"><span class="comment"> * and avoid order-dependency on const_tbl</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>這就是我們這次要討論的問題來源，要觸發這個處理依照原始碼的實作要滿足某些條件才行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rb_cObject &amp;&amp; (RB_TYPE_P(val, T_MODULE) || RB_TYPE_P(val, T_CLASS))) &#123;</span><br></pre></td></tr></table></figure><ol><li><code>Object</code> 是有被定義的（正常情況下都應該是被定義的）</li><li>賦予的數值必須是 Module 或者 Class</li></ol><p>接下來要再滿足另一個條件，就是通過 <code>rb_class_path_cached</code> 的檢查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (NIL_P(rb_class_path_cached(val))) &#123;</span><br></pre></td></tr></table></figure><p>因為裡面的實作也有點多，所以這邊直接去找了一下<a href="https://docs.ruby-lang.org/ja/latest/function/rb_class_path.html" rel="external nofollow noopener noreferrer" target="_blank">文件</a>關於 <code>rb_class_path</code> 的用途，然後再去看 <code>rb_class_path_cached</code> 的這段實作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">VALUE</span><br><span class="line">rb_class_path_cached(VALUE klass)</span><br><span class="line">&#123;</span><br><span class="line">    st_table *ivtbl;</span><br><span class="line">    <span class="keyword">st_data_t</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!RCLASS_EXT(klass)) <span class="keyword">return</span> Qnil;</span><br><span class="line">    <span class="keyword">if</span> (!(ivtbl = RCLASS_IV_TBL(klass))) <span class="keyword">return</span> Qnil;</span><br><span class="line">    <span class="keyword">if</span> (st_lookup(ivtbl, (<span class="keyword">st_data_t</span>)classpath, &amp;n)) <span class="keyword">return</span> (VALUE)n;</span><br><span class="line">    <span class="keyword">if</span> (st_lookup(ivtbl, (<span class="keyword">st_data_t</span>)tmp_classpath, &amp;n)) <span class="keyword">return</span> (VALUE)n;</span><br><span class="line">    <span class="keyword">return</span> Qnil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致上我們可以理解成每個有名字的 Class 或 Module 都會被記錄起來，所以這邊要找的條件是「匿名的 Class 或是 Module」都符合條件後，就會做下面的動作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (klass == rb_cObject) &#123;</span><br><span class="line"> rb_ivar_set(val, classpath, rb_id2str(id));</span><br><span class="line"> rb_name_class(val, id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">VALUE path;</span><br><span class="line">ID pathid;</span><br><span class="line"><span class="keyword">st_data_t</span> n;</span><br><span class="line">st_table *ivtbl = RCLASS_IV_TBL(klass);</span><br><span class="line"><span class="keyword">if</span> (ivtbl &amp;&amp;</span><br><span class="line">    (st_lookup(ivtbl, (<span class="keyword">st_data_t</span>)(pathid = classpath), &amp;n) ||</span><br><span class="line">     st_lookup(ivtbl, (<span class="keyword">st_data_t</span>)(pathid = tmp_classpath), &amp;n))) &#123;</span><br><span class="line">    path = rb_str_dup((VALUE)n);</span><br><span class="line">    rb_str_append(rb_str_cat2(path, <span class="string">"::"</span>), rb_id2str(id));</span><br><span class="line">    OBJ_FREEZE(path);</span><br><span class="line">    rb_ivar_set(val, pathid, path);</span><br><span class="line">    rb_name_class(val, id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假設這個常數是定義在 <code>Object</code>（全域）的情況，那麼就直接對他做兩件事情：</p><ol><li>設定 <code>classpath</code> （就是前面的暫存檢查）</li><li>對這個匿名的 Class 或 Module 設定名字為當下的常數</li></ol><p>如果是定義在某個 Class 或 Module 下面的話，因為 <code>classpath</code> 就不會是剛好的，所以要先算過（產生） <code>classpath</code> 然後再做一樣的事情。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>找完之後我們就可以解釋為什麼文章一開始的 <code>C = a</code> 再去問 <code>C.name</code> 會得到 <code>B</code> 這個結果了，主要是因為已經被命名過的 Class 會在記憶體中製作一個類似捷徑的東西，讓下次去呼叫這個 Class 或 Module 可以更快。</p><p>而給這個 Class 或 Module 物件命名的時機點，就在於它被記錄到捷徑的時機，所以即使再次賦予給其他常數，也不會改變他的名字。</p><blockquote><p>這樣我們可以延伸出來的問題是 <code>C = a</code> 的情況下，因為 <code>classpath</code> 是 Cache 在 <code>B</code> 上面，這時候使用 <code>C</code> 是不是會比 <code>B</code> 更慢呢？而匿名的 Class 和 Module 會不會對效能有所影響。</p></blockquote>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2019/06/18/The-relationship-between-constant-and-class-in-ruby/#disqus_thread</comments>
    </item>
    
    <item>
      <title>關於 Rails 中的 Form Object / Presenter 這些物件該怎麼用（一）</title>
      <link>https://blog.frost.tw/posts/2019/05/28/How-to-use-Form-Object-and-others-for-Rails/</link>
      <guid>https://blog.frost.tw/posts/2019/05/28/How-to-use-Form-Object-and-others-for-Rails/</guid>
      <pubDate>Tue, 28 May 2019 15:54:08 GMT</pubDate>
      <description>
      
        &lt;p&gt;前陣子在 Review 新專案中同事的程式碼時，發現同事對像是 Service Object / Form Object 這類物件不太有概念。不過這個新專案因為是接手其他公司的專案，所以有不少地方要微調。至少那個值得吐槽的「因為 Controller 程式碼太長不知道放哪裡，就都丟去 Service Object 好了！」的神奇用法，完全沒有幫助改善程式碼。&lt;/p&gt;&lt;p&gt;也因為這個機會，我用了一點時間跟專案的同事分享了一下我對這些物件的看法。畢竟當出我也是搞不太懂，不過隨著了解物件導向和 Ruby 的語言特性，從這些角度切入後，就比較能理解該怎麼使用。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>前陣子在 Review 新專案中同事的程式碼時，發現同事對像是 Service Object / Form Object 這類物件不太有概念。不過這個新專案因為是接手其他公司的專案，所以有不少地方要微調。至少那個值得吐槽的「因為 Controller 程式碼太長不知道放哪裡，就都丟去 Service Object 好了！」的神奇用法，完全沒有幫助改善程式碼。</p><p>也因為這個機會，我用了一點時間跟專案的同事分享了一下我對這些物件的看法。畢竟當出我也是搞不太懂，不過隨著了解物件導向和 Ruby 的語言特性，從這些角度切入後，就比較能理解該怎麼使用。</p><a id="more"></a><p>我想，在能夠應用 Rails 開發網站後，撇除 Controller / Model 之外，要在加入其他的物件類型，就很難去「區分」該如何使用了！所以，我們應該要先來看「物件向語言」之所以要製作成物件的理由。</p><h2 id="物件導向"><a href="#物件導向" class="headerlink" title="物件導向"></a>物件導向</h2><p>剛開始，我們寫程式就是直接把想要做的事情描述出來，類似這樣</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">puts <span class="string">'[INFO] Server started'</span></span><br></pre></td></tr></table></figure><p>不過隨著行為重複的使用，每次都要複製同樣的程式碼，我們通常會包裝成一個「方法」</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(level, message)</span></span></span><br><span class="line">  puts <span class="string">"[<span class="subst">#&#123;level.upcase&#125;</span>] <span class="subst">#&#123;message&#125;</span>"</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>隨著這些行為變得複雜，我們可能會有一些希望共用的情境跟邏輯，那就會製作成一個「物件」</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(output)</span></span></span><br><span class="line">    @output = output</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">info</span><span class="params">(message)</span></span></span><br><span class="line">    log(<span class="string">'info'</span>, message)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(level, message)</span></span></span><br><span class="line">    @output.write <span class="string">"[<span class="subst">#&#123;level.upcase&#125;</span>] <span class="subst">#&#123;message&#125;</span>"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我們依照這個脈絡來看，其實我們都是在做「輸出紀錄」的功能，只是輸出記錄這件事情有越來越多行為，所以我們一步一步的把它封裝起來。</p><blockquote><p>其實這也是重構的基本思考方式，我們該如何將散落的「相似程式」整理歸納，變成一個統一的行為跟功能。</p></blockquote><p>有了這樣的概念，我們再去看隨著學習 Rails （或是任何框架）不斷出現的新物件類型，就能夠抓到這樣應用的理由。</p><h2 id="Form-Object"><a href="#Form-Object" class="headerlink" title="Form Object"></a>Form Object</h2><p>一開始我要講的是 Form Object，通常是用來處理不同畫面上不同輸入的需求。依照前面的脈絡，物件導向語言的設計大多遵從 <a href="https://zh.wikipedia.org/wiki/SOLID_(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1)" rel="external nofollow noopener noreferrer" target="_blank">SOLID</a> 的原則，不過我們先關注 S（單一功能）這件事情就好了。</p><p>既然叫做 Form Object 也就表示 Form Object 著重在處理使用者填寫表單的輸入，一開始你可能會覺得直接放到 Model 不就好了嗎？</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@post = Post.new(post_params)</span><br><span class="line"><span class="keyword">return</span> redirect_to posts_path <span class="keyword">if</span> @post.save</span><br><span class="line"></span><br><span class="line">render <span class="symbol">:new</span></span><br></pre></td></tr></table></figure><p>大多數時候我們都會這樣寫，不過這建立在的前提就是每次輸入的欄位都相同，假設新增跟編輯可以輸入的欄位有所不同，要怎麼控制？</p><blockquote><p>也許你會想到可以用 Validator 的 <code>on</code> 選定要在 <code>#update</code> 還是 <code>#create</code> 處理，這確實是一個方法，但是如果要判定的基準相對複雜，就不一定這麼方便。</p></blockquote><p>所以我們就會用 Form Object 來輔助。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostUpdateForm</span></span></span><br><span class="line">  <span class="keyword">include</span> ActiveModel::Model</span><br><span class="line">  </span><br><span class="line">  validate <span class="symbol">:content</span>, <span class="symbol">presence:</span> <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">save</span></span></span><br><span class="line">    @post = Post.find(@id)</span><br><span class="line">    </span><br><span class="line">    attrs = attributes.dup</span><br><span class="line">    attrs.delete(<span class="symbol">:id</span>)</span><br><span class="line">    @post.update(attrs)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@form = PostUpdateForm.new(create_params)</span><br><span class="line"><span class="keyword">return</span> render <span class="symbol">:new</span> <span class="keyword">unless</span> @form.valid?</span><br><span class="line"></span><br><span class="line">@form.save</span><br></pre></td></tr></table></figure><p>至少像這樣，我們就可以視情況單獨對某個表單做處理，而且 Model 就從要處理資料的角色，變成單純處理從資料庫進行讀寫以及建立資料關聯的角色。</p><p>至少在某種意義上，Model 的工作更簡單、更單純。</p><h2 id="Context-Object"><a href="#Context-Object" class="headerlink" title="Context Object"></a>Context Object</h2><p>搭配 Form Object 來講一下在我目前負責的其中一個專案，我們拿來處理「查詢資料」的物件類型。如果是在 PHP 中的 Laravel 的話，類似的物件應該會叫做 Repository。</p><p>不過，為什麼會需要 Context Object 呢？在一些比較複雜的系統，我們要處理的查詢條件是非常繁複的，一般的專案可能像是這樣就可以解決。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@posts = Post.where(<span class="symbol">category:</span> <span class="string">'Ruby'</span>)</span><br></pre></td></tr></table></figure><p>不過如果是一些大的系統，要的查詢條件可能會是跨兩三個資料表同時做 JOIN 查詢，再篩選出結果這樣可能就得變成像這樣有大量的判斷。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@posts = Post.all</span><br><span class="line">@posts = @posts.where(<span class="symbol">category:</span> @categories) <span class="keyword">if</span> @categories</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>一方面是看起來不這麼好看，另一方面是可能需要先去從其他資料表篩選出一些資訊才能夠查詢，都塞進去的話 Controller 大概就爆炸了！</p><p>所以我們就會像這樣做改寫</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostContext</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(params)</span></span></span><br><span class="line">    @params = params</span><br><span class="line">    @relation = Post</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">perform</span></span></span><br><span class="line">    scope_by_categories</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    @relation</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">scope_by_categories</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> @params[<span class="symbol">:categories</span>].blank?</span><br><span class="line">    </span><br><span class="line">    categories = Category.where(<span class="symbol">name:</span> @params[<span class="symbol">:categories</span>])</span><br><span class="line">    @relation = @relation.where(<span class="symbol">category:</span> caregories)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如此一來搭配查詢的時候就會像這樣應用</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@context = PostContext.new(params)</span><br><span class="line">@posts = @context.perform</span><br></pre></td></tr></table></figure><p>那麼我們就可以將不同的查詢條件處理實作在 Context 裡面，就不需要在 Controller 裡面實作了！（有點類似 Ransack 的感覺）</p><blockquote><p>有些人會把這類問題都用 Service Object 解決，其實最近處理專案的經驗看起來，如果分不出來該怎麼做，通常就會被當作 Service Object 去做，但是如果類似的邏輯已經很多了，那麼獨立出來成一類有統一行為的物件會是更好的。</p></blockquote><p>不過即使這樣實作，我們還是會遇到兩類問題：</p><ol><li><code>params</code> 的參數不是 Context 想要的</li><li>查詢條件太過複雜</li></ol><p>我們先討論第一點，假設我們只希望使用者查詢一年內的資料，要怎麼限制呢？其實這時候 Form Object 就會再度出場，畢竟他的職責就是處理「使用者的輸入」</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostSearchForm</span></span></span><br><span class="line">  <span class="comment"># 其實這行應該放在 BaseForm</span></span><br><span class="line">  <span class="keyword">include</span> ActiveModel::Model</span><br><span class="line">  </span><br><span class="line">  validate <span class="symbol">:search_ranges</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">search_ranges</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (@end_at - @start_at).to_i.abs &gt; <span class="number">365</span></span><br><span class="line">    </span><br><span class="line">    errors.add(<span class="symbol">:end_at</span>, I18n.t(<span class="string">'.invalid_search_ranges'</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如此一來，我們就可以像這樣使用</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@form = PostSearchForm.new(params)</span><br><span class="line"><span class="keyword">return</span> render <span class="symbol">:index</span> <span class="keyword">unless</span> @form.valid?</span><br><span class="line"></span><br><span class="line">@context = PostContext.new(@form)</span><br><span class="line">@posts = @context.perform</span><br></pre></td></tr></table></figure><p>看起來就會精簡很多，不過 Context 似乎出錯了，因為 Form Object 並沒有 <code>@form[:categories]</code> 這樣行為可以使用，要怎麼解決呢？</p><p>對 Ruby 來說，其實不外乎就是 Duck Typing 的問題，而其他語言來看，其實就是物件有沒有相同的 Interface 而已，我們只需要對 Form Object 做擴充即可。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Form</span></span></span><br><span class="line"> <span class="class"><span class="keyword">module</span> <span class="title">HasHashAccessor</span></span></span><br><span class="line">   extend ActiveSupport::Concern</span><br><span class="line">   </span><br><span class="line">   included <span class="keyword">do</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">[]</span><span class="params">(attribute)</span></span></span><br><span class="line">       instance_variable_get(<span class="string">"@<span class="subst">#&#123;attribute&#125;</span>"</span>)</span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostSearchForm</span></span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">  <span class="keyword">include</span> Form::HasHashAccessor</span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如此一來，就可以用非常漂亮的方式讓 Form / Context / Model 三種物件串連起來一起運作，並且都只處理一種類型的行為。</p><blockquote><p><code>HasHashAccessor</code> 的命名方式是我從之前一個日本客戶的專案學來的，他可以很直觀的告訴我們這個物件上擴充了什麼行為，對 Ruby 語言特性來說會是個比 <code>HashAccessor</code> 這樣單純的命名更加容易理解。</p></blockquote><p>大家可能會疑惑為什麼要在這個時候用 Module 呢？一方面是剛剛有提到，這是一個通用的 Interface 對 Context 來說，拿到的是 Form Object 或者 Params 其實都沒有關係，只要可以用 <code>[]</code> 方法存取他要用來查詢的參數就好了。</p><p>但是 <code>ActionController::Parameters</code> 物件其實不能滿足我們驗證查詢或者預處理之類的行為，那麼交給 Form Object 來做看起來是更恰當的，那麼要滿足 Context 的使用條件，提供他 <code>[]</code> 行為就是合理的，而且這個行為應該只提供給 SearchForm 而非所有的 Form Object。</p><blockquote><p>簡單說對 Ruby 來說就是 Duck Typing 只在意有沒有 <code>[]</code> 方法，其他語言可能就是有沒有實作 <code>[]</code> 行為了！</p></blockquote><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>在我目前的專案其實還有像是 Transformer、Calculator 等等各種類型物件的變化，不過如果每一種都討論的話大概是一篇文章無法討論完全的。</p><p>下一篇就來討論跟呈現資料有關係的 Presenter 和 Decorator 這兩個物件，還有 Context 還可以怎樣做拆分。</p><blockquote><p>要注意的是，不管他是哪類型的物件，其實想要使用都可以使用。只不過這些物件都是在過去經驗總結中，經常會重複使用所以分類出來的物件。照這樣的邏輯來看，只有 Service Object 通常會有 PhotoUploadService 和 PhotoUploader 兩種方式來命名，後者會用這樣的命名邏輯，也許就是當這類物件增加之後，直接分出一類會是更加適合的。</p></blockquote>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2019/05/28/How-to-use-Form-Object-and-others-for-Rails/#disqus_thread</comments>
    </item>
    
    <item>
      <title>利用 Ruby 的 Lambda 做條件判斷</title>
      <link>https://blog.frost.tw/posts/2019/05/20/Use-Ruby-s-Lambda-as-case-when-condition/</link>
      <guid>https://blog.frost.tw/posts/2019/05/20/Use-Ruby-s-Lambda-as-case-when-condition/</guid>
      <pubDate>Mon, 20 May 2019 13:59:53 GMT</pubDate>
      <description>
      
        &lt;p&gt;週末在思考一些 Ruby 特性可以應用的小技巧時，想到龍哥大概跟我講了三次以上的一個特性。&lt;/p&gt;&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;fn = -&amp;gt;(other) &amp;#123; other == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fn == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# =&amp;gt; false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fn === &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# =&amp;gt; true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;剛好最近工作的專案上有個問題，似乎挺適合用這個技巧。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>週末在思考一些 Ruby 特性可以應用的小技巧時，想到龍哥大概跟我講了三次以上的一個特性。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn = -&gt;(other) &#123; other == <span class="number">1</span> &#125;</span><br><span class="line">fn == <span class="number">1</span></span><br><span class="line"><span class="comment"># =&gt; false</span></span><br><span class="line">fn === <span class="number">1</span></span><br><span class="line"><span class="comment"># =&gt; true</span></span><br></pre></td></tr></table></figure><p>剛好最近工作的專案上有個問題，似乎挺適合用這個技巧。</p><a id="more"></a><h2 id="Proc-物件的-方法"><a href="#Proc-物件的-方法" class="headerlink" title="Proc 物件的 === 方法"></a>Proc 物件的 === 方法</h2><p>我們在 Proc 的原始碼可以看到，<code>Proc</code> 類別被特別定義了 <code>#===</code> 方法，但不包括了 <code>#==</code> 方法，而這個 <code>#===</code> 方法又剛好指定成呼叫方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rb_add_method(rb_cProc, rb_intern(<span class="string">"==="</span>), VM_METHOD_TYPE_OPTIMIZED,</span><br><span class="line">truetrue  (<span class="keyword">void</span> *)OPTIMIZED_METHOD_TYPE_CALL, METHOD_VISI_PUBLIC);</span><br></pre></td></tr></table></figure><p>同樣還有像是 <code>#[]</code> 也有類似的性質，簡單說就是 <code>#call</code> 方法的別名。這個使用方式也可以在 <a href="https://ruby-doc.org/core-2.6.2/Proc.html#method-i-3D-3D-3D" rel="external nofollow noopener noreferrer" target="_blank">Ruby Doc</a> 上找到。<br>因為這樣的特性，剛好有些情境就是不錯的應用情況。</p><h2 id="Excel-的產生難題"><a href="#Excel-的產生難題" class="headerlink" title="Excel 的產生難題"></a>Excel 的產生難題</h2><p>最近花了不少時間在幫客戶處理 Excel 報表的生成功能，中間就發現了一個問題，因為客戶的報表有很多種（十幾種）而且需要的欄位又不太一樣，每種都寫一次程式的話其實是很沒有效率的（而且未來還希望能自訂報表的呈現）所以用設定檔方式設計是最適合的，不過產生的 Excel 檔案卻無法指定格式（Ex. 文字、日期）尤其是「日期」客戶每張報表的要求又不太一樣，這讓生成就變成一個難題。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">KPI</span> <span class="string">Report</span></span><br><span class="line"><span class="attr">  columns:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">user_id</span></span><br><span class="line"><span class="attr">      display:</span> <span class="string">User</span> <span class="string">ID</span></span><br><span class="line"><span class="attr">      format:</span> <span class="string">:integer</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">signup_at</span></span><br><span class="line"><span class="attr">      display:</span> <span class="string">Signup</span> <span class="string">At</span></span><br><span class="line"><span class="attr">      format:</span> <span class="string">:datetime</span></span><br><span class="line"><span class="attr">      datetime:</span> <span class="string">:customize</span></span><br><span class="line"><span class="attr">      excel_format:</span> <span class="string">'[$-409]yyyy-MM-dd;@'</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">last_active_at</span></span><br><span class="line"><span class="attr">      display:</span> <span class="string">Last</span> <span class="string">Active</span> <span class="string">At</span></span><br><span class="line"><span class="attr">      format:</span> <span class="string">:datetime</span></span><br><span class="line"><span class="attr">      datetime:</span> <span class="string">:split</span></span><br></pre></td></tr></table></figure><p>以上面這個 YAML 設定檔為例子，客戶可能會希望顯示 <code>yyyy-MM-dd</code> 或者 <code>yyyy-MM-dd</code> + <code>HH:mm</code> 之類的格式，所以在判斷 Excel 要提供怎樣的欄位的時候，就變得相對的複雜。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">formats</span></span></span><br><span class="line">  @columns.map <span class="keyword">do</span> <span class="params">|column|</span></span><br><span class="line">    <span class="keyword">next</span> <span class="keyword">unless</span> column[<span class="symbol">:format</span>] == <span class="symbol">:datetime</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> column[<span class="symbol">:datetime</span>]</span><br><span class="line">    <span class="keyword">when</span> <span class="symbol">:split</span> <span class="keyword">then</span> [@date_format, @time_format]</span><br><span class="line">    <span class="keyword">when</span> <span class="symbol">:customize</span> <span class="keyword">then</span> format(column[<span class="symbol">:excel_format</span>])</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      @date_format</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span>.flatten</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>雖然上面的情況看起來還算單純，不過最後再加入其他不同類型的欄位判斷後，可能就會越來越複雜跟難以辨識。</p><p>在這個狀況下，利用 <code>Proc</code> 的 <code>#===</code> 特性就可能會是一個不錯的作法。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">is_datetime = -&gt;(c) &#123; c[<span class="symbol">:format</span>] == <span class="symbol">:datetime</span> &#125;</span><br><span class="line">is_split_datetime = -&gt;(c) &#123; c[<span class="symbol">:format</span>] == <span class="symbol">:datetime</span> &amp;&amp; c[<span class="symbol">:datetime</span>] == <span class="symbol">:split</span> &#125;</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> column</span><br><span class="line"><span class="keyword">when</span> is_split_datetime <span class="keyword">then</span> [@date_format, @time_format]</span><br><span class="line"><span class="keyword">when</span> is_datetime <span class="keyword">then</span> @date_format</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>不過這實際上並無法解決有很多複雜情況的時候，不過既然我們已經知道了 <code>#===</code> 在 <code>case ... when</code> 上可以發揮作用，那麼是否可以進一步封裝呢？</p><h2 id="自訂物件"><a href="#自訂物件" class="headerlink" title="自訂物件"></a>自訂物件</h2><p>假設我們有個可以把設定檔轉成 <code>ExcelColumn</code> 物件的設計，也許可以像這樣實作。</p><p>先定義 <code>ExcelColumn</code> 物件，而且可以被做 <code>Pattern Matching</code>（簡易版）然後在提供回傳對應的格式跟數值的機制。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExcelColumn</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(format = <span class="literal">nil</span>, **pattern, &amp;block)</span></span></span><br><span class="line">    @name = name</span><br><span class="line">    @format = format</span><br><span class="line">    @pattern = pattern</span><br><span class="line">    @value_of = block</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">===</span><span class="params">(other)</span></span></span><br><span class="line">    @pattern.reduce(<span class="literal">true</span>) <span class="keyword">do</span> <span class="params">|prev, (key, value)|</span></span><br><span class="line">      prev &amp; (other[key] == value)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">format</span></span></span><br><span class="line">    <span class="keyword">return</span> @format <span class="keyword">if</span> @format.<span class="literal">nil</span>? <span class="params">||</span> @format.is_a?(Symbol)</span><br><span class="line">    </span><br><span class="line">    format(@format) <span class="comment"># Customize Format</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">value</span><span class="params">(name, row)</span></span></span><br><span class="line">    <span class="keyword">return</span> row.send(name) <span class="keyword">if</span> @value_of.<span class="literal">nil</span>?</span><br><span class="line">    </span><br><span class="line">    @value_of.call(name, row)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>然後再設計 DSL 讓我們可以定義需要的格式。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExcelGenerator</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> &lt;&lt; self</span></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:patterns</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pattern</span><span class="params">(format, **pattern, &amp;block)</span></span></span><br><span class="line">      @patterns <span class="params">||</span>= []</span><br><span class="line">      @patterns &lt;&lt; ExcelColumn.new(name, format, pattern, &amp;block)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">columns</span></span></span><br><span class="line">    @columns <span class="params">||</span>=</span><br><span class="line">      @config.columns.map <span class="keyword">do</span> <span class="params">|column|</span></span><br><span class="line">        [</span><br><span class="line">         column,</span><br><span class="line">         <span class="keyword">self</span>.patterns.find &#123; <span class="params">|pattern|</span> pattern === column &#125; <span class="params">||</span> ExcelColumn.new</span><br><span class="line">        ]</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>接下來就可以在實際使用時，像這樣去拓展 Excel 產生器，然後定義我們所需要的報表格式生成。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExcelReportGnerator</span> &lt; ExcelGenerator</span></span><br><span class="line">  pattern format(<span class="symbol">:date</span>), <span class="symbol">datetime:</span> <span class="symbol">:date</span> <span class="keyword">do</span> <span class="params">|name, row|</span></span><br><span class="line">    row.send(name)&amp;.to_datetime</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如此一來就能夠利用 DSL 跟 <code>#===</code> 的特性，針對我們需要有特殊格式的欄位挑選出來，然後給予特定的規則來產生對應的 Excel Cell 設定。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">insert_header(headers)</span><br><span class="line"></span><br><span class="line">formats = columns.map(&amp;<span class="symbol">:last</span>).map(&amp;<span class="symbol">:format</span>)</span><br><span class="line">rows.each <span class="keyword">do</span> <span class="params">|row|</span></span><br><span class="line">  items = columns.map &#123; <span class="params">|column, pattern|</span> pattern.value_of(column[<span class="symbol">:name</span>], row) &#125;</span><br><span class="line">  insert_row(items, <span class="symbol">formats:</span> formats)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>最後實作的版本其實還是一個構想，畢竟這樣的情境是不常使用到的，不過在某些時候似乎又是個非常有用的小技巧。而這樣的構想是否適合這樣使用，以及能不能有更好的改進（例如一開始就直接定義好對應的欄位類型物件，而不要像這樣動態的定義）都還要再討論。</p><p>不過在 Ruby 中確實有不少有趣的應用技巧，多多挖掘的話其實能在不少不同的應用情況下用足夠簡單的方式實現，而不是繞一大圈去做。</p><p>更重要的是，這些技巧往往會是在時間緊迫下的輔助，有些功能透過這些技巧就可以很快地實現，而將時間投資在其他地方，而不是只能用一些折衷的方案暫時做好，之後再回來慢慢修改。</p><blockquote><p>這是最近做專案的心得，因為客戶是新成立的部門很需要有一個實績，所以開發上難免偏向以開發進度為主。很多其實花時間思考後能做更好的部分，就這樣變成技術債了⋯⋯</p></blockquote>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2019/05/20/Use-Ruby-s-Lambda-as-case-when-condition/#disqus_thread</comments>
    </item>
    
    <item>
      <title>如何在沒有任何設定下產生 Rails 的 Docker Image</title>
      <link>https://blog.frost.tw/posts/2019/03/20/The-zero-configure-dockerfile-for-rails/</link>
      <guid>https://blog.frost.tw/posts/2019/03/20/The-zero-configure-dockerfile-for-rails/</guid>
      <pubDate>Wed, 20 Mar 2019 15:37:22 GMT</pubDate>
      <description>
      
        &lt;p&gt;前陣子看到 &lt;a href=&quot;https://thoughtbot.com/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Throughbot&lt;/a&gt; 這間在 Ruby 圈 算是蠻有名的公司做了一個叫做 &lt;a href=&quot;https://github.com/thoughtbot/suspenders&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Suspenders&lt;/a&gt; 的 Gem 主要是對 Rails 擴充，簡單說就是基於原本的 &lt;code&gt;rails new&lt;/code&gt; 做了一個替代品，而這個替代品會自動幫你先做好一些原本要手動做的事情。&lt;/p&gt;&lt;p&gt;像是安裝好常用的 Gem、套版之類的，想了一下覺得&lt;a href=&quot;https://5xruby.tw&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;五倍&lt;/a&gt;其實也很需要，不少新專案也都是從我這邊經手初始化的，有一個這樣的工具會省下不少時間。&lt;/p&gt;&lt;p&gt;所以 &lt;a href=&quot;https://github.com/5xRuby/bankai&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Bankai&lt;/a&gt; （卍解） 這個 Gem 就樣做出來了，裡面基本上就是設置好在五倍大多數時候用的標配 Ex. GitLab CI 設定、RSpec 等等&lt;/p&gt;&lt;p&gt;但是又發現好像不太夠用，有些時候有 Docker 會方便很多，但是 Bankai 現在做不到！&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>前陣子看到 <a href="https://thoughtbot.com/" rel="external nofollow noopener noreferrer" target="_blank">Throughbot</a> 這間在 Ruby 圈 算是蠻有名的公司做了一個叫做 <a href="https://github.com/thoughtbot/suspenders" rel="external nofollow noopener noreferrer" target="_blank">Suspenders</a> 的 Gem 主要是對 Rails 擴充，簡單說就是基於原本的 <code>rails new</code> 做了一個替代品，而這個替代品會自動幫你先做好一些原本要手動做的事情。</p><p>像是安裝好常用的 Gem、套版之類的，想了一下覺得<a href="https://5xruby.tw" rel="external nofollow noopener noreferrer" target="_blank">五倍</a>其實也很需要，不少新專案也都是從我這邊經手初始化的，有一個這樣的工具會省下不少時間。</p><p>所以 <a href="https://github.com/5xRuby/bankai" rel="external nofollow noopener noreferrer" target="_blank">Bankai</a> （卍解） 這個 Gem 就樣做出來了，裡面基本上就是設置好在五倍大多數時候用的標配 Ex. GitLab CI 設定、RSpec 等等</p><p>但是又發現好像不太夠用，有些時候有 Docker 會方便很多，但是 Bankai 現在做不到！</p><a id="more"></a><p>所以 Bankai Docker 這個外掛就這樣在一週左右完成原型的製作，作為 Bankai 的額外擴充被支援了！</p><h2 id="特色"><a href="#特色" class="headerlink" title="特色"></a>特色</h2><p>Bankai Docker 目前功能還很陽春，不過對於大多數情況應該都是夠用的。</p><p>產生的 Docker Image 大小會落在 180MB 上下，主要是因為 Ruby + Node.js 約 80MB 剩下的則是安裝的 Gem 所佔用的，以一個 Docker Image 來說不算輕量，但也在可以接受的範圍內。</p><p>主要的特色是<strong>不用任何設定</strong>，也就是說在安裝好 Bankai Docker 後，直接執行 <code>rake docker:build</code> 你的專案就會自動被打包好，而且馬上可以使用。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>目前還在考慮是否要能獨立運作，不過預設是相依 Bankai 的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安裝 Bankai</span></span><br><span class="line">gem install bankai</span><br><span class="line"></span><br><span class="line"><span class="comment"># 開啟新專案</span></span><br><span class="line">bankai dockerize</span><br></pre></td></tr></table></figure><p>這樣就能產生一個全新的 Rails 專案（五倍版）目前還沒有支援 <code>rails g bankai:docker</code> 的選項，所以先手動把 <code>bankai-docker</code> 加入到 Gemfile 裡面。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">group <span class="symbol">:development</span> <span class="keyword">do</span></span><br><span class="line"> <span class="comment"># ... 略</span></span><br><span class="line"> gem <span class="string">'bankai'</span></span><br><span class="line"> gem <span class="string">'bankai-docker'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>接下來跑一下 <code>bundle install</code> 就安裝完畢了！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安裝 Bankai Docker 到專案中</span></span><br><span class="line">bundle install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包 Docker Image</span></span><br><span class="line">rake docker:build</span><br></pre></td></tr></table></figure><p>好像什麼事情都沒做就產生 Docker Image 對吧？我想要的就是這種感覺！！</p><h2 id="DSL"><a href="#DSL" class="headerlink" title="DSL"></a>DSL</h2><p>自動化的設定總是會有限制，所以在設計的時候已經預先想好可以透過 <code>config/docker.rb</code> 這個設定檔來寫 DSL 用來修改原本的行為。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rails g bankai:docker:install</span><br></pre></td></tr></table></figure><p>這個指令可能會替換掉，跑完之後會把原本放在 Gem 裡面的 <code>docker.rb</code> 放到 <code>config/docker.rb</code> 裡面，然後我們就可以安心的來修改了！</p><p>像是預設的 Docker Image 會是 <code>$(whoami)/APP_NAME</code> 以剛剛的範例就會是 <code>elct9620/dockerize</code> 一般情況可能沒什麼問題，但是如果像我想要用五倍內部的 Registry 伺服器，這個命名就不適合了！</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bankai::Docker.setup <span class="keyword">do</span></span><br><span class="line">  name <span class="string">'registry.5xruby.tw/elct9620/dockerize'</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 略</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>簡單來說，要在預設的 DSL 設定裡面補上這個 <code>name</code> 設定，就可以修改預設的 Docker Image 名稱，大致上就是這樣使用的。</p><p>因為新版本的 Docker 多了叫做 Multi Stage 的機制，所以我們可以把 <code>bundle install</code> 的步驟放到一個單獨的 <code>stage</code> 編譯好後再複製到主體，這樣就可以省下很多空間（因為不用安裝額外的套件）</p><p>所以 DSL 的結構就會像這樣：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Bankai::Docker.setup <span class="keyword">do</span></span><br><span class="line">  stage <span class="symbol">:gem</span> <span class="keyword">do</span></span><br><span class="line">   <span class="comment"># ...</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">  </span><br><span class="line">  main <span class="keyword">do</span></span><br><span class="line">   <span class="comment"># ...</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在 Stage 中就可以使用對應 Docker 原本有的指令，像是 <code>RUN bundle install</code> 會對應成 <code>run &#39;bundle install</code> 目前大多數都支援，還有少部分之後會慢慢補齊。</p><p>如此一來，我們就可以很簡單的去修改原本 Docker 建置的過程。</p><blockquote><p>目前還不支援預設值，後續的改版會簡化為如果不修改 gem / node / main 三個預設設定，就不用寫出來去覆蓋。</p></blockquote><h2 id="Auto-Package"><a href="#Auto-Package" class="headerlink" title="Auto Package"></a>Auto Package</h2><p>有一些 Gem 會需要先安裝好一些套件才能使用，像是 <code>pg</code> 和 <code>mysql2</code> 這兩個大家常用的資料庫套件，為了可以無視這些設定，所以透過「工人智慧」我們可以用 DSL 去定義偵測條件，自動的安裝套件。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Bankai::Docker.setup <span class="keyword">do</span></span><br><span class="line">  detect_package <span class="symbol">:database</span>, <span class="symbol">:gem</span> <span class="keyword">do</span> <span class="params">|package|</span></span><br><span class="line">    <span class="keyword">if</span> pg?</span><br><span class="line">      package.add_dependency <span class="string">'postgresql-dev'</span>, <span class="symbol">runtime:</span> <span class="literal">false</span></span><br><span class="line">      package.add_runtime_dependency <span class="string">'postgresql-libs'</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> mysql?</span><br><span class="line">      package.add_dependency <span class="string">'mariadb-dev'</span>, <span class="symbol">runtime:</span> <span class="literal">false</span></span><br><span class="line">      package.add_runtime_dependency <span class="string">'mariadb-client-libs'</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>像是上面這樣，我們可以在 <code>gem</code> 這個階段增加 <code>postgresql-dev</code> 套件，而實際執行的時候只使用 <code>postgresql-libs</code> 如此一來就可以盡可能的縮小最後產出的檔案大小。</p><blockquote><p>上面是節錄自 <a href="https://github.com/5xRuby/bankai-docker/blob/master/templates/auto_package.rb" rel="external nofollow noopener noreferrer" target="_blank">templates/auto_package.rb</a> 這個檔案，如果有一些常用的套件需要增加，可以送 PR 給我們。</p></blockquote><h2 id="COPY-FROM"><a href="#COPY-FROM" class="headerlink" title="COPY FROM"></a>COPY FROM</h2><p>另外一個比較困擾的是 <code>COPY --from=gem</code> 這指令，如果要手動下在 <code>main</code> 的話其實有點麻煩，所以就提供了 <code>produce</code> 這個 DSL 來輔助。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stage <span class="symbol">:node</span>, <span class="symbol">from:</span> <span class="string">'node:10.15.2-alpine'</span> <span class="keyword">do</span></span><br><span class="line">  run <span class="string">'mv /opt/yarn-v$&#123;YARN_VERSION&#125; /opt/yarn'</span></span><br><span class="line"></span><br><span class="line">  produce <span class="string">'/usr/local/bin/node'</span></span><br><span class="line">  produce <span class="string">'/opt/yarn'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>像是這邊我們處理好 Node.js 之後，要讓最後產出能有 <code>/usr/local/bin/node</code> 這個檔案和 <code>/opt/yarn</code> 目錄，我們就可以用 <code>produce</code> 告訴 Bankai Docker 要在最後產出時自動給這樣指令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY --from=node /usr/local/bin/node /usr/local/bin/node</span><br><span class="line">COPY --from=node /opt/yarn /opt/yarn</span><br></pre></td></tr></table></figure><p>如此一來就省事很多，在處理 Docker Image 生成的不少小細節都已經先在 Bankai Docker 做掉（像是 <code>.dockerignore</code> 的設定等等）使用起來就比自己寫 Dockerfile 快上非常多。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>以前常想「資深工程師」有哪些特質，其中一個我認為有的特質就是能製作「順手」的工具，畢竟當你有自己的一套方法現有的預設做法或者一些設定，就不一定符合需求。雖然能製作自己使用的工具不代表有資深工程師的實力，不過開始有這樣的需求時，應該就是走在這條路上了吧！</p><p>當這個 Gem 成型之後，其實後面還有更厲害的組合應用還沒完成，下次有機會的話會再跟大家分享怎麼用這樣的特性做 DevOps 來改善開發流程。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2019/03/20/The-zero-configure-dockerfile-for-rails/#disqus_thread</comments>
    </item>
    
    <item>
      <title>我在 Ruby 埋了一個陷阱 - Signal 的應用</title>
      <link>https://blog.frost.tw/posts/2019/03/12/I-make-a-trap-in-the-Ruby-the-usage-of-Signal/</link>
      <guid>https://blog.frost.tw/posts/2019/03/12/I-make-a-trap-in-the-Ruby-the-usage-of-Signal/</guid>
      <pubDate>Tue, 12 Mar 2019 13:29:15 GMT</pubDate>
      <description>
      
        &lt;p&gt;在 Ruby 之中，其實隱藏了很多非常實用的標準函式庫，而 Signal 就是其中一個。&lt;/p&gt;&lt;p&gt;我們在寫 Ruby 大多數時候都是 Ruby on Rails 框架的應用，但是你們有想過當我們在一些 Gem 運行的時候，使用 Ctrl + C 為什麼不會出現錯誤嗎？&lt;/p&gt;&lt;p&gt;例如我們常常用到的 &lt;code&gt;irb&lt;/code&gt; 和 &lt;code&gt;pry&lt;/code&gt; 為什麼按下 Ctrl + C 的時候不是直接中斷，卻還能繼續運作？&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>在 Ruby 之中，其實隱藏了很多非常實用的標準函式庫，而 Signal 就是其中一個。</p><p>我們在寫 Ruby 大多數時候都是 Ruby on Rails 框架的應用，但是你們有想過當我們在一些 Gem 運行的時候，使用 Ctrl + C 為什麼不會出現錯誤嗎？</p><p>例如我們常常用到的 <code>irb</code> 和 <code>pry</code> 為什麼按下 Ctrl + C 的時候不是直接中斷，卻還能繼續運作？</p><a id="more"></a><h2 id="常駐程式"><a href="#常駐程式" class="headerlink" title="常駐程式"></a>常駐程式</h2><p>一般來說我們很少會用 Ruby 寫一個常駐程式（Daemon）不過有時候我們希望持續的抓資料或者監聽一個 Socket 的時候，還是會需要用到類似下面這樣的實作。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">loop <span class="keyword">do</span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>當我們跑起來之後，用 Ctrl + C 去中斷的話，就會出現類似下面的錯誤訊息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">        2: from loop.rb:3:in `&lt;main&gt;&apos;</span><br><span class="line">        1: from loop.rb:3:in `loop&apos;</span><br><span class="line">loop.rb:5:in `block in &lt;main&gt;&apos;: Interrupt</span><br></pre></td></tr></table></figure><p>這是因為我們的程式在未預期的狀況下被「中斷（Interrupt）」的關係。</p><h2 id="Signal"><a href="#Signal" class="headerlink" title="Signal"></a>Signal</h2><p>在很多 Unix 作業系統中，我們可以對任一一個執行中的程式（Process）發送一個 Signal 來告訴這個程式該做什麼。</p><p>也因此，我們可以從<a href="https://zh.wikipedia.org/wiki/Unix%E4%BF%A1%E5%8F%B7" rel="external nofollow noopener noreferrer" target="_blank">維基百科</a>的解說其實可以了解到，平常我們很習慣的 Ctrl + C 其實就是發送訊號的動作，而這個訊號剛好就是 SIGINT （中斷訊號）</p><p>另一方面，我們的程式卡住又無法關閉的時候，也會使用 <code>kill</code> 指令來強致終止程式，其實也是對程式發送訊號的一種形式。</p><p>像是我想要終止 PID 1000 的程式，可以像這樣下指令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -int 1000</span><br></pre></td></tr></table></figure><p>如此一來就可以發送一個 SIGINT 給 PID 1000 的程式。</p><p>由此可見，有很多我們平常在使用的東西都有支援接收訊號，例如 Nginx 的<a href="https://nginx.org/en/docs/control.html" rel="external nofollow noopener noreferrer" target="_blank">文件</a>就有說明哪些訊號可以做哪些事情。</p><p>像是 <code>SIGHUP</code> 可以讓 Nginx 重新讀取設定檔，也就是 <code>nginx -s reload</code> 的指令（雖然大多數時候我們可能都會直接重開 Nginx 吧⋯⋯）</p><p>有了這些概念後，我們就可以用 Ruby 提供的 Signal 來做一些應用。</p><h2 id="Graceful-Shutdown"><a href="#Graceful-Shutdown" class="headerlink" title="Graceful Shutdown"></a>Graceful Shutdown</h2><p>當我們在執行一個迴圈處理事情的時候，如果遇到中斷的情況，很有可能會沒有把事情做完。</p><p>例如我們嘗試插入三筆資料到資料庫，到第二筆的時候就被中斷，那麼就會損失第三筆資料，而且下次重新執行的時候就會有錯誤的結果。</p><blockquote><p>這個情況實務上應該是要善用資料庫的 Transaction （交易）功能，來確保該做的事情都完成後一起 Commit （確認）</p></blockquote><p>所以，要避免一些「不應該直接被中斷」的情況，我們就可以善用 <code>Signal.trap</code> 這個方法。</p><p>稍微改良一下文章一開始的無限迴圈，變成像這樣：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">running = <span class="literal">true</span></span><br><span class="line">Signal.trap(<span class="symbol">:INT</span>) &#123; running = <span class="literal">false</span> &#125;</span><br><span class="line"></span><br><span class="line">loop <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">break</span> <span class="keyword">unless</span> running</span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>按下 Ctrl + C 就不會有任何錯誤，因為對 Ruby 來說他還是確實的執行完畢一個迴圈才停止，而不是跑到一半就被直接中斷。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>這算是一個超級冷知識吧，不過大多數的程式語言其實都有提供這樣的機制。而且這個功能其實也很好用，例如我們可以做一個 Ctrl + C 兩次才離開的功能。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">try_exit = <span class="number">0</span></span><br><span class="line">Signal.trap(<span class="symbol">:INT</span>) <span class="keyword">do</span></span><br><span class="line">  try_exit += <span class="number">1</span></span><br><span class="line">  puts <span class="string">"Are you sure exit? Press Ctrl + C Again"</span> <span class="keyword">if</span> try_exit == <span class="number">1</span></span><br><span class="line">  running = <span class="literal">true</span> <span class="keyword">if</span> try_exit == <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">loop <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">break</span> <span class="keyword">if</span> try_exit == <span class="number">2</span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如此一來，我們就可以有效的避免程式意外中斷。</p><blockquote><p>剩下要擔心的大概就是停電或者被強制中開機的狀況了吧⋯⋯</p></blockquote><p>另外 Ruby 還有一個叫做 <code>at_exit</code> 的方法，之後機會可以來和 Signal 比較一下使用情境上的差異。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2019/03/12/I-make-a-trap-in-the-Ruby-the-usage-of-Signal/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Rails 串接 ProxmoxVE API 自動化教學用虛擬機分配</title>
      <link>https://blog.frost.tw/posts/2019/02/19/Automatic-VM-allocate-using-Proxmox-VE-and-Rails/</link>
      <guid>https://blog.frost.tw/posts/2019/02/19/Automatic-VM-allocate-using-Proxmox-VE-and-Rails/</guid>
      <pubDate>Tue, 19 Feb 2019 11:41:59 GMT</pubDate>
      <description>
      
        &lt;p&gt;之前有一段時間因為用 KVM 手動管理&lt;a href=&quot;https://5xruby.tw&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;五倍&lt;/a&gt;的虛擬機花上不少時間，評估之後我們就調整成 ProxmoxVE 來管理，至少在大多數的情況有 GUI 是很方便的。&lt;/p&gt;&lt;p&gt;不過使用的權限還是限制在有權限管理機器的人身上，最近剛好有不少新同事加入，想讓他們練習部署伺服器。&lt;/p&gt;&lt;p&gt;所以就有了這樣的問題：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;可以讓同事自己申請虛擬機來練習嗎？&lt;/strong&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>之前有一段時間因為用 KVM 手動管理<a href="https://5xruby.tw" rel="external nofollow noopener noreferrer" target="_blank">五倍</a>的虛擬機花上不少時間，評估之後我們就調整成 ProxmoxVE 來管理，至少在大多數的情況有 GUI 是很方便的。</p><p>不過使用的權限還是限制在有權限管理機器的人身上，最近剛好有不少新同事加入，想讓他們練習部署伺服器。</p><p>所以就有了這樣的問題：</p><p><strong>可以讓同事自己申請虛擬機來練習嗎？</strong></p><a id="more"></a><p>其實算是很簡單的，只要會最基本的 Ruby 就能夠把這些東西串起來。不過因為有一些非同步操作，所以我們會需要把一些「觀念」放下，才可以在快速打造原型的時候用最簡單的方式呈現。</p><p>開始之前先看一下週末大概一天多的快速原型長怎樣</p><p><img src="https://blog.frost.tw/images/2019-02-19-automatic-vm-allocate-using-proxmox-ve-and-rails/B1C5927BAA75A6CBB07D220E20B5E687.png" alt="螢幕快照 2019-02-18 上午12.34.25.png"></p><blockquote><p>ProxmoxVE 的 Rollback 機制似乎連選項都會 Rollback 所以正在跑那台又被改回去原本設定的名字了⋯⋯</p></blockquote><p><img src="https://blog.frost.tw/images/2019-02-19-automatic-vm-allocate-using-proxmox-ve-and-rails/6A5F3F8546357A6AC62C7EB32DC5033D.png" alt="螢幕快照 2019-02-18 上午12.34.37.png"></p><h2 id="ProxmoxVE-的-Ticket-機制"><a href="#ProxmoxVE-的-Ticket-機制" class="headerlink" title="ProxmoxVE 的 Ticket 機制"></a>ProxmoxVE 的 Ticket 機制</h2><p>我們以往在串接 API 時會很習慣用 API Token 之類的呼叫 API 但是 ProxmoxVE 用了一個有點微妙的方式，就是提供了一個「可以得到 Cookie 的 API」讓我們來生成叫做 Ticket 的東西。</p><p>簡單說我們要用 Ticket API 用帳號密碼登入，然後拿到一段 Cookie 的數值在需要登入的 API 時一起送過去。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'net/http'</span></span><br><span class="line">rquire <span class="string">'oj'</span></span><br><span class="line"></span><br><span class="line">uri = URI(<span class="string">'https://192.168.100.220:8006/api2/json/access/ticket'</span>)</span><br><span class="line">req = Net::HTTP::Post.new</span><br><span class="line">req[<span class="string">'Content-Type'</span>] = <span class="string">'application/x-www-form-urlencoded'</span></span><br><span class="line">req.body = URI.encode_www_form(<span class="symbol">username:</span> <span class="string">'xxx@pve'</span>, <span class="symbol">password:</span> <span class="string">'xxx'</span>)</span><br><span class="line"></span><br><span class="line">token = &#123;&#125;</span><br><span class="line">Net::HTTP.start(uri.host, uri.port, <span class="symbol">use_ssl:</span> <span class="literal">true</span>) <span class="keyword">do</span> <span class="params">|http|</span></span><br><span class="line">  res = http.request(req)</span><br><span class="line"></span><br><span class="line">  token = Oj.load(res.body)&amp;.fetch(<span class="string">'data'</span>, &#123;&#125;)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">puts token[<span class="string">'ticket'</span>] <span class="comment"># =&gt; XXXX</span></span><br><span class="line">puts token[<span class="string">'CSRFPreventionToken'</span>] <span class="comment"># =&gt; XXX</span></span><br></pre></td></tr></table></figure><p>大致上使用方式就是，如果是 GET 請求只要在 Cookie 中帶有回傳的 Ticket 數值即可，如果是 POST 請求的話，還要額外在 Header 加上 CSRFPreventionToken 才行。</p><blockquote><p>這邊有幾點要注意跟可以善用：</p><ol><li>如果你的 ProxmoxVE 跟我們一樣是在內網，你需要讓 Ruby 的 Net::HTTP 不要見證 SSL</li><li>ProxmoxVE 有提供 ACL 的機制，所以我先針對可以用的機器開了專用的群組分配了足夠的權限，避免影響其他人</li></ol></blockquote><h2 id="呼叫其他-API"><a href="#呼叫其他-API" class="headerlink" title="呼叫其他 API"></a>呼叫其他 API</h2><p>可以順利取得 Token 後，就可以參考<a href="https://pve.proxmox.com/pve-docs/api-viewer/index.html" rel="external nofollow noopener noreferrer" target="_blank">官方的文件</a>來實作各類的 API 雖然有點說明不清楚，但是透過幾次嘗試多少還是堪用的。</p><p>為了要可以正常的呼叫，我們需要對 Request 補上 Cookie 資訊：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 略</span></span><br><span class="line"></span><br><span class="line">req = Net::HTTP::Get.new(uri)</span><br><span class="line">req[<span class="string">'Cookie'</span>] = <span class="string">"PVEAuthCookie=<span class="subst">#&#123;token[<span class="string">'ticket'</span>]&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 略</span></span><br></pre></td></tr></table></figure><p>其實很簡單，在 HTTP 請求裡面 <code>Cookie</code> Header 表示的是用戶已知的 Cookie 資訊，用來傳給伺服器。而收到回應時 <code>Set-Cookie</code> 則是要求用戶更新 Cookie 資訊。</p><p>掌握好之後，在寫一些網路爬蟲的時候，就能很簡單的做到模擬登入的效果。</p><p>如果是要發送 POST 類型的請求，則是在補上 CSRF 對應的 Header 即可</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 略</span></span><br><span class="line"></span><br><span class="line">req = Net::HTTP::Post.new(uri)</span><br><span class="line">req[<span class="string">'Cookie'</span>] = <span class="string">"PVEAuthCookie=<span class="subst">#&#123;token[<span class="string">'ticket'</span>]&#125;</span>"</span></span><br><span class="line">req[<span class="string">'CSRFPreventionToken'</span>] = token[<span class="string">'CSRFPreventionToken'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 略</span></span><br></pre></td></tr></table></figure><p>礙於篇幅的關係，在這之前我已經簡單封裝好了一個叫做 <code>Proxmox::API</code> 來管理 API 請求，以及幾個「假 Model」來封裝成對應的行為，像是上一段提到的 Ticket 變成像這樣</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxmox::API.ticket = Proxmox::Ticket.create(<span class="string">'user@pve'</span>, <span class="string">'password'</span>)</span><br></pre></td></tr></table></figure><p>後面的文章會直接用這個封裝過的行為來示範，如果想知道細節的話我們可以在其他文章中再做討論。</p><h2 id="非同步行為"><a href="#非同步行為" class="headerlink" title="非同步行為"></a>非同步行為</h2><p>不過，像是虛擬機的開關機其實都是非同步的行為。</p><p>也就是說，像是我做了這樣的呼叫：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Proxmox::API.post(<span class="string">'nodes/pve/100/status/start'</span>)</span><br><span class="line">            .fetch(<span class="symbol">:data</span>)</span><br><span class="line"><span class="comment"># =&gt; UPID:pve:00001560:3C9C598C:5C6944F7:qmstart:100:user<span class="doctag">@pve</span>:</span></span><br></pre></td></tr></table></figure><blockquote><p>裡面的 <code>pve</code> 是節點的名稱，而 <code>100</code> 是虛擬機的編號</p></blockquote><p>會得到一個叫做 UPID 的回傳，而這個回傳數值是表示在 ProxmoxVE 中的某個 Task （任務）我們可以透過兩種 API 來查詢：</p><ol><li><code>cluster/tasks</code></li><li><code>nodes/{node}/tasks/{upid}/status</code></li></ol><p>要注意的是第一種只會得到大概，而且最近（一段時間後會被刪掉）的任務資訊，而第二個需要知道確切的 Node 和 UPID 才能夠拿到。</p><p>也就是說，我們想知道「開機」有沒有執行完成，需要做像這樣的設計</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(node, upid)</span></span></span><br><span class="line">  Proxmox::API.get(<span class="string">"nodes/<span class="subst">#&#123;node&#125;</span>/tasks/<span class="subst">#&#123;upid&#125;</span>/status"</span>)</span><br><span class="line">              .dig(<span class="symbol">:data</span>, <span class="symbol">:status</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">upid = start(<span class="string">'pve'</span>, <span class="string">'100'</span>) <span class="comment"># 開機</span></span><br><span class="line">loop <span class="keyword">do</span></span><br><span class="line">  status = task(<span class="string">'pve'</span>, upid)</span><br><span class="line">  <span class="keyword">break</span> <span class="keyword">if</span> status[<span class="string">'exitstatus'</span>] == <span class="string">'OK'</span></span><br><span class="line">  sleep <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 開機完成</span></span><br></pre></td></tr></table></figure><p>不過這會遇到一個問題，就是「如果錯誤或者沒有結果」那麼我們的程式就會被卡在無限迴圈之中，這樣在 Rails 端就會有一個 HTTP 請求被卡住。</p><p>這時候我們可以利用 Ruby 的 <code>Timeout</code> 機制</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'timeout'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 略</span></span><br><span class="line">Timeout::timeout(<span class="number">30</span>) <span class="keyword">do</span></span><br><span class="line"> loop <span class="keyword">do</span></span><br><span class="line">   <span class="comment"># 略</span></span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># 略</span></span><br></pre></td></tr></table></figure><p>如此一來，假設執行超過 30 秒，就會因為收到 <code>Timeout::Error</code> 的超時錯誤，強制終止這段程式。</p><blockquote><p>超時之後可以再對機器下過像是 <code>stop</code> 之類的指令關機，避免佔用資源</p></blockquote><h2 id="自動還原"><a href="#自動還原" class="headerlink" title="自動還原"></a>自動還原</h2><p>ProxmoxVE 裡面提供了 Backup 和 Snapshot 兩種備份方式，不過 API 只有 Snapshot 可以選用。</p><p>要注意的是在製作 Snapshot 之前除了機器要安裝好之外，也要記得將像是 Options 裡面的各項設定都調整好，不然我們會因為在 Rollback 的過程中，讓設定跑回原本的舊設定。</p><p>Snapshot 還原的 API 會是像這樣：<code>nodes/{node}/qemu/{vmid}/snapshot/{name}/rollback</code></p><p>因為我們是練習用的虛擬機，所以直接在設定好的環境下，製作一個叫做 <code>initialize_state</code> 的 Snapshot 統一還原回去就可以了！</p><blockquote><p>或者你會想要做更複雜的管理，不過對我們來說這樣就是堪用的。</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">upid = Proxmox::API.post(<span class="string">'nodes/pve/qemu/100/snapshot/initialize_state/rollback'</span>)</span><br><span class="line"><span class="comment"># 等待完成</span></span><br></pre></td></tr></table></figure><p>做 Snapshot 的 Rollback 是非同步的（要先關機再把資料寫回去）所以會比開機之類的還要等稍微久一點，不過用跟上一段提到的 <code>Timeout</code> 機制就可以做到在還原會繼續動作的設計。</p><h2 id="自動安裝-SSH-Key"><a href="#自動安裝-SSH-Key" class="headerlink" title="自動安裝 SSH Key"></a>自動安裝 SSH Key</h2><p>另外一個難題是裝好的機器其實誰都 SSH 不進去，對我們來說 VNC 串接似乎也比較麻煩。</p><p>還好使用 Qemu 有一個叫做 Qemu Guest Agent 的背景程序，我們可以透過安裝這個程序進行「裡應外合」讓我們可以存取到和操作虛擬機內的部分功能。</p><p>因為我們習慣使用 CentOS 所以可以用 YUM 來安裝。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install qemu-guest-agent</span><br></pre></td></tr></table></figure><p>重開機後如果在 ProxmoxVE 上看到這樣的訊息，就算是成功了！</p><p><img src="https://blog.frost.tw/images/2019-02-19-automatic-vm-allocate-using-proxmox-ve-and-rails/912F134AB7BBA01EFA083119460302AB.png" alt="螢幕快照 2019-02-18 上午1.09.10.png"></p><p>不過，要能自動寫入 SSH Key 還有一個問題，因為 Qemu Guest Agent 雖然提供寫入檔案的功能，但是會受到以下限制：</p><ol><li>設定檔預設不開放使用</li><li>SELinux 會阻止你寫入某些檔案</li><li>必須是存在的檔案（至少讀取是）</li></ol><p>所以我們要先做幾件事情：</p><ol><li>修改 <code>/etc/sysconfig/qemu-ga</code> 把 BLACKLIST 註解掉（練習用的機器安全性就放一邊吧！）</li><li>修改 <code>/etc/selinux/config</code> 把 SELinux 設定成 <code>disabled</code> 狀態</li><li>產生一個空的 <code>/root/.ssh/authorized_keys</code> 檔案</li></ol><blockquote><p>要確定 <code>/root/.ssh</code> 目錄權限是 700 而 <code>authorized_keys</code> 檔案權限是 600 不然 SSH 是會因為權限設定錯誤而無法登入！</p></blockquote><p>前置動作就緒，也重開機讓設定確實生效之後，就可以透過 API 來寫入檔案</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Proxmox::API</span><br><span class="line">  .post(</span><br><span class="line">    <span class="string">'nodes/pve/qemu/100/agent/file-write'</span>,</span><br><span class="line">    <span class="symbol">file:</span> <span class="string">'/root/.ssh/authorized_keys'</span>,</span><br><span class="line">    <span class="symbol">content:</span> <span class="string">'...'</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>大家可能會好奇 SSH Key 要從哪裡取得？因為五倍有自己的 GitLab 來放各種專案，所以在設計的時候透過 OmniAuth GitLab 直接讓員工登入，然後直接透過 GitLab 的 API 把大家設定的 SSH Key 讀取出來使用。</p><p>畢竟大部分的人都會把預設的 SSH Key 當作 Git 用的 Key 一般來說會直接通用。</p><blockquote><p>做完之後記得重新設置一次 Snapshot 確保新設定都能在被重設的時候吃到！</p></blockquote><h2 id="自動產生乾淨環境"><a href="#自動產生乾淨環境" class="headerlink" title="自動產生乾淨環境"></a>自動產生乾淨環境</h2><p>結合以上所有的技巧，我們可以封裝成像是這樣的 Service Object 在使用者點選「使用」的時候初始化這台虛擬機。</p><p>以下是真實實作的程式碼：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frozen_string_literal: true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">require</span> <span class="string">'timeout'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldVMService</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:vmid</span>, <span class="symbol">:user</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(vmid, user)</span></span></span><br><span class="line">    @vmid = vmid</span><br><span class="line">    @user = user</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">perform</span></span></span><br><span class="line">    <span class="comment"># rubocop:disable Style/ColonMethodCall</span></span><br><span class="line">    Timeout::timeout(<span class="number">30</span>) <span class="keyword">do</span></span><br><span class="line">      vm = Proxmox::VM.find(@vmid)</span><br><span class="line">      wait_task vm.reinitialize!</span><br><span class="line">      wait_task vm.start!</span><br><span class="line">      install(vm, @user.keys)</span><br><span class="line">      <span class="literal">true</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># rubocop:enable Style/ColonMethodCall</span></span><br><span class="line">  <span class="keyword">rescue</span> Timeout::Error</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  private</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">wait_task</span><span class="params">(id)</span></span></span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> Use nodes/&#123;node&#125;/tasks/&#123;upid&#125;/status instead pull all tasks</span></span><br><span class="line">    loop <span class="keyword">do</span></span><br><span class="line">      tasks = Proxmox::Task.all</span><br><span class="line">      <span class="keyword">break</span> <span class="keyword">if</span> tasks.find &#123; <span class="params">|t|</span> t.upid == id &amp;&amp; t.status == <span class="string">'OK'</span> &#125;</span><br><span class="line">      sleep <span class="number">0</span>.<span class="number">5</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">install</span><span class="params">(machine, keys)</span></span></span><br><span class="line">    machine.install_authorized_keys(keys)</span><br><span class="line">  <span class="keyword">rescue</span> Proxmox::API::ServerError</span><br><span class="line">    <span class="keyword">retry</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>因為在看文件時沒仔細看，所以還是用到了 <code>cluster/tasks</code> 的方式來讀取 Task 可能會跟文章上面介紹的方式有點出入（直接讀取對應的 UPID 會比這個方式好）</p><p>雖然跟文章介紹的有不少出入（像是 <code>Proxmox::VM</code> 封裝）但是整體上可以看出來，想要製作一個自動設定好乾淨環境的虛擬機提供同事練習，其實不困難：</p><ol><li>安裝並設定好虛擬機</li><li>利用迴圈不斷檢查處理狀態</li><li>利用 Qemu Guest Agent 寫入檔案設定 SSH Key</li><li>開始使用！</li></ol><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>說好的 Rails 在哪裡？目前其實除了是用 Rails 當基底之外，其實還沒使用到 Rails 的功能。不過後續會加上「限制其他使用者搶走虛擬機」之類的權限管理，就會要靠 Rails 跟資料庫的串接了。</p><p>這篇文章只是很簡單、快速的帶過整個在設計跟思考上的過程是怎樣運行的。</p><p>實際上是很考驗使用 Ruby 的經驗跟技巧，不過我們身為 Ruby 使用者其實常常因為 Rails 的關係限制住了視野，透過這樣的方式練習用不同的思考方式去做一些看起來不能做的機制或者功能，其實是很有趣的。</p><p>尤其是這只是很簡單的 API 串接技巧，最早有這個想法的時候是想要用 <code>libvirt</code> 去跟 KVM 的底層互動，不過因為太花時間就先暫時放棄。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2019/02/19/Automatic-VM-allocate-using-Proxmox-VE-and-Rails/#disqus_thread</comments>
    </item>
    
    <item>
      <title>探索 Ruby 的 each 方法（一）</title>
      <link>https://blog.frost.tw/posts/2019/02/13/Deep-into-ruby-s-each-method-Part-1/</link>
      <guid>https://blog.frost.tw/posts/2019/02/13/Deep-into-ruby-s-each-method-Part-1/</guid>
      <pubDate>Tue, 12 Feb 2019 17:00:23 GMT</pubDate>
      <description>
      
        &lt;p&gt;原本是想討論 Enumerable 這個 Module 的機制跟運作原理，不過越寫越發現光是一篇文章很難講明白。&lt;/p&gt;&lt;p&gt;所以就一邊查資料跟 Ruby 原始碼，慢慢的把 Enumerable / Enumerator 這兩個讓 &lt;code&gt;#each&lt;/code&gt; 運作起來的機制討論清楚。&lt;/p&gt;&lt;p&gt;在 Ruby 裡面我們已經很熟悉使用 &lt;code&gt;#each&lt;/code&gt; 來對陣列相關的物件進行操作，不過在大部分的語言我們都需要透過迴圈的方式來取出陣列的元素，那麼 &lt;code&gt;#each&lt;/code&gt; 這個方法到底是怎麼讓我們用這麼方便的機制來操作陣列的呢？&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>原本是想討論 Enumerable 這個 Module 的機制跟運作原理，不過越寫越發現光是一篇文章很難講明白。</p><p>所以就一邊查資料跟 Ruby 原始碼，慢慢的把 Enumerable / Enumerator 這兩個讓 <code>#each</code> 運作起來的機制討論清楚。</p><p>在 Ruby 裡面我們已經很熟悉使用 <code>#each</code> 來對陣列相關的物件進行操作，不過在大部分的語言我們都需要透過迴圈的方式來取出陣列的元素，那麼 <code>#each</code> 這個方法到底是怎麼讓我們用這麼方便的機制來操作陣列的呢？</p><a id="more"></a><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>在<a href="https://zh.wikipedia.org/wiki/%E8%BF%AD%E4%BB%A3%E5%99%A8" rel="external nofollow noopener noreferrer" target="_blank">維基百科</a>裡面提到 Ruby 是隱式的將迭代器內建在語言裡面的。</p><p>我們可以先來看看迭代器通常是怎麼實現的：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterator</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(collection)</span></span></span><br><span class="line">    @collection = collection</span><br><span class="line">    @ptr = <span class="number">0</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">next</span></span></span><br><span class="line">   ret = @collection[@ptr]</span><br><span class="line">   @ptr += <span class="number">1</span></span><br><span class="line">   ret</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">rewind</span></span></span><br><span class="line">    @ptr = <span class="number">0</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>那麼我們就可以用像下面這樣的方式來讀取陣列的內容</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">array = (<span class="number">1</span>..<span class="number">10</span>).to_a</span><br><span class="line">iter = Iterator.new(array)</span><br><span class="line">iter.<span class="keyword">next</span> <span class="comment"># =&gt; 1</span></span><br><span class="line">iter.<span class="keyword">next</span> <span class="comment"># =&gt; 2</span></span><br><span class="line">iter.rewind</span><br><span class="line">iter.<span class="keyword">next</span> <span class="comment"># =&gt; 1</span></span><br></pre></td></tr></table></figure><p>實際上，在 Ruby 中已經有內建這樣的機制，那就是 <code>Enumerator</code> 類別。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">array = (<span class="number">1</span>..<span class="number">10</span>).to_a</span><br><span class="line">iter = Enumerator.new(array)</span><br><span class="line"><span class="comment"># warning: Enumerator.new without a block is deprecated; use Object#to_enum</span></span><br><span class="line">iter.<span class="keyword">next</span> <span class="comment"># =&gt; 1</span></span><br><span class="line">iter.<span class="keyword">next</span> <span class="comment"># =&gt; 2</span></span><br><span class="line">iter.rewind</span><br><span class="line">iter.<span class="keyword">next</span> <span class="comment"># =&gt; 1</span></span><br></pre></td></tr></table></figure><p>那麼，假設我們對陣列使用 <code>#each</code> 方法時，不傳入 Block 的話，會看到什麼呢？</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">irb(main):067:0&gt;</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].each</span><br><span class="line">=&gt; #&lt;Enumerator: [1, 2, 3]:each&gt;</span><br></pre></td></tr></table></figure><p>我們會得到一個 <code>Enumerator</code> 物件，也就是說 <code>#each</code> 方法回傳的就是迭代器。</p><h2 id="使用-Block-的情境"><a href="#使用-Block-的情境" class="headerlink" title="使用 Block 的情境"></a>使用 Block 的情境</h2><p>不過，當我們提供了 Block 之後，回傳的卻是普通的陣列，又是怎麼一回事？</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">irb(main):070:0&gt;</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].each &#123; <span class="params">|v|</span> p v &#125;.class</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">=&gt; Array</span><br></pre></td></tr></table></figure><p>而且，當我們使用不同類型的物件時，也會得到同樣的物件類型</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">irb(main):074:0&gt;</span> (<span class="number">1</span>..<span class="number">2</span>).each</span><br><span class="line">=&gt; #&lt;Enumerator: 1..2:each&gt;</span><br><span class="line"><span class="meta">irb(main):075:0&gt;</span> (<span class="number">1</span>..<span class="number">2</span>).each &#123; <span class="params">|v|</span> p v &#125;.class</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">=&gt; Range</span><br></pre></td></tr></table></figure><p>這就表示在 Ruby 中 <code>#each</code> 的行為並不單純是我們所看到的這樣，不過這就要再跟 <code>Enumerator</code> 的實作有所關聯，所以就將它留到下一篇文章再討論吧！</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>在寫這篇文章之前其實都沒有認真思考過 <code>#each</code> 是怎麼運作的，雖然他是很常見而且很常使用的功能。但是從 Ruby 1.8 到現在的 Ruby 2.6 中間所出現的改變一些新的特性，其實是蠻值得去探討的。</p><p>會寫這系列文章主要是因為最近手邊的專案遇到了一個蠻有趣的問題，就是如果靠 ActiveRecord 的話，會產生多餘的 N+1 Query 而如果是直接針對讀取出來的資料進行普通的陣列操作，反而可以避開，又不會浪費太多的資源。</p><p>這就成為了一個盲點，也就是我們大多數時候已經習慣了 Rails 提供給我們的便利功能，而忘記應該評估使用情境去選擇適合的方案來處理。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2019/02/13/Deep-into-ruby-s-each-method-Part-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>你看懂五倍紅寶石粉專上的 Ruby 版台灣共識了嗎？</title>
      <link>https://blog.frost.tw/posts/2019/01/14/Do-you-understand-the-Ruby-version-Taiwan-Consensus-on-5xruby-s-fanpage/</link>
      <guid>https://blog.frost.tw/posts/2019/01/14/Do-you-understand-the-Ruby-version-Taiwan-Consensus-on-5xruby-s-fanpage/</guid>
      <pubDate>Mon, 14 Jan 2019 14:00:39 GMT</pubDate>
      <description>
      
        &lt;p&gt;最近「台灣共識」很熱門，公司的粉專也分享了 Ruby 版的台灣共識。&lt;/p&gt;&lt;p&gt;我們在公司內部的群組大家其實討論了蠻久，如果只是單純的去實作跟其他語言一樣的內容，不就沒有意義了嗎？&lt;/p&gt;&lt;p&gt;我們之所以會選擇用 Ruby 來當作工作上的工具，就表示他有一些特別的地方吸引我們。&lt;/p&gt;&lt;p&gt;所以，上面用了哪些 Ruby 技巧讓我們一起來分析看看！&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>最近「台灣共識」很熱門，公司的粉專也分享了 Ruby 版的台灣共識。</p><p>我們在公司內部的群組大家其實討論了蠻久，如果只是單純的去實作跟其他語言一樣的內容，不就沒有意義了嗎？</p><p>我們之所以會選擇用 Ruby 來當作工作上的工具，就表示他有一些特別的地方吸引我們。</p><p>所以，上面用了哪些 Ruby 技巧讓我們一起來分析看看！</p><a id="more"></a><p>先來看一下原始的版本，這是一個可以實際執行的 Ruby 語法。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Consensus92</span><span class="params">(<span class="symbol">countries:</span>, <span class="symbol">system:</span>)</span></span></span><br><span class="line">  Module.new <span class="keyword">do</span></span><br><span class="line">    define_method <span class="string">'definition'</span> <span class="keyword">do</span></span><br><span class="line">      &#123; <span class="symbol">countries:</span> countries, <span class="symbol">system:</span> system &#125;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    define_method <span class="string">'build_consensus_with?'</span> <span class="keyword">do</span> <span class="params">|other|</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span> <span class="keyword">if</span> definition == other.definition</span><br><span class="line">      raise <span class="string">"This is not <span class="subst">#&#123;other&#125;</span> consensus"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Taiwan</span></span></span><br><span class="line">  extend Consensus92(<span class="symbol">countries:</span> <span class="number">2</span>, <span class="symbol">system:</span> <span class="number">2</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">China</span></span></span><br><span class="line">  extend Consensus92(<span class="symbol">countries:</span> <span class="number">1</span>, <span class="symbol">system:</span> <span class="number">2</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">China.build_consensus_with?(Taiwan)</span><br></pre></td></tr></table></figure><h2 id="include-與-extend"><a href="#include-與-extend" class="headerlink" title="include 與 extend"></a>include 與 extend</h2><p>大多數時候我們都是對 <code>include</code> 比較熟悉，因為它可以把一些方法切割到一個 Module 裡面，然後在物件中呼叫。</p><p>我們先來看一下這段程式碼：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Extension</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">echo</span></span></span><br><span class="line">    puts <span class="string">'ECHO'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line">  <span class="keyword">include</span> Extension</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line">  extend Extension</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p A.ancestors</span><br><span class="line"><span class="comment"># =&gt; [A, Extension, Object, Kernel, BasicObject]</span></span><br><span class="line">A.new.echo</span><br><span class="line">p B.ancestors</span><br><span class="line"><span class="comment"># =&gt; [B, Object, Kernel, BasicObject]</span></span><br><span class="line">B.echo</span><br></pre></td></tr></table></figure><p>我們會發現在 <code>B</code> 上面的繼承上，是沒有 <code>Extension</code> 模組的，所以兩者的差異在哪邊呢？</p><blockquote><p>因為我們希望是 <code>China.build_consensus_with?(Taiwan)</code> 而不是 <code>China.new.build_consensus_with?(Taiwan.new)</code> 的寫法，才選擇用 <code>extend</code></p></blockquote><h3 id="線索一"><a href="#線索一" class="headerlink" title="線索一"></a>線索一</h3><p>調查了 Ruby 的文件會發現 <code>include</code> 屬於 <code>Module</code> 物件的行為，而 <code>extend</code> 則是屬於 <code>Object</code> 物件的行為。</p><p>簡單說就表示 <code>include</code> 只能作用在 <code>Class</code> 上，物件的實例是不行的，像是下面這樣：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.new.<span class="keyword">include</span> Extension</span><br></pre></td></tr></table></figure><p>但是 <code>extend</code> 是屬於 <code>Object</code> 的行為，所以原本我們預期是這樣</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B.new.extend Extension</span><br></pre></td></tr></table></figure><p>但是同時 Ruby 的所有東西都是物件的一種，所以同理可以證明 <code>Module</code> 也是一種物件（而 <code>Class</code> 物件繼承於 <code>Module</code>）所以下面的用法也會成立：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B.extend Extension</span><br></pre></td></tr></table></figure><h3 id="線索二"><a href="#線索二" class="headerlink" title="線索二"></a>線索二</h3><p>根據 Ruby 文件提供的 <code>extend</code> 實作，大概是長這樣的，意外的很簡單。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> VALUE</span><br><span class="line">rb_obj_extend(<span class="keyword">int</span> argc, VALUE *argv, VALUE obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    ID id_extend_object, id_extended;</span><br><span class="line"></span><br><span class="line">    CONST_ID(id_extend_object, <span class="string">"extend_object"</span>);</span><br><span class="line">    CONST_ID(id_extended, <span class="string">"extended"</span>);</span><br><span class="line"></span><br><span class="line">    rb_check_arity(argc, <span class="number">1</span>, UNLIMITED_ARGUMENTS);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">        Check_Type(argv[i], T_MODULE);</span><br><span class="line">    <span class="keyword">while</span> (argc--) &#123;</span><br><span class="line">        rb_funcall(argv[argc], id_extend_object, <span class="number">1</span>, obj);</span><br><span class="line">        rb_funcall(argv[argc], id_extended, <span class="number">1</span>, obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>裡面其實就只是把 <code>extend</code> 傳入的 Module 都帶入，並且呼叫 <code>extended</code> 和 <code>extend_object</code> 兩個方法。</p><p>經過簡單的測試，像下面這樣的修改就能阻止 <code>extend</code> 複製方法。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Extension</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">extend_object</span><span class="params">(obj)</span></span></span><br><span class="line">    <span class="comment"># Do Nothing</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">echo</span></span></span><br><span class="line">    puts <span class="string">'ECHO'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line">  extend Extension</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">B.echo</span><br><span class="line"><span class="comment"># =&gt; undefine method</span></span><br></pre></td></tr></table></figure><p>也就是說，在 <code>extend</code> 的行為下，我們會透過 <code>extend_object</code> 方法做某些處理後，才得以「複製」方法，而不是像 <code>include</code> 一樣把整個 Module 放入物件的繼承體系之中。</p><blockquote><p>因為文章篇幅限制，我們先不去追 <code>extend_object</code> 的源頭。</p></blockquote><h2 id="Consensus92-的用法"><a href="#Consensus92-的用法" class="headerlink" title="Consensus92 的用法"></a>Consensus92 的用法</h2><p>首先，大家可能會有點疑惑為什麼可以用 <code>extend Consensus92()</code> 這樣的寫法，我們先釐清一下「方法」和「常數」的差異。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Consensus92</span>;</span> <span class="keyword">end</span></span><br><span class="line">p Consensus92()</span><br><span class="line">p Consensus92 <span class="comment"># =&gt; uninitialized constant Consensus92</span></span><br></pre></td></tr></table></figure><p>從上面這段程式碼我們可以發現，實際上「方法」和「常數」的命名空間是不同的，也就是說他們兩者並不衝突可以並存。而 Ruby 在這個情況下是透過有沒有 <code>()</code> 來判斷到底是個方法，還是一個常數。</p><blockquote><p>這邊省略 Ruby 的 Keyword Arguments 解釋，這部分雖然不常見但還是屬於日常使用的一部分。</p></blockquote><p>那麼，為什麼 <code>Consensus92()</code> 的回傳結果可以被 <code>extend</code> 呢？</p><p>這個問題大家可能很快就猜到了，因為我們使用了「匿名模組」的技巧，雖然不確定是否真的有這個詞，不過大多數我們都用「匿名 XX」來稱呼一些沒有取名的定義，所以這邊也就這樣使用吧！</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Consensus92</span></span></span><br><span class="line">  Module.new; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Taiwan</span></span></span><br><span class="line">  extend Consensus92</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>因為不論 <code>include</code> 還是 <code>extend</code> 都只會確認對象是不是一個 Module 所以在這邊我們「即時」產生一個新的 Module 是符合 Ruby 在運作上的判定，也因此會被視為合法的行為。</p><p>所以實際上我們在 <code>Taiwan</code> 和 <code>China</code> 擴充的模組是不一樣的，這樣在程式的意義上，剛好也跟「九二共識沒有共識」的意思重疊在一起，畢竟從一開始「拓展（extend）」的共識就是不同的。</p><blockquote><p>如果有在使用 Rails 的話，可能會注意到像是 <code>Association_User_CollectionProxy</code> 之類的類別名稱，其實就是運用這種技巧去動態產生的 Class 喔！</p></blockquote><h2 id="define-method-的理由"><a href="#define-method-的理由" class="headerlink" title="define_method 的理由"></a>define_method 的理由</h2><p>實際上，我們使用 <code>Module.new do; end</code> 和 <code>module Extension; end</code> 的效果是相同的，從下面的程式碼可以得到驗證：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A = Module.new</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">echo</span></span></span><br><span class="line">    puts <span class="string">'ECHO'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line">  extend A</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">B.echo</span><br></pre></td></tr></table></figure><p>既然這樣也會運作，那麼我們為什麼還需要用 <code>define_method</code> 呢？</p><p>這是因為我們希望達到類似 Closure 的技巧，看看下面這段程式就會注意到一個有趣的問題：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Consensus92</span><span class="params">(<span class="symbol">countries:</span>)</span></span></span><br><span class="line">  Module.new</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">definition</span></span></span><br><span class="line">      &#123; <span class="symbol">countries:</span> countries &#125;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Taiwan</span></span></span><br><span class="line">  extend Consensus(<span class="symbol">countries:</span> <span class="number">2</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Taiwan.definition</span><br><span class="line"><span class="comment"># =&gt; undefine variable countries</span></span><br></pre></td></tr></table></figure><p>為什麼會這樣，因為對 <code>def</code> 來說 <code>countries</code> 已經是屬於在執行階段的一部分，所以我們在呼叫 <code>definition</code> 的時候才會嘗試去尋找 <code>countries</code> 這個東西，但是他已經無法被找到。</p><p>但是 <code>define_method</code> 就不太一樣了！</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Consensus92</span><span class="params">(<span class="symbol">countries:</span>)</span></span></span><br><span class="line">  Module.new <span class="keyword">do</span></span><br><span class="line">    define_method <span class="string">'definition'</span> <span class="keyword">do</span></span><br><span class="line">      &#123; <span class="symbol">countries:</span> countries &#125;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Taiwan</span></span></span><br><span class="line">  extend Consensus92(<span class="symbol">countries:</span> <span class="number">2</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>實際上 <code>define_method</code> 在被呼叫的當下，會被轉成像這樣的樣子</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">definition</span></span></span><br><span class="line">  &#123; <span class="symbol">countries:</span> <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>這是因為對於 <code>define_method</code> 所傳入的 Block 是用來定義方法的內容，但是因為我們是在呼叫一個方法，所以 <code>countries</code> 變數就被視為是處於 <code>Consensus92</code> 方法的環境下，而不是呼叫的當下。</p><blockquote><p>稍微有點難懂，不過是不是很像 Closure 的感覺呢？</p></blockquote><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>這段程式碼其實算是有不少巧思在裡面，把程式碼換成中文讀起來意思也是很容易懂的。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 九二共識<span class="params">(國家<span class="symbol">:</span>, 制度<span class="symbol">:</span>)</span></span></span><br><span class="line">  Module.new <span class="keyword">do</span></span><br><span class="line">    define_method <span class="string">'定義'</span> <span class="keyword">do</span></span><br><span class="line">      &#123; 國家: 國家, 制度: 制度 &#125;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    define_method <span class="string">'建立共識？'</span> <span class="keyword">do</span> <span class="params">|定義|</span></span><br><span class="line">      <span class="keyword">return</span> 是 如果 定義 == 對方.定義</span><br><span class="line">      raise <span class="string">"這不是<span class="subst">#&#123;對方&#125;</span>共識"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 台灣</span></span><br><span class="line">  擴充 九二共識(國家: <span class="number">2</span>, 制度: <span class="number">2</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 中國</span></span><br><span class="line">  擴充 九二共識(國家: <span class="number">1</span>, 制度: <span class="number">2</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">中國.建立共識?（台灣）</span><br><span class="line"><span class="comment"># =&gt; 錯誤「這不是台灣共識」</span></span><br></pre></td></tr></table></figure><p>這也是 Ruby 在 DSL 表現優異上的原因之一，我們可以透過許多動態定義或者語法上的特殊技巧，製作出非常接近我們習慣的語言跟用法。</p><p>這篇文章提到關於 Ruby 類別上的應用，可以參考之前寫過的<a href="https://blog.frost.tw/posts/2017/10/22/The-ruby-s-class-is-free-Part-1/">自由的 Ruby 類別</a>來了解背後的機制。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2019/01/14/Do-you-understand-the-Ruby-version-Taiwan-Consensus-on-5xruby-s-fanpage/#disqus_thread</comments>
    </item>
    
    <item>
      <title>用 Ruby 來尋找區網中的 Airplay、Chromecast</title>
      <link>https://blog.frost.tw/posts/2018/12/25/Use-Ruby-to-find-the-Airplay-or-Chromecast-device/</link>
      <guid>https://blog.frost.tw/posts/2018/12/25/Use-Ruby-to-find-the-Airplay-or-Chromecast-device/</guid>
      <pubDate>Tue, 25 Dec 2018 10:42:06 GMT</pubDate>
      <description>
      
        &lt;p&gt;從雲端開始熱門起來後，為了能能讓提供不同服務的伺服器能夠被自動的偵測，我們在許多雲端相關的工具都會看到 Service Discovery 這個名詞。&lt;/p&gt;&lt;p&gt;不過，除了雲端上的服務能夠透過這樣的機制互相「發現」對方，我們也可以在區網中用類似的方法找到「提供服務」的裝置。&lt;/p&gt;&lt;p&gt;這就要從 mDNS (Multicast DNS) 和 DNS-SD (DNS-based Service Discovery) 開始談起。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>從雲端開始熱門起來後，為了能能讓提供不同服務的伺服器能夠被自動的偵測，我們在許多雲端相關的工具都會看到 Service Discovery 這個名詞。</p><p>不過，除了雲端上的服務能夠透過這樣的機制互相「發現」對方，我們也可以在區網中用類似的方法找到「提供服務」的裝置。</p><p>這就要從 mDNS (Multicast DNS) 和 DNS-SD (DNS-based Service Discovery) 開始談起。</p><a id="more"></a><h2 id="概觀"><a href="#概觀" class="headerlink" title="概觀"></a>概觀</h2><p>想要可以發現區網的裝置，我們需要先搞懂 mDNS 和 DNS-SD 這兩個東西在做些什麼。簡單來說 mDNS 就是對區網做「廣播」而廣播的內容則是我們熟悉的 DNS Query。當其他有在關注 mDNS 的裝置注意到之後，就會把回應廣播回區網上。也因為這樣的特性，我們不需要特別在區網架設一個 DNS 伺服器，因為我們會直接在這個區網中交換有興趣的訊息。</p><p>而 DNS-SD 其實是由 Apple 所提出的，如果看到 Bonjour 大致上他們可能是同一個東西。簡單來說就是基於 mDNS 在區網用特定的規則「查詢」和「回應」就能讓某個裝置辨識出另一個裝置有提供的服務，從而做到 Service Discovery 的功能。</p><blockquote><p>Bonjour 是不是相等 DNS-SD 資料不多，所以我不太敢直接斷定是同樣的東西，不過 DNS-SD 文件上是會出現 Bonjour 這個名詞的。</p></blockquote><h2 id="Ruby-的-Resolv-標準函式庫"><a href="#Ruby-的-Resolv-標準函式庫" class="headerlink" title="Ruby 的 Resolv 標準函式庫"></a>Ruby 的 Resolv 標準函式庫</h2><p>基本上 <code>Resolv</code> 這個函式庫存在感低到我都懷疑他為什麼一直在 Ruby 原始碼中活得好好的，沒有被切割出來。不過如果我們想產生 DNS 查詢的封包，就得靠他來實現。</p><blockquote><p>原本我是看著這篇<a href="https://routley.io/tech/2017/12/28/hand-writing-dns-messages.html" rel="external nofollow noopener noreferrer" target="_blank">文章</a>透過 Python 來實作產生和解析封包的功能，但是想起來我曾經對 Ruby 送過 PR 剛好就是 Resolv 相關的。</p></blockquote><p>先來一段 <code>Resolv::DNS</code> 的官方使用，讓我們快速了解一下怎麼送出 DNS 查詢。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'resolv'</span></span><br><span class="line"></span><br><span class="line">Resolv::DNS.new</span><br><span class="line">           .each_resource(<span class="string">'frost.tw'</span>, Resolv::DNS::Resource::IN::A) <span class="keyword">do</span> <span class="params">|record|</span></span><br><span class="line">             pp record</span><br><span class="line">           <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如此一來就可以查詢到 <code>frost.tw</code> 的 A 紀錄有哪些，那麼從前面的介紹來看假設 mDNS 也是使用 DNS 封包來互動的話，是不是就表示 <code>Resolv::DNS</code> 已經提供了足夠我們實現 mDNS 和 DNS-SD 的必要實作了呢？</p><h2 id="監聽-mDNS-封包"><a href="#監聽-mDNS-封包" class="headerlink" title="監聽 mDNS 封包"></a>監聽 mDNS 封包</h2><p>跟我們平常使用的 <code>Socket</code> 功能比起來要正確的設定 <code>UDPSocket</code> 才能夠順利加入一個 <a href="https://en.wikipedia.org/wiki/Multicast" rel="external nofollow noopener noreferrer" target="_blank">Multicast 群組</a>，然後接收裡面的訊息。</p><p>根據 <a href="https://en.wikipedia.org/wiki/Multicast_DNS" rel="external nofollow noopener noreferrer" target="_blank">mDNS 定義</a>的 Multicast IPv4 位置，我們需要監聽 <code>224.0.0.251</code> 上的 <code>5353</code> 埠就可以收到 mDNS 的封包，剛開始我們可能會覺得像這樣實作應該就可以了。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'socket'</span></span><br><span class="line"></span><br><span class="line">socket = UDPSocket.new</span><br><span class="line">socket.bind(<span class="string">'224.0.0.251'</span>, <span class="number">5353</span>)</span><br></pre></td></tr></table></figure><p>不過馬上就會得到 <code>Errno::EADDRINUSE (Address already in use - bind(2) for &quot;224.0.0.251&quot; port 5353)</code> 這樣的錯誤訊息，所以我們需要對這個 UDPSocket 做一些設定，讓他以「加入 Multicast 群組成員」的形式運作。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">membership = IPAddr.new(<span class="string">'224.0.0.251'</span>).hton + IPAddr.new(<span class="string">'0.0.0.0'</span>).hton</span><br><span class="line">socket = UDPSocket.new</span><br><span class="line"></span><br><span class="line">socket.setsockopt(<span class="symbol">:IPPROTO_IP</span>, <span class="symbol">:IP_ADD_MEMBERSHIP</span>, membership)</span><br><span class="line">socket.setsockopt(<span class="symbol">:SOL_SOCKET</span>, <span class="symbol">:SO_REUSEPORT</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">socket.bind(<span class="string">'0.0.0.0'</span>, <span class="number">5353</span>)</span><br></pre></td></tr></table></figure><p>上述的程式碼簡單來說做了這幾件事情：</p><ol><li>設定 Socket 要加入 <code>224.0.0.251</code> 作為成員</li><li>設定 Socket 允許重複使用 5353 這個 Port</li></ol><p>設定 5353 Port 可以被重複使用是因為在這個裝置上可能還有其他服務存在，他也會需要關注 mDNS 或者做出廣播，所以我們可能會跟其他人共用這個 Port。</p><p>而加入 <code>224.0.0.251</code> 成員就相對不容易理解了，對沒學過網路相關知識的人來說還真的不太好好懂（所以特地查了一下資料）</p><p>我們先看 <code>setsockopt</code> 在 Ruby 原始碼做了什麼，才會知道上面這段的意思。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 略</span><br><span class="line"><span class="keyword">if</span> (setsockopt(fptr-&gt;fd, level, option, v, vlen) &lt; <span class="number">0</span>)</span><br><span class="line">        rsock_sys_fail_path(<span class="string">"setsockopt(2)"</span>, fptr-&gt;pathv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> INT2FIX(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>在實作上 Ruby 會直接去呼叫 C API 來做這件事情，而 <code>level</code>, <code>option</code>, <code>v</code> 就是我們從 Ruby 傳入的數值。</p><p>接下來再看看我查到的 <code>IP_ADDD_MEMBERSHIP</code> 的 C API <a href="https://www.tldp.org/HOWTO/Multicast-HOWTO-6.html" rel="external nofollow noopener noreferrer" target="_blank">使用說明</a>（嚴格上來說是 Multicast 的說明）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_multiaddr</span>;</span>   <span class="comment">/* IP multicast address of group */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_interface</span>;</span>   <span class="comment">/* local IP address of interface */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsockopt (socket, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;mreq, <span class="keyword">sizeof</span>(mreq));</span><br></pre></td></tr></table></figure><p>實際上跟 Ruby 的版本幾乎沒有差別，最主要的是 <code>ip_mreq</code> 是一個資料結構，我們要怎樣才能夠正確的傳遞進去呢？</p><p>先看看 <code>IPAddr.new(&#39;224.0.0.251&#39;).hton</code> 執行後會得到什麼？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">irb(main):003:0&gt; IPAddr.new(<span class="string">'224.0.0.251'</span>).hton</span><br><span class="line">=&gt; <span class="string">"\xE0\x00\x00\xFB"</span></span><br></pre></td></tr></table></figure><p>那麼跟 <code>0.0.0.0</code> 的 <code>IPAddr#hton</code> 相加之後，因為是字串所以會變成像這樣</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">irb(main):004:0&gt; IPAddr.new(<span class="string">'224.0.0.251'</span>).hton + IPAddr.new(<span class="string">'0.0.0.0'</span>).hton</span><br><span class="line">=&gt; <span class="string">"\xE0\x00\x00\xFB\x00\x00\x00\x00"</span></span><br></pre></td></tr></table></figure><p>我們再回去看 Ruby 在 <code>setsockopt</code> 實作中，遇到 <code>String</code> 時，會怎樣處理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *v;</span><br><span class="line"></span><br><span class="line"># 略</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (TYPE(val)) &#123;</span><br><span class="line">      # 略</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        StringValue(val);</span><br><span class="line">        v = RSTRING_PTR(val);</span><br><span class="line">        vlen = RSTRING_SOCKLEN(val);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"># C API 呼叫處</span><br></pre></td></tr></table></figure><p>簡單說就是直接弄成一段 <code>char</code> 陣列，基本上我們在 C 裡面只要大小一樣直接對到結構上基本上是會運作的，於是我們就很自然的利用 Ruby 的字串變成一個在 C 裡面的 <code>ip_mreq</code> 資料結構，順利的傳遞進去了。</p><p>至於 <code>#hton</code> 是什麼呢？他是 <code>Host Byte Order to Network Byte Order</code> 的縮寫，簡單說在處理網路封包的時候需要知道 IP 位置，所以有一個特殊的格式，但是因為作業系統差異，存位置的規格可能有差異，所以送到網路上時會統一轉成網路用的位元順序。</p><p>總而言之，我們目前可以順利的接收到來自 mDNS 的廣播封包拉！</p><h2 id="解析封包"><a href="#解析封包" class="headerlink" title="解析封包"></a>解析封包</h2><p>首先，我們先把上面的程式碼簡單重構成下面這樣的結構</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'socket'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'resolv'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'awesome_print'</span></span><br><span class="line"></span><br><span class="line">MDNS_PORT = <span class="number">5353</span></span><br><span class="line">MDNS_ADDRESS = <span class="string">'224.0.0.251'</span>.freeze</span><br><span class="line">BIND_ADDRESS = <span class="string">'0.0.0.0'</span>.freeze</span><br><span class="line"></span><br><span class="line">M_MEMBERSHIP = IPAddr.new(MDNS_ADDRESS).hton + IPAddr.new(BIND_ADDRESS).hton</span><br><span class="line"></span><br><span class="line"><span class="comment"># :nodoc:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MDNS</span></span></span><br><span class="line">  <span class="keyword">include</span> Enumerable</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></span><br><span class="line">    @socket = UDPSocket.new</span><br><span class="line">    @socket.setsockopt(<span class="symbol">:IPPROTO_IP</span>, <span class="symbol">:IP_ADD_MEMBERSHIP</span>, M_MEMBERSHIP)</span><br><span class="line">    @socket.setsockopt(<span class="symbol">:SOL_SOCKET</span>, <span class="symbol">:SO_REUSEPORT</span>, <span class="number">1</span>)</span><br><span class="line">    @socket.bind(BIND_ADDRESS, MDNS_PORT)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">each</span><span class="params">(&amp;_block)</span></span></span><br><span class="line">    loop <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">yield</span> @socket.recvfrom(<span class="number">4096</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">mdns = MDNS.new</span><br><span class="line">mdns.each <span class="keyword">do</span> <span class="params">|packet|</span></span><br><span class="line">  ap packet</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>執行之後，稍微等待一段時間就可以收到類似像這樣的封包資訊</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    [<span class="number">0</span>] <span class="string">"\x00\x00\x84\x00\x00\x00\x00\x02\x00\x00\x00\x01\aAndroid\x05local\x00\x00\x01\x80\x01\x00\x00\x00x\x00\x04\xAC\x1F\x01\xC0\xC0\f\x00\x1C\x80\x01\x00\x00\x00x\x00\x10\xFE\x80\x00\x00\x00\x00\x00\x00\xAEc\xBE\xFF\xFE\xC21;\xC0\f\x00/\x80\x01\x00\x00\x00x\x00\b\xC0\f\x00\x04@\x00\x00\b"</span>,</span><br><span class="line">    [<span class="number">1</span>] [</span><br><span class="line">        [<span class="number">0</span>] <span class="string">"AF_INET"</span>,</span><br><span class="line">        [<span class="number">1</span>] <span class="number">5353</span>,</span><br><span class="line">        [<span class="number">2</span>] <span class="string">"172.31.1.192"</span>,</span><br><span class="line">        [<span class="number">3</span>] <span class="string">"172.31.1.192"</span></span><br><span class="line">    ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>那麼我們該如何解析呢？因為封包內容其實就是 DNS 查詢（或者回應）所以我們只需要透過 <code>Resolv::DNS::Message</code> 的 <code>#decode</code> 去解析就可以知道內容了！</p><blockquote><p>比較痛苦的大概是 <code>Resolv::DNS</code> 本身是 Class 所以無法用 <code>include</code> 進來使用，要打很長 Class Name XD</p></blockquote><p>我們稍微調整讀取封包的程式，改成這個樣子</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mdns = MDNS.new</span><br><span class="line">mdns.each <span class="keyword">do</span> <span class="params">|packet, _addr|</span></span><br><span class="line">  ap Resolv::DNS::Message.decode(packet)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>執行後就可以看到 <code>Resolv::DNS::Message</code> 物件被產生，然後裡面包含了各種類型的 DNS 查詢。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&lt;Resolv::DNS::Message:0x00007ff3dc0b8420 <span class="doctag">@id</span>=0, <span class="doctag">@qr</span>=0, <span class="doctag">@opcode</span>=0, <span class="doctag">@aa</span>=0, <span class="doctag">@tc</span>=0, <span class="doctag">@rd</span>=0, <span class="doctag">@ra</span>=0, <span class="doctag">@rcode</span>=0, <span class="doctag">@question</span>=[[#&lt;Resolv::DNS::Name: _airplay._tcp.local.&gt;, Resolv::DNS::Resource::Generic::Type12_Class32769]], <span class="doctag">@answer</span>=[[#&lt;Resolv::DNS::Name: _airplay._tcp.local.&gt;, 4487, #&lt;Resolv::DNS::Resource::IN::PTR:0x00007ff3de822790 <span class="doctag">@name</span>=#&lt;Resolv::DNS::Name: \xE8\x87\xA5\xE5\xAE\xA4._airplay._tcp.local.&gt;, <span class="doctag">@ttl</span>=4487&gt;]], <span class="doctag">@authority</span>=[], <span class="doctag">@additional</span>=[]&gt;</span></span><br><span class="line"><span class="comment">#&lt;Resolv::DNS::Message:0x00007ff3de820ff8 <span class="doctag">@id</span>=0, <span class="doctag">@qr</span>=0, <span class="doctag">@opcode</span>=0, <span class="doctag">@aa</span>=0, <span class="doctag">@tc</span>=0, <span class="doctag">@rd</span>=0, <span class="doctag">@ra</span>=0, <span class="doctag">@rcode</span>=0, <span class="doctag">@question</span>=[[#&lt;Resolv::DNS::Name: _airplay._tcp.local.&gt;, Resolv::DNS::Resource::IN::PTR]], <span class="doctag">@answer</span>=[[#&lt;Resolv::DNS::Name: _airplay._tcp.local.&gt;, 4486, #&lt;Resolv::DNS::Resource::IN::PTR:0x00007ff3dc0e3198 <span class="doctag">@name</span>=#&lt;Resolv::DNS::Name: \xE8\x87\xA5\xE5\xAE\xA4._airplay._tcp.local.&gt;, <span class="doctag">@ttl</span>=4486&gt;]], <span class="doctag">@authority</span>=[], <span class="doctag">@additional</span>=[]&gt;</span></span><br></pre></td></tr></table></figure><p>不過有些是查詢，有些則是回應，我們先把回應區分出來。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mdns = MDNS.new</span><br><span class="line">mdns.each <span class="keyword">do</span> <span class="params">|packet, _addr|</span></span><br><span class="line">  message = Resolv::DNS::Message.decode(packet)</span><br><span class="line">  <span class="keyword">next</span> <span class="keyword">if</span> message.qr.zero?</span><br><span class="line"></span><br><span class="line">  ap message</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在 <code>Resolve::DNS::Message</code> 物件上有一個叫做 <code>qr</code> 的屬性，當他是 0 的時候表示這是一個「查詢」而 1 的時候，就是回應，所以只需要排除是 0 的訊息。</p><h2 id="根據-DNS-SD-篩選出-Airplay-Chromecast-裝置"><a href="#根據-DNS-SD-篩選出-Airplay-Chromecast-裝置" class="headerlink" title="根據 DNS-SD 篩選出 Airplay / Chromecast 裝置"></a>根據 DNS-SD 篩選出 Airplay / Chromecast 裝置</h2><p>首先我們要先搞懂幾個 DNS-SD 的規則，才能夠找到我們希望找到的資訊。</p><ol><li>DNS-SD 的 FQDN 結構</li><li>DNS-SD 會使用的 Record</li></ol><p>關於 FQDN 結構，我們會看到三種</p><ol><li>&lt; Service &gt;.&lt; Domain &gt;</li><li>&lt; Instance &gt;.&lt; Service &gt;.&lt; Domain &gt;</li><li>&lt; Hostname &gt;</li></ol><p>扣掉第三種不算，因為他就是 Host Name 之外，以 Airplay 裝置會這樣表示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_airplay._tcp_.local</span><br></pre></td></tr></table></figure><p>基本上在區網使用 <code>.local</code> 是必然的，然後 <code>_tcp</code> 暴露出了他是透過 TCP 連線，而 <code>_airplay</code> 就是這個服務的類型。</p><p>以我的房間為例，我有一台 Sonos One 音響叫做「臥室」那在 mDNS 中就可以查到 <code>臥室._airplay._tcp.local</code> 這個 DNS 紀錄。</p><p>至於會用到的 DNS Record 則有四種</p><ol><li>PTR (Pointer Record)</li><li>SRV (Service Record)</li><li>A (Address Record)</li><li>TXT (Text Record)</li></ol><p>簡單說 PTR 是一個指標，他會回應一個 Instance 給我們，讓我們知道該去問誰要這個 Service 的資訊，而 SRV / TXT 則提供了這個 Service 的 Port &amp; Hostname 資訊，以及一些 Metadata 讓我們可以了解這個服務。</p><p>最後 A (or AAAA) 則會在我們詢問 Hostname 時回應區網的 IP 位置，讓我們知道該連到哪裡。</p><blockquote><p>這個機制看起來很聰明，有興趣的話可以參考 Spotify 的 <a href="https://labs.spotify.com/2017/03/31/spotifys-lovehate-relationship-with-dns/" rel="external nofollow noopener noreferrer" target="_blank">DNS-SD</a> 文章，跟這個其實很像。</p></blockquote><p>所以整體流程會變成像這樣</p><ol><li>詢問 <code>PTR _airplay._tcp.local</code> 獲得 <code>_airplar._tcp.local PTR 臥室._airplay_.tcp.local</code> 的回答</li><li>詢問 <code>SRV 臥室._airplay_.tcp.local</code> 獲得 <code>臥室._airplay_.tcp.local SRV 0 0 7000 Sonos-0xAF.local</code> 的回答</li><li>詢問 <code>A Sonos-0xAF.local</code> 獲得 <code>Sonos-0xAF.local A 172.31.1.166</code> 的回答</li></ol><p>基於這些情報，我們可以彙整出：</p><ol><li>有一個裝置叫做「臥室」</li><li>IP 位置是 <code>172.31.1.166</code></li><li>使用 7000 Port 可以和他建立連線</li></ol><p>那麼，我們稍微調整一下程式碼讓我們可以拿到 PTR 來顯示詳細資訊。</p><blockquote><p>DNS-SD 的 <a href="https://tools.ietf.org/html/rfc6763" rel="external nofollow noopener noreferrer" target="_blank">RFC6763</a> 提到回應 PTR 時要把 SRV / TXT / A 都一起回覆，理論上我們是不太需要重複詢問 SRV / TXT / A 的，不過因為除了 PTR 會把 TTL 設定的比較長，其他都會設定為短時間，好在一段時間後確認 IP 是否有變動之類的。</p></blockquote><p>我們先稍微重構一下，讓 <code>MDNS</code> 可以指篩選出我們有興趣的 PTR Record 回應給我們。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># :nodoc:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MDNS</span></span></span><br><span class="line">  <span class="keyword">include</span> Enumerable</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 略</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">listen</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> @thread</span><br><span class="line"></span><br><span class="line">    @thread = Thread.new <span class="keyword">do</span></span><br><span class="line">      loop <span class="keyword">do</span></span><br><span class="line">        packet, = @socket.recvfrom(<span class="number">4096</span>)</span><br><span class="line">        reply = Resolv::DNS::Message.decode(packet)</span><br><span class="line">        <span class="keyword">next</span> <span class="keyword">if</span> reply.qr.zero?</span><br><span class="line">        <span class="keyword">next</span> <span class="keyword">if</span> ptr?(reply)</span><br><span class="line"></span><br><span class="line">        @replies &lt;&lt; reply</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">each</span><span class="params">(&amp;_block)</span></span></span><br><span class="line">    loop <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">yield</span> @replies.shift <span class="keyword">until</span> @replies.empty?</span><br><span class="line">      sleep <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  private</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">ptr?</span><span class="params">(reply)</span></span></span><br><span class="line">    reply.answer.reduce(<span class="literal">true</span>) <span class="keyword">do</span> <span class="params">|prev, (_, _, data)|</span></span><br><span class="line">      prev &amp; data.is_a?(Resolv::DNS::Resource::IN::PTR)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">mdns = MDNS.new</span><br><span class="line">mdns.listen</span><br><span class="line">mdns.each <span class="keyword">do</span> <span class="params">|reply|</span></span><br><span class="line">  reply.each_answer <span class="keyword">do</span> <span class="params">|name, _, _|</span></span><br><span class="line">    ap name</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>執行後會獲得類似這樣的的訊息，因為 PTR 回應的是 Instance Name 所以是預期的結果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#&lt;Resolv::DNS::Name: 臥室._airplay._tcp.local.&gt;</span><br><span class="line">#&lt;Resolv::DNS::Name: Sonos-7828CAC4542C.local.&gt;</span><br><span class="line">#&lt;Resolv::DNS::Name: 7828CAC4542C@臥室._raop._tcp.local.&gt;</span><br></pre></td></tr></table></figure><p>如此一來，我們只要稍加修改就可以篩選出是提供 Airplay / Chromecast 的裝置。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Airplay 有兩種</span></span><br><span class="line">airplay = Resolv::DNS::Name.create(<span class="string">'_airplay._tcp.local.'</span>)</span><br><span class="line">raop = Resolv::DNS::Name.create(<span class="string">'_raop._tcp.local.'</span>)</span><br><span class="line"><span class="comment"># Chromecast</span></span><br><span class="line">chromecast = Resolv::DNS::Name.create(<span class="string">'_googlecast._tcp.local.)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mdns.each do |reply|</span></span><br><span class="line"><span class="string">  reply.each_answer do |name, _, _|</span></span><br><span class="line"><span class="string">    next unless name.subdomain_of?(airplay)</span></span><br><span class="line"><span class="string">    next unless name.subdomain_of?(raop)</span></span><br><span class="line"><span class="string">    next unless name.subdomain_of?(chromecast)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    ap name</span></span><br><span class="line"><span class="string">  end</span></span><br><span class="line"><span class="string">end</span></span><br></pre></td></tr></table></figure><blockquote><p>另外我們可以透過 <code>reply.each_addationial</code> 獲取更多資訊，不過可惜的是 <code>Resolv::DNS::Message</code> 在解析時可能因為某些關係只能知道他是 <code>PTR</code> 但是無法正確解析，就會獲得 <code>Generic::Type12_XXXX</code> 這種類型的物件，反而不好處理。</p></blockquote><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>在做這個技術測試的時候，發現蠻多情境下大家都是串 C API 然後去呼叫作業系統提供的 DNS-SD 機制來實作，不過在了解原理的狀況下，其實我們還是可以靠純 Ruby 的方式實現一定程度的 DNS-SD 機制。</p><p>那麼，這個技術有什麼用途嗎？在五倍的 IoT 專案 <a href="https://tamashii.io" rel="external nofollow noopener noreferrer" target="_blank">Tamashii</a> 當時因為裝置很多的關係，我們就有研究過透過 DNS-SD 去找到區網內的裝置，然後讓他能夠一次性的套用或者修改設定，不過礙於各種因素就暫時沒有把他實作出來。</p><p>這次重新審視之後發現其實還是非常有用的，近期應該會更新一個在 Tamashii 專案下可以使用的 DNS-SD Gem 吧！</p><blockquote><p>礙於篇幅，其實還有下篇 - 偽裝成 Airplay 裝置的系列，不過就先到這裡告一段落吧！</p></blockquote>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/12/25/Use-Ruby-to-find-the-Airplay-or-Chromecast-device/#disqus_thread</comments>
    </item>
    
    <item>
      <title>為什麼要學習 Bootstrap 呢？</title>
      <link>https://blog.frost.tw/posts/2018/11/27/Why-we-choose-the-Bootstrap/</link>
      <guid>https://blog.frost.tw/posts/2018/11/27/Why-we-choose-the-Bootstrap/</guid>
      <pubDate>Tue, 27 Nov 2018 13:07:50 GMT</pubDate>
      <description>
      
        &lt;p&gt;最近在工作上或者跟有在做網站開發的朋友聊天，都剛好會討論到 &lt;a href=&quot;https://getbootstrap.com/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Bootstrap&lt;/a&gt; 這個 CSS 框架。&lt;/p&gt;&lt;p&gt;在業界，我想大部分的公司也大多會以 Bootstrap 為基礎來開發網站，而這幾年網路上可以買到的版型也多以 Bootstrap 為主。&lt;/p&gt;&lt;p&gt;從這些跡象看起來，會使用 Bootstrap 很重要，中間的過程跟原因是什麼呢？&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>最近在工作上或者跟有在做網站開發的朋友聊天，都剛好會討論到 <a href="https://getbootstrap.com/" rel="external nofollow noopener noreferrer" target="_blank">Bootstrap</a> 這個 CSS 框架。</p><p>在業界，我想大部分的公司也大多會以 Bootstrap 為基礎來開發網站，而這幾年網路上可以買到的版型也多以 Bootstrap 為主。</p><p>從這些跡象看起來，會使用 Bootstrap 很重要，中間的過程跟原因是什麼呢？</p><a id="more"></a><h2 id="很久以前"><a href="#很久以前" class="headerlink" title="很久以前"></a>很久以前</h2><p>最早的時候，我們在製作網頁大多還是透過像是 <code>&lt;table&gt;</code> 跟 <code>float: left</code> 等等變化去組合網頁，當時其實大多沒什麼概念，能跟後端的程式搭配起來就好了。</p><p>像是 PHP 早期就會將 HTML 和 PHP 混合在一起撰寫，而很多程式語言最初也都是用類似的方式動態的組合 HTML 並且將它輸出到網頁上。</p><p>不過，當專案越來越大的時候，這看起來就不太好維護了！</p><h2 id="樣板引擎"><a href="#樣板引擎" class="headerlink" title="樣板引擎"></a>樣板引擎</h2><p>像是 Ruby 中有 <code>ERB</code>、<code>slim</code> 可以使用，或者 PHP 有 <code>Twig</code>、<code>Smarty</code> 等等，為了能將程式的邏輯部分跟顯示的部分分離出來，開始出現了樣版引擎這種類型的工具，讓我們可以將工作區分為負責邏輯部分以及顯示部分兩個區塊，只要數值能對應起來，就可以正常顯示。</p><blockquote><p>此時，都還是後端工程師在製作這些網頁，沒有前後端之分。</p></blockquote><h2 id="JavaScript-的時代"><a href="#JavaScript-的時代" class="headerlink" title="JavaScript 的時代"></a>JavaScript 的時代</h2><p>大概在 Gmail 使用了 Ajax 技術之後，大家開始注意到網頁的可能性。透過 JavaScript 以及各種 CSS/HTML 組合的技巧，網頁開始豐富了起來。</p><p>這也為之後的 HTML5 發展揭開了序幕。</p><h2 id="分工的變化"><a href="#分工的變化" class="headerlink" title="分工的變化"></a>分工的變化</h2><p>我們從將 HTML 和程式混合在一起，發展到了樣版引擎，又發展到了更加複雜且豐富的 HTML5 時代，原本簡單的 HTML 也變得不簡單，也因此我們需要耗費更多力氣在 HTML 和 CSS 上，這也是前端被切割出來的原因之一。</p><blockquote><p>最早的時候大概只會分設計跟後端而已，而且設計給的圖片就由後端想辦法實現。</p></blockquote><h2 id="互相卡住的分工"><a href="#互相卡住的分工" class="headerlink" title="互相卡住的分工"></a>互相卡住的分工</h2><p>當我們有了設計、前端跟後端，分工變的精細，卻也因此被其他人的工作進度卡住。因為後端總是要等前端提供可操作的網頁，整合到後端上才能夠進行測試。而前端又需要等待設計提供設計圖，才能夠依照設計圖切出對應的版型。</p><p>所以這個分工組合剛開始出現時，我們很容易就變成「等設計」「等前端」再「等後端」的流程，讓效率變得非常差。</p><p>以前我也常思考能不能優化這個流程，而這也是當時大家偶爾會思考到的問題，一些大公司到底有什麼作法呢？我們也不一定有機會知道。</p><h2 id="標準化"><a href="#標準化" class="headerlink" title="標準化"></a>標準化</h2><p>不過同時間，設計跟前端的工作量也逐漸變大，而且 UX 的意識也逐漸出現，為了應對這些問題，我們開始看到一些大公司整理了 Design Pattern（不是程式上的，是 UI 設計上的模式）來將常見的網頁排版歸納。</p><p>基於這樣的的改念，我們開始看到了「元件化」概念的出現，而 Bootstrap 從這樣的時空背景下，將 Twitter 製作網站的 UI 元件搜集起來，基於這樣的概念，我們發現了一個重要的事情。</p><h2 id="缺少的東西"><a href="#缺少的東西" class="headerlink" title="缺少的東西"></a>缺少的東西</h2><p>Bootstrap 提供了我們以往很少完整規劃的 UI 元件組合，而大家也開始注意到如果有一個統一的「標準」不論是設計、前端或者後端，我們都能夠在不互相干擾的前提之下「同時作業」</p><p>以設計的工作來看，設計只要能夠提供與 Bootstrap UI 元件對應的樣式風格，即使再怎麼調整或者修改，前端都有辦法在不影響原有的進度下，根據設計提供的元件繼續的擴充或者修改。</p><p>而後端要測試系統的操作，也只需要使用符合 Bootstrap 規範的 HTML 結構即可，在未來只要由前端調整或者直接使用，那麼就可以使用。</p><p>有了這樣的機制，我們就能夠減少很多溝通跟調整的時間成本，進而專注在自己應該專注的任務上。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>簡單的從網頁的發展的幾個里程碑變化來看 Bootstrap 的出現原因就能夠大概發現他的優點，其實最近工作上也有遇到客戶的前端切版出來後因為不是使用 Bootstrap 而切版的方式幾乎是換一頁就無法重複利用元件，反而造成困擾的狀況。雖然問題不是出在沒有使用 Bootstrap 上，但是不完整的元件切割跟高度耦合頁面呈現，都讓開發人員在套用版型上遇到了很大的困難，反而讓效率下降很多。</p><p>實際上使用 Bootstrap 並不是重要的關鍵，像是 Material UI 也是可以採用的選項，不過因為 Bootstrap 已經非常普及，再加上大部分的人都能夠使用，所以在開發專案有時程壓力的情況下，使用 Bootstrap 大多是容易調整跟減少溝通時間的最佳方案。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/11/27/Why-we-choose-the-Bootstrap/#disqus_thread</comments>
    </item>
    
    <item>
      <title>轉職工程師：尋找自己的價值</title>
      <link>https://blog.frost.tw/posts/2018/11/06/Become-a-programmer-Find-your-own-value/</link>
      <guid>https://blog.frost.tw/posts/2018/11/06/Become-a-programmer-Find-your-own-value/</guid>
      <pubDate>Tue, 06 Nov 2018 12:55:40 GMT</pubDate>
      <description>
      
        &lt;p&gt;這系列的文章已經稍微討論過我自己在學習寫程式過程中的&lt;a href=&quot;https://blog.frost.tw/posts/2018/09/25/Become-a-programmer-lose-at-the-starting-line/&quot;&gt;心態&lt;/a&gt;、&lt;a href=&quot;https://blog.frost.tw/posts/2018/10/02/Become-a-programmer-how-to-start/&quot;&gt;方法&lt;/a&gt;跟&lt;a href=&quot;https://blog.frost.tw/posts/2018/10/23/Become-a-programmer-Why-is-bottleneck-coming-very-soon/&quot;&gt;困難&lt;/a&gt;，最後就來討論最後一個我認為很重要的問題。&lt;/p&gt;&lt;p&gt;不論學了什麼，或者有多麽厲害的技術，作為一個工程師我們的價值在哪裡？&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>這系列的文章已經稍微討論過我自己在學習寫程式過程中的<a href="https://blog.frost.tw/posts/2018/09/25/Become-a-programmer-lose-at-the-starting-line/">心態</a>、<a href="https://blog.frost.tw/posts/2018/10/02/Become-a-programmer-how-to-start/">方法</a>跟<a href="https://blog.frost.tw/posts/2018/10/23/Become-a-programmer-Why-is-bottleneck-coming-very-soon/">困難</a>，最後就來討論最後一個我認為很重要的問題。</p><p>不論學了什麼，或者有多麽厲害的技術，作為一個工程師我們的價值在哪裡？</p><a id="more"></a><h2 id="殘酷的問題"><a href="#殘酷的問題" class="headerlink" title="殘酷的問題"></a>殘酷的問題</h2><p>有時候，可能會想到一些在網路上看過或者似乎很已明的人，可能會有點嫉妒「明明沒什麼能力為什麼待遇這麼好？」「他只是運氣好而已吧！」「他只是靠關係而已！」之類的，我們越思考這個問題，就開始覺得有很多人「條件比自己差」但是總是能能拿到比自己好的待遇。</p><p>所以，問題真的是自己「能力」差的關係嗎？忘記從什麼時候開始，我偶爾會思考這個問題。</p><p>很可惜，在「業界」能力雖然很重要，但是偏偏不是「唯一」的條件。</p><blockquote><p>還有一些人是很擅長包裝自己，不過這篇文章不討論，因為我也不太清楚那是怎麼運作的。</p></blockquote><h2 id="應該扮演的角色"><a href="#應該扮演的角色" class="headerlink" title="應該扮演的角色"></a>應該扮演的角色</h2><p>以在五倍來說，在很多外面的活動如果被老闆們介紹，常常會聽到老闆說「我們家的工程師都比老闆厲害」這樣的話，在五倍老闆（甚至負責行政的同事）幾乎全部的人都懂程式，但是為什麼會這樣介紹呢？</p><p>單純就技術面來說，老闆們確實在像是「開會」的這些日常任務中慢慢失去了可以磨練技術的機會。但是對五倍這間公司重要的是什麼？公司的案源、人脈，還有面對客戶的壓力等等問題，都是由「老闆」這個角色負責的，所以能力真的很重要嗎？</p><p><strong>要看你現在是什麼角色</strong></p><p>我從小就確定我不適合當「領導者」這個角色，如果是小團隊的話我倒是有自信讓一個團隊發揮出更好的成果，但是如果是一個大的組織，我認為我是不適合帶領一大群人的。</p><p>所以我給自己的角色是一個「輔助者」的角色，儘可能的讓被支援的人可以安心的去專注在他應該專注的事情上，以我的工作來說，我要做的就是儘可能地去改善開發上的環境跟方法，讓公司能有更多的選擇。</p><blockquote><p>有機會我就會去嘗試一些新的東西，像是 CI/CD 的建立、一些針對工程師的輔助和管理的工具等等，或者是在部署上的嘗試，因為不知道什麼時候可能會需要用到，必要的時候也能夠過類似的概念去推測對應的方案。</p></blockquote><p>其實這些事情誰來做都可以，只不過⋯⋯</p><p><strong>對你來說，你認為值不值得做？</strong></p><h2 id="失去還是得到？"><a href="#失去還是得到？" class="headerlink" title="失去還是得到？"></a>失去還是得到？</h2><p>以前和人聊過，如果把一些東西「自動化」之後，原本自己負責的工作就會變得輕鬆。那麼就有可能失業或者被安排更多的工作，那麼「自動化」到底是好還是不好呢？</p><p>像是前陣子因為人工智慧的發展，開始能夠自動的寫程式，就有人就開始提出「未來工程師會失業」之類的像法，或者像是淘寶這幾年用人工智慧製作廣告橫幅的技術好了，設計師或工程師真的會失業嗎？</p><p>週末在 Netflix 上看了一部叫做「機械拳擊（Megalo Box）」的動畫，在主角爭奪進入決賽的資格時，對上的就是人工智慧的拳擊裝甲，但是即使人工智慧能夠預測所有的動作，當他碰到預期之外的事情時，他就無法做出反應。</p><p>而裡面總是回提到一句話「在擂台上，只有真的能留下來」</p><p>所以，我實際上是不擔心，也不害怕我去做這些工具、自動化的輔助，會影響我在工作上的待遇或者工作的內容，對工作來說，我的想法也挺簡單的。</p><p><strong>得到多少待遇，就付出多少力氣</strong></p><p>所以當我有能力創造這些工作加速我的工作時，我應該是期待我的待遇會被提高才對吧？因為我能比其他人負擔更多任務，也就表示我在一個團隊裡面「更重要」</p><p>另一方面，即使我把這些東西設定和配置出來，也不代表在缺少我的情況下這些工具是能使用的。</p><blockquote><p>大家有沒有碰過一些接過來的專案，所有人都是照著使用，但是卻沒有人知道最初是怎麼用的？而原作者可能還已經離職很久了，這個東西其實處於隨時都可能突然無法用的狀態。</p></blockquote><p>就像我配置的 CI 設定好了，雖然大部分的專案都能複製過去使用，但是每個專案的細微差距，其實在不同專案間因為沒有調整而有些微的問題，但有在使用的同事都沒有注意到（最後是我自己找出來）</p><p><strong>改善自己跟同事的工作環境，不會是件壞事</strong></p><blockquote><p>另一個角度想，某件事情都是你在負責，已經嚴重干擾自己日常的工作。把他教給同事跟自動化，是改善工作的品質的一種手段，而且能讓你更專心在該做的事情上。</p></blockquote><h2 id="你需不需要夥伴？"><a href="#你需不需要夥伴？" class="headerlink" title="你需不需要夥伴？"></a>你需不需要夥伴？</h2><p>以前我覺得我「自己」就能夠做到所有的事情，什麼事情都「自己來」就可以了。畢竟從後端、前端或者設計、管理以及其他相關的知識，我都學過，也都建立了一個基本的概念。</p><p>不過，如果只是一個小專案，自己來是沒有問題的。但是現在是一個稍微有點規模的專案呢？即使動作再快，方法再好，也跟不上需求，所以你總是會需要夥伴。</p><p><strong>在一個團隊，只追求自己的進步效果是很差的</strong></p><p>如果你待的是一間很好的公司，最後選擇離開的理由通常會是什麼？我認為大多會是待遇和同事跟不上你的進步，所以你必須去換一個更好的公司。</p><p>但是如果這是一間夠好的公司，同事跟待遇都還不錯，如果發現同事跟待遇都要跟不上自己的話，我該做什麼事情？</p><p><strong>讓這個團隊成長</strong></p><p>程式語言社群其實就是一個例子，只要還有人希望這個語言成長、有人使用，那麼就會開始分享、舉辦活動。這也是我很喜歡找同事聊技術（即使同事可能不想！？）或者參加研討會去分享我知道的東西，因為只有創造一個良性的循環，我們才有機會繼續互相讓對方成長。</p><blockquote><p>而且收到回饋的時候，會發現有更多有趣的事物可以去探索。</p></blockquote><h2 id="自身的價值"><a href="#自身的價值" class="headerlink" title="自身的價值"></a>自身的價值</h2><p>不論是在玩遊戲，或者是在工作上，我想不管是誰都希望自己「被信任」所以老闆/組長才會放心的把工作交給你，而我們的責任就是把工作做好、完成。</p><p>在五倍我也是很相信同個專案的同事，無關能力或者其他東西，我認為一起工作的夥伴都會把工作做好為前提，如果真的做的不理想，那麼就來討論為什麼會這樣，要怎麼改善就好。</p><p>所以，得到的待遇跟期待，有時候無關能力，還跟態度有關係。</p><p>就像<a href="https://blog.frost.tw/posts/2018/09/10/How-to-choose-your-first-job/">怎麼選第一篇工作？</a>和<a href="https://blog.frost.tw/posts/2018/05/14/About-my-first-time-interview-and-resume/">我怎麼準備履歷</a>兩篇文章，我都提出「態度」的問題。</p><p>我設定給自己的角色是一個「輔助」的角色，而且我相信同事跟老闆應該都是「信任」我會把事情做好，所以才會請我協助的。</p><blockquote><p>提升能力對我來說確實是重點，但是在能力之外，我還是會注意我自己的態度是不是正確，或者有沒有要改善的地方。</p></blockquote><p>偶爾有人會問我說「以你現在這樣的能力，這個待遇是不是太低了？」我雖然會想一下，但是其實並沒辦法做出一個適當的回答，一方面是我認為我的表現老闆都看得到。另一方面是我知道我自己還有很多地方做不好，像是有時候會對一些問題因為定義上很糾結，反而卡住跟客戶討論的進度，或者不太能掌握該提出什麼比較適合。</p><p><strong>能力只是一種手段可以靠學習，但是人格特質需要細心培養</strong></p><p>所以不要覺得上了課就能順利成為工程師，也不要覺得能力很強了就可以拿到好的待遇。因為我們的問題很可能「不在能力」上面。</p><blockquote><p>其實工程師的職缺也不難拿到，還是很常聽到有人在找工程師。只不過作為一個工程師之外，是不是還需要有其他人格上的要素去配合，才能擔任好這個角色？</p></blockquote><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>雖然文章提到了除了個人能力以外，扮演什麼角色也很重要。還有一個我「不擅長」也「不喜歡使用」的方式，那就是讓自己變得出名（包裝自己）。這不是一件壞事，只是要看運用得恰不恰當就是了，至少在我知道的人們裡面，有惡名昭彰的，也有我認為做得非常好我學不來的。</p><p><strong>太多出名的人都是過度包裝的</strong></p><p>如果是因為做事做得好（像是教學、熱心參與社群）而變得出名，那當然是令人尊敬的。不過現實上，程式圈我們總是會看到一些「沒有什麼實力」的人被很多人吹捧，然後因為支持者眾多，有很難提出反面的意見，反而讓很多可以思考跟討論的問題剩下一個唯一的答案。</p><p>雖然不知道是不是錯覺，其實我個人感覺這幾年很多真正的高手都像是隱居起來，然後一些社團之類的混亂，就這樣繼續亂下去⋯⋯（也許是真的回到累了，所以放手了吧 XD）</p><p>所以比起這些方式，我比較喜歡慢慢累積，隨著時間體現（累積）自己的價值。</p><blockquote><p>寫文章、分享、參與社群活動，其實很累，不過也是一種累積的方式。</p></blockquote>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/11/06/Become-a-programmer-Find-your-own-value/#disqus_thread</comments>
    </item>
    
    <item>
      <title>轉職工程師：為什麼馬上就遇到瓶頸？</title>
      <link>https://blog.frost.tw/posts/2018/10/23/Become-a-programmer-Why-is-bottleneck-coming-very-soon/</link>
      <guid>https://blog.frost.tw/posts/2018/10/23/Become-a-programmer-Why-is-bottleneck-coming-very-soon/</guid>
      <pubDate>Tue, 23 Oct 2018 12:49:47 GMT</pubDate>
      <description>
      
        &lt;p&gt;前面已經討論了&lt;a href=&quot;https://blog.frost.tw/posts/2018/09/25/Become-a-programmer-lose-at-the-starting-line/&quot;&gt;起步的心態&lt;/a&gt;跟&lt;a href=&quot;https://blog.frost.tw/posts/2018/10/02/Become-a-programmer-how-to-start/&quot;&gt;起步的方法&lt;/a&gt;兩個問題，好不容易開始寫程式了，卻發現⋯⋯&lt;/p&gt;&lt;p&gt;&lt;strong&gt;照著教學做，但是沒有教學就完全不會&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;不管是去上更多的課，還是看更多的教學，怎麼樣都無法擺脫這個問題。這到底是什麼原因呢？&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>前面已經討論了<a href="https://blog.frost.tw/posts/2018/09/25/Become-a-programmer-lose-at-the-starting-line/">起步的心態</a>跟<a href="https://blog.frost.tw/posts/2018/10/02/Become-a-programmer-how-to-start/">起步的方法</a>兩個問題，好不容易開始寫程式了，卻發現⋯⋯</p><p><strong>照著教學做，但是沒有教學就完全不會</strong></p><p>不管是去上更多的課，還是看更多的教學，怎麼樣都無法擺脫這個問題。這到底是什麼原因呢？</p><a id="more"></a><h2 id="學會使用"><a href="#學會使用" class="headerlink" title="學會使用"></a>學會使用</h2><p>在剛入門的階段，或者我在教人的時候，最初的階段我會希望「即使有問題也先不要問」我們先專注在一個事情上，那就是「熟練」</p><p>熟練什麼？以 Ruby 和 Rails 來舉例子，就是先要做到 Ruby 大部分的語法都可以不用查資料或者問題之類的，還有就是像 Rails 的一些基本的操作都能夠使用。</p><p>這樣一來，你在後續提問或者去找答案的時候才會有一種感覺。</p><p><strong>這個東西我知道，原來是因為這樣！</strong></p><p>舉例來說，如果一個寫 Ruby 的工程師連下面這段程式都還不太清楚會發生什麼事情，那麼去思考原理就還太早了。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].each <span class="keyword">do</span> <span class="params">|num|</span></span><br><span class="line">  puts num</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><blockquote><p>上述的程式即使你不清楚 <code>[]</code> <code>each</code> <code>do ... end</code> 是做什麼用的，至少也要有能力執行它發現會顯示出數字，或者根據過去操作的經驗推測他可能出現一些數字。</p></blockquote><p>當然，上面的舉例其實很基本，大部分的人在學到的時候應該都已經隱約了解一些原理了。</p><blockquote><p>其實一個課程或者教材的好或者不好，就看他是不是都只局限在這個階段，如果都給你一些反覆操作就能做出來的東西，那麼你就會覺得「卡住」跟「好像還是什麼都不會」</p></blockquote><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>既然我們已經對一些基本的程式有一些概念，接下來去探討原理或者「理由」之類的問題就會比較好理解跟上手。</p><p>我有時候會思考，我理解的「藍色」跟其他人的「藍色」是不是一樣的。不過因為沒辦法讀取別人的想法，所以我只能簡單的假設，因為看到的「藍色」是相同的東西，所以我們對藍色的理解應該是接近的。</p><blockquote><p>其實這是一個很有趣的問題，那麼當色盲遇到同樣的顏色分不出來，我們的理解還是相同的嗎？</p></blockquote><p>同樣的道理可以證明，為什麼在「初學」的階段先不要對各種「新事物」想要有太多的解答，因為這些知識就有點類似遊戲的關卡解鎖一樣，需要到某個程度的理解，才能夠繼續。</p><p><strong>如果現在不懂，去學點其他的東西，再回來看一遍</strong></p><p>從上面的程式來說，裡面用到了叫像是「陣列」「迴圈」「迭代器」這些概念，如果前面兩個無法瞭解的話，就很難對「迭代器」有概念，就會對 <code>each</code> 的原理有困難，而 <code>each</code> 的真正運作，又會跟 Ruby 語言特性的 Block （區塊）也就是 <code>do ... end</code> 有關係。</p><p>所以在第一次接觸新的寫法（即使是複雜的寫法）我都會打開電腦，然後試著寫出來看看，去檢測他的運作邏輯是怎樣的，在嘗試去理解背後的原理。</p><p>像是在 C 語言裡面關於陣列的儲存其實又跟「指標」是有關係的，如果理解了指標的概念，就會對陣列有更深入的了解，近一步的對迭代器的運作又會有新的認識。</p><p>透過這樣不斷的「擴充」知識，我們就能夠逐漸的對一個程式語言越來越了解，並且能夠組織更加複雜的專案。</p><p>關於這個階段，其實我猜我在教人的時候有時候可能會覺得我很兇是因為我常常會拿著程式碼然後問「你覺得這是怎樣的？」「這是什麼意思？」</p><p>其實我是在確認一個問題，就是對方是否「把知識連接起來」如果問了完全回答不出來，那麼就表示說要再往回退，找到一個適合的點把概念串接起來，才能夠順利繼續。</p><blockquote><p>所以有些工程師討論東西像在吵架⋯⋯</p></blockquote><p>另外一個有趣的地方是我以前常常會「塞」很多東西給新手，大概可以介紹個一兩小時這樣。然後就會被對方回答說「我回去再看看⋯⋯」然後就沒下文了，大概是被嚇到吧，或是消化需要花很多時間。</p><p>其實不管哪個領域都是這樣，我們很多時候都覺得自己（應該）很專業但是實際上如果發現自己連「舉例」都舉不出來，真的就不要有幻覺了⋯⋯</p><blockquote><p>上週五才跟同事討論 3D 建模的問題，因為他在讀碩班老師讓他選。我就簡單介紹了我在大學讀多媒體的知識，其實光是我這樣「皮毛」的東西，仔細想想可能就要花上一兩年練習了，所以我是建議不要選這塊比較不熟的。<br>3D 建模除了要會軟體外，其實還要有繪畫（材質）跟攝影（光影）的基礎，才能做出好看的靜態模型，動起來就更困難了⋯⋯</p></blockquote><h2 id="以一化千，化繁為簡"><a href="#以一化千，化繁為簡" class="headerlink" title="以一化千，化繁為簡"></a>以一化千，化繁為簡</h2><blockquote><p>這個小標題感覺超中二的 XD</p></blockquote><p>有些人可能知道我從蠻小的時候就開始學寫程式，不過真正有明顯進步的其實也才五六年。在這之前，我其實花了大概五六年做一件事情——留言板。</p><p>當時能做出來的東西其實很少，也很簡單。做過最多次的東西就是留言板，而且我常常跟人這樣講。</p><p><strong>當你會做留言板，你就能做出大部分的網站</strong></p><p>以最簡單的留言板功能來看，其實就是一個 CRUD 的表現。</p><p>假設我們現在想將留言板進化，只需要這樣。</p><ol><li>留言功能</li><li>留言功能（複製） -&gt; 改名叫做分類</li><li>原本的留言功能增加設定分類</li></ol><p>當一個留言有了分類之後，就進化到了叫做「討論版」的等級。</p><p>所以，我們在更近一步的去改良一下。</p><ol><li>留言功能</li><li>留言功能（複製）-&gt; 改名叫做回覆</li><li>在回覆功能上增加設定目標留言</li></ol><p>現在討論板又進化成叫做「論壇」的東西。</p><p>所以，依照這個邏輯繼續做下去，理論上來說所有類型的網站都要可以實現。</p><p><strong>但是沒有想像的這麼簡單啊！</strong></p><p>如果我們要產生會員功能，還要檢查留言的權限才行，其實只是在加入了「判斷」的功能。</p><ol><li>留言功能</li><li>留言功能（複製）-&gt; 改名叫做會員，增加一些相關欄位（帳號密碼）</li><li>留言功能增加設定發表的會員</li></ol><p>然後再到編輯，原本是沒有限制的，這次只是增加上限制。</p><ol><li>編輯</li><li>（新增）檢查現在的會員是不是發表的會員</li><li>可以編輯</li></ol><p>所以，照這樣繼續發展下去，有更多的判斷跟資料檢查，就會慢慢構成一個完整的網站。</p><p>這就是「以一化千」也就是在理論上，我們應該能只用一種技巧做完所有事情。</p><blockquote><p>大致上來說就是邏輯判斷，還有迴圈的使用。</p></blockquote><p>如果把這些東西反過來看，當我們學習了各種五花八門的技巧，要怎麼樣用「最少的動作」做到「最多的事情」那就是「化繁為簡」的領域。</p><p>不過要接觸到這個世界，至少要很熟練才會漸漸的有感覺，我自己是在這一兩年才比較有一種「原來是這樣」的感覺。</p><blockquote><p>突破貧頸其實有時候就是練習量到了，就會有一種「好像懂了！」然後也能解釋的狀態。不過越到後面其實越痛苦，以前可能幾個月就能感覺到，現在一年可能只有一兩次 XD</p></blockquote><p>化繁為簡的入門就是「重構」的技巧，也就是我們怎麼從鬆散的程式碼變成一堆「函式」然後隨著函式的增加我們在繼續轉換成「物件」而大量的物件成變成一個「套件」（Ex. Ruby Gem）然後透過這些累積的套件在組成一個完整的「專案」</p><p>雖然在工作上我們都是從「專案」開始慢慢的重構出小段落，但是「變複雜」然後再「變簡單」就是作為一個專業工程師「專業表現」的一種。</p><blockquote><p>專業表現還有很多面向都會讓人覺得你很專業，不過這種能夠隨心所欲的重組程式的技巧，算是很基本也很容易看出程度的一種類型。越厲害的工程師在初始階段就能夠做到越好的拆分跟規劃，以整個系統等級的規劃來說，個人認為就是架構師（而且可能含包含了網路跟硬體層級等等的規劃）</p></blockquote><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>雖然每次結尾都覺得好像離題，不過我想大致上還是有在主題上（心虛）</p><p>其實「瓶頸」主要是因為「知識不足以支持繼續」的情況所造成的，通常我們學語言的時候會覺得自己要「深入」但是到了某個階段後就會發現無法繼續深入。</p><p>因為我們還缺少不少「電腦科學」的知識，這時候資訊相關科系的人真的是比較吃香。在這種情況，就可以考慮以「廣泛學習」的心態，去接觸不同的語言。</p><p>像是 Ruby / JavaScript 這類型的語言其實都沒有型別，那麼就去試試看有形別的語言。然後看看像是指標之類的東西，再回到 Ruby / JavaScript 上面思考，就會發現一些原本只寫一種語言看不到的東西。</p><p>另一方面就像是我們大多數都在學做「網站」都使用 Rails 來開發，但是有沒有試過用 Rack 直接架構網站伺服器？這些都會幫助對 Rails 的理解，因為有很多零碎的概念已經在很多高手的重構中一層一層的被隱藏起來。</p><p>所以，如果卡住的時候先不要緊張或者焦慮。先看看「還有什麼能做的？」然後去把那些「可以做沒做過」的事情做看看，也許再回到原本的問題，就會被解決了。</p><p>所以，那些厲害的高手或者身邊進步很快的朋友是不是都有一個類似的特點？</p><p><strong>常常做東西出來看看</strong></p><p>因為我們練習還不夠，所以卡住了，如果想進步快一點多花時間在「不一樣」的嘗試會更有效果。</p><blockquote><p>上一篇文章寫完被實習生問「努力不一定有效果」後來我想想，努力還是有效果，只是可能會有個人差異。另外還有一種可能，那就是練習的方式錯了，練習再多「會的東西」除了做出來比較快幾乎沒有幫助。</p></blockquote>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/10/23/Become-a-programmer-Why-is-bottleneck-coming-very-soon/#disqus_thread</comments>
    </item>
    
    <item>
      <title>客製化你樹莓派上運行的 Linux</title>
      <link>https://blog.frost.tw/posts/2018/10/09/Customize-a-linux-for-your-raspberrypi/</link>
      <guid>https://blog.frost.tw/posts/2018/10/09/Customize-a-linux-for-your-raspberrypi/</guid>
      <pubDate>Tue, 09 Oct 2018 13:29:53 GMT</pubDate>
      <description>
      
        &lt;p&gt;最近因為手邊有一個工作以外的專案需要搭配硬體做一些 IoT 類型的應用，雖然之前在五倍紅寶石開發的 Tamashii 系列應用已經足以應對在這個專案上開發所需的解決方案，但是依舊缺少了一些功能。&lt;/p&gt;&lt;p&gt;也就是我們過去並沒有考慮到的，如果裝置是交給一般使用者的狀況下，如何在透過網路的前提將裝置更新。&lt;/p&gt;&lt;p&gt;這是很多硬體都會有的功能，但是就目前而言 Tamashii 並不支援。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>最近因為手邊有一個工作以外的專案需要搭配硬體做一些 IoT 類型的應用，雖然之前在五倍紅寶石開發的 Tamashii 系列應用已經足以應對在這個專案上開發所需的解決方案，但是依舊缺少了一些功能。</p><p>也就是我們過去並沒有考慮到的，如果裝置是交給一般使用者的狀況下，如何在透過網路的前提將裝置更新。</p><p>這是很多硬體都會有的功能，但是就目前而言 Tamashii 並不支援。</p><a id="more"></a><p>經過幾天的調查，發現有一個 Open Source 的專案似乎符合條件。</p><h1 id="Mender-的-OTA-伺服器"><a href="#Mender-的-OTA-伺服器" class="headerlink" title="Mender 的 OTA 伺服器"></a>Mender 的 OTA 伺服器</h1><p>這個開源專案叫做 <a href="https://mender.io/" rel="external nofollow noopener noreferrer" target="_blank">Mender</a> 是透過好幾種程式語言組合而成，功能也很簡單。在預先製作好的 Linux 發行版本中寫入 Mender 伺服器的位置，只要在伺服器上「認證」這一台裝置，未來就能夠收到來自 Mender 伺服器所提供的更新。</p><p>而更新的方式基本上就是製作一份新的 Rootfs 提供給硬體裝置下載，並且嘗試將這個新的版本加入到現有硬體中，並且嘗試是否能夠正常的運行，如果失敗的話再將舊版的 Rootfs 載入。</p><p>也因此，要能夠使用 Mender 來發布 OTA (Over the Air）更新的話，就必須要能夠製作自己的 Linux 發行版本才可以。</p><h1 id="Yocto-專案"><a href="#Yocto-專案" class="headerlink" title="Yocto 專案"></a>Yocto 專案</h1><p>想要讓所有人都知道怎麼自己編譯完整的 Linux 作業系統是很困難的，從韌體、核心（Kernel）到各種開機所需要的套件庫（Library）等等，光是編譯的步驟就非常繁複，更何況還要配合使用不同開發版或者晶片的使用者。</p><p>所以 Mender 也採許了另一套開放原始碼的解決方案，叫做 Yocto 專案。這個專案跟另一個開源專案 OpenEmbedded 已經整合在一起，或者說能夠互通使用。</p><p>在 Yocto 之中，我們透過所謂的 Layer 的疊加就能夠製作出我們所需的 Linux 系統，而有很多硬體上所需要配合的韌體，也大多會有社群貢獻，因此在大部分的情況下都不太需要擔心。</p><blockquote><p>Mender 團隊也提供付費協助處理硬體整合上的問題，也許這是主要的收入之一？</p></blockquote><p>舉例來說，我想要製作一個能在 RaspberryPi 上面執行的 Linux 環境，就需要叫做 <code>meta-respberrypi</code> 這一個 Layer 來幫助我。</p><p>他會依賴於 <code>oe-core</code> 和幾個相關的 Layer 才能夠正確編譯（因為已經有的設定不用重複撰寫）</p><p>當我加入 <code>meta-raspberry</code> 之後，我在選擇編譯的機器類型時，就能夠用像是 <code>MACHINE=raspberrypi3</code> 這樣的模式告知我希望得到能在 Raspberry Pi 3 上執行的 Linux。</p><p>最棒的是，當我們完成這個動作之後，生成的 Linux 鏡像檔案燒入到 SD 卡中就能夠正常運行。</p><blockquote><p>以前嘗試過使用 Buildroot 來製作，但是失敗率非常高。</p></blockquote><p>簡單來說 Yocto 就是一堆社群貢獻預先撰寫好的建置腳本，因此我們只需要專注在自己需要預先加入這個 Linux 環境的部分，像是 Tamashii 或者 Ruby 的運行環境。</p><h1 id="初次嘗試"><a href="#初次嘗試" class="headerlink" title="初次嘗試"></a>初次嘗試</h1><p>首先，我們需要可以運行的環境。這篇文章使用的是 CentOS 7 來進行示範，所需的相關套件可以參考 <a href="https://www.yoctoproject.org/docs/2.4/yocto-project-qs/yocto-project-qs.html#yp-resources" rel="external nofollow noopener noreferrer" target="_blank">Yocto 官方文件</a>來配置，另外要注意的是目前較新版本是需要有 Python 3 的環境，但是 CentOS 7 還是使用 Python 2 需要自己配置。</p><h2 id="下載-Poky"><a href="#下載-Poky" class="headerlink" title="下載 Poky"></a>下載 Poky</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b sumo git://git.yoctoproject.org/poky</span><br></pre></td></tr></table></figure><p>Poky 類似於一個基礎的樣板，裡面將生成 Yocto 版本的 Linux 必要的相關檔案都放在裡面，我們可以基於這個資料夾來進行後續的設定跟配置。</p><blockquote><p>Yocto 每個版本都會有代號，目前最新的穩定版是 Sumo (2.5) 版</p></blockquote><h2 id="加入-Mender"><a href="#加入-Mender" class="headerlink" title="加入 Mender"></a>加入 Mender</h2><p>這篇文章會以 Mender 作為例子，這樣在成品階段的時候也比較好用 Mender 來體驗。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd poky</span><br><span class="line">git clone -b sumo git://github.com/mendersoftware/meta-mender</span><br></pre></td></tr></table></figure><p>如此一來，我們就可以在後續的階段使用由 Mender 所製作的 Layer 來提供 OTA 的功能。<br>不過在此之前，因為我們希望製作的是 Raspberry Pi 版本的 Linux 發行版本，所以還需要先把 Raspberry Pi 對應的 Layer 加入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone -b sumo git://git.yoctoproject.org/meta-raspberrypi</span><br><span class="line">git clone -b sumo git://git.openembedded.org/meta-openembedded</span><br></pre></td></tr></table></figure><h2 id="配置-Layer"><a href="#配置-Layer" class="headerlink" title="配置 Layer"></a>配置 Layer</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source oe-init-build-env</span><br></pre></td></tr></table></figure><p>因為 Yocto 已經提供好了各種設置，所以我們只需要透過上面的指令就能切換到對應的建置環境中。</p><blockquote><p>預設會產生一個 <code>build</code> 目錄，如果想要其他目錄的話也可以在後面指定。</p></blockquote><p>然後我們要告訴 Yocto 想要使用哪些 Layer 才能夠正常運作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bitbake-layers add-layer ../meta-mender/meta-mender-core</span><br><span class="line">bitbake-layers add-layer ../meta-openembedded/meta-oe</span><br><span class="line">bitbake-layers add-layer ../meta-raspberrypi</span><br><span class="line">bitbake-layers add-layer ../meta-mender/meta-mender-raspberrypi</span><br></pre></td></tr></table></figure><p>加入上述的 Layer 後，我們就可以產生一個能在 Raspberry Pi 上運行，以及透過 Mender 來做 OTA 更新的 Linux 發行版本。</p><p>不過礙於篇幅的關係，這次我們直接使用 Mender 提供的 Demo Layer 來加入客製化的內容。</p><blockquote><p>如果想加入自己編譯的程式、服務等等，是需要自己建立一個 Layer 來加入的，這樣也能對原有的 Layer 做擴充或者增加設定。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bitbake-layers add-layer ../meta-mender/meta-mender-demo</span><br><span class="line">bitbake-layers add-layer ../meta-mender/meta-mender-raspberrypi</span><br></pre></td></tr></table></figure><p>接下來，我們要對 <code>conf/local.conf</code> 進行設定，把伺服器位置等等設定值都加入到產生的 Linux 發行版本中，才能夠連接到正確的 Mender 伺服器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 釋出的版本，需要不同才能被辨識出來</span><br><span class="line">MENDER_ARTIFACT_NAME = &quot;release-1&quot;</span><br><span class="line"></span><br><span class="line">INHERIT += &quot;mender-full&quot;</span><br><span class="line"></span><br><span class="line"># 指定為 Raspberry Pi 3 是預設的目標</span><br><span class="line">MACHINE ?= &quot;raspberrypi3&quot;</span><br><span class="line"></span><br><span class="line"># 針對 Raspberry Pi 的額外設定</span><br><span class="line">RPI_USE_U_BOOT = &quot;1&quot;</span><br><span class="line">MENDER_PARTITION_ALIGNMENT = &quot;4194304&quot;</span><br><span class="line">MENDER_BOOT_PART_SIZE_MB = &quot;40&quot;</span><br><span class="line">IMAGE_INSTALL_append = &quot; kernel-image kernel-devicetree&quot;</span><br><span class="line">IMAGE_FSTYPES_remove += &quot; rpi-sdimg&quot;</span><br><span class="line"></span><br><span class="line"># 你的 Mender OTA 更新伺服器</span><br><span class="line">MENDER_SERVER_URL = &quot;https://ota.tamashii.io&quot;</span><br><span class="line"></span><br><span class="line">DISTRO_FEATURES_append = &quot; systemd&quot;</span><br><span class="line">VIRTUAL-RUNTIME_init_manager = &quot;systemd&quot;</span><br><span class="line">DISTRO_FEATURES_BACKFILL_CONSIDERED = &quot;sysvinit&quot;</span><br><span class="line">VIRTUAL-RUNTIME_initscripts = &quot;&quot;</span><br><span class="line"></span><br><span class="line">ARTIFACTIMG_FSTYPE = &quot;ext4&quot;</span><br><span class="line"></span><br><span class="line"># Raspberry Pi WiFi 設定（Demo 才有開啟 WiFi 功能）</span><br><span class="line">MENDER_DEMO_WIFI_SSID ?= &quot;ssid&quot;</span><br><span class="line">MENDER_DEMO_WIFI_PASSKEY ?= &quot;password&quot;</span><br></pre></td></tr></table></figure><h2 id="建置"><a href="#建置" class="headerlink" title="建置"></a>建置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitbake core-image-full-cmdline</span><br></pre></td></tr></table></figure><p>執行這個指令後，大概會要花上數小時才會完成，這段時間可以睡覺或打個遊戲。</p><blockquote><p>開發階段我會推薦使用 <code>full-cmdline</code> 的版本，因為可以直接 SSH 到機器或者接上鍵盤除錯。</p></blockquote><p>確認跑起來都沒問題之後，就可以改為使用 <code>core-image-minimal</code> 製作出刪減掉除了開啟 Linux 以及自己加入的額外功能之外，所有不必要的檔案來盡可能的縮小檔案大小。</p><h1 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h1><p>到這篇文章完成建置的段落，其實從頭到尾只花上數小時。不過目前還在測試如何讓有 C Extension 的 Ruby Gem 可以正常的被 Cross Compile 並且放進自訂的發行版本。</p><p>如果只是想單純的啟用 Ruby 的功能，直接在 <code>conf/local.conf</code> 裡面加上這行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_INSTALL_append = &quot;ruby &quot;</span><br></pre></td></tr></table></figure><p>在自訂的發行版本就可以使用 ruby 指令（目前預設是 2.5.0 版）</p><h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>這篇文章其實只是很粗略的將 Yocto 可以做的事情介紹出來，實際上深入了解 <code>bitbake</code> 這套工具以及 Layer 機制後，就會發現還有很多東西可以做。</p><p>舉例來說能透過 <code>.bbclass</code> 定義一個範本（Ex. <code>rubygem.bbclass</code>）讓其他套件（<code>Package</code>）繼承使用，而除了 Layer 之外，底下還有細分了食譜（<code>Receipe</code>）和套件（<code>Package</code>）可以做很多變的調整。</p><p>或者透過 <code>.bbappend</code> 來對原本的套件修訂，像是目前正在製作的 Tamashii Linux 就是利用這種方法讓 Ruby Gem 的 Cross Compile 得以實現。</p><p>如果之後已經有成熟的 Tamashii Linux 案例，會在分享該如何在 Yocto 上面客製化以 Ruby 為基底的 IoT 裝置嵌入是系統。</p>]]></content:encoded>
      
      <comments>https://blog.frost.tw/posts/2018/10/09/Customize-a-linux-for-your-raspberrypi/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
