<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>弦而時習之</title><link>https://blog.frost.tw/</link><description>Recent content on 弦而時習之</description><generator>Hugo -- gohugo.io</generator><language>zh-TW</language><managingEditor>contact@frost.tw (蒼時弦也)</managingEditor><webMaster>contact@frost.tw (蒼時弦也)</webMaster><lastBuildDate>Sun, 21 Feb 2021 22:07:21 +0800</lastBuildDate><atom:link href="https://blog.frost.tw/index.xml" rel="self" type="application/rss+xml"/><item><title>TDD 與持續重構課程心得</title><link>https://blog.frost.tw/posts/2021/02/21/experience-of-tdd-continuous-refactoring/</link><category>TDD</category><category>重構</category><category>心得</category><pubDate>Sun, 21 Feb 2021 22:07:21 +0800</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2021/02/21/experience-of-tdd-continuous-refactoring/</guid><description>&lt;p>年初上完&lt;a href="https://blog.frost.tw/posts/2021/01/10/experience-of-unit-testing-effectively-with-legacy-code/">針對遺留代碼加入單元測試的藝術&lt;/a>後，這週末又上了另一門相關的課程。在開始上課後發現很大的突破自己以往的觀念，同時也多出很多想法以及想嘗試的事情。&lt;/p></description><content:encoded>&lt;p>年初上完&lt;a href="https://blog.frost.tw/posts/2021/01/10/experience-of-unit-testing-effectively-with-legacy-code/">針對遺留代碼加入單元測試的藝術&lt;/a>後，這週末又上了另一門相關的課程。在開始上課後發現很大的突破自己以往的觀念，同時也多出很多想法以及想嘗試的事情。&lt;/p>
&lt;h2 id="content">課程節奏、內容&lt;/h2>
&lt;p>跟上一篇文章一樣，先來介紹一下課程的內容跟節奏。內容的話其實跟大家想像的差異蠻大的，寫測試的時間本身不多反而是更著重在為何而寫測試這件事情上面。節奏來說其實非常緊湊，這陣子又有一點精神上的狀況所以上課起來更加吃力一些，兩天的課程基本上就是講解概念跟實戰的搭配，不要認為自己會跟不上就不去報名。除了會因為太熱門要排到明年之外，這門課光是課堂上的練習跟回到工作中練習使用，就會有很大的改善跟幫助。&lt;/p>
&lt;p>就我自己的感想來看，以我自己在&lt;a href="https://5xruby.com">五倍紅寶石軟體開發&lt;/a>的經驗，其實已經有應用到一部分的概念但是非常的零碎，而在台灣目前很難有系統地學習這方面的知識，不論是想讓自己更近一步或者導入到工作中都是很不錯的。&lt;/p>
&lt;h2 id="從理解需求開始">從理解需求開始&lt;/h2>
&lt;p>第一個練習是實作 &lt;a href="https://www.facebook.com/91agile">91 哥&lt;/a>經常會在 Facebook 上分享的 Tennis 的練習，在不知道詳細的規格的前提下，我們需要從 Product Owner（講師）身上問出更多的細節，像是網球中每一個分數都會有自己的專有名詞、勝負的判定條件等等，以及「功能」上的要求是怎樣的，有些我們想到的功能可能是「超出需求」範圍的，如何拿捏好該確認的訊息來幫助開發，就變成很重要的關鍵。&lt;/p>
&lt;h2 id="pair-programming">Pair Programming&lt;/h2>
&lt;p>跟大多數課程形式不同的地方在於我們會採取「小組」的方式安排座位，同時需要跟附近的人進行 Pair Programming 進行開發，在這樣的過程中就會觀察到習慣的差異、思考方向的不同等等，原本自己一個人可以獨立完成的任務變得更花時間，但相對的在 Pair Programming 中我們有更多的討論以及對規格、需求的理解，假設我們已經非常熟悉 Pair Programming 的狀況下，也許能更好的完成任務。&lt;/p>
&lt;p>在課程的設計中，每一次的 Pair Programming 基本上都是無法完成任務的，中途也會逐漸增加難度。從一個人引導另一個人撰寫，到隔一段時間就要換人寫來模擬出一個專案被多次接手之後的狀況。&lt;/p>
&lt;h2 id="test-driven-development">Test Driven Development&lt;/h2>
&lt;p>這一次的課程大概讓大家對「TDD」的誤會大大地解開，在過去我們只要聽到 TDD 就會想到「要先寫測試」然後就開始因為時程壓力或者對撰寫測試不熟悉而開始排斥，但「先寫測試」這件事情雖然是「TDD」的一部分，但並不是全部。&lt;/p>
&lt;p>我們在練習中通常只對「關鍵物件」進行測試，也就是重構過程產生的一些輔助物件是不做測試的。&lt;/p>
&lt;p>這其實非常的顛覆以往我們對於 TDD 的想像，我們要測試的應該是「最有價值」的功能，在「單元測試的藝術」課後補充雖然有提到，但是在這門課中反而有實際的體會到「最有價值」的概念。除此之外，那些被我們拆分出去的物件因為會被「關鍵物件」使用跟呼叫，實際上還是有被覆蓋到的。&lt;/p>
&lt;p>從這樣的角度來看，我們針對那些對產品是非常核心或者不能出問題的「程式碼」進行測試，從理解需求轉換成測試程式碼，再進一步透過實作一步步驗證每一個需求細節的理解正確，對軟體的保護是遠遠高出我們過去直接去實作商業邏輯來的安全且嚴謹。&lt;/p>
&lt;h2 id="refactor">重構&lt;/h2>
&lt;p>在第一天的課程中並沒有硬性規定要使用 TDD 來練習，而是讓我們「儘可能完成要求」當作目標去開發，從很短的時間內還要 Pair Programming 跟換人操作，中途有很多混亂的發生而導致我們無法如期完成。到了第二天，講師挑選出第一天「勉強完成」的專案，然後開始對程式碼進行重構。&lt;/p>
&lt;p>雖然我們經常會說「重構」也對很多重構的「術語」非常熟悉，但實際上重構本身是怎麼進行和運作的可能很多人也說不清楚，在課程中講師用很實際的示範告訴我們該怎麼做。&lt;/p>
&lt;p>在第一天我們為了交付程式碼，因此大多數的組別都是將一個超大的方法作為核心商業邏輯提交出去。講師透過補完測試來對原本的商業邏輯進行保護，再一步一步的將這個方法重構到可以在善用語言特性的前提下，只需要一行就能完成的方法。&lt;/p>
&lt;p>中間應用了很多我們熟悉的技巧，像是將方法分離出來等等。不過也有很多重新將方法統合回去變成更大方法的處理，這是為了找出「重複」的邏輯並且合併，這剛好跟 TDD 裡面的技巧相互呼應，在講師推薦的 &lt;a href="https://www.tenlong.com.tw/products/9789864345618?list_name=i-r-zh_tw">Kent Beck 的測試驅動開發&lt;/a>這本書中就建議我們「小步前進」也因此在重構的「過程」中會出現很多我們認為「不好」的實現，但這些動作最後都會變成我們消除 Code Smell（程式碼壞味道）的線索，以課堂上的例子來看就因為過早抽取方法（Extract Method）而造成重複的程式碼產生。&lt;/p>
&lt;p>這也是我會推薦這堂課的原因之一，因為即使我們知道了所有對應的技巧，只要無法用恰當的方式應用還是會造成有壞味道的程式碼。&lt;/p>
&lt;h2 id="practice">練習&lt;/h2>
&lt;p>當我們對 TDD 和重構理解後，最後一個階段就是先以 TDD 的精神再一次分析需求，一步一步從客戶了解每一個需求並且依照「實作的複雜程度」拆分成小的步驟，然後再接著將這些需求依序寫成測試並且加入實際的程式碼，這個過程中會實作非常多「未完成」的程式，像是直接回傳可以「通過」測試的數值。&lt;/p>
&lt;p>在我們的理解中這是一個很奇怪的事情，不是要讓程式碼變成「綠燈」嗎？但這樣寫死難道不會有問題？&lt;/p>
&lt;p>不過這也是我們對於 TDD 理解的誤區，當我們加入下一個測試案例時必定會因為前一次的實作「不完整」而失敗，也因此我們需要再進一步的重構原本的程式來完善功能，隨著每一步實現功能到完善後，就得到了一份「可以被改善」但是「符合需求」的程式碼，最後我們只需要在測試的保護下放心的重構就可以將這一次實作的功能完成。&lt;/p>
&lt;h2 id="conclusion">小結&lt;/h2>
&lt;p>這一次的課程內容蠻難用一些範例程式碼去說明，與之相對的裡面更多的是一種「心法」的感覺，從我第一次聽到 91 哥的演講後就一直有這樣的感覺。我自己是一個很靠直覺去寫程式的人，大多數的經驗都是靠無數字重複的實踐來做到的，所以大部分時候都很難有系統的去說明一些經驗技巧。&lt;/p>
&lt;p>這樣的問題也反應在我自己在學習過程中不容易去找出缺少的技能，這次的課程讓我有非常多新想法想要導入公司來應用。而且這些技巧不單純是工程師適合，在接案公司接觸需求的第一線人員是我們的 PM 也很適合學習分析需求的技巧，我們在需求分析中其實是沒有討論「程式實作」而是更多地用「實際案例」去比對，逐步的探索出客戶真實的需求。&lt;/p>
&lt;p>像這樣的技能也可以很大的幫助 PM 在不完全理解技術的前提下向客戶確認詳細的需求，同時工程師也能基於這樣的資訊開發。&lt;/p></content:encoded></item><item><title>針對遺留代碼加入單元測試的藝術課程心得</title><link>https://blog.frost.tw/posts/2021/01/10/experience-of-unit-testing-effectively-with-legacy-code/</link><category>測試</category><category>RSpec</category><category>Ruby</category><category>心得</category><pubDate>Sun, 10 Jan 2021 03:24:59 +0800</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2021/01/10/experience-of-unit-testing-effectively-with-legacy-code/</guid><description>&lt;p>大概在 2019 年底就有考慮要來報名，結果一直拖到 2020 才下定決心。寫測試這件事情雖然很早就知道，不過一直到出社會開始工作後才逐漸的接觸，而且最開始的時候其實寫了很多糟糕的測試，直到這幾年逐漸摸索才有一個比較有系統的測試撰寫方式。&lt;/p>
&lt;p>但是透過自學比較大的問題就是知識很多時候是沒有系統的，大多是碎片的形式同時我自己也不太擅長將這些東西歸納整理，也就會出現一些盲點。也因此這次參加課程主要有兩個目的，一個是看看是否適合作為公司內部訓練的選項建議老闆，另一方面就是我自己學東西的習慣，反覆的練習基礎來達到熟練一個技能。&lt;/p></description><content:encoded>&lt;p>大概在 2019 年底就有考慮要來報名，結果一直拖到 2020 才下定決心。寫測試這件事情雖然很早就知道，不過一直到出社會開始工作後才逐漸的接觸，而且最開始的時候其實寫了很多糟糕的測試，直到這幾年逐漸摸索才有一個比較有系統的測試撰寫方式。&lt;/p>
&lt;p>但是透過自學比較大的問題就是知識很多時候是沒有系統的，大多是碎片的形式同時我自己也不太擅長將這些東西歸納整理，也就會出現一些盲點。也因此這次參加課程主要有兩個目的，一個是看看是否適合作為公司內部訓練的選項建議老闆，另一方面就是我自己學東西的習慣，反覆的練習基礎來達到熟練一個技能。&lt;/p>
&lt;h2 id="content">課程節奏、內容&lt;/h2>
&lt;p>大概開始一小時左右我就確定節奏很適合當作公司內部訓練的選項，&lt;a href="https://www.facebook.com/91agile">91 哥&lt;/a>作為專業講師一直都很讓我佩服，幾年前在 PHPConf 聽到的分享就讓我一直很有印象，直到現在也還在工作使用裡面的一些概念。&lt;/p>
&lt;p>原本是想整理一份 Ruby 版本的課程心得來完善課程中 Ruby 範例的，不過既然決定寫一篇文章跟大家分享，後面就會以我自己的經驗跟學到的概念跟大家分享，想要知道課程內容的話就請大家趕快去報名吧！&lt;/p>
&lt;h2 id="test-in-ruby">Ruby 的測試&lt;/h2>
&lt;p>在 Ruby 中最主流的會是使用 &lt;a href="https://rspec.info/">RSpec&lt;/a> 來進行測試，這是一套 BDD（Behaviour Driven Development）框架， &lt;a href="https://rubyonrails.org/">Ruby on Rails&lt;/a> 則是使用 &lt;a href="https://github.com/seattlerb/minitest">MiniTest&lt;/a> 來進行測試，除此之外也會使用 &lt;a href="https://cucumber.io/">Cucumber&lt;/a> 來撰寫測試。&lt;/p>
&lt;blockquote>
&lt;p>Ruby on Rails 專案預設會使用 MiniTest 但是大多數的人都會使用 RSpec 來寫測試，因此常常會看到新手把 &lt;code>test&lt;/code> 和 &lt;code>spec&lt;/code> 目錄放在專案中，這是兩種測試框架習慣使用的目錄不同的關係，正確的做法應該是在 &lt;code>rails new&lt;/code> 就指定使用 RSpec 作為測試框架。&lt;/p>
&lt;/blockquote>
&lt;p>我自己是沒有在使用 MiniTest 不過倒是對 Cucumber 很有興趣，跟 RSpec 需要由工程師撰寫程式碼不同，使用 Cucumber 會先由工程師設計出一些文法規則，而 PO（Product Owner）或者 PM（Project Manager）就能夠透過描述的方式將規格自行填入，進而減少工程師去確認規格的時間，不過前幾年有看過一些團隊在推行，但似乎沒有看到一些好的成效。&lt;/p>
&lt;blockquote>
&lt;p>實際上寫測試最困難的地方是根據「正確的規格」去撰寫，我們更多的時候是經過一層又一層的傳話拿到一些「有問題的規格」也因此跟客戶確認清楚是很重要的環節。&lt;/p>
&lt;/blockquote>
&lt;h2 id="better-specs">更好的 RSpec 測試&lt;/h2>
&lt;p>在這幾年應徵&lt;a href="https://5xruby.com">五倍紅寶石&lt;/a>的時候，我們會給出一份還算簡單的 Ruby on Rails 專案來確認面試者是否具備最基本的獨立開發功能的實力，裡面有一個環節就是使用 RSpec 撰寫 Feature Test（功能測試）這個環節會用來觀察面試者對撰寫測試的理解程度，另一方面也是因為 Feature Test 大多只要能達到針對某個畫面檢測就可以，相對於單元測試來說容易很多。&lt;/p>
&lt;p>不過到目前為止都還沒有看到過寫的特別好的情況，也因此大部分面試者在加入五倍的第一個專案通常都會卡住一到兩週在 Code Review 上面，這個階段我會不斷的從測試和重構兩個階段讓新同事習慣一些技巧，像是在撰寫的時候就要同時思考該怎麼測試，而測試該怎麼寫才會更乾淨。&lt;/p>
&lt;p>跟學程式語言最困難的地方在「了解語言特性」一樣，學習測試框架也需要知道框架的功能和性質，像是 RSpec 一直都有一份叫做 &lt;a href="https://www.betterspecs.org/">Better Specs&lt;/a> 的文件，裡面就提到了非常多 RSpec 撰寫時應該善用的技巧，不過這份文件最近翻新了一次，原本的中文翻譯也一起消失了。&lt;/p>
&lt;h2 id="learn-rspec-from-lint">從 Lint 學習 RSpec 測試&lt;/h2>
&lt;p>2020 年大概是 Ruby 社群有很多大變動的年份吧，除了 Ruby 3 終於推出開始跟上其他語言的效能上改進之外，經常被用來檢查 Coding Style（程式碼風格）的工具 &lt;a href="https://github.com/rubocop-hq/rubocop">Rubocop&lt;/a> 也迎來了大改版正式邁入 1.0 而在這個大版本前的幾個版本也開始將 RSpec、Rails、ThreadSafety 等等跟 Ruby 核心比較不相關的檢查獨立出來，如果你的專案想使用 RSpec 的話也請把 Rubocop RSpec 加入到 Rubocop 的檢查中，這樣至少能知道 Ruby 社群的偏好。&lt;/p>
&lt;p>不過使用 Rubocop 其實也有蠻多爭議，像是 GitHub 和 Shopify 都有自己客製化的 Rubocop 風格設定，而且和預設的差異非常大，詳細的理由大多可以在他們說明 Coding Style 的部落格或者 Repoistory 上面找到。&lt;/p>
&lt;blockquote>
&lt;p>Rubocop RSpec 給了很多限制，像是 Example Group（&lt;code>describe&lt;/code> 和 &lt;code>context&lt;/code>）不能巢狀超過三層、每一個 Example Group 裡面至少要有一個 Example 等等&lt;/p>
&lt;/blockquote>
&lt;h2 id="intent-of-test">測試意圖&lt;/h2>
&lt;p>課程中我印象中比較深刻的幾個關鍵，這個是其中一個。雖然想示範糟糕的 RSpec 寫法，但是這邊更接近我目前使用的測試撰寫方式要如何改進會更好，因此下面是一段我原本會這樣寫的測試。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="c1"># frozen_string_literal: true&lt;/span>
&lt;span class="nb">require&lt;/span> &lt;span class="s1">&amp;#39;spec_helper&amp;#39;&lt;/span>
&lt;span class="no">RSpec&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">describe&lt;/span> &lt;span class="no">RedeemService&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="c1"># Rubocop RSpec 建議對「物件實例」造假，因此建議用 `instance_double` 代替 `double`&lt;/span>
&lt;span class="n">let&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ss">:redeem_code&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">instance_double&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">RedeemCode&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="c1"># Rubocop RSpec 建議用 `described_class` 來表示測試物件，重構名稱時就不用修改 `RSpec.describe` 之後的程式碼&lt;/span>
&lt;span class="n">let&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ss">:service&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">described_class&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">new&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">redeem_code&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="c1"># RSpec 慣例用 `#method` 表示 Instance Method 用 `.method` 表示 Static Method&lt;/span>
&lt;span class="n">describe&lt;/span> &lt;span class="s1">&amp;#39;#available?&amp;#39;&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="c1"># RSpec 特性，利用 `subject` 建立 One line test case&lt;/span>
&lt;span class="n">subject&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">service&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">available?&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="c1"># Rubocop RSpec 要求 `context` 以 `when` 開頭&lt;/span>
&lt;span class="n">context&lt;/span> &lt;span class="s1">&amp;#39;when redeem code valid&amp;#39;&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="c1"># RSpec 內建支援 Stub / Mock 機制，這邊對 RedeemCode 物件做 Stub 處理&lt;/span>
&lt;span class="n">before&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">allow&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">redeem_code&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">to&lt;/span> &lt;span class="n">receive&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ss">:valid?&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">and_return&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kp">true&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="c1"># `is_expected` 等同 `expect(subject)` 使用單行測試案例時會用 `is_expected` 去表示&lt;/span>
&lt;span class="c1"># RSpec 中會自動將 `be_` 呼叫，像是 `truthy` 就會呼叫該物件的 `truthy` 方法，如果有指定 Matcher 時則以 Matcher 為主&lt;/span>
&lt;span class="n">it&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">is_expected&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">to&lt;/span> &lt;span class="n">be_truthy&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="n">context&lt;/span> &lt;span class="s1">&amp;#39;when reedeem code invalid&amp;#39;&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="n">before&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">allow&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">redeem_code&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">to&lt;/span> &lt;span class="n">receive&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ss">:valid?&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">and_return&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kp">false&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="n">it&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">is_expected&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">to&lt;/span> &lt;span class="n">be_falsy&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>上面的範例實際上沒辦法完整表示所有的技巧，不過在「意圖」這塊是還能夠改善的，在課程中了解到上面的測試描述的只是「程式上的定義」也因此我們可以繼續改進&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="c1"># frozen_string_literal: true&lt;/span>
&lt;span class="nb">require&lt;/span> &lt;span class="s1">&amp;#39;spec_helper&amp;#39;&lt;/span>
&lt;span class="no">RSpec&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">describe&lt;/span> &lt;span class="no">RedeemService&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="c1"># 這邊也可以用 self.given_redeem_code 來定義，但是因為 Rubocop RSpec 建議一個 Group 只有一個 before / after 因此就採取這種方式&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">given_redeem_code&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ss">valid&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kp">true&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">allow&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">redeem_code&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">to&lt;/span> &lt;span class="n">receive&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ss">:valid?&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">and_return&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">valid&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="n">let&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ss">:redeem_code&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">instance_double&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">RedeemCode&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="n">let&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ss">:service&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">described_class&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">new&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">redeem_code&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="n">subject&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">service&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="n">describe&lt;/span> &lt;span class="s1">&amp;#39;#available?&amp;#39;&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="n">context&lt;/span> &lt;span class="s1">&amp;#39;when redeem code valid&amp;#39;&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="n">before&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">given_redeem_code&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ss">valid&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kp">true&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="n">it&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">is_expected&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">to&lt;/span> &lt;span class="n">be_available&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="n">context&lt;/span> &lt;span class="s1">&amp;#39;when reedeem code invalid&amp;#39;&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="n">before&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">given_redeem_code&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ss">valid&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kp">false&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="n">it&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">is_expected&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">not_to&lt;/span> &lt;span class="n">be_available&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>一時之間想不到更好的範例，在課程中提供的範例涵蓋的範圍太廣，不過不方便拿來當例子因此就只能用這個來做簡單的分析跟解釋。&lt;/p>
&lt;blockquote>
&lt;p>在寫這篇文章的時候又發現一些可以改進的地方，像是可以直接用 &lt;code>be_available&lt;/code> 而不用定義 &lt;code>subject&lt;/code> 而這更接近所謂測試的「意圖」&lt;/p>
&lt;/blockquote>
&lt;p>在 RSpec 裡面支援使用 Helper Method （輔助方法）來幫助我們撰寫一些輔助測試的行為，像是在 RSpec Rails 就提供了像是 &lt;code>get&lt;/code> 這類可以模擬 HTTP 請求的輔助方法。&lt;/p>
&lt;p>我們定義了 &lt;code>given_redeem_code(valid: true)&lt;/code> 這個方法，用來代替原本的 &lt;code>allow(redeem_code).to receive(:valid?).and_return(true)&lt;/code> 讓測試可以更明確的表示「給出正確的兌換碼」這個情境，另外要注意的是這個方法一定要定義在測試群組裡面，才不會在其他測試被載入到而互相影響。&lt;/p>
&lt;blockquote>
&lt;p>不過在我自己的經驗中 Ruby 社群似乎不太常使用這樣的技巧，而想要使用像是 &lt;code>Given&lt;/code> 和 &lt;code>When&lt;/code> 的語法其實也有人做了 &lt;a href="https://github.com/jimweirich/rspec-given">RSpec Given&lt;/a> 套件，但在我的記憶中並沒有太多人使用，而這樣的應用方式反而是在寫 Cucumber 時因為語言性質會被應用。&lt;/p>
&lt;/blockquote>
&lt;h2 id="graceful-rspec-tests">優雅的 RSpec 測試&lt;/h2>
&lt;p>在這次的課程中因為提到了不少之前寫測試沒有特別注意的細節，也因此我在空檔花了一些時間去看 RSpec 文件提供了哪些機制來輔助，以我個人偏好來說我會優先採取 One-liner Syntax（單行測試）的方式，除了寫的程式碼相對少之外，使用恰當在 RSpec 預設的「輸出選項」也能適當的呈現出非常容易理解的測試文件。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">rspec --format doc
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我們就可以獲取這樣的結果&lt;/p>
&lt;pre>&lt;code>RedeemService
when code valid
is expected to be available
when code invalid
is expected not to be available
Finished in 0.02296 seconds (files took 0.27232 seconds to load)
2 examples, 0 failures
&lt;/code>&lt;/pre>&lt;p>這其實也是 Ruby 語言在 DSL（Domain Specific Language）的強項，我們在測試寫的東西幾乎是 100% 接近文件的輸出，這也是為什麼 Rubocop RSpec 會要求測試群組的巢狀層級數量跟要使用 &lt;code>when&lt;/code> 作為 &lt;code>context&lt;/code> 描述起始，這樣就能在輸出上達到一制性也更容易閱讀。&lt;/p>
&lt;blockquote>
&lt;p>另外一個值得探討的地方是，還需要寫 &lt;code>describe '#available?'&lt;/code> 來建立一個測試群組嗎，而以 Context 為基礎的話，下面再切割的群組又會是怎樣的。這也是我在不同專案上看到不同的習慣，目前我自己還是以「方法」區分為主。&lt;/p>
&lt;/blockquote>
&lt;p>而上面的程式碼我們還能在做改進，前面我們使用的 Helper Method 叫做 Arbitrary Helper Method 也就是「任意定義」的意思，假設 RedeemCode 經常會被設定，我們就可以利用 Ruby 的 Module 特性將這些設定統一到一個模組中管理。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="c1"># spec/support/helpers/redeem_test_helper.rb&lt;/span>
&lt;span class="k">module&lt;/span> &lt;span class="nn">RedeemTestHelper&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">given_redeem_code_with_state&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ss">valid&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kp">true&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">allow&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">redeem_code&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">to&lt;/span> &lt;span class="n">receive&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ss">:valid?&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">and_return&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">valid&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">given_redeem_code_with_rewards&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rewards&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">allow&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">redeem_code&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">to&lt;/span> &lt;span class="n">receive&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ss">:rewards&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">and_return&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rewards&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="c1"># 我個人偏好直接在 Helper Module 加入設定，我們通常會習慣在 spec_helper.rb 直接導引用所有 `support/` 目錄下的檔案&lt;/span>
&lt;span class="no">RSpec&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">configure&lt;/span> &lt;span class="k">do&lt;/span> &lt;span class="o">|&lt;/span>&lt;span class="n">config&lt;/span>&lt;span class="o">|&lt;/span>
&lt;span class="n">config&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">include&lt;/span> &lt;span class="no">RedeemTestHelper&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">:redeem_module&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>接下來我們在測試裡面就可以像這樣使用&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="c1"># frozen_string_literal: true&lt;/span>
&lt;span class="nb">require&lt;/span> &lt;span class="s1">&amp;#39;spec_helper&amp;#39;&lt;/span>
&lt;span class="c1"># RSpec 的 Metadata 功能可以標記 Tag 之類的，常見的會是 `type: :controller` 這種&lt;/span>
&lt;span class="no">RSpec&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">describe&lt;/span> &lt;span class="no">RedeemService&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">:redeem_module&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="c1"># ...&lt;/span>
&lt;span class="n">describe&lt;/span> &lt;span class="s1">&amp;#39;#available?&amp;#39;&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="n">context&lt;/span> &lt;span class="s1">&amp;#39;when redeem code valid&amp;#39;&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="n">before&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">given_redeem_code_with_state&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ss">valid&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kp">true&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="n">it&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">is_expected&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">to&lt;/span> &lt;span class="n">be_available&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="c1"># ...&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如此一來我們就能在有用到 RedeemCode 相關邏輯的地方加上 &lt;code>:redeem_module&lt;/code> 的標記，讓對應的輔助方法可以被載入進來使用。&lt;/p>
&lt;h2 id="verify-method-call">對方法呼叫的檢驗&lt;/h2>
&lt;p>之前在嘗試處理一些問題時有看過 &lt;code>spy&lt;/code> 這個使用方式，但是一直不清楚該如何使用以及跟 Mock / Stub 的關係，在課程中經過練習和說明後就稍微有概念，而這部分確實也是我目前沒有使用在測試中的技巧。&lt;/p>
&lt;p>假設 RedeemService 在成功兌換後會發送一封通知信，但我們只關注通知的訊息是否正確而不在意怎麼發出去，就可以用這個技巧來處理。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="c1"># frozen_string_literal: true&lt;/span>
&lt;span class="nb">require&lt;/span> &lt;span class="s1">&amp;#39;spec_helper&amp;#39;&lt;/span>
&lt;span class="no">RSpec&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">describe&lt;/span> &lt;span class="no">RedeemService&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">:redeem_module&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="c1"># TODO: 移動到 Helper Module&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">player_notification_should_notify_with&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">message&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">notification&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">to&lt;/span> &lt;span class="n">have_received&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ss">:notify&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">with&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kp">include&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">message&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="c1"># 我個人偏好在做 Mock 處理時直接指定對應的物件，出現錯誤訊息比較好確認當下假定會使用的物件是什麼&lt;/span>
&lt;span class="n">let&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ss">:notification&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">spy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">PlayerNotification&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="n">let&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ss">:service&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">described_class&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">new&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">redeem_code&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">notification&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="c1"># ...&lt;/span>
&lt;span class="n">context&lt;/span> &lt;span class="s1">&amp;#39;when redeem code valid&amp;#39;&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="n">before&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">given_redeem_code_with_state&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ss">valid&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kp">true&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="n">it&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">is_expected&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">to&lt;/span> &lt;span class="n">be_available&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="n">describe&lt;/span> &lt;span class="s1">&amp;#39;#perform&amp;#39;&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="n">subject&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ss">:when_redeem&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">service&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">perform&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="n">before&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="n">given_redeem_code_with_rewards&lt;/span> &lt;span class="o">[&lt;/span>
&lt;span class="no">RewardItem&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">new&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;Sowrd&amp;#39;&lt;/span>&lt;span class="p">),&lt;/span>
&lt;span class="no">RewardItem&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">new&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;Bow&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="o">]&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="n">it&lt;/span> &lt;span class="s1">&amp;#39;is expected to send notify&amp;#39;&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="n">when_redeem&lt;/span>
&lt;span class="n">player_notification_should_notify_with&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;2 rewards&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="c1"># ...&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>這樣我們就可以確認我們會呼叫某種屬於 Notification 類型的物件上的 &lt;code>#notify&lt;/code> 方法並且訊息含有 &lt;code>2 rewards&lt;/code> 的字串，這邊就沒辦法單純的用單行去呈現，並且最好將 &lt;code>it&lt;/code> 的描述用 &lt;code>is expected to&lt;/code> 來撰寫，這樣在 RSpec 輸出的文件中會更容易閱讀，雖然 Rubocop RSpec 沒有強制這個規格，不過用 &lt;code>is expected to&lt;/code> 會相對整齊多，在我的印象中也有一些流派是建議這樣使用的。&lt;/p>
&lt;blockquote>
&lt;p>在這邊 &lt;code>describe '#perform'&lt;/code> 似乎就變得突兀，是否能有其他改進的方式就可能會需要進行探討&lt;/p>
&lt;/blockquote>
&lt;h2 id="conclusion">小結&lt;/h2>
&lt;p>不知不覺就寫到半夜，其實還有不少東西沒辦法寫到。但是這次的課程雖然在框架應用上大多我已經知道，或者了解的更詳細。不過更重要的是課程中還帶出了很多觀念上的問題讓我對於測試能再更近一步的方法有了一些方向，不過同時也蠻感概這個領域我們知道的也許比想像中的少。&lt;/p>
&lt;p>即使在一些知名的開源專案中，也不一定能看到像這樣完整的測試撰寫跟明確的表達意圖。不過同樣的要完成到這樣的測試花費的心力跟資源也是非常值得評估的，因此在課程結束前也在跟大家討論何時該寫測試的問題，以及怎樣判斷哪些測試該先寫跟對覆蓋率的迷思。&lt;/p>
&lt;p>整體上來說這門課對我自己的意義更多在心法上的改進，在技巧上現有的方法已經相當不錯只是缺少了對應的心法讓他更近一步。&lt;/p></content:encoded></item><item><title>作為工程師，我們與專業的距離</title><link>https://blog.frost.tw/posts/2020/09/28/The-distance-to-become-a-professional-programmer/</link><category>心得</category><category>工程師</category><pubDate>Mon, 28 Sep 2020 11:22:49 +0800</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2020/09/28/The-distance-to-become-a-professional-programmer/</guid><description>&lt;p>不知不覺工作已經四年左右了，如果是從開始接觸程式語言計算的話似乎快要二十年。這幾年也開始擔任公司負責面試的主管，也看到越來越多工程師培訓班的出現以及更多的人挑戰轉職工程師。在這樣的狀況下，每次跟同事交流，我總是覺得我們不夠專業。&lt;/p>
&lt;p>這也一直讓我在思考，作為一個「專業」的工程師應該要滿足什麼條件？&lt;/p></description><content:encoded>&lt;p>不知不覺工作已經四年左右了，如果是從開始接觸程式語言計算的話似乎快要二十年。這幾年也開始擔任公司負責面試的主管，也看到越來越多工程師培訓班的出現以及更多的人挑戰轉職工程師。在這樣的狀況下，每次跟同事交流，我總是覺得我們不夠專業。&lt;/p>
&lt;p>這也一直讓我在思考，作為一個「專業」的工程師應該要滿足什麼條件？&lt;/p>
&lt;h2 id="年資">年資&lt;/h2>
&lt;p>我想年資應該是一個非常容易判斷的方式，畢竟大多數的職缺都會說希望有幾年經歷。不過年資真的適合作為一個評斷的標準嗎？&lt;/p>
&lt;p>如果從我開始寫程式來計算，至少有十五年的時間。不過實際上我工作的時間也只有四年左右，而扣掉工作的這幾年過去這十年的「累積」真的是有在持續成長的嗎？&lt;/p>
&lt;p>事實上，在剛接觸的時候我至少有五年的時間耗費在摸索這個領域，雖然是因為在那個時間點大多只能靠自己看書跟查資料（當時也不容易找到資料）來學習，所以效果一直都非常有限，直到朋友推薦我去參加研討會（Conference）之後才讓我接觸到原本在學習 PHP 上不一樣的觀念，第一次瞭解到什麼是框架等等概念同時也認識了很多能夠做技術交流的朋友，也因此才在短時間內快速的進步。&lt;/p>
&lt;p>這也是大部分的技術社群都會推薦參加社群活動的原因，即使是單純的吸收資訊也遠比自己研究的快很多，雖然很多時候不一定是當下自己能吸收或者需要的。&lt;/p>
&lt;p>簡單來說，使用一個技術的時間跟能力並不一定相等，從培訓班的出現向我們證明了如果有適合的老師跟教材，要在短時間入門是非常容易的。&lt;/p>
&lt;h2 id="經驗">經驗&lt;/h2>
&lt;p>既然年資不影響能力，時間拉長之後就不會進步了嗎？我想這也是否定的，我們需要討論的是「經驗」也就是在同樣的時間裡面，我們累積多少「經驗」的問題。&lt;/p>
&lt;p>舉例來說，我接觸程式語言的前五年左右，我不斷的重複在練習 CRUD 和一些常見的網站系統（大多是書上教的）除此之外就是把 HTML/CSS 的應用不斷的加強，當時 JavaScript 並沒有像現在如此興盛，因此就只有在做簡單的效果會使用。&lt;/p>
&lt;p>實際上我前五年練習的東西，如果在培訓班的角度來看只需要幾個月密集的練習就有一部分的人能做到「熟練」的水平，這也是年資對「能力」的影響不一定成比例的關係，我們如果一直止步在同樣的技術跟知識上，總會達到一個極限。&lt;/p>
&lt;p>跟其他人的交流以及挑戰和嘗試新的技術就變成一個很適合累積經驗的地方，從另一個角度來看新創公司因為需要靠自己做的事情相對的多，所以也就能夠讓人快速的累積大量的經驗。&lt;/p>
&lt;h2 id="知識">知識&lt;/h2>
&lt;p>然而累積經驗雖然豐富了，但很多時候卻無法用一個能「說服」其他人的方式描述這個經驗。這也是我認為我現階段「卡住」的地方，雖然我透過在接案公司經手各種專案以及自己的練習、黑客松等情境，在不同領域跟情境下累積了非常多的經驗，也因此能夠處理非常廣泛類型的專案開發，但是卻很難將這些東西教給其他人以及「說服」其他人使用。&lt;/p>
&lt;p>我認為這是一個「廣度」跟「深度」的問題，現在我們有非常多的網路資源以及文章可以參考，很多時候我們都是基於某個文章的說明來解決工作或者自己專案上的問題，但是很少深入去探討問題的原因、解決方案能解決的原理以及這個做法帶來的影響。&lt;/p>
&lt;p>這樣的狀況就造成了對客戶無法用合理的數據或者分析來解釋我們如何處理這些需求，而對於帶領團隊上則無法給予適合的指示或者建議只能盲目的嘗試，也就造成了在需求跟開發上的時間成本。&lt;/p>
&lt;blockquote>
&lt;p>雖然需求的決定還有很多因素，但是如果我們能更專業的說明問題是否就能更快說服客戶使用我們推薦的作法呢？&lt;/p>
&lt;/blockquote>
&lt;p>回過頭來看，作為非資訊相關科系畢業的人就會發現自己缺少的那一塊還是回歸到了學校是否學好這些東西，不然像是 CS50 這類課程、演算法、資料結構等等資工系學生都學過的知識，就不會在社群裡面被大力的推薦跟討論。&lt;/p>
&lt;p>不過這樣看來，資工系的學生作為工程師不是應該大部分的人做得更好，業界還是有一半左右的工程師是非本科系的原因是什麼？也許就是經驗上的差距吧，即使考試題目過關了但並不是每個人都樂於去挑戰不同的專案開發。&lt;/p>
&lt;p>至少，在我這十幾年的經驗裡面「知識」跟「經驗」實際上是缺一不可的，只不過我們在「學校」跟「公司」大多偏重某一部份，能夠注意到兩者的平衡並且「加以整合」的人可能比我們想像中的要少，畢竟工作不一定會遇到需要這些知識的情況，或者單純的跟著其他人學習卻不知道該如何和自己的經驗進行連結。&lt;/p>
&lt;h2 id="視野">視野&lt;/h2>
&lt;p>前面討論了這麼多，我們足夠專業了嗎？&lt;/p>
&lt;p>也許作為一個「資深」工程師可能足夠了，要再繼續提升的話還缺少了什麼？我想是「視野」這個部分，一間公司的目標是以「賺錢」為目的，而我們卻只能看到自己眼前的錢（薪水）這樣是足夠的嗎？&lt;/p>
&lt;p>我想很多人跟我一樣有察覺到一些跡象，雖然我在過去的工作中也逐漸地開始考慮「客戶的理由」這個問題，不過直到最近在 &lt;a href="https://next.tgonetworks.org/">TGONext&lt;/a> 結束後拿到來自導師 &lt;a href="https://blog.gcos.me/">Ant&lt;/a> 贈與的書——&lt;a href="https://www.books.com.tw/products/CN11645111">知行&lt;/a>以及結合過去跟前輩們學習的知識才對這樣的狀況有了一個比較能明確區分和認識。&lt;/p>
&lt;p>書中將待在公司體制的工程師區分為兩種發展方向，分別是架構師（技術管理）跟技術專家（技術特化）兩種體系，如果是選擇管理體系的話就會要面對到處理人的問題，不論是對上司還是下屬都需要處理，但不管是哪一種體系的工程師，我們最後還是要面對的是「公司怎麼賺錢」的問題，也就回歸到了我們「看到多少」&lt;/p>
&lt;p>也因此除了技術的問題之外，我們還需要將商業和人的問題也一起考慮到解決方案裡面，即使我們可以用完美的技術把問題解決但是趕不上時程呢？在經驗中處理某個情況用某個方法總是有用，但實際上我們的客戶卻是例外的狀況呢？&lt;/p>
&lt;p>要能夠區分清楚這些問題，就沒辦法再以單純的「開發者」去看這件事情，同理可證即使是「開源專案」也要考慮到社群的發展、長期的經營等等問題。&lt;/p>
&lt;blockquote>
&lt;p>我想我現在除了「知識」之外，就是要拓展「視野」的開闊度，因為他已經不是單純用技術好壞就能處理的問題，而是要能夠了解到手邊握有的技術能怎樣解決問題。&lt;/p>
&lt;/blockquote>
&lt;h2 id="路">路&lt;/h2>
&lt;p>結合上面的過程，在我看來就是一條一條的路。&lt;/p>
&lt;p>當你開始想前進的時候，可以跟著前人的經驗選擇一條安穩的路前進，如果想走得更遠就需要知識的累積來讓自己對這條路更加熟悉。不過不管怎樣，這都會是別人的路，如果想要走出自己的路就需要有自己的視野、看法，才能夠前進。&lt;/p>
&lt;p>但是要開拓自己的路，就需要有足夠的經驗跟知識才能應對未知的危機。&lt;/p>
&lt;p>如果想要獨當一面的話，大概就是要有自己的視野去選擇自己的方向並且能讓別人能跟著你的腳步前進吧！&lt;/p>
&lt;p>對我來說，這是我目前所知道的「專業」的表現。&lt;/p>
&lt;h2 id="後記">後記&lt;/h2>
&lt;p>這幾年除了速成工程師之外也開始出現網紅工程師等等各種不同的工程師類型，這大概是有一些人默默累積開拓出了這些可能性讓這些情況變得可行。不過與之相對的，大概就是這幾年聽說或看過的神奇現象也更加的嚴重，像是在社群網站上會看到只要業主開價太低就先攻擊而沒有仔細分析過需求和自己的能力是否適合說這些話、剛從培訓班上完課剛好遇到一些公司找不到人接手專案就能被當作資深工程師被招募進去卻以為自己能力非常好等等，也因為這樣讓我開始思考這個問題。&lt;/p>
&lt;p>在運氣好或者整體環境使然所獲得的職位、名聲是而沒有思考過自身的能力是足夠、在這個領域還有多少需要學習，是否就是所謂的「心態」的膨脹或者「視野」太狹小了呢？&lt;/p>
&lt;p>不過，最主要的還是想要提醒自己，現在有的能力跟自己「想象中」的能力還有差距多少。&lt;/p>
&lt;blockquote>
&lt;p>心態的問題似乎不太適合在這篇文章討論，不過有一個有趣的部分是我花了很多年才找到「戰勝自己」的認知，雖然到現在都還是很難去避免跟其他人比較，只不過比較的對象已經逐漸能變成去觀察自己「進步了多少」&lt;/p>
&lt;/blockquote></content:encoded></item><item><title>COSCUP 2020 速記</title><link>https://blog.frost.tw/posts/2020/08/03/COSCUP-2020-Note/</link><category>COSCUP</category><category>心得</category><pubDate>Mon, 03 Aug 2020 01:31:31 +0800</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2020/08/03/COSCUP-2020-Note/</guid><description>&lt;p>距離上一篇文章已經好幾個月了，手邊還有一些有趣的東西想寫不過實在太忙。每年參加完研討會都會寫一篇心得來記錄一下，不過我後面幾個月可能還要準備日本的 RubyKaigi（線上版）、鐵人賽跟在等投稿結果的 JSDC、MOPCON 等，應該是暫時沒辦法跟大家分享這幾個月找到的有趣技術。&lt;/p></description><content:encoded>&lt;p>距離上一篇文章已經好幾個月了，手邊還有一些有趣的東西想寫不過實在太忙。每年參加完研討會都會寫一篇心得來記錄一下，不過我後面幾個月可能還要準備日本的 RubyKaigi（線上版）、鐵人賽跟在等投稿結果的 JSDC、MOPCON 等，應該是暫時沒辦法跟大家分享這幾個月找到的有趣技術。&lt;/p>
&lt;h2 id="前夜祭">前夜祭&lt;/h2>
&lt;p>這幾年越來越多研討會開始舉辦前夜祭，作為講者和會眾之間的交流算是不錯的時間，畢竟在議程的規劃改變跟複雜化的狀況下，有時候反而沒什麼機會交流。&lt;/p>
&lt;p>今年基本上也是跟以前跑社群的朋友打招呼後就差不多結束了，跟以往不一樣的是結束後我馬上到中山附近的臨時辦公室開始跑 &lt;a href="https://unlight.app">Open Unlight&lt;/a> 的遊戲更新，因為下週（8/8）我們要舉辦一個營運一週年的&lt;a href="https://anniversary.unlight.events/">活動&lt;/a>所以需要先更新遊戲伺服器來設定好相關的資料，也因此一直忙到半夜我們才啟程回家休息。&lt;/p>
&lt;blockquote>
&lt;p>前面的時間也大多在開發各類輔助的系統來支援這次的活動，往好處想就是這個活動讓我們在營運上多了一些新的手段可以應用，不過幾乎是在接近體力極限狀況在開發也因此這幾天都非常想睡。&lt;/p>
&lt;/blockquote>
&lt;h2 id="day-1">Day 1&lt;/h2>
&lt;p>因為很累的關係就直接睡到下午，原本打算去參加晚上的 BoF，不過 COSCUP 這幾年議程大多是四點多就結束，而 BoF 主辦又選在晚上七點半才開始。對台科不太熟悉的我在找不到已經全數撤退的朋友、同事之後，只好報復性消費到京站嘗試看看京都勝牛。&lt;/p>
&lt;p>因為時間還早就沒有排隊，以目前在台灣吃過的炸牛排品質來說算是最好的。熟度也蠻剛好約五分，所以店家預設不會幫你點小火爐起來讓你自己加熱，不過以前幾年在日本吃到的炸牛排來說，幾乎是生的自己調整熟度跟好吃度，台灣目前還是沒有找到覺得同樣好吃的。&lt;/p>
&lt;h2 id="day-2">Day 2&lt;/h2>
&lt;p>早上開場後就是 Vue 作者尤雨溪的分享，原本以為會用中文結果是用英文來講。目前英文聽力還處於一種微妙的狀態，大致上就是集中或者聊天可以聽得清楚，不過演講通常前面十分鐘後就會斷線分心，然後就沒有辦法繼續聽了，前幾年在 RubyKaigi 的經驗除了少數會刻意放慢語速的講者之外，大多都沒聽進去多少，剩下都還是靠簡報幫忙理解。&lt;/p>
&lt;p>其他時間原本還在考慮要不要去其他社群聽，結果時間上幾乎是無縫接軌也因此只好都待在 Ruby 社群聽同事們演講。今年可能也是因為疫情的關係所以一些外國的社群朋友沒辦法來參與，也就這樣讓同事們順利都可以分享他們的經驗。實際上這也是一個很不錯的開始，不論是對技術還是職涯，做演講跟分享對技術的反思或者未來增加自己履歷的精彩程度都是很有幫助的。&lt;/p>
&lt;p>今年嘗試辦看看 BoF 不過幾乎沒什麼人來，原本以為會來當樁腳的同事就這樣自己跑去吃午餐。不過跟前面一場 Vue 社群的 &lt;a href="https://kuro.tw/">Kuro&lt;/a> 大大聊過，雖然來的人很多不過還是沒有 BoF 的氣氛，也就是大家互相交流的部分，下午遇到其他朋友也還是看到其他場都維持這樣的狀況，只是不知道是場地限制還是因為大家都誤會 BoF 的形式。&lt;/p>
&lt;p>中午吃了一下大會推薦的漢堡（在中庭擺攤的爺爺）真的蠻好吃的，不過也因為排隊等待讓我錯過了一場同事的演講（還有因為 BoF 跟 Lightning Talk 也錯過另外兩場）&lt;/p>
&lt;p>即使會眾人數已經來到歷史新高，這次 Lightning Talk 的投稿比預想中的少，還是一樣的很好抽到。&lt;/p>
&lt;p>原本想說要上台刷個存在感就下來，不過剛好在 Pre-Party 的晚上大致摸熟 Terrafork CDK 的使用之後，就決定利用 Lightning Talk 來分享怎麼使用，可惜沒做簡報就是會忘記一些橋段。像是我只用了三天就搞懂、要偷偷抱怨 BoF （以為會有）的樁腳不見了之類的都沒有講到，反而讓效果差了不少。&lt;/p>
&lt;p>關於 Terraform CDK 的使用應該會盡快抽空寫一篇來分享，相比以往的 Terraform 跟 Cloud Formation 使用 CDK 來撰寫變得容易很多，而 CDK 實際上比較像是一個 Compiler 把 TypeScript 或 Python 的程式碼轉換成對應的格式，也因此 Terraform 的版本太舊是會裝不起來的。&lt;/p>
&lt;h2 id="總結">總結&lt;/h2>
&lt;p>大概算了一下，距離我第一次參加 COSCUP 已經快要有十年，從原本每一場議程都會有收穫。到現在已經變成覺得簡單或者跟自己的領域差異太大，可能就沒有去聽看看。而更多的時間也都花在跟認識的朋友聊天上，這大概是在台灣研討會的一個限制。&lt;/p>
&lt;p>因為以前辦過 SITCON 跟參加過幾個不同研討會的籌備，也能理解這樣針對比較新手的議程設計是相對重要的。而比較專業跟深入的研討會，大多受限於人口基數不夠很難籌備到足夠的資金去辦一場這樣的活動，也期待哪天台灣可以有像 RubyKaigi 這樣霸氣的研討會，因為疫情就能全額退票，議程投稿一年比一年要的技術力更加高深，只為了不斷改進 Ruby 的語言。&lt;/p>
&lt;blockquote>
&lt;p>當然，像是 COSCUP 這類研討會主要是在分享跟推廣上，就不適合太困難的題目。但其他各社群自己的研討會，還是受限於資源而無法投入比較高的比例在進階的技巧應用上。&lt;/p>
&lt;/blockquote></content:encoded></item><item><title>GitLab 是如何讓 SSH Server 和 Git 並存而不影響安全性</title><link>https://blog.frost.tw/posts/2020/06/20/How-to-secure-SSH-Server-when-GitLab-add-git-user/</link><category>Git</category><category>GitLab</category><category>Ruby</category><pubDate>Mon, 29 Jun 2020 00:43:26 +0800</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2020/06/20/How-to-secure-SSH-Server-when-GitLab-add-git-user/</guid><description>&lt;p>這次第四屆的 &lt;a href="https://astro.5xruby.tw/">Astro Camp&lt;/a> 有學員嘗試做了 GitHub 的架構，也就是能夠在遠端建立 Git 專案並且能夠在本機上傳檔案。&lt;/p>
&lt;p>不過在和當助教的同事跟學員聊到 &lt;code>git&lt;/code> 使用者可以登入伺服器進行任意操作的安全性問題時，在前陣子的一些測試發現實際上我自己的假設（特製的 SSH Server）是有問題的，而這個解決方法實際上也比我們想像的還容易。&lt;/p></description><content:encoded>&lt;p>這次第四屆的 &lt;a href="https://astro.5xruby.tw/">Astro Camp&lt;/a> 有學員嘗試做了 GitHub 的架構，也就是能夠在遠端建立 Git 專案並且能夠在本機上傳檔案。&lt;/p>
&lt;p>不過在和當助教的同事跟學員聊到 &lt;code>git&lt;/code> 使用者可以登入伺服器進行任意操作的安全性問題時，在前陣子的一些測試發現實際上我自己的假設（特製的 SSH Server）是有問題的，而這個解決方法實際上也比我們想像的還容易。&lt;/p>
&lt;h2 id="possible-solution">可能的解法&lt;/h2>
&lt;p>因為我以前曾經讀過 GitLab 的部分原始碼，所以大概有個印象猜測是使用一個獨立的 SSH Server 來處理這件事情，透過限制可以執行的動作來達到安全的效果。不過這個假設在最近我登入 &lt;a href="https://unlight.app">Open Unlight&lt;/a> 的 GitLab 伺服器時，發現實際上還是基於 OpenSSH 的。&lt;/p>
&lt;p>同事也有提出一些不同的假設，像是將 &lt;code>git&lt;/code> 設定為 &lt;code>/usr/sbin/nologin&lt;/code> 之類的，不過這些方法都造成了無法正常使用 Git 相關的操作。&lt;/p>
&lt;blockquote>
&lt;p>在寫這篇文章的時候已經在&lt;a href="https://juejin.im/post/5cf686b85188253cec305fa7">掘金&lt;/a>的文章有分析過，不過裡面提到的東西已經從 Ruby 替換成 Golang 實作，但是並不影響我們繼續進行研究跟討論。&lt;/p>
&lt;/blockquote>
&lt;h2 id="related-reasoning">相關的推理&lt;/h2>
&lt;p>既然發現了 SSH Server 是共用的，那麼肯定在使用者登入的時候有做過一些處理。&lt;/p>
&lt;p>大多數情況我們會先去查詢 &lt;code>/etc/passwd&lt;/code> 來看使用者預設的 Shell 使什麼，而 &lt;code>git&lt;/code> 的使用者是 &lt;code>/usr/bin/bash&lt;/code> 也就表示是可以正常登入的，實際上如果被設定為特殊的 Shell 或者 &lt;code>/usr/sbin/noling&lt;/code> 的話，也會造成我們無法使用 &lt;code>git&lt;/code> 使用者來進行一些操作，而像是備份之類的操作還是會需要透過 &lt;code>git&lt;/code> 使用者。&lt;/p>
&lt;p>既然不是對使用者的 Bash 進行處理，難道是登入的時候會有什麼特殊處理嗎？依照可能性跟相關的機制，我去檢查了 &lt;code>~/.ssh/authorized_keys&lt;/code> 這個檔案，然後發現了一些線索。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># ...&lt;/span>
&lt;span class="nv">command&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;/opt/gitlab/embedded/service/gitlab-shell key-10&amp;#34;&lt;/span>,no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty ssh-rsa &lt;span class="o">[&lt;/span>SSH-KEY&lt;span class="o">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>看到這邊就再次對自己對於 Linux 或者 SA (System Admin) 的熟練不足，原來在 &lt;code>authorized_keys&lt;/code> 這個檔案是可以指定執行的指令以及能夠使用的特性，透過這樣的方式原本的 &lt;code>/usr/bin/bash&lt;/code> 就會被替換成 GitLab 特製的 &lt;code>gitlab-shell&lt;/code> 這個檔案，並且加以限制 &lt;code>no-&lt;/code> 系列的選項讓透過這把 Key 登入的使用者不能進行各種操作，來防止預期外的操作（像是將某個內部 Port 導向到本機）&lt;/p>
&lt;blockquote>
&lt;p>這邊簡單補充一下，Port Forwarding 我們通常會拿來模擬像是 Ngrok 的功能，不過反過來說我們也可以讓原本隱藏在伺服器不對外的資料庫建立起連線，讓我們能夠在自己的電腦連上，那麼就會有額外的風險出現。&lt;/p>
&lt;/blockquote>
&lt;p>看到這邊基本上已經知道安全性的問題如何解決，不過該如何用 Ruby 來實現這個機制呢？&lt;/p>
&lt;h2 id="experiment">實驗&lt;/h2>
&lt;p>這次我是使用我家裡用來測試的伺服器（Proxmox VE）來搭建虛擬環境，大家可以利用 Digital Ocean 或者 Virtual Box 等工具來實驗這件事情。&lt;/p>
&lt;p>為了模擬這件事情，我們需要先有一個 Ruby 跟 Git 的環境，再啟動虛擬機之後請先安裝。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># RHEL&lt;/span>
yum install git ruby -y
&lt;span class="c1"># Ubuntu&lt;/span>
apt install git ruby -y
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>因為是實驗用的，基本上我們不太需要去管 &lt;code>git&lt;/code> 和 &lt;code>ruby&lt;/code> 的版本。&lt;/p>
&lt;blockquote>
&lt;p>目前安裝到的 Ruby 大概會是 2.5 基本上是夠新的。&lt;/p>
&lt;/blockquote>
&lt;p>首先我們先產生 &lt;code>git&lt;/code> 使用者，以及他的家目錄（Home Directory）&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">useradd -m -d /opt/git git
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>接下來我們就仿造 GitLab 的方式把我們自己的 SSH Key 加入到 &lt;code>/opt/git/.ssh/authorized_keys&lt;/code> 裡面，另外別忘記將檔案設定成正確的權限（600）&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">sudo su - git
mkdir -p ~/.ssh
chmod &lt;span class="m">700&lt;/span> ~/.ssh
vim ~/.ssh/authorized_keys
&lt;span class="c1"># 插入 command=&amp;#34;/opt/git/bin/shell aotoki&amp;#34;,no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty [YOUR_PUBLIC_KEY]&lt;/span>
chmod &lt;span class="m">600&lt;/span> ~/.ssh/authorized_keys
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>這邊我們做了幾個調整，第一個是將指令的位置設定為 &lt;code>/opt/git/bin/shell&lt;/code> 來使用等一下我們會自己撰寫的 Ruby 腳本，而 &lt;code>key-10&lt;/code> 這個則替代成使用者可以存取的目錄，在 GitLab 的設計是會透過 API 去查詢資料庫對應的 SSH Key 來取得使用者，並以此作為基準判斷是否能執行某個動作（Ex. &lt;code>git pull&lt;/code>）&lt;/p>
&lt;h3 id="shell-script">Shell 腳本&lt;/h3>
&lt;p>首先先產生 &lt;code>/opt/git/bin/shell&lt;/code> 這個檔案，並且賦予可以執行的權限。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">mkdir -p ~/bin
touch ~/bin/shell
chmod +x ~/bin/shell
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>接著編輯 &lt;code>/opt/git/bin/shell&lt;/code> 讓他印出 &lt;code>Hello World!&lt;/code> 的訊息&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="ch">#!/usr/bin/env ruby&lt;/span>
&lt;span class="nb">puts&lt;/span> &lt;span class="s2">&amp;#34;Hello World!&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我們可以用 &lt;code>ssh -T&lt;/code> 指令來實驗，如果我們對 GitHub 或者 GitLab 下這個指令的話，也會得到一串歡迎訊息。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">ssh -T git@&lt;span class="o">[&lt;/span>YOUR_SERVER&lt;span class="o">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>到這邊為止我們就順利獲取到了自訂的訊息，下一步就是解析怎麼執行 Git 相關的操作，這部分因為參考文章已經有了，所以我們直接利用已知的線索來進行後續的操作。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="cp">#!/usr/bin/env ruby
&lt;/span>&lt;span class="cp">&lt;/span>
puts ENV.fetch&lt;span class="o">(&lt;/span>&lt;span class="s1">&amp;#39;SSH_ORIGINAL_COMMAND&amp;#39;&lt;/span>, &lt;span class="s1">&amp;#39;noop&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>稍微修改我們的 &lt;code>shell&lt;/code> 執行檔後，就可以知道現在 SSH 客戶端想執行的指令是什麼，像是我們用&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">ssh -T git@&lt;span class="o">[&lt;/span>YOUR_SERVER&lt;span class="o">]&lt;/span> cat /etc/passwd
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>就會得到 &lt;code>cat /etc/passwd&lt;/code> 這個指令，這也表示在沒有使用自定義的 Shell 之前，我們可以很簡單地將伺服器的一些重要資訊呈現出來。&lt;/p>
&lt;h3 id="git-command-implementation">Git 指令實作&lt;/h3>
&lt;p>如果直接使用 &lt;code>git clone git@[YOUR_SERVER]:dummy/repo&lt;/code> 的話，會發現出現錯誤訊息，這是因為 &lt;code>git&lt;/code> 在這個階段會透過我們輸出的資訊來抓取資料，如果不是預期的格式就會發生問題。&lt;/p>
&lt;p>因此我們只需要稍微調整一下程式，將每次執行 &lt;code>git&lt;/code> 指令的資訊寫入到 Log 檔裡面即可。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="ch">#!/usr/bin/env ruby&lt;/span>
&lt;span class="nb">require&lt;/span> &lt;span class="s1">&amp;#39;json&amp;#39;&lt;/span>
&lt;span class="nb">require&lt;/span> &lt;span class="s1">&amp;#39;logger&amp;#39;&lt;/span>
&lt;span class="n">logger&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="no">Logger&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">new&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;/opt/git/shell.log&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">logger&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">info&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">ENV&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">to_h&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">to_json&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>這樣我們就可以確認到 &lt;code>git clone&lt;/code> 實際上會嘗試執行怎樣的指令，反推回來後會發現使用的是 &lt;code>git-upload-pack&lt;/code> 這個指令（前面提到的文章已經有驗證過）&lt;/p>
&lt;p>那麼我們就先在 &lt;code>/opt/git/repos/dummy/repo&lt;/code> 產生一個 Bare Repo 來供我們測試。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">mkdir -p ~/repos/dummy/repo
&lt;span class="nb">cd&lt;/span> ~/repos/dummy/repo
git init --bare
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>接下來在原本的 &lt;code>/opt/git/bin/shell&lt;/code> 增加一些處理針對 &lt;code>git-upload-pack&lt;/code> 來修正指令並且透過 &lt;code>exec&lt;/code> 直接執行&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="n">command&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">args&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="no">ENV&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">fetch&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;SSH_ORIGINAL_COMMAND&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;nohup&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">split&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39; &amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="n">command&lt;/span>
&lt;span class="k">when&lt;/span> &lt;span class="s1">&amp;#39;git-upload-pack&amp;#39;&lt;/span>
&lt;span class="n">path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">#{&lt;/span>&lt;span class="no">Dir&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">pwd&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">/repos/&lt;/span>&lt;span class="si">#{&lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="sr">/&amp;#39;(.+)&amp;#39;/&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;span class="nb">exec&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;git-upload-pack &lt;/span>&lt;span class="si">#{&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>上面的程式碼做了幾項處理：&lt;/p>
&lt;ol>
&lt;li>將指令拆分出來，後面是執行的參數&lt;/li>
&lt;li>利用正規表達式把參數的 &lt;code>'&lt;/code> 去除&lt;/li>
&lt;li>因為參數是路徑，改成絕對路徑設定（否則會找不到）&lt;/li>
&lt;li>用 &lt;code>exec&lt;/code> 方法執行&lt;/li>
&lt;/ol>
&lt;p>這次我們再次嘗試 &lt;code>git clone&lt;/code> 指令就能夠正常抓到這個空的專案，繼續使用同樣的方式測試跟檢驗把對應的指令實作出來。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="n">command&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">path&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">args&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="no">ENV&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">fetch&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;SSH_ORIGINAL_COMMAND&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;nohup&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">split&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39; &amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">#{&lt;/span>&lt;span class="no">Dir&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">pwd&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">/repos/&lt;/span>&lt;span class="si">#{&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="sr">/&amp;#39;(.+)&amp;#39;/&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="n">command&lt;/span>
&lt;span class="k">when&lt;/span> &lt;span class="s1">&amp;#39;git-upload-pack&amp;#39;&lt;/span>
&lt;span class="nb">exec&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;git-upload-pack &lt;/span>&lt;span class="si">#{&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">when&lt;/span> &lt;span class="s1">&amp;#39;git-receive-pack&amp;#39;&lt;/span>
&lt;span class="nb">exec&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;git-receive-pack &lt;/span>&lt;span class="si">#{&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">else&lt;/span>
&lt;span class="nb">exit&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>基本上我們只會使用到 &lt;code>git-upload-pack&lt;/code> 和 &lt;code>git-receive-pack&lt;/code> 兩個指令，而且參數都是 &lt;code>path&lt;/code> 因此稍微改寫了程式碼成為這個樣子，最基本的 Git Push/Pull 操作就能正常運作。&lt;/p>
&lt;blockquote>
&lt;p>在 Ruby 裡面我們可以選用像是 &lt;code>system&lt;/code> 或者 &lt;code>exec&lt;/code> 等方法來執行系統指令，不過 &lt;code>exec&lt;/code> 的特性是會代替現在的正在執行的程序，也就是說我們是在確認可以執行指令後直接轉交給 Git 指令處理，是最容易實作的方式。&lt;/p>
&lt;/blockquote>
&lt;h3 id="permission-check">權限檢查&lt;/h3>
&lt;p>在前面的規劃中，我們希望可以針對該 SSH Key 進行權限檢查，像是參數是 &lt;code>aotoki&lt;/code> 的狀況下應該只能存取 &lt;code>aotoki/&lt;/code> 以下的 Repo 而不應該下載到 &lt;code>dummy/&lt;/code> 的專案，因此我們可以再針對前面的程式碼做簡單的修改，利用 Ruby 的 &lt;code>start_with?&lt;/code> 方法做簡易的檢查。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="c1"># ...&lt;/span>
&lt;span class="n">command&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">path&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">args&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="no">ENV&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">fetch&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;SSH_ORIGINAL_COMMAND&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;nohup&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">split&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39; &amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nb">exit&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="k">unless&lt;/span> &lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">start_with?&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;&amp;#39;&lt;/span>&lt;span class="si">#{&lt;/span>&lt;span class="no">ARGV&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">/&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># 因為還沒去除雙引號要補上&lt;/span>
&lt;span class="n">path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">#{&lt;/span>&lt;span class="no">Dir&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">pwd&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">/repos/&lt;/span>&lt;span class="si">#{&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="sr">/&amp;#39;(.+)&amp;#39;/&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;span class="c1"># ...&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我們在原本修正路徑的前一行，先針對傳入的 &lt;code>dummy/repo&lt;/code> 這個參數做檢查，如果是 &lt;code>aotoki/&lt;/code> 開頭的，表示跟這把 SSH Key 的所有者一致，那麼就會繼續執行。否則我們直接回傳 &lt;code>1&lt;/code> 的狀態碼結束程式，同時表示在存取的過程中發生了錯誤。&lt;/p>
&lt;p>接下來製作一個跟 SSH Key 配套的 Repo 出來，比較看看是否是只能下載 &lt;code>aotoki/&lt;/code> 而無法下載 &lt;code>dummy/&lt;/code> 了呢？&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git clone git@&lt;span class="o">[&lt;/span>YOUR_SERVER&lt;span class="o">]&lt;/span>:dummy/repo
&lt;span class="c1"># fatal: Could not read from remote repository.&lt;/span>
git clone git@&lt;span class="o">[&lt;/span>YOUR_SERVER&lt;span class="o">]&lt;/span>:aotoki/repo
&lt;span class="c1"># warning: You appear to have cloned an empty repository.&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="conclusion">總結&lt;/h2>
&lt;p>雖然這個知識在大多數情況下可能沒有太多的幫助，不過透過這樣的探討也能讓我們看到在 Linux 上還有許多我們不熟悉的地方。作為網站工程師在前後端可能是很熟練的，不過實際上我們對於 Linux 和系統管理實際上還是受限的，除了增加知識的範圍之外，透過這樣在同個領域不同專業的交流，說不定能設計出更多不一樣的設計。&lt;/p>
&lt;p>同理來看，容器技術實際上也是需要同時了解 Linux 和軟體開發才能夠得以實現，很多時候我們並不是單純的使用單一的技術在解決問題，而是基於對不同專業的理解來架構我們所期望的軟體系統。&lt;/p></content:encoded></item><item><title>TGONext: 追蹤和技術債</title><link>https://blog.frost.tw/posts/2020/05/11/TGONext-Tracing-and-Technical-Debt/</link><category>心得</category><category>TGONext</category><category>架構</category><pubDate>Mon, 11 May 2020 00:19:35 +0800</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2020/05/11/TGONext-Tracing-and-Technical-Debt/</guid><description>&lt;p>在 TGONext 期間我們基本上有 4 ~ 5 次的聚會，而這次算是表定上的最後一次聚會。在可能是最後一次的聚會，我們先討論了幾個原本沒有要討論的主題。&lt;/p>
&lt;p>這次聚會中，我們會討論關於日誌追蹤跟如何處理技術債。&lt;/p></description><content:encoded>&lt;p>在 TGONext 期間我們基本上有 4 ~ 5 次的聚會，而這次算是表定上的最後一次聚會。在可能是最後一次的聚會，我們先討論了幾個原本沒有要討論的主題。&lt;/p>
&lt;p>這次聚會中，我們會討論關於日誌追蹤跟如何處理技術債。&lt;/p>
&lt;h2 id="log-tracing">日誌追蹤&lt;/h2>
&lt;p>會討論這個是因為我們之中有人在工作中對於日誌蒐集這件事情有一些疑問。&lt;/p>
&lt;h3 id="collection">蒐集&lt;/h3>
&lt;p>在大多數情況下會選擇直接將日誌放到本機端的硬碟，不過當我們的服務成長後這反而變得很難從日誌中進行除錯。&lt;/p>
&lt;p>在我的公司，基本上我們因為客戶基本上只有單一伺服器所以會把紀錄放在本機上。或者我們會讓我們的客戶將紀錄上傳到一些第三方的 SaaS 服務來節省建置日治伺服器的時間。實際上我們也已經有非常方便的工具可以選擇，像是 AWS 的 CloudWatch 或者 &lt;a href="https://www.papertrail.com/">Papertrail&lt;/a> 都可很容易的整合到 Rails 上。&lt;/p>
&lt;h3 id="open-tracing">Open Tracing&lt;/h3>
&lt;p>當整個服務的數量成長之後，單純的日誌也不再足以去追蹤整個系統，而且我們會需要更多資訊去了解我們的系統。&lt;/p>
&lt;p>Open Tracing 是一個標準定義了該如何追蹤我們的系統. 我們可以選用 &lt;a href="https://www.jaegertracing.io/">Jagger&lt;/a> 或者 &lt;a href="https://zipkin.io/">Zipkin&lt;/a> 這類支援 Open Tracing API 的工具。&lt;/p>
&lt;blockquote>
&lt;p>選用 Open Tracing 可能會是個不錯的選擇，大多數商業解決方案都已經支援 Open Tracing API 也因此我們可以輕易的在他們之間切換。&lt;/p>
&lt;/blockquote>
&lt;h3 id="application-performance-monitor">Application Performance Monitor&lt;/h3>
&lt;p>我們可以視為這是 Open Tracing 的一部分，他提供我們追蹤 Function Call 或者 API Call 的花費時間。在我的經驗中，一些商業解決方案像是 &lt;a href="https://www.datadoghq.com/">Datadog&lt;/a>, &lt;a href="https://newrelic.com/">NewRelic&lt;/a>、&lt;a href="https://scoutapm.com/">ScoutAPM&lt;/a> 和其他服務，都提供我們更多詳細的資訊來幫助我們可以追蹤效能上的問題。&lt;/p>
&lt;p>不過開源的專案像是 &lt;a href="https://www.elastic.co/apm">ElasticAPM&lt;/a> 就有比較多限制以及追蹤的資訊相對的簡單。&lt;/p>
&lt;blockquote>
&lt;p>在商業解決方案大多支援記憶體的追蹤而且對記憶體問題的處理非常有幫助，不過像是 ElasticAPM 就還在計畫中而沒有支援。&lt;/p>
&lt;/blockquote>
&lt;h3 id="time">時間&lt;/h3>
&lt;p>在我們分享經驗跟工具後，我們的導師點出了一個追蹤工具的關鍵點。&lt;/p>
&lt;p>當我們使用這些工具追蹤服務時，他大多是跟時間相關的。為了避免網路延遲，這些工具大多會選擇使用本地的時間當作時間戳記然後發送到追蹤伺服器上。&lt;/p>
&lt;p>這表示如果我們有兩台機器的時間是不同步的，我們就會得到一個錯誤的時間線從而導致我們在儀表板上看到的錯的資訊。&lt;/p>
&lt;p>舉例來說，我們有三個 API 呼叫（A =&amp;gt; B =&amp;gt; C）在這個追蹤內，其中一個 API 伺服器（B）有錯誤的本地時間。我們可能會發現 B 在時間線上早於 A，但是這跟實際上的順序是不一致的，這就可能造成我們無法準確的追蹤問題。&lt;/p>
&lt;h3 id="dashboard">儀表板&lt;/h3>
&lt;p>另外一個重要的點則是儀表板，我們想要在短時間內找到問題通常仰賴一個設計優良的儀表板去幫助開發者追蹤問題。&lt;/p>
&lt;p>這也是為什麼商業解決方案相對開源專案還成熟很多，而在自己搭建的方案中會選擇 ElasticSearch 來作為解決方案。&lt;/p>
&lt;p>建構一個強大的儀表板是不容易的，何況追蹤大多不是在產品開發中最優先的事項。&lt;/p>
&lt;p>這也是為什麼大多會偏向使用 SaaS 或者現有的開源方案。&lt;/p>
&lt;h2 id="technical-debt">技術債&lt;/h2>
&lt;p>這部分我們分享了我們在決定重構或者安排解決技術債的經驗。&lt;/p>
&lt;p>我想我們大多同意這沒有一個正確的解答，不過我們還是有一些方向可以遵循。&lt;/p>
&lt;h3 id="the-test">測試&lt;/h3>
&lt;p>為了解決技術債，我們大多會去重構我們的程式碼。而重構重程式碼就會需要透過測試來保證不會破壞任何東西。&lt;/p>
&lt;p>在我自己的經驗裡「規格」是很重要的。如果我們沒有正確的規格，測試也只會專注在錯誤的目標從而撰寫出一些沒有幫助的測試。&lt;/p>
&lt;h3 id="the-known-and-unknown-debt">已知跟未知的技術債&lt;/h3>
&lt;p>在工作中，我們通常不會有足夠的時間去撰寫一些理想的程式碼。這表示即使我們不想產生技術債，我們還是因為時間的限制被迫留下技術債。&lt;/p>
&lt;p>在這個情況，我們通常會加入 &lt;code>TODO&lt;/code> 作為註解表示我們需要去重構他，在另一方面，我們也可能撰寫了一些不恰當的程式而沒有自覺。&lt;/p>
&lt;p>為了解決技術債，我們大多同意去「主動」的消除他們，至於未知的部分也只能等待他被發現的時候再去處理。&lt;/p>
&lt;p>不過「追蹤」其實能夠幫助我們更快找到隱藏的問題，這剛好和我們前面討論的部分互相呼應。&lt;/p>
&lt;blockquote>
&lt;p>程式語言的版本太舊是另外一種情況會造成技術債。當程式語言被改善或者升級後，可能會放棄掉一些語法，而這可能會導致我們無法繼續使用舊的程式碼在新版本的程式語言中繼續使用。&lt;/p>
&lt;/blockquote>
&lt;h3 id="the-communicate">溝通&lt;/h3>
&lt;p>在最後，我們的導師基於他的經驗給了我們一些總結。&lt;/p>
&lt;p>造成技術在的原因通常是因為行銷或者產品團隊的需求，不過這些需求能幫助公司產生更多價值。&lt;/p>
&lt;p>如果我們希望有時間去處理技術債就需要跟他們解釋其中的優缺點。&lt;/p>
&lt;p>不過開發團隊的要求大多被拒絕，因為他們大多很難理解重構的重要性。&lt;/p>
&lt;p>為了解決這個問題，我們需要將資訊轉換成相同的單位讓其他團隊能夠比較從而理解。&lt;/p>
&lt;p>舉例來說，我們可以解釋重構將能夠改善 10% 未來在宣傳工能上的開發時間，這能夠讓行銷團隊更快的去推廣他們的新產品。不過這會需要付出 50% 的時間在這一次的開發上一併重構這個功能。&lt;/p>
&lt;p>如果行銷團隊認為這個價值高於繼續維持現在的方法去加入新的宣傳功能，那們我們就會得到他們的支持來進行重構。&lt;/p>
&lt;h2 id="conclusion">總結&lt;/h2>
&lt;p>實際上這次聚會比其他聚會還短了一些，不過在這幾次的聚會中我們大致上將我們希望討論的主題都討論了一遍。&lt;/p>
&lt;p>在這些聚會中，我認為我學到了兩個重要的事情。第一個是要嘗試去找到我們正在評估的架構中的關鍵或者目標，這再讓我們選擇適合的解決方案跟避免他的缺點影響我們系統佔了很重要的角色。&lt;/p>
&lt;p>另一個就是溝通技巧，實際上在我的工作中我是很重視的。不過我仍只有在跟工程師有嘗試做好，對於客戶或者非工程師的夥伴還是沒有辦法做得很好。在大多數情況下，我是希望 PM 能幫我做好這件事情，不過這個技能在我需要向非工程師解釋技術問題時就變得很重要。&lt;/p></content:encoded></item><item><title>做一個 Rails Form Helper 相容的 Form Object</title><link>https://blog.frost.tw/posts/2020/05/03/Build-a-Form-Helper-capable-Form-Object-in-Rails/</link><category>Rails</category><category>Ruby</category><category>Ruby on Rails</category><category>心得</category><pubDate>Sun, 03 May 2020 16:29:36 +0800</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2020/05/03/Build-a-Form-Helper-capable-Form-Object-in-Rails/</guid><description>&lt;p>當我們的 Rails 專案邊複雜的時候，Form Object 算是一個常見的方法。不過網路上的教學似乎大多都沒有能夠相容 Rails 的 Form Helper 的版本。&lt;/p>
&lt;p>所以我就開始思考，有沒有辦法法在比較少的修改下去支援 Form Helper 呢？&lt;/p></description><content:encoded>&lt;p>當我們的 Rails 專案邊複雜的時候，Form Object 算是一個常見的方法。不過網路上的教學似乎大多都沒有能夠相容 Rails 的 Form Helper 的版本。&lt;/p>
&lt;p>所以我就開始思考，有沒有辦法法在比較少的修改下去支援 Form Helper 呢？&lt;/p>
&lt;h2 id="common-form-object-implementation">常見的 Form Object 實作&lt;/h2>
&lt;p>為了要改善我們的 Form Object，我們至少要先知道目前在使用的原始版本。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="k">class&lt;/span> &lt;span class="nc">RegistrationForm&lt;/span>
&lt;span class="kp">include&lt;/span> &lt;span class="no">ActiveModel&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="no">Model&lt;/span>
&lt;span class="kp">include&lt;/span> &lt;span class="no">ActiveModel&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="no">Validations&lt;/span>
&lt;span class="kp">attr_accessor&lt;/span> &lt;span class="ss">:email&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">:password&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">:password_confirmation&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">initialize&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">user&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">params&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{})&lt;/span>
&lt;span class="vi">@user&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">user&lt;/span>
&lt;span class="k">super&lt;/span> &lt;span class="n">params&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="c1"># ...&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">attributes&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="ss">email&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="vi">@email&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="ss">password&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="vi">@password&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">save&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">unless&lt;/span> &lt;span class="n">valid?&lt;/span>
&lt;span class="vi">@user&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">assign_attributes&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">attributes&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="vi">@user&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">save&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>這是一個網路上很常見的 Form Object，基本上它提供了類似 Model 行為讓我們可以不用在 Controller 上有太多的修改。&lt;/p>
&lt;p>不過在 View 裡面的時候，我們的 Form Helper 就會變成一直需要設定 Method 和 URL 了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="o">&amp;lt;%=&lt;/span> &lt;span class="n">form_for&lt;/span> &lt;span class="vi">@form&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">method&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="ss">:post&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">url&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">users_path&lt;/span> &lt;span class="k">do&lt;/span> &lt;span class="o">|&lt;/span>&lt;span class="n">f&lt;/span>&lt;span class="o">|&lt;/span> &lt;span class="s">%&amp;gt;
&lt;/span>&lt;span class="s">&amp;lt;% # ... %&amp;gt;&lt;/span>
&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="sx">% end &lt;/span> &lt;span class="o">%&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="the-form-helper">關於 Form Helper&lt;/h2>
&lt;p>為了改善 Form Object 我開始去看 Form Helper 的原始碼。&lt;/p>
&lt;p>在 &lt;a href="https://github.com/rails/rails/blob/bdc581616b760d1e2be3795c6f0f3ab4b1e125a5/actionview/lib/action_view/helpers/form_helper.rb#L440">action_view/helpers/form_helper.rb#L440&lt;/a> 裡面，ActionView 會嘗試在我們傳入物件的時候用 &lt;code>apply_form_for_options!&lt;/code> 來處理。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="n">apply_form_for_options!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">record&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">object&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">options&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>而在 &lt;a href="https://github.com/rails/rails/blob/bdc581616b760d1e2be3795c6f0f3ab4b1e125a5/actionview/lib/action_view/helpers/form_helper.rb#L457-L474">&lt;code>apply_form_for_options!&lt;/code>&lt;/a> 方法中，我們可以發現他會設定 &lt;code>method&lt;/code> 和 &lt;code>url&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="n">action&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">method&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">object&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">respond_to?&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ss">:persisted?&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">object&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">persisted?&lt;/span> &lt;span class="p">?&lt;/span> &lt;span class="o">[&lt;/span>&lt;span class="ss">:edit&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">:patch&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="o">[&lt;/span>&lt;span class="ss">:new&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">:post&lt;/span>&lt;span class="o">]&lt;/span>
&lt;span class="c1"># ...&lt;/span>
&lt;span class="n">options&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="ss">:url&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">||=&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">options&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">key?&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ss">:format&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">polymorphic_path&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">record&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">format&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">options&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">delete&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ss">:format&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="k">else&lt;/span>
&lt;span class="n">polymorphic_path&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">record&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">{})&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>這表示如果我們的 Form Object 可以提供相同的介面給 Form Helper 的話，基本上我們就不用做什麼事情就能正確的設定 Method 和 URL 參數。&lt;/p>
&lt;h2 id="the-persisted">persisted? 方法&lt;/h2>
&lt;p>當 Form Helper 決定用 &lt;code>POST&lt;/code> 去產生新物件，或者用 &lt;code>PUT&lt;/code> 去更新一個現有物件時，他取決於 Model 的 &lt;code>persisted?&lt;/code> 方法。&lt;/p>
&lt;p>這表示當我們加入 &lt;code>persisted?&lt;/code> 方法到我們的 Form Object 之後，就能夠被偵測到。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="k">class&lt;/span> &lt;span class="nc">BaseForm&lt;/span>
&lt;span class="c1"># ...&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">initialize&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">record&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">params&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{})&lt;/span>
&lt;span class="vi">@record&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">record&lt;/span>
&lt;span class="k">super&lt;/span> &lt;span class="n">params&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">persisted?&lt;/span>
&lt;span class="vi">@record&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="vi">@record&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">persisted?&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>不過我們還可以再改善這個寫法，利用 ActiveSupport 提供的 &lt;a href="https://api.rubyonrails.org/classes/Module.html#method-i-delegate">&lt;code>delegate&lt;/code>&lt;/a> 來實作。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="k">class&lt;/span> &lt;span class="nc">BaseForm&lt;/span>
&lt;span class="c1"># ...&lt;/span>
&lt;span class="n">delegate&lt;/span> &lt;span class="ss">:persisted?&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">to&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="ss">:@record&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">allow_nil&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kp">true&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">initialize&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">record&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">params&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{})&lt;/span>
&lt;span class="vi">@record&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">record&lt;/span>
&lt;span class="k">super&lt;/span> &lt;span class="n">params&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="the-to_param-and-model_name">model_name 和 to_param&lt;/h2>
&lt;p>URL 是透過 &lt;a href="https://api.rubyonrails.org/classes/ActionDispatch/Routing/PolymorphicRoutes.html#method-i-polymorphic_path">&lt;code>polymorphic_path&lt;/code>&lt;/a> 生成的，他會使用 &lt;code>model_name&lt;/code> 和 &lt;code>to_param&lt;/code> 來產生路徑。&lt;/p>
&lt;p>所以我們可以像這樣在 Rails Console 嘗試：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&amp;gt; app.polymorphic_path&lt;span class="o">(&lt;/span>User.new&lt;span class="o">)&lt;/span>
&lt;span class="o">=&lt;/span>&amp;gt; &lt;span class="s2">&amp;#34;/users&amp;#34;&lt;/span>
&amp;gt; app.polymorphic_path&lt;span class="o">(&lt;/span>User.last&lt;span class="o">)&lt;/span>
&lt;span class="o">=&lt;/span>&amp;gt; &lt;span class="s2">&amp;#34;/users/1234&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>當我們加入 &lt;code>model_name&lt;/code> 和 &lt;code>to_param&lt;/code> 的 Delegate 到 Form Object 之後，我們就可以取得一樣的結果。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="n">delegate&lt;/span> &lt;span class="ss">:persisted?&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">:model_name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">:to_param&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">to&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="ss">:@record&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">allow_nil&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kp">true&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>再次確認效果：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&amp;gt; app.polymorphic_path&lt;span class="o">(&lt;/span>RegistrationForm.new&lt;span class="o">(&lt;/span>User.new&lt;span class="o">))&lt;/span>
&lt;span class="o">=&lt;/span>&amp;gt; &lt;span class="s2">&amp;#34;/users&amp;#34;&lt;/span>
&amp;gt; app.polymorphic_path&lt;span class="o">(&lt;/span>RegistrationForm.new&lt;span class="o">(&lt;/span>User.last&lt;span class="o">))&lt;/span>
&lt;span class="o">=&lt;/span>&amp;gt; &lt;span class="s2">&amp;#34;/users/1234&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>現在我們就有跟 Model 相同的介面可以使用。&lt;/p>
&lt;h2 id="load-attributes">讀取屬性&lt;/h2>
&lt;p>當我們可以讓 Form Helper 正確運作後，我們還是沒有辦法讓資料自動在編輯的情況下被自動載入。&lt;/p>
&lt;p>為了解決這個問題，我們可以調整我們的 &lt;code>initialize&lt;/code> 方法來讀取必要的欄位。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="k">class&lt;/span> &lt;span class="nc">RegistrationForm&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="no">BaseForm&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">initialize&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">record&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">params&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{})&lt;/span>
&lt;span class="n">attributes&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">record&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">slice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ss">:email&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">:password&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">merge&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">params&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">super&lt;/span> &lt;span class="n">record&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">params&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>另一種方法是透過 Attribute API 來支援這個功能，但是我們必須明確的在 Form Object 指定每個屬性。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="k">class&lt;/span> &lt;span class="nc">BaseForm&lt;/span>
&lt;span class="c1"># ...&lt;/span>
&lt;span class="kp">include&lt;/span> &lt;span class="no">ActiveModel&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="no">Attributes&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">initialize&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">record&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">params&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{})&lt;/span>
&lt;span class="vi">@record&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">record&lt;/span>
&lt;span class="n">attributes&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">record&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">attributes&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">slice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*.&lt;/span>&lt;span class="n">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">class&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">attribute_names&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">super&lt;/span> &lt;span class="n">attributes&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">merge&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">params&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="c1"># app/forms/registration_form.rb&lt;/span>
&lt;span class="k">class&lt;/span> &lt;span class="nc">RegistrationForm&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="no">BaseForm&lt;/span>
&lt;span class="n">attribute&lt;/span> &lt;span class="ss">:email&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">:string&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>不過我們必須注意 &lt;code>params&lt;/code> 的使用，Model 回傳的屬性會是 &lt;code>{&amp;quot;name&amp;quot; =&amp;gt; &amp;quot;Joy&amp;quot;}&lt;/code> 但是我們用 &lt;code>{name: &amp;quot;Joy&amp;quot;}&lt;/code> 的話，我們最後會得到混合字串和 Symbol 的 &lt;code>{&amp;quot;name&amp;quot; =&amp;gt; &amp;quot;Joy&amp;quot;, name: &amp;quot;Joy&amp;quot;}&lt;/code> 而且可能會讓我們在設定 Form Object 屬性時發生點問題。&lt;/p>
&lt;/blockquote>
&lt;h2 id="future-improve">後續改進&lt;/h2>
&lt;p>在目前的版本，我們必須將 Model 實體傳入到 Form Object 裡面，也許我們可以加入一些 DSL 去自動產生。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="c1"># Option 1&lt;/span>
&lt;span class="k">class&lt;/span> &lt;span class="nc">RegistrationForm&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="no">BaseForm&lt;/span>
&lt;span class="n">model_class&lt;/span> &lt;span class="s1">&amp;#39;User&amp;#39;&lt;/span>
&lt;span class="n">attribute&lt;/span> &lt;span class="ss">:name&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="c1"># Option 2&lt;/span>
&lt;span class="k">class&lt;/span> &lt;span class="nc">RegistrationForm&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="no">BaseForm&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="no">User&lt;/span>&lt;span class="o">]&lt;/span>
&lt;span class="n">attribute&lt;/span> &lt;span class="ss">:name&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>不過這樣的做法在比較複雜的系統是是需要考量的，不一定會是個好做法。&lt;/p>
&lt;p>舉例來說，我們已經在 Controller 或者其他物件讀取 &lt;code>User&lt;/code> 。但是我們無法將它傳給 Form Object 這表示我們的 Form Object 會永遠的在我們取用時讀取一次。
假設我們這是一個 Nested Form 的話，在這個情況還會導致 N+1 問題。&lt;/p>
&lt;p>這是另外一個主題需要去討論，當我們使用 Form Object 或者其他 Service Object 來重構的時候，我們可能減少了重複的程式碼卻造成我們的系統出現沒有被注意到的隱藏問題，或者讓整體變慢。&lt;/p>
&lt;h2 id="conclusion">總結&lt;/h2>
&lt;p>實際上我並沒有太說使用 Form Object 的經驗，不過我認為這應該是一個很常見的使用情境。
這個版本的 Form Object 還有很多限制，而且我也沒有完善考慮到所有的情況。&lt;/p>
&lt;p>不過我打算繼續在之後的工作中改進，並且嘗試保持單純。我認為並不是所有的情況都需要提供複雜的行為或者透過 Gem 來解決一些應該要很單純的情境。&lt;/p></content:encoded></item><item><title>複習 Rails 的 Autoloading 和 Reloading</title><link>https://blog.frost.tw/posts/2020/04/28/Review-the-Rails-Autoloading-and-Reloading/</link><category>Ruby</category><category>Rails</category><category>Autoloading</category><pubDate>Tue, 28 Apr 2020 00:31:53 +0800</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2020/04/28/Review-the-Rails-Autoloading-and-Reloading/</guid><description>&lt;p>在幾年前我有一篇文章討論 &lt;a href="https://blog.frost.tw/posts/2017/03/06/The-Rails-auto-reload-trap/">Autoloading&lt;/a> 的問題，這幾天剛好有同事在 Autoloading 和 Reloading 上也有類似的問題。&lt;/p>
&lt;p>所以我決定寫一篇文章來複習 Rails 5 和 6 的 Autoloading 的機制。&lt;/p></description><content:encoded>&lt;p>在幾年前我有一篇文章討論 &lt;a href="https://blog.frost.tw/posts/2017/03/06/The-Rails-auto-reload-trap/">Autoloading&lt;/a> 的問題，這幾天剛好有同事在 Autoloading 和 Reloading 上也有類似的問題。&lt;/p>
&lt;p>所以我決定寫一篇文章來複習 Rails 5 和 6 的 Autoloading 的機制。&lt;/p>
&lt;h2 id="why-autoloading">為什麼要 Autoloading&lt;/h2>
&lt;p>在開始討論 Autoloading 和 Reloading 之前，我想先花一點時間思考這個問題。&lt;/p>
&lt;p>像是 C、C++ 或者 Java 這類需要編譯的語言，他們通常不會需要 Autoload（自動載入）的功能，因為 Compiler（編譯器）已經需要的檔案包含在二進位檔案中。也因此我們經常會用 &lt;code>#include&lt;/code> 或 &lt;code>import&lt;/code> 來將需要的符號或者參照引用進來。&lt;/p>
&lt;p>如果像是 Ruby、PHP 或者 Node.js 這類在執行的時候才進行轉換的語言，通常表示我們的程式碼在執行前都不會被處理的。同時我們的程式碼也不會知道其他程式碼，直到我們用 &lt;code>require&lt;/code> 或者 &lt;code>include&lt;/code> 將他們從主程式引用進來。&lt;/p>
&lt;p>這兩種類型的語言實際上都是嘗試將程式碼分割為小檔案，不過對於直譯式語言來說如果我們將全部的檔案都引用的話，是無法跳過不需要的部分。&lt;/p>
&lt;p>在 Ruby 裡面有一個叫做 &lt;a href="https://ruby-doc.org/core-2.7.0/Module.html#method-i-autoload-3F">&lt;code>autoload&lt;/code>&lt;/a> 的關鍵字，它允許我們去定義「當常數（Constant）不存在時，要去讀取哪個指定的檔案。」來實現這個需求。&lt;/p>
&lt;p>這可能在我們載入大量程式碼的時候減少一些記憶體使用，不過我更相信 Autoloading 是用來幫助我們更容易的在大型專案中尋找到我們需要的程式碼。&lt;/p>
&lt;h2 id="the-require-method">require 方法&lt;/h2>
&lt;p>在我的 Code Review 裡面，我要求同事使用 &lt;code>require 'middleware/domain_rewriter'&lt;/code> 而不是 &lt;code>require_relative '../lib/middleware/domain_rewriter'&lt;/code> 去引用額外的 Middleware 在 Rails 的 &lt;code>config/application.rb&lt;/code>。&lt;/p>
&lt;p>不過實際上這並沒有正常運作， 在這個情況我們必須使用 &lt;code>require_relative&lt;/code> 才對。&lt;/p>
&lt;p>第一個問題是「為什麼我們可以在非相對的路徑使用 &lt;code>require&lt;/code> 呢？」&lt;/p>
&lt;p>在 Ruby 中，我們有一個全域變數叫做 &lt;code>$LOAD_PATH&lt;/code> 如果我們用 &lt;code>pp&lt;/code> 去顯示他的內容，我們會發現 Ruby 的安裝路徑是被放在裡面的。他是用來讓 Ruby 在我們嘗試引用某些東西時用來參考的搜尋路徑。&lt;/p>
&lt;p>如果我們有 &lt;code>Gemfile&lt;/code> 在專案目錄，那麼 Gem 安裝的路徑也會被加入到這個列表，這也是為什麼我們可以直接引用 Gem 而只需要將他們寫在 Gemfile 的理由。&lt;/p>
&lt;p>在我們知道 &lt;code>$LOAD_PATH&lt;/code> 提供給 &lt;code>require&lt;/code> 搜尋路徑後，我們無法直接在 &lt;code>config/application.rb&lt;/code> 去引用 &lt;code>lib/&lt;/code> 目錄的原因就非常的明顯了。&lt;/p>
&lt;p>基本上 Rails 是一個 Rack 為基礎的應用，因此通常會以 &lt;code>config.ru&lt;/code> 這個檔案作為起點啟動。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="c1"># frozen_string_literal: true&lt;/span>
&lt;span class="c1"># This file is used by Rack-based servers to start the application.&lt;/span>
&lt;span class="n">require_relative&lt;/span> &lt;span class="s2">&amp;#34;config/environment&amp;#34;&lt;/span>
&lt;span class="n">run&lt;/span> &lt;span class="no">Rails&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">application&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>這個檔案會繼續引用 &lt;code>config/environment.rb&lt;/code> 並且我們可以發現他引用了 &lt;code>config/application.rb&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="c1"># frozen_string_literal: true&lt;/span>
&lt;span class="c1"># Load the Rails application.&lt;/span>
&lt;span class="n">require_relative&lt;/span> &lt;span class="s2">&amp;#34;application&amp;#34;&lt;/span>
&lt;span class="c1"># Initialize the Rails application.&lt;/span>
&lt;span class="no">Rails&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">application&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">initialize!&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>很明顯的，在這裏 Rails 並沒有把 &lt;code>lib/&lt;/code> 放到 &lt;code>$LOAD_PATH&lt;/code> 裡面造成我們無法直接去引用裡面的檔案。&lt;/p>
&lt;h2 id="the-autoloading">Autoloading&lt;/h2>
&lt;p>既然我們知道我們可以用 &lt;code>require&lt;/code> 簡單的載入函式庫，但我們還是需要透過 &lt;code>require_relative&lt;/code> 去載入專案的程式碼，這在我們的程式碼增加時會讓人開始感到煩躁。&lt;/p>
&lt;p>從 Rails 6 之後開始使用 &lt;a href="https://github.com/fxn/zeitwerk">&lt;code>Zeitwerk&lt;/code>&lt;/a> 作為程式碼的載入器，我會用他來當作範例解釋，來減少我們討論後續複雜的行為。&lt;/p>
&lt;p>根據 Zeitwerk 的說明，我們可以看到載入的邏輯基本上如下：&lt;/p>
&lt;pre>&lt;code>lib/my_gem.rb -&amp;gt; MyGem
lib/my_gem/foo.rb -&amp;gt; MyGem::Foo
lib/my_gem/bar_baz.rb -&amp;gt; MyGem::BarBaz
lib/my_gem/woo/zoo.rb -&amp;gt; MyGem::Woo::Zoo
&lt;/code>&lt;/pre>&lt;p>這其實非常類似我們將檔案放在 &lt;code>app/controller&lt;/code> 或者 &lt;code>app/model&lt;/code> 下面的狀況，因為 Rails 會把這些目錄註冊給 Zeitwerk。&lt;/p>
&lt;blockquote>
&lt;p>某方面來說這也表示我們不一定需要在 &lt;code>app/controller&lt;/code> 目錄下使用 &lt;code>_controller&lt;/code> 作為檔案的結尾，不過我們通常不會使用這種難以區分用途的做法。&lt;/p>
&lt;/blockquote>
&lt;p>而 Zeitwerk 會使用 Ruby 的 &lt;code>autoload&lt;/code> 來載入這些 Class 也因此當我們設定 Autoload 路徑後，他會去掃描所有的檔案並把他登記到相關的 Class 上的 Autoload 列表。&lt;/p>
&lt;blockquote>
&lt;p>在我的記憶中舊版的 Rails 有他自己的 Autoloading 實作，會透過覆蓋掉部分 Kernel 的方法以及對 NameError 的捕捉來找到實際應該載入的檔案。&lt;/p>
&lt;/blockquote>
&lt;h2 id="the-reloading">Reloading&lt;/h2>
&lt;p>實際上我認為這個部分是大部分初級工程師嘗試自己用 &lt;code>require&lt;/code> 載入某些東西，但是修改某些檔案後就壞掉後，會覺得疑惑的地方。&lt;/p>
&lt;p>在 Zeitwerk 我們有 &lt;code>#enable_reloading&lt;/code> 選項可以讓我們能夠使用 &lt;code>#reload&lt;/code> 方法。在開發中 Reloading 功能是非常有幫助的，尤其是當我們修改了一些東西後不需要重新啟動伺服器。&lt;/p>
&lt;blockquote>
&lt;p>對編譯式的語言來說總會需要重新編譯和重新打開，不過還是有一些方法可以避免這件事情。&lt;/p>
&lt;/blockquote>
&lt;p>不過為什麼我們可以 &lt;code>#unload&lt;/code> 掉已經轉換過的程式碼呢？實際上這很看語言的特性，至少在 Ruby 裡面常數是一種被允許修改跟被移除的數值。&lt;/p>
&lt;p>當我們呼叫 &lt;code>#reload&lt;/code> 時，Zeitwerk 會 &lt;a href="https://github.com/fxn/zeitwerk/blob/806795d302840a7e96612b88ff45f231ea4318b0/lib/zeitwerk/loader.rb#L796">&lt;code>#unload&lt;/code>&lt;/a> 那些被載入的常數。同時會再將這些 Class 讀取一次，來將新的程式碼放到記憶體中。&lt;/p>
&lt;p>這也是為什麼當我們有一個頂層的常數被移除後，他下面的物件或模組也會被一起移除的原因。&lt;/p>
&lt;p>這其實是一個常見的錯誤，當我們在父物件的檔案同時定義了一個子物件並且在其他檔案呼叫時可能會出現錯誤。&lt;/p>
&lt;blockquote>
&lt;p>不過這可能不會在比較新的 Rails 發生，載入器通常會對他的父物件的檔案先嘗試載入一次。&lt;/p>
&lt;/blockquote>
&lt;p>在同樣的狀況下，類似的錯誤是我們定義了一個 &lt;code>API&lt;/code> 的命名空間在 Autoload 管理的目錄（像是 &lt;code>app/&lt;/code>）同時也定義在沒有被管理的目錄（像是 &lt;code>lib/&lt;/code>）裡面。&lt;/p>
&lt;p>當我們修改一些在 &lt;code>app/&lt;/code> 目錄下的檔案時，&lt;code>API&lt;/code> 會被移除，而 &lt;code>lib/&lt;/code> 定義的 &lt;code>API&lt;/code> 就永遠不會再被載入回來。&lt;/p>
&lt;p>這是因為 &lt;code>require&lt;/code> 認為這個檔案已經被載入，因此 Ruby 認為這個檔案不需要再次被載入，但他已經因為 Reloading 被移除了。&lt;/p>
&lt;p>以下是一個簡單的範例：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="c1"># frozen_string_literal: true&lt;/span>
&lt;span class="n">require_relative&lt;/span> &lt;span class="s1">&amp;#39;api&amp;#39;&lt;/span>
&lt;span class="n">pp&lt;/span> &lt;span class="n">defined?&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">API&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1"># =&amp;gt; &amp;#34;constant&amp;#34;&lt;/span>
&lt;span class="no">Object&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">send&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ss">:remove_const&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;API&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">require_relative&lt;/span> &lt;span class="s1">&amp;#39;api&amp;#39;&lt;/span>
&lt;span class="n">pp&lt;/span> &lt;span class="n">defined?&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">API&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1"># =&amp;gt; nil&lt;/span>
&lt;span class="nb">load&lt;/span> &lt;span class="s2">&amp;#34;api.rb&amp;#34;&lt;/span>
&lt;span class="n">pp&lt;/span> &lt;span class="n">defined?&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">API&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1"># &amp;#34;constant&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>require&lt;/code> 可以避免我們載入檔案兩次，不過 &lt;code>load&lt;/code> 並不會檢查，而 Zeitwerk 也覆蓋掉 &lt;a href="https://github.com/fxn/zeitwerk/blob/master/lib/zeitwerk/kernel.rb#L24">&lt;code>#require&lt;/code>&lt;/a> 方法來提供由 Zeitwerk 管理的類似的功能。&lt;/p>
&lt;p>基於以上的例子，我們大致上就能對 Rails 的 Autoloading 和 Reloading 有一個概念，並且幫助我們更合理的應用他們。&lt;/p>
&lt;h2 id="conclusion">總結&lt;/h2>
&lt;p>在最後，我還有一件事情要提一下。實際上 &lt;code>lib/&lt;/code> 也是被 Rails 管理的。不過他只能在 Rails 啟動之後使用，這也是為什麼我們無法在 &lt;code>config/application.rb&lt;/code> 使用的原因。&lt;/p>
&lt;blockquote>
&lt;p>在原始碼的&lt;a href="https://github.com/rails/rails/blob/758e4f8406e680a6cbf21b170749202c537a2576/railties/lib/rails/engine/configuration.rb#L53">這裏&lt;/a>定義了作為 Load Path 以及在&lt;a href="https://github.com/rails/rails/blob/c0d91a4f9da10094ccdb80e34d1be42ce1016c9a/railties/lib/rails/engine.rb#L570-L575">這裏&lt;/a>將他加入了 Load Path 中。&lt;/p>
&lt;/blockquote>
&lt;p>Autoloading 和 Reloading 是我們在開發時非常有用的工具，而 Zeitwerk 更讓我們非常容易的加入這個功能到專案中。如果你有專案不是使用 Rails 的話，我很推薦嘗試加入 Zeitwerk 並且在實踐中了解更多相關的知識。&lt;/p></content:encoded></item><item><title>TGONext: 資料庫變遷跟架構改變</title><link>https://blog.frost.tw/posts/2020/04/03/TGONext-Database-Migration-and-Architecture-Changing/</link><category>TGONext</category><category>架構</category><category>資料庫</category><category>心得</category><pubDate>Fri, 03 Apr 2020 21:14:56 +0800</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2020/04/03/TGONext-Database-Migration-and-Architecture-Changing/</guid><description>&lt;p>這次在開始討論關於架構的主題之前，我們的倒是讓我們提出一些問題。&lt;/p>
&lt;p>剛好在兩次聚會的期間，我的客戶因為一些錯誤的計畫讓 Migration 失敗了，所以我提出了關於在不停機的狀況下做 Migration 的規劃問題。&lt;/p></description><content:encoded>&lt;p>這次在開始討論關於架構的主題之前，我們的倒是讓我們提出一些問題。&lt;/p>
&lt;p>剛好在兩次聚會的期間，我的客戶因為一些錯誤的計畫讓 Migration 失敗了，所以我提出了關於在不停機的狀況下做 Migration 的規劃問題。&lt;/p>
&lt;h2 id="migrate-database-without-downtime">不停機的 Migration&lt;/h2>
&lt;p>實際上，在我的工作中大多客戶都是能接受停止一段時間來更新資料庫的新創公司類型。&lt;/p>
&lt;p>不過對於比較大的服務，將伺服器停止後進行更新基本上是很難被接受的。&lt;/p>
&lt;blockquote>
&lt;p>尤其是越來越多提供全球使用的服務，即使我們可以在某個區域暫停來停機，對於其他區域來說也不一定能被接受。&lt;/p>
&lt;/blockquote>
&lt;h3 id="the-mentee-s-experience">參與者的經驗&lt;/h3>
&lt;p>我認為包含我的大部分工程師都知道怎麼做，不過應該是有很多細節我們沒有預期到的。&lt;/p>
&lt;p>導師讓我們分享各自的經驗：&lt;/p>
&lt;ul>
&lt;li>不要去移除欄位&lt;/li>
&lt;li>避免框架的 Migration 移除東西&lt;/li>
&lt;li>複製並且重新命名資料表&lt;/li>
&lt;li>使用 Trigger 複製資料&lt;/li>
&lt;/ul>
&lt;p>其實大部分的做法我都在網路上看過，大家提出比較常見的作法就是避免去移除或者更改欄位名稱。&lt;/p>
&lt;h3 id="does-the-database-has-version-control">資料庫真的有版本控制嗎？&lt;/h3>
&lt;p>有些人提到因為在 Migiration 的過程中不能遺失資料，所以他們大多不刪除欄位或者在 Rollback （回滾）的時候刪除任何東西。也因此在討論的過程中，我們的導師點出了這樣一個問題。&lt;/p>
&lt;p>以原始碼來說我們可以跳到任一個版本而不會有任何副作用，這是因為原始碼大多是無狀態的。但是我們嘗試去改變資料庫的版本從 &lt;code>2020-03-28&lt;/code> 到 &lt;code>2020-01-01&lt;/code> 然後我們可能再次跳回 &lt;code>2020-03-28&lt;/code> 的版本而能讓所有跟 Rollback 之前完全一樣嗎？&lt;/p>
&lt;p>基本上這沒有一個準確的解答，大多會仰賴於我們的服務對這些資料的重視程度。不過在我們設計 Migration 的時候，確實應該要小心的選擇一個比較安全的做法。&lt;/p>
&lt;h3 id="the-performance-lost">效能損失&lt;/h3>
&lt;p>既然我們不會去刪除欄位，資料庫就會需要去讀取一個更大的 Row 來查詢東西而這可能會讓資料庫變慢。&lt;/p>
&lt;p>基本上這是因為 RDBMS 的資料庫大多是以 Row 為基礎來設計的才會有這樣的特性。而 NoSQL 通常以 Column 為基礎設計，因此 NoSQL 通常不會遇到這類問題。&lt;/p>
&lt;p>不過我們也有其他的選擇，像是透過修改重新命名資料表的方式來避免長成大表。先建立一個暫時的資料表套用變更後再去替換這個資料表。&lt;/p>
&lt;p>像是 GitHub 就有一個叫做 &lt;a href="https://github.com/github/gh-ost">gh-host&lt;/a> 的工具可以讓我們不用自己實作上面的流程。&lt;/p>
&lt;blockquote>
&lt;p>不過我們的導師也提醒我們，如果 Migration 的過程會花費很多時間我們可能會想要中途暫停，但是 &lt;code>gh-ost&lt;/code> 並不支援這樣的機制。&lt;/p>
&lt;/blockquote>
&lt;p>除了效能問題之外，我們也還有像是 Table-lock 和其他問題需要注意。&lt;/p>
&lt;blockquote>
&lt;p>在討論中我發現其實有很多資料庫的行為是我們已經知道的，但是在選擇方案時並沒有將這些東西連結起來去確認可能存在的風險。&lt;/p>
&lt;/blockquote>
&lt;h2 id="the-database-scalability">資料庫的擴充性&lt;/h2>
&lt;p>這算是前面問題的延伸，當我們討論到 RDBMS 和 NoSQL 有不同特性時，我們開始比較 MySQL/PostgreSQL 和 MongoDB 的設計。&lt;/p>
&lt;p>在 RDBMS 中我們通常會使用 B+ Tree 來建立 Index（索引），而我們的導師向我們提出問題：「為什麼 MongoDB 會選擇使用 B Tree 來建立索引？」&lt;/p>
&lt;p>為了加快查詢資料，其中一種方法是減少總查詢的筆數。在 RDBMS 我們通常會選擇使用 Shard（分片）或者 Partition（分區）來建立一個比較小的資料表子集合。&lt;/p>
&lt;p>在 B+ Tree 裡面，資料節點通常會連接著下一筆資料，這表示我們在 RDBMS 能有快速的範圍查詢。不過如果我們需要去建立一個 Shard 或者將資料切割到不同的資料庫，這反而變成一個讓 RDBMS 感到困難的問題，因為很難確定要將哪些資料節點放在一起切割出來同時還要考慮資料節點的連結關係。&lt;/p>
&lt;p>因為 MongoDB 使用了 B Tree，這表示可以非常容易的選出一個子樹就能切割，因為不需要擔心資料節點會連結在另一個子樹上的資料節點上。&lt;/p>
&lt;p>這種特性讓 MongoDB 更容易被拓展，但是同時缺點就包含了範圍查詢相對的慢，以及 Shard 機制可能因為某些原因頻繁的移動資料而造成 Disk I/O 上的壓力。&lt;/p>
&lt;blockquote>
&lt;p>這個討論其實給我了一些在未來建議其他人選用資料庫的靈感，每一個小的設計細節都會改變行為跟優缺點。&lt;/p>
&lt;/blockquote>
&lt;h2 id="the-architecture-changing">架構的改變&lt;/h2>
&lt;p>這其實是我們這次聚會預定討論的主題，我們的導師先讓我們分享一些當服務無法處理增加的請求時要怎麼做的想法。&lt;/p>
&lt;p>大致上歸納整理後，我們大概有這幾種方式：&lt;/p>
&lt;ul>
&lt;li>垂直升級 (像是增加記憶體、處理器)&lt;/li>
&lt;li>水平拓展 (增加更多同質的實體)&lt;/li>
&lt;li>加入快取&lt;/li>
&lt;li>加入隊列（Queue）&lt;/li>
&lt;li>增加限流機制（像是次數或者流量限制）&lt;/li>
&lt;li>將單機服務分割成不同的實體&lt;/li>
&lt;/ul>
&lt;p>接下來我們的導師讓我們分享何時會從其中一種模式換到另外一種，網路上有很多公司分享過他們的經驗，但是這些並不一定符合我們的情況。&lt;/p>
&lt;p>如同每一次的聚會，我們從討論每一種選擇的缺點開始。像是水平拓展雖然看似是一個不錯的選擇，但是假設我們有超過 300 台或者更多機器時，管理上是容易的嗎？進行改版時要花多久才能全部更新完畢？&lt;/p>
&lt;p>因此我們可能會想要合併或者減少我們所管理的總實體數量，我們的導師也讓我們思考一些使用 Microservice 的知名公司總共有多少微服務以及是否有一個管理數量的極限存在。&lt;/p>
&lt;p>我們也針對上面幾種模式討論各種選擇的優點跟缺點，這邊我選了幾個比較有趣的跟大家分享。&lt;/p>
&lt;blockquote>
&lt;p>在現實世界中我們大多不會只用一種模式，我覺得比較像是當作積木的感覺去組合或者分解來配合我們的業務需求。&lt;/p>
&lt;/blockquote>
&lt;h2 id="queue">Queue&lt;/h2>
&lt;p>這是我們討論比較多的部分，最開始我們是討論使用 Queue 的時機。&lt;/p>
&lt;p>舉例來說，如果我們有一些服務是非常要求即時回應的。那麼 Queue 的非同步特性可能會造成一些問題，而這樣的特性跟 Thread 是類似的。&lt;/p>
&lt;p>在現實中我們常常需要讓寫入資料庫的動作是依序執行的來避免 Race-Condition（競爭條件）也因此 Queue 通常會是依序執行的。&lt;/p>
&lt;p>另一方面，Queue 也通常會有一個容量的上限，如果我們接收了超過上限的請求就需要反過來阻塞使用者。&lt;/p>
&lt;p>這表示我們雖然可以透過使用 Queue 可以為資料庫爭取到緩衝，但同時也可能變成其他服務的瓶頸。&lt;/p>
&lt;blockquote>
&lt;p>這其實也符合在上一次聚會我的感想，不同的選項會有不同的缺點，而我們的工作是要小心地在這些選項中選擇一個恰當的方案。&lt;/p>
&lt;/blockquote>
&lt;h3 id="rabbitmq">RabbitMQ&lt;/h3>
&lt;p>我們也討論了幾個 Queue 服務的解決方案。RabbitMQ 是用 Erlang 所撰寫的，而 Erlang 有著能從失敗的 Process 恢復的特性。這表示在大多數情況下我們的 Queue 會需要兩倍的記憶體來確保能夠正確的恢復，因為我們有另一份備份在記憶體中，來確保失敗的 Process 可以被復原。&lt;/p>
&lt;h3 id="kafka">Kafka&lt;/h3>
&lt;p>我們的導師問我們，Kafka 是用 Java 寫的但是為什麼他跑得非常快？是什麼原因讓 Java 會慢？&lt;/p>
&lt;p>其中一個原因是 GC 會造成一些效能的問題，不過 Java 也提供了 &lt;code>Off-Heap&lt;/code> 的機制讓我們自己管理記憶體，因此 Kafka 能比正常狀況更快。&lt;/p>
&lt;p>而 Kafka 是由 Linkedin 所開發，主要專注在吞吐量（Throughput）上，這是因為對 Linkedin 來說吞吐量比較重要。我們的導師告訴我們，有些比較是沒有意義的因為他們嘗試比較同類型的服務，但是並沒有注意到這些服務想解決的問題不同。&lt;/p>
&lt;h2 id="region">區域&lt;/h2>
&lt;p>另一個有趣的討論是關於區域，在垂直升級的選項中哪個通常是難以升級的？通常是網路，也因此像是 AWS、GCP 和大多數大型的全球公司都會嘗試搭建他們自己的海纜或者機房在不同的國家。&lt;/p>
&lt;p>為了能夠在兩個區域高速交換資料，我們很難用購買 CPU、記憶體或者應䩞的方式改善。&lt;/p>
&lt;p>另一個問題是當我們有高可用性（High-Avalability）或者 Master-Master 架構的時候，如果我們其中一個資料中心停止運作的時候，有多少問題需要我們去解決？&lt;/p>
&lt;p>我們可能會有一些資料並沒有同步到另一個資料中心，假設主要的機房恢復的狀況下，要怎麼確保資料是一致的&lt;/p>
&lt;p>？以及我們主要的機房停止的狀況下，備援的機房是否有相同的硬體可以去支撐原本的請求呢？&lt;/p>
&lt;h2 id="conclusion">結論&lt;/h2>
&lt;p>在這次的聚會中我認為學到了一些關於選擇方案的技巧，在過去我經常很難去回答別人像是為什麼要使用 PostgreSQL 或者 MySQL 或是為什麼要使用 Ruby 這類問題。&lt;/p>
&lt;p>剛開始我認為這是因為我不夠專業的關係，不過我想原因可能是因為我並沒有去注意特性跟那些隱藏在功能後的細節。&lt;/p>
&lt;p>其實這是很好的機會去練習在缺點中去尋找更多資訊，我現在也嘗試改變我的習慣跟流程去實踐這個做法。&lt;/p></content:encoded></item><item><title>TGONext: 從缺點選擇架構</title><link>https://blog.frost.tw/posts/2020/03/15/TGONext-Choose-Architecture-by-Cons/</link><category>架構</category><category>微服務</category><category>資料庫</category><category>心得</category><category>TGONext</category><pubDate>Sun, 15 Mar 2020 03:02:32 +0800</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2020/03/15/TGONext-Choose-Architecture-by-Cons/</guid><description>&lt;p>這次聚會我們先簡單的回顧一下上一次的討論，然後就切換到了下一個主題。基於前一次聚會高併發的討論，我們模擬一個簡單的架構然後開始演進。&lt;/p></description><content:encoded>&lt;p>這次聚會我們先簡單的回顧一下上一次的討論，然後就切換到了下一個主題。基於前一次聚會高併發的討論，我們模擬一個簡單的架構然後開始演進。&lt;/p>
&lt;h2 id="the-trap-inside-the-suggested-way">建議方法中的陷阱&lt;/h2>
&lt;p>首先，我們有一個單體式的應用將 Web 伺服器跟資料庫都跑在同一台機器上。&lt;/p>
&lt;pre>&lt;code>+-----------------------+
|+---------------------+|
|| ||
|| Web Server ||
|| ||
|+---------------------+|
|+---------------------+|
|| ||
|| Database ||
|| ||
|+---------------------+|
+-----------------------+
&lt;/code>&lt;/pre>&lt;p>當請求量增加之後，我們可能會先把 Web 伺服器和資料庫分離到獨立的機器中。&lt;/p>
&lt;pre>&lt;code>+---------------------+ +---------------------+
| | | |
| Web Server &amp;lt;----------&amp;gt; Database |
| | | |
+---------------------+ +---------------------+
&lt;/code>&lt;/pre>&lt;p>當我們再次感覺到變慢的時候，我們可能會增加「快取伺服器」到我們的架構中。
像是增加一個快取伺服器到 Web 伺服器和資料庫之間。&lt;/p>
&lt;pre>&lt;code>+---------------------+ +---------------------+ +---------------------+
| | | | | |
| Web Server &amp;lt;------&amp;gt; Cache Server &amp;lt;------&amp;gt; Database |
| | | | | |
+---------------------+ +---------------------+ +---------------------+
&lt;/code>&lt;/pre>&lt;p>當我們的快取伺服器故障時，我們的服務會再重啟之後恢復正常嗎？&lt;/p>
&lt;blockquote>
&lt;p>實際上它可能不會在快取伺服器重啟後正常恢復，因為我們的快取伺服器遺失了所有資料同時 Web 伺服器依舊發出大量地請求到快取伺服器卻無法處理而轉送到資料庫上。&lt;/p>
&lt;/blockquote>
&lt;p>這就是所謂的「雪崩效應」，當一個服務發生故障時進而影響其他人變得不穩，最後造成整個服務停止。&lt;/p>
&lt;p>我們的導師建議我們在我們的團隊成員了解快取伺服器的優缺點和整個框架或套件使用後會如何運作之前，不要輕易的去增加快取伺服器。&lt;/p>
&lt;h2 id="will-microservice-rescue-us">微服務能解決這一切嗎？&lt;/h2>
&lt;p>如果我們想要避免雪崩效應，你可能會聯想到這幾年很熱門的微服務（Microservice）&lt;/p>
&lt;p>微服務是以「去中心化（Decentralize）」為目的設計的，這表示每個元件大多獨立運作而且很容易的重新部署。&lt;/p>
&lt;p>但是這其實有點太過理想，我們的服務經常會有一些相依於其他服務的情況。像是 Web 伺服器就經常的依賴於資料庫。&lt;/p>
&lt;p>這是另外一個關鍵我們需要在設計架構的時候去考慮的地方。&lt;/p>
&lt;p>目前在微服務中最熱門的相依問題解決方式是製作一種叫做「邊車（Sidecar）」的服務來控制每個元件間的溝通，因為邊車通常會知道其他服務的存活情況以及是否可以被連接，因此能夠回報跟管理他目前所負責的服務。&lt;/p>
&lt;p>我們的導師告訴我們架構大多是為了要解決某個問題才會被設計出來的。&lt;/p>
&lt;p>另一方面，我們如果要在微服務中找到問題，我們必須知道在這連續的呼叫中是在哪個服務停止的。這也表示微服務的系統需要有一個強大的紀錄追蹤機制來追蹤系統中的每一個事件。&lt;/p>
&lt;h2 id="which-is-paid-for-an-architecture-choice">選擇某種架構付出的代價&lt;/h2>
&lt;p>在我們學習了一些最近熱門的關鍵字之後，我們開始討論是否適合使用微服務。&lt;/p>
&lt;p>我們的導師告訴我們效能（Performance）涵蓋三個部分：&lt;/p>
&lt;ul>
&lt;li>吞吐量（Throughput）&lt;/li>
&lt;li>延遲（Latency）&lt;/li>
&lt;li>記憶體使用（Memory Footprint）&lt;/li>
&lt;/ul>
&lt;p>他們會互相影響，這表示如果我們選擇了其中一個作為目標其他的項目就會變成代價支付出去。&lt;/p>
&lt;p>在微服務系統中會將封包導向目標的服務，這也表示延遲會比其他架構還高得多。但是他的去中心化特性讓我們很容易的增加更多的元件來處理不斷增加的流量。&lt;/p>
&lt;p>微服務是透過延遲來交換更大的吞吐量，讓我們擁有處理大量請求的能力。&lt;/p>
&lt;p>也因此，如果我們的服務非常要求低延遲的話，微服務對我們的產品可能就不是一個好主意。&lt;/p>
&lt;h3 id="domain-driven-design">Domain-Driven Design&lt;/h3>
&lt;p>DDD 是我們討論的主題之一，我們的導師讓我們思考為什麼微服務變得熱門的同時 DDD 也同樣開始變得熱門。&lt;/p>
&lt;p>實際上我們可以發現他們相似的在意「領域（Domain）」，他們嘗試將讓每個服務都專注在某一個業務上。這和我們平常使用的 MVC 是非常不同的，不過這也說明了為什麼 DDD 的設計會更適合微服務的需要。&lt;/p>
&lt;p>另一方面，如果我們想要在公司中使用微服務。他通常取決於公司的規模或者在跨部門之前的溝通有些問題時，微服務可可能會是得不錯的選擇讓每個部門維護自己的服務。&lt;/p>
&lt;blockquote>
&lt;p>不過我們也需要注意過度的設計在我們自己的部門中，因為我們很可能只需要一個單體式的應用在我們的部門或公司。另一方面微服務也有不少需求需要滿足，如果在一個部門中擁有過多的為服務可能會造成另外的問題。&lt;/p>
&lt;/blockquote>
&lt;h2 id="the-data-consistency">資料的一致性&lt;/h2>
&lt;p>除了效能問題之外，資料在我們的架構中也是另一個重要的面向。每一個系統都會有他自己的狀態，而我們的服務則需要小心討論來決定使用強一致性或者最終一致性。&lt;/p>
&lt;p>舉例來說，一個銀行系統必須是強一致性的。至少你不會預期銀行在你存入一些錢之後，顯示並沒有這筆紀錄。卻在幾小時完成一致性的檢查後，才顯示出來。&lt;/p>
&lt;blockquote>
&lt;p>分散式系統其實也是一種資料一制的探討。&lt;/p>
&lt;/blockquote>
&lt;h2 id="the-database-evolution">資料庫的演進&lt;/h2>
&lt;p>在一個系統中，資料庫通常是最直接跟資料一致性有關聯的主題。因此我們的導師讓我們先比較 RDBMS（關連式資料庫）、NoSQL 和 NewSQL 的差異。&lt;/p>
&lt;h3 id="rdbms">RDBMS&lt;/h3>
&lt;p>在 RDBMS 之前還有一個叫做 Object-Orident Database （物件導向資料庫）的東西，雖然 PostgreSQL 有一部分的特性，但是我們並沒有繼續討論他。&lt;/p>
&lt;blockquote>
&lt;p>基本上這是我們討論演進的第一個階段，令一方面因為他算是非常常見因此我們並沒有在這個時候討論太多。&lt;/p>
&lt;/blockquote>
&lt;h3 id="nosql">NoSQL&lt;/h3>
&lt;p>在 NoSQL 的情況，我們透過將一致性作為代價來提高吞吐量。這也是為什麼 NoSQL 擁有很不錯的拓展性能讓我們非常簡單的去擴充。&lt;/p>
&lt;p>不過 NoSQL 必須在應用層實作很多東西，因為 RDBMS 幫我們處理了不少事情，但是 NoSQL 並沒有。&lt;/p>
&lt;blockquote>
&lt;p>另外一個特性是 NoSQL 是伴隨 SSD 的特性出現的，因此透過改變儲存資料的方式讓我們獲得高速的 Key-Value 資料存取能力。&lt;/p>
&lt;/blockquote>
&lt;h3 id="newsql">NewSQL&lt;/h3>
&lt;p>NewSQL 比較類似於 NoSQL 的反思，人們開始使思考 NoSQL 作為一個資料庫還有所不足。實際上有很多東西不應該在應用層實現，而應該讓資料庫幫助我們來完成。&lt;/p>
&lt;p>也因此開始開發 NewSQL 這種具備類似 RDBMS 的強一致性但是又有足夠的擴充能力的資料庫。&lt;/p>
&lt;blockquote>
&lt;p>目前 NewSQL 還沒有變的熱門，而且也沒有太多開放原始碼的解決方案。&lt;/p>
&lt;/blockquote>
&lt;h2 id="the-choose-of-database">資料庫的選擇&lt;/h2>
&lt;p>在前面的討論，我們的導師讓我們分享選用一個資料庫的觀點和理由。&lt;/p>
&lt;p>這裡有很多情況讓我們決定要選擇哪個資料庫：&lt;/p>
&lt;ul>
&lt;li>資料庫的功能&lt;/li>
&lt;li>使用的框架&lt;/li>
&lt;li>團隊成員&lt;/li>
&lt;li>客戶的偏好&lt;/li>
&lt;/ul>
&lt;p>實際上這沒有正確答案，就像前面在架構上的討論在不同的設計上會有不同的優缺點出現。&lt;/p>
&lt;h2 id="conclusion">總結&lt;/h2>
&lt;p>實際上這篇文章還是缺少了很多細節，不過太多東西我實在沒辦法一次性的記住。&lt;/p>
&lt;p>實際上在第一次聚會結束後我是有點擔心討論會止於一些計算或了解一些知識而已。&lt;/p>
&lt;p>不過這次聚會我們的導師讓我們學到了一些新的方法跟觀點能夠直接應用在工作上。&lt;/p>
&lt;p>最重要的是我們要在決定之前「找出計畫的缺點」並且重新檢視他，優點確實能給我們好處，但當系統發生問題的時候缺點才是我們需要面對的。&lt;/p>
&lt;p>也因此，我們需要去決定一個架構是對我們的產品傷害最小的，也就是大多數的缺點跟我們產品的需求是不會有太多衝突。&lt;/p></content:encoded></item></channel></rss>