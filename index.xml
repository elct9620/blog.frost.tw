<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>弦而時習之</title><link>https://blog.frost.tw/</link><description>Recent content on 弦而時習之</description><generator>Hugo -- gohugo.io</generator><language>zh-TW</language><managingEditor>contact@frost.tw (蒼時弦也)</managingEditor><webMaster>contact@frost.tw (蒼時弦也)</webMaster><lastBuildDate>Mon, 03 Aug 2020 01:31:31 +0800</lastBuildDate><atom:link href="https://blog.frost.tw/index.xml" rel="self" type="application/rss+xml"/><item><title>COSCUP 2020 速記</title><link>https://blog.frost.tw/posts/2020/08/03/COSCUP-2020-Note/</link><category>COSCUP</category><category>心得</category><pubDate>Mon, 03 Aug 2020 01:31:31 +0800</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2020/08/03/COSCUP-2020-Note/</guid><description>&lt;p>距離上一篇文章已經好幾個月了，手邊還有一些有趣的東西想寫不過實在太忙。每年參加完研討會都會寫一篇心得來記錄一下，不過我後面幾個月可能還要準備日本的 RubyKaigi（線上版）、鐵人賽跟在等投稿結果的 JSDC、MOPCON 等，應該是暫時沒辦法跟大家分享這幾個月找到的有趣技術。&lt;/p></description><content:encoded>&lt;p>距離上一篇文章已經好幾個月了，手邊還有一些有趣的東西想寫不過實在太忙。每年參加完研討會都會寫一篇心得來記錄一下，不過我後面幾個月可能還要準備日本的 RubyKaigi（線上版）、鐵人賽跟在等投稿結果的 JSDC、MOPCON 等，應該是暫時沒辦法跟大家分享這幾個月找到的有趣技術。&lt;/p>
&lt;h2 id="前夜祭">前夜祭&lt;/h2>
&lt;p>這幾年越來越多研討會開始舉辦前夜祭，作為講者和會眾之間的交流算是不錯的時間，畢竟在議程的規劃改變跟複雜化的狀況下，有時候反而沒什麼機會交流。&lt;/p>
&lt;p>今年基本上也是跟以前跑社群的朋友打招呼後就差不多結束了，跟以往不一樣的是結束後我馬上到中山附近的臨時辦公室開始跑 &lt;a href="https://unlight.app">Open Unlight&lt;/a> 的遊戲更新，因為下週（8/8）我們要舉辦一個營運一週年的&lt;a href="https://anniversary.unlight.events/">活動&lt;/a>所以需要先更新遊戲伺服器來設定好相關的資料，也因此一直忙到半夜我們才啟程回家休息。&lt;/p>
&lt;blockquote>
&lt;p>前面的時間也大多在開發各類輔助的系統來支援這次的活動，往好處想就是這個活動讓我們在營運上多了一些新的手段可以應用，不過幾乎是在接近體力極限狀況在開發也因此這幾天都非常想睡。&lt;/p>
&lt;/blockquote>
&lt;h2 id="day-1">Day 1&lt;/h2>
&lt;p>因為很累的關係就直接睡到下午，原本打算去參加晚上的 BoF，不過 COSCUP 這幾年議程大多是四點多就結束，而 BoF 主辦又選在晚上七點半才開始。對台科不太熟悉的我在找不到已經全數撤退的朋友、同事之後，只好報復性消費到京站嘗試看看京都勝牛。&lt;/p>
&lt;p>因為時間還早就沒有排隊，以目前在台灣吃過的炸牛排品質來說算是最好的。熟度也蠻剛好約五分，所以店家預設不會幫你點小火爐起來讓你自己加熱，不過以前幾年在日本吃到的炸牛排來說，幾乎是生的自己調整熟度跟好吃度，台灣目前還是沒有找到覺得同樣好吃的。&lt;/p>
&lt;h2 id="day-2">Day 2&lt;/h2>
&lt;p>早上開場後就是 Vue 作者尤雨溪的分享，原本以為會用中文結果是用英文來講。目前英文聽力還處於一種微妙的狀態，大致上就是集中或者聊天可以聽得清楚，不過演講通常前面十分鐘後就會斷線分心，然後就沒有辦法繼續聽了，前幾年在 RubyKaigi 的經驗除了少數會刻意放慢語速的講者之外，大多都沒聽進去多少，剩下都還是靠簡報幫忙理解。&lt;/p>
&lt;p>其他時間原本還在考慮要不要去其他社群聽，結果時間上幾乎是無縫接軌也因此只好都待在 Ruby 社群聽同事們演講。今年可能也是因為疫情的關係所以一些外國的社群朋友沒辦法來參與，也就這樣讓同事們順利都可以分享他們的經驗。實際上這也是一個很不錯的開始，不論是對技術還是職涯，做演講跟分享對技術的反思或者未來增加自己履歷的精彩程度都是很有幫助的。&lt;/p>
&lt;p>今年嘗試辦看看 BoF 不過幾乎沒什麼人來，原本以為會來當樁腳的同事就這樣自己跑去吃午餐。不過跟前面一場 Vue 社群的 &lt;a href="https://kuro.tw/">Kuro&lt;/a> 大大聊過，雖然來的人很多不過還是沒有 BoF 的氣氛，也就是大家互相交流的部分，下午遇到其他朋友也還是看到其他場都維持這樣的狀況，只是不知道是場地限制還是因為大家都誤會 BoF 的形式。&lt;/p>
&lt;p>中午吃了一下大會推薦的漢堡（在中庭擺攤的爺爺）真的蠻好吃的，不過也因為排隊等待讓我錯過了一場同事的演講（還有因為 BoF 跟 Lightning Talk 也錯過另外兩場）&lt;/p>
&lt;p>即使會眾人數已經來到歷史新高，這次 Lightning Talk 的投稿比預想中的少，還是一樣的很好抽到。&lt;/p>
&lt;p>原本想說要上台刷個存在感就下來，不過剛好在 Pre-Party 的晚上大致摸熟 Terrafork CDK 的使用之後，就決定利用 Lightning Talk 來分享怎麼使用，可惜沒做簡報就是會忘記一些橋段。像是我只用了三天就搞懂、要偷偷抱怨 BoF （以為會有）的樁腳不見了之類的都沒有講到，反而讓效果差了不少。&lt;/p>
&lt;p>關於 Terraform CDK 的使用應該會盡快抽空寫一篇來分享，相比以往的 Terraform 跟 Cloud Formation 使用 CDK 來撰寫變得容易很多，而 CDK 實際上比較像是一個 Compiler 把 TypeScript 或 Python 的程式碼轉換成對應的格式，也因此 Terraform 的版本太舊是會裝不起來的。&lt;/p>
&lt;h2 id="總結">總結&lt;/h2>
&lt;p>大概算了一下，距離我第一次參加 COSCUP 已經快要有十年，從原本每一場議程都會有收穫。到現在已經變成覺得簡單或者跟自己的領域差異太大，可能就沒有去聽看看。而更多的時間也都花在跟認識的朋友聊天上，這大概是在台灣研討會的一個限制。&lt;/p>
&lt;p>因為以前辦過 SITCON 跟參加過幾個不同研討會的籌備，也能理解這樣針對比較新手的議程設計是相對重要的。而比較專業跟深入的研討會，大多受限於人口基數不夠很難籌備到足夠的資金去辦一場這樣的活動，也期待哪天台灣可以有像 RubyKaigi 這樣霸氣的研討會，因為疫情就能全額退票，議程投稿一年比一年要的技術力更加高深，只為了不斷改進 Ruby 的語言。&lt;/p>
&lt;blockquote>
&lt;p>當然，像是 COSCUP 這類研討會主要是在分享跟推廣上，就不適合太困難的題目。但其他各社群自己的研討會，還是受限於資源而無法投入比較高的比例在進階的技巧應用上。&lt;/p>
&lt;/blockquote></content:encoded></item><item><title>GitLab 是如何讓 SSH Server 和 Git 並存而不影響安全性</title><link>https://blog.frost.tw/posts/2020/06/20/How-to-secure-SSH-Server-when-GitLab-add-git-user/</link><category>Git</category><category>GitLab</category><category>Ruby</category><pubDate>Mon, 29 Jun 2020 00:43:26 +0800</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2020/06/20/How-to-secure-SSH-Server-when-GitLab-add-git-user/</guid><description>&lt;p>這次第四屆的 &lt;a href="https://astro.5xruby.tw/">Astro Camp&lt;/a> 有學員嘗試做了 GitHub 的架構，也就是能夠在遠端建立 Git 專案並且能夠在本機上傳檔案。&lt;/p>
&lt;p>不過在和當助教的同事跟學員聊到 &lt;code>git&lt;/code> 使用者可以登入伺服器進行任意操作的安全性問題時，在前陣子的一些測試發現實際上我自己的假設（特製的 SSH Server）是有問題的，而這個解決方法實際上也比我們想像的還容易。&lt;/p></description><content:encoded>&lt;p>這次第四屆的 &lt;a href="https://astro.5xruby.tw/">Astro Camp&lt;/a> 有學員嘗試做了 GitHub 的架構，也就是能夠在遠端建立 Git 專案並且能夠在本機上傳檔案。&lt;/p>
&lt;p>不過在和當助教的同事跟學員聊到 &lt;code>git&lt;/code> 使用者可以登入伺服器進行任意操作的安全性問題時，在前陣子的一些測試發現實際上我自己的假設（特製的 SSH Server）是有問題的，而這個解決方法實際上也比我們想像的還容易。&lt;/p>
&lt;h2 id="possible-solution">可能的解法&lt;/h2>
&lt;p>因為我以前曾經讀過 GitLab 的部分原始碼，所以大概有個印象猜測是使用一個獨立的 SSH Server 來處理這件事情，透過限制可以執行的動作來達到安全的效果。不過這個假設在最近我登入 &lt;a href="https://unlight.app">Open Unlight&lt;/a> 的 GitLab 伺服器時，發現實際上還是基於 OpenSSH 的。&lt;/p>
&lt;p>同事也有提出一些不同的假設，像是將 &lt;code>git&lt;/code> 設定為 &lt;code>/usr/sbin/nologin&lt;/code> 之類的，不過這些方法都造成了無法正常使用 Git 相關的操作。&lt;/p>
&lt;blockquote>
&lt;p>在寫這篇文章的時候已經在&lt;a href="https://juejin.im/post/5cf686b85188253cec305fa7">掘金&lt;/a>的文章有分析過，不過裡面提到的東西已經從 Ruby 替換成 Golang 實作，但是並不影響我們繼續進行研究跟討論。&lt;/p>
&lt;/blockquote>
&lt;h2 id="related-reasoning">相關的推理&lt;/h2>
&lt;p>既然發現了 SSH Server 是共用的，那麼肯定在使用者登入的時候有做過一些處理。&lt;/p>
&lt;p>大多數情況我們會先去查詢 &lt;code>/etc/passwd&lt;/code> 來看使用者預設的 Shell 使什麼，而 &lt;code>git&lt;/code> 的使用者是 &lt;code>/usr/bin/bash&lt;/code> 也就表示是可以正常登入的，實際上如果被設定為特殊的 Shell 或者 &lt;code>/usr/sbin/noling&lt;/code> 的話，也會造成我們無法使用 &lt;code>git&lt;/code> 使用者來進行一些操作，而像是備份之類的操作還是會需要透過 &lt;code>git&lt;/code> 使用者。&lt;/p>
&lt;p>既然不是對使用者的 Bash 進行處理，難道是登入的時候會有什麼特殊處理嗎？依照可能性跟相關的機制，我去檢查了 &lt;code>~/.ssh/authorized_keys&lt;/code> 這個檔案，然後發現了一些線索。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># ...&lt;/span>
&lt;span class="nv">command&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;/opt/gitlab/embedded/service/gitlab-shell key-10&amp;#34;&lt;/span>,no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty ssh-rsa &lt;span class="o">[&lt;/span>SSH-KEY&lt;span class="o">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>看到這邊就再次對自己對於 Linux 或者 SA (System Admin) 的熟練不足，原來在 &lt;code>authorized_keys&lt;/code> 這個檔案是可以指定執行的指令以及能夠使用的特性，透過這樣的方式原本的 &lt;code>/usr/bin/bash&lt;/code> 就會被替換成 GitLab 特製的 &lt;code>gitlab-shell&lt;/code> 這個檔案，並且加以限制 &lt;code>no-&lt;/code> 系列的選項讓透過這把 Key 登入的使用者不能進行各種操作，來防止預期外的操作（像是將某個內部 Port 導向到本機）&lt;/p>
&lt;blockquote>
&lt;p>這邊簡單補充一下，Port Forwarding 我們通常會拿來模擬像是 Ngrok 的功能，不過反過來說我們也可以讓原本隱藏在伺服器不對外的資料庫建立起連線，讓我們能夠在自己的電腦連上，那麼就會有額外的風險出現。&lt;/p>
&lt;/blockquote>
&lt;p>看到這邊基本上已經知道安全性的問題如何解決，不過該如何用 Ruby 來實現這個機制呢？&lt;/p>
&lt;h2 id="experiment">實驗&lt;/h2>
&lt;p>這次我是使用我家裡用來測試的伺服器（Proxmox VE）來搭建虛擬環境，大家可以利用 Digital Ocean 或者 Virtual Box 等工具來實驗這件事情。&lt;/p>
&lt;p>為了模擬這件事情，我們需要先有一個 Ruby 跟 Git 的環境，再啟動虛擬機之後請先安裝。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># RHEL&lt;/span>
yum install git ruby -y
&lt;span class="c1"># Ubuntu&lt;/span>
apt install git ruby -y
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>因為是實驗用的，基本上我們不太需要去管 &lt;code>git&lt;/code> 和 &lt;code>ruby&lt;/code> 的版本。&lt;/p>
&lt;blockquote>
&lt;p>目前安裝到的 Ruby 大概會是 2.5 基本上是夠新的。&lt;/p>
&lt;/blockquote>
&lt;p>首先我們先產生 &lt;code>git&lt;/code> 使用者，以及他的家目錄（Home Directory）&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">useradd -m -d /opt/git git
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>接下來我們就仿造 GitLab 的方式把我們自己的 SSH Key 加入到 &lt;code>/opt/git/.ssh/authorized_keys&lt;/code> 裡面，另外別忘記將檔案設定成正確的權限（600）&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">sudo su - git
mkdir -p ~/.ssh
chmod &lt;span class="m">700&lt;/span> ~/.ssh
vim ~/.ssh/authorized_keys
&lt;span class="c1"># 插入 command=&amp;#34;/opt/git/bin/shell aotoki&amp;#34;,no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty [YOUR_PUBLIC_KEY]&lt;/span>
chmod &lt;span class="m">600&lt;/span> ~/.ssh/authorized_keys
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>這邊我們做了幾個調整，第一個是將指令的位置設定為 &lt;code>/opt/git/bin/shell&lt;/code> 來使用等一下我們會自己撰寫的 Ruby 腳本，而 &lt;code>key-10&lt;/code> 這個則替代成使用者可以存取的目錄，在 GitLab 的設計是會透過 API 去查詢資料庫對應的 SSH Key 來取得使用者，並以此作為基準判斷是否能執行某個動作（Ex. &lt;code>git pull&lt;/code>）&lt;/p>
&lt;h3 id="shell-script">Shell 腳本&lt;/h3>
&lt;p>首先先產生 &lt;code>/opt/git/bin/shell&lt;/code> 這個檔案，並且賦予可以執行的權限。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">mkdir -p ~/bin
touch ~/bin/shell
chmod +x ~/bin/shell
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>接著編輯 &lt;code>/opt/git/bin/shell&lt;/code> 讓他印出 &lt;code>Hello World!&lt;/code> 的訊息&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="ch">#!/usr/bin/env ruby&lt;/span>
&lt;span class="nb">puts&lt;/span> &lt;span class="s2">&amp;#34;Hello World!&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我們可以用 &lt;code>ssh -T&lt;/code> 指令來實驗，如果我們對 GitHub 或者 GitLab 下這個指令的話，也會得到一串歡迎訊息。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">ssh -T git@&lt;span class="o">[&lt;/span>YOUR_SERVER&lt;span class="o">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>到這邊為止我們就順利獲取到了自訂的訊息，下一步就是解析怎麼執行 Git 相關的操作，這部分因為參考文章已經有了，所以我們直接利用已知的線索來進行後續的操作。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="cp">#!/usr/bin/env ruby
&lt;/span>&lt;span class="cp">&lt;/span>
puts ENV.fetch&lt;span class="o">(&lt;/span>&lt;span class="s1">&amp;#39;SSH_ORIGINAL_COMMAND&amp;#39;&lt;/span>, &lt;span class="s1">&amp;#39;noop&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>稍微修改我們的 &lt;code>shell&lt;/code> 執行檔後，就可以知道現在 SSH 客戶端想執行的指令是什麼，像是我們用&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">ssh -T git@&lt;span class="o">[&lt;/span>YOUR_SERVER&lt;span class="o">]&lt;/span> cat /etc/passwd
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>就會得到 &lt;code>cat /etc/passwd&lt;/code> 這個指令，這也表示在沒有使用自定義的 Shell 之前，我們可以很簡單地將伺服器的一些重要資訊呈現出來。&lt;/p>
&lt;h3 id="git-command-implementation">Git 指令實作&lt;/h3>
&lt;p>如果直接使用 &lt;code>git clone git@[YOUR_SERVER]:dummy/repo&lt;/code> 的話，會發現出現錯誤訊息，這是因為 &lt;code>git&lt;/code> 在這個階段會透過我們輸出的資訊來抓取資料，如果不是預期的格式就會發生問題。&lt;/p>
&lt;p>因此我們只需要稍微調整一下程式，將每次執行 &lt;code>git&lt;/code> 指令的資訊寫入到 Log 檔裡面即可。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="ch">#!/usr/bin/env ruby&lt;/span>
&lt;span class="nb">require&lt;/span> &lt;span class="s1">&amp;#39;json&amp;#39;&lt;/span>
&lt;span class="nb">require&lt;/span> &lt;span class="s1">&amp;#39;logger&amp;#39;&lt;/span>
&lt;span class="n">logger&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="no">Logger&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">new&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;/opt/git/shell.log&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">logger&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">info&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">ENV&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">to_h&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">to_json&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>這樣我們就可以確認到 &lt;code>git clone&lt;/code> 實際上會嘗試執行怎樣的指令，反推回來後會發現使用的是 &lt;code>git-upload-pack&lt;/code> 這個指令（前面提到的文章已經有驗證過）&lt;/p>
&lt;p>那麼我們就先在 &lt;code>/opt/git/repos/dummy/repo&lt;/code> 產生一個 Bare Repo 來供我們測試。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">mkdir -p ~/repos/dummy/repo
&lt;span class="nb">cd&lt;/span> ~/repos/dummy/repo
git init --bare
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>接下來在原本的 &lt;code>/opt/git/bin/shell&lt;/code> 增加一些處理針對 &lt;code>git-upload-pack&lt;/code> 來修正指令並且透過 &lt;code>exec&lt;/code> 直接執行&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="n">command&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">args&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="no">ENV&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">fetch&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;SSH_ORIGINAL_COMMAND&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;nohup&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">split&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39; &amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="n">command&lt;/span>
&lt;span class="k">when&lt;/span> &lt;span class="s1">&amp;#39;git-upload-pack&amp;#39;&lt;/span>
&lt;span class="n">path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">#{&lt;/span>&lt;span class="no">Dir&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">pwd&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">/repos/&lt;/span>&lt;span class="si">#{&lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="o">][&lt;/span>&lt;span class="sr">/&amp;#39;(.+)&amp;#39;/&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;span class="nb">exec&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;git-upload-pack &lt;/span>&lt;span class="si">#{&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>上面的程式碼做了幾項處理：&lt;/p>
&lt;ol>
&lt;li>將指令拆分出來，後面是執行的參數&lt;/li>
&lt;li>利用正規表達式把參數的 &lt;code>'&lt;/code> 去除&lt;/li>
&lt;li>因為參數是路徑，改成絕對路徑設定（否則會找不到）&lt;/li>
&lt;li>用 &lt;code>exec&lt;/code> 方法執行&lt;/li>
&lt;/ol>
&lt;p>這次我們再次嘗試 &lt;code>git clone&lt;/code> 指令就能夠正常抓到這個空的專案，繼續使用同樣的方式測試跟檢驗把對應的指令實作出來。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="n">command&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">path&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">args&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="no">ENV&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">fetch&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;SSH_ORIGINAL_COMMAND&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;nohup&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">split&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39; &amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">#{&lt;/span>&lt;span class="no">Dir&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">pwd&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">/repos/&lt;/span>&lt;span class="si">#{&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="sr">/&amp;#39;(.+)&amp;#39;/&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="n">command&lt;/span>
&lt;span class="k">when&lt;/span> &lt;span class="s1">&amp;#39;git-upload-pack&amp;#39;&lt;/span>
&lt;span class="nb">exec&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;git-upload-pack &lt;/span>&lt;span class="si">#{&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">when&lt;/span> &lt;span class="s1">&amp;#39;git-receive-pack&amp;#39;&lt;/span>
&lt;span class="nb">exec&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;git-receive-pack &lt;/span>&lt;span class="si">#{&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">else&lt;/span>
&lt;span class="nb">exit&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>基本上我們只會使用到 &lt;code>git-upload-pack&lt;/code> 和 &lt;code>git-receive-pack&lt;/code> 兩個指令，而且參數都是 &lt;code>path&lt;/code> 因此稍微改寫了程式碼成為這個樣子，最基本的 Git Push/Pull 操作就能正常運作。&lt;/p>
&lt;blockquote>
&lt;p>在 Ruby 裡面我們可以選用像是 &lt;code>system&lt;/code> 或者 &lt;code>exec&lt;/code> 等方法來執行系統指令，不過 &lt;code>exec&lt;/code> 的特性是會代替現在的正在執行的程序，也就是說我們是在確認可以執行指令後直接轉交給 Git 指令處理，是最容易實作的方式。&lt;/p>
&lt;/blockquote>
&lt;h3 id="permission-check">權限檢查&lt;/h3>
&lt;p>在前面的規劃中，我們希望可以針對該 SSH Key 進行權限檢查，像是參數是 &lt;code>aotoki&lt;/code> 的狀況下應該只能存取 &lt;code>aotoki/&lt;/code> 以下的 Repo 而不應該下載到 &lt;code>dummy/&lt;/code> 的專案，因此我們可以再針對前面的程式碼做簡單的修改，利用 Ruby 的 &lt;code>start_with?&lt;/code> 方法做簡易的檢查。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="c1"># ...&lt;/span>
&lt;span class="n">command&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">path&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">args&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="no">ENV&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">fetch&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;SSH_ORIGINAL_COMMAND&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;nohup&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">split&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39; &amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nb">exit&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="k">unless&lt;/span> &lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">start_with?&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;&amp;#39;&lt;/span>&lt;span class="si">#{&lt;/span>&lt;span class="no">ARGV&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">/&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># 因為還沒去除雙引號要補上&lt;/span>
&lt;span class="n">path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">#{&lt;/span>&lt;span class="no">Dir&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">pwd&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">/repos/&lt;/span>&lt;span class="si">#{&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="sr">/&amp;#39;(.+)&amp;#39;/&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;span class="c1"># ...&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我們在原本修正路徑的前一行，先針對傳入的 &lt;code>dummy/repo&lt;/code> 這個參數做檢查，如果是 &lt;code>aotoki/&lt;/code> 開頭的，表示跟這把 SSH Key 的所有者一致，那麼就會繼續執行。否則我們直接回傳 &lt;code>1&lt;/code> 的狀態碼結束程式，同時表示在存取的過程中發生了錯誤。&lt;/p>
&lt;p>接下來製作一個跟 SSH Key 配套的 Repo 出來，比較看看是否是只能下載 &lt;code>aotoki/&lt;/code> 而無法下載 &lt;code>dummy/&lt;/code> 了呢？&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git clone git@&lt;span class="o">[&lt;/span>YOUR_SERVER&lt;span class="o">]&lt;/span>:dummy/repo
&lt;span class="c1"># fatal: Could not read from remote repository.&lt;/span>
git clone git@&lt;span class="o">[&lt;/span>YOUR_SERVER&lt;span class="o">]&lt;/span>:aotoki/repo
&lt;span class="c1"># warning: You appear to have cloned an empty repository.&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="conclusion">總結&lt;/h2>
&lt;p>雖然這個知識在大多數情況下可能沒有太多的幫助，不過透過這樣的探討也能讓我們看到在 Linux 上還有許多我們不熟悉的地方。作為網站工程師在前後端可能是很熟練的，不過實際上我們對於 Linux 和系統管理實際上還是受限的，除了增加知識的範圍之外，透過這樣在同個領域不同專業的交流，說不定能設計出更多不一樣的設計。&lt;/p>
&lt;p>同理來看，容器技術實際上也是需要同時了解 Linux 和軟體開發才能夠得以實現，很多時候我們並不是單純的使用單一的技術在解決問題，而是基於對不同專業的理解來架構我們所期望的軟體系統。&lt;/p></content:encoded></item><item><title>TGONext: 追蹤和技術債</title><link>https://blog.frost.tw/posts/2020/05/11/TGONext-Tracing-and-Technical-Debt/</link><category>心得</category><category>TGONext</category><category>架構</category><pubDate>Mon, 11 May 2020 00:19:35 +0800</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2020/05/11/TGONext-Tracing-and-Technical-Debt/</guid><description>&lt;p>在 TGONext 期間我們基本上有 4 ~ 5 次的聚會，而這次算是表定上的最後一次聚會。在可能是最後一次的聚會，我們先討論了幾個原本沒有要討論的主題。&lt;/p>
&lt;p>這次聚會中，我們會討論關於日誌追蹤跟如何處理技術債。&lt;/p></description><content:encoded>&lt;p>在 TGONext 期間我們基本上有 4 ~ 5 次的聚會，而這次算是表定上的最後一次聚會。在可能是最後一次的聚會，我們先討論了幾個原本沒有要討論的主題。&lt;/p>
&lt;p>這次聚會中，我們會討論關於日誌追蹤跟如何處理技術債。&lt;/p>
&lt;h2 id="log-tracing">日誌追蹤&lt;/h2>
&lt;p>會討論這個是因為我們之中有人在工作中對於日誌蒐集這件事情有一些疑問。&lt;/p>
&lt;h3 id="collection">蒐集&lt;/h3>
&lt;p>在大多數情況下會選擇直接將日誌放到本機端的硬碟，不過當我們的服務成長後這反而變得很難從日誌中進行除錯。&lt;/p>
&lt;p>在我的公司，基本上我們因為客戶基本上只有單一伺服器所以會把紀錄放在本機上。或者我們會讓我們的客戶將紀錄上傳到一些第三方的 SaaS 服務來節省建置日治伺服器的時間。實際上我們也已經有非常方便的工具可以選擇，像是 AWS 的 CloudWatch 或者 &lt;a href="https://www.papertrail.com/">Papertrail&lt;/a> 都可很容易的整合到 Rails 上。&lt;/p>
&lt;h3 id="open-tracing">Open Tracing&lt;/h3>
&lt;p>當整個服務的數量成長之後，單純的日誌也不再足以去追蹤整個系統，而且我們會需要更多資訊去了解我們的系統。&lt;/p>
&lt;p>Open Tracing 是一個標準定義了該如何追蹤我們的系統. 我們可以選用 &lt;a href="https://www.jaegertracing.io/">Jagger&lt;/a> 或者 &lt;a href="https://zipkin.io/">Zipkin&lt;/a> 這類支援 Open Tracing API 的工具。&lt;/p>
&lt;blockquote>
&lt;p>選用 Open Tracing 可能會是個不錯的選擇，大多數商業解決方案都已經支援 Open Tracing API 也因此我們可以輕易的在他們之間切換。&lt;/p>
&lt;/blockquote>
&lt;h3 id="application-performance-monitor">Application Performance Monitor&lt;/h3>
&lt;p>我們可以視為這是 Open Tracing 的一部分，他提供我們追蹤 Function Call 或者 API Call 的花費時間。在我的經驗中，一些商業解決方案像是 &lt;a href="https://www.datadoghq.com/">Datadog&lt;/a>, &lt;a href="https://newrelic.com/">NewRelic&lt;/a>、&lt;a href="https://scoutapm.com/">ScoutAPM&lt;/a> 和其他服務，都提供我們更多詳細的資訊來幫助我們可以追蹤效能上的問題。&lt;/p>
&lt;p>不過開源的專案像是 &lt;a href="https://www.elastic.co/apm">ElasticAPM&lt;/a> 就有比較多限制以及追蹤的資訊相對的簡單。&lt;/p>
&lt;blockquote>
&lt;p>在商業解決方案大多支援記憶體的追蹤而且對記憶體問題的處理非常有幫助，不過像是 ElasticAPM 就還在計畫中而沒有支援。&lt;/p>
&lt;/blockquote>
&lt;h3 id="time">時間&lt;/h3>
&lt;p>在我們分享經驗跟工具後，我們的導師點出了一個追蹤工具的關鍵點。&lt;/p>
&lt;p>當我們使用這些工具追蹤服務時，他大多是跟時間相關的。為了避免網路延遲，這些工具大多會選擇使用本地的時間當作時間戳記然後發送到追蹤伺服器上。&lt;/p>
&lt;p>這表示如果我們有兩台機器的時間是不同步的，我們就會得到一個錯誤的時間線從而導致我們在儀表板上看到的錯的資訊。&lt;/p>
&lt;p>舉例來說，我們有三個 API 呼叫（A =&amp;gt; B =&amp;gt; C）在這個追蹤內，其中一個 API 伺服器（B）有錯誤的本地時間。我們可能會發現 B 在時間線上早於 A，但是這跟實際上的順序是不一致的，這就可能造成我們無法準確的追蹤問題。&lt;/p>
&lt;h3 id="dashboard">儀表板&lt;/h3>
&lt;p>另外一個重要的點則是儀表板，我們想要在短時間內找到問題通常仰賴一個設計優良的儀表板去幫助開發者追蹤問題。&lt;/p>
&lt;p>這也是為什麼商業解決方案相對開源專案還成熟很多，而在自己搭建的方案中會選擇 ElasticSearch 來作為解決方案。&lt;/p>
&lt;p>建構一個強大的儀表板是不容易的，何況追蹤大多不是在產品開發中最優先的事項。&lt;/p>
&lt;p>這也是為什麼大多會偏向使用 SaaS 或者現有的開源方案。&lt;/p>
&lt;h2 id="technical-debt">技術債&lt;/h2>
&lt;p>這部分我們分享了我們在決定重構或者安排解決技術債的經驗。&lt;/p>
&lt;p>我想我們大多同意這沒有一個正確的解答，不過我們還是有一些方向可以遵循。&lt;/p>
&lt;h3 id="the-test">測試&lt;/h3>
&lt;p>為了解決技術債，我們大多會去重構我們的程式碼。而重構重程式碼就會需要透過測試來保證不會破壞任何東西。&lt;/p>
&lt;p>在我自己的經驗裡「規格」是很重要的。如果我們沒有正確的規格，測試也只會專注在錯誤的目標從而撰寫出一些沒有幫助的測試。&lt;/p>
&lt;h3 id="the-known-and-unknown-debt">已知跟未知的技術債&lt;/h3>
&lt;p>在工作中，我們通常不會有足夠的時間去撰寫一些理想的程式碼。這表示即使我們不想產生技術債，我們還是因為時間的限制被迫留下技術債。&lt;/p>
&lt;p>在這個情況，我們通常會加入 &lt;code>TODO&lt;/code> 作為註解表示我們需要去重構他，在另一方面，我們也可能撰寫了一些不恰當的程式而沒有自覺。&lt;/p>
&lt;p>為了解決技術債，我們大多同意去「主動」的消除他們，至於未知的部分也只能等待他被發現的時候再去處理。&lt;/p>
&lt;p>不過「追蹤」其實能夠幫助我們更快找到隱藏的問題，這剛好和我們前面討論的部分互相呼應。&lt;/p>
&lt;blockquote>
&lt;p>程式語言的版本太舊是另外一種情況會造成技術債。當程式語言被改善或者升級後，可能會放棄掉一些語法，而這可能會導致我們無法繼續使用舊的程式碼在新版本的程式語言中繼續使用。&lt;/p>
&lt;/blockquote>
&lt;h3 id="the-communicate">溝通&lt;/h3>
&lt;p>在最後，我們的導師基於他的經驗給了我們一些總結。&lt;/p>
&lt;p>造成技術在的原因通常是因為行銷或者產品團隊的需求，不過這些需求能幫助公司產生更多價值。&lt;/p>
&lt;p>如果我們希望有時間去處理技術債就需要跟他們解釋其中的優缺點。&lt;/p>
&lt;p>不過開發團隊的要求大多被拒絕，因為他們大多很難理解重構的重要性。&lt;/p>
&lt;p>為了解決這個問題，我們需要將資訊轉換成相同的單位讓其他團隊能夠比較從而理解。&lt;/p>
&lt;p>舉例來說，我們可以解釋重構將能夠改善 10% 未來在宣傳工能上的開發時間，這能夠讓行銷團隊更快的去推廣他們的新產品。不過這會需要付出 50% 的時間在這一次的開發上一併重構這個功能。&lt;/p>
&lt;p>如果行銷團隊認為這個價值高於繼續維持現在的方法去加入新的宣傳功能，那們我們就會得到他們的支持來進行重構。&lt;/p>
&lt;h2 id="conclusion">總結&lt;/h2>
&lt;p>實際上這次聚會比其他聚會還短了一些，不過在這幾次的聚會中我們大致上將我們希望討論的主題都討論了一遍。&lt;/p>
&lt;p>在這些聚會中，我認為我學到了兩個重要的事情。第一個是要嘗試去找到我們正在評估的架構中的關鍵或者目標，這再讓我們選擇適合的解決方案跟避免他的缺點影響我們系統佔了很重要的角色。&lt;/p>
&lt;p>另一個就是溝通技巧，實際上在我的工作中我是很重視的。不過我仍只有在跟工程師有嘗試做好，對於客戶或者非工程師的夥伴還是沒有辦法做得很好。在大多數情況下，我是希望 PM 能幫我做好這件事情，不過這個技能在我需要向非工程師解釋技術問題時就變得很重要。&lt;/p></content:encoded></item><item><title>做一個 Rails Form Helper 相容的 Form Object</title><link>https://blog.frost.tw/posts/2020/05/03/Build-a-Form-Helper-capable-Form-Object-in-Rails/</link><category>Rails</category><category>Ruby</category><category>Ruby on Rails</category><category>心得</category><pubDate>Sun, 03 May 2020 16:29:36 +0800</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2020/05/03/Build-a-Form-Helper-capable-Form-Object-in-Rails/</guid><description>&lt;p>當我們的 Rails 專案邊複雜的時候，Form Object 算是一個常見的方法。不過網路上的教學似乎大多都沒有能夠相容 Rails 的 Form Helper 的版本。&lt;/p>
&lt;p>所以我就開始思考，有沒有辦法法在比較少的修改下去支援 Form Helper 呢？&lt;/p></description><content:encoded>&lt;p>當我們的 Rails 專案邊複雜的時候，Form Object 算是一個常見的方法。不過網路上的教學似乎大多都沒有能夠相容 Rails 的 Form Helper 的版本。&lt;/p>
&lt;p>所以我就開始思考，有沒有辦法法在比較少的修改下去支援 Form Helper 呢？&lt;/p>
&lt;h2 id="common-form-object-implementation">常見的 Form Object 實作&lt;/h2>
&lt;p>為了要改善我們的 Form Object，我們至少要先知道目前在使用的原始版本。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="k">class&lt;/span> &lt;span class="nc">RegistrationForm&lt;/span>
&lt;span class="kp">include&lt;/span> &lt;span class="no">ActiveModel&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="no">Model&lt;/span>
&lt;span class="kp">include&lt;/span> &lt;span class="no">ActiveModel&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="no">Validations&lt;/span>
&lt;span class="kp">attr_accessor&lt;/span> &lt;span class="ss">:email&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">:password&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">:password_confirmation&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">initialize&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">user&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">params&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{})&lt;/span>
&lt;span class="vi">@user&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">user&lt;/span>
&lt;span class="k">super&lt;/span> &lt;span class="n">params&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="c1"># ...&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">attributes&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="ss">email&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="vi">@email&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="ss">password&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="vi">@password&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">save&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">unless&lt;/span> &lt;span class="n">valid?&lt;/span>
&lt;span class="vi">@user&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">assign_attributes&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">attributes&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="vi">@user&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">save&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>這是一個網路上很常見的 Form Object，基本上它提供了類似 Model 行為讓我們可以不用在 Controller 上有太多的修改。&lt;/p>
&lt;p>不過在 View 裡面的時候，我們的 Form Helper 就會變成一直需要設定 Method 和 URL 了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="o">&amp;lt;%=&lt;/span> &lt;span class="n">form_for&lt;/span> &lt;span class="vi">@form&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">method&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="ss">:post&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">url&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">users_path&lt;/span> &lt;span class="k">do&lt;/span> &lt;span class="o">|&lt;/span>&lt;span class="n">f&lt;/span>&lt;span class="o">|&lt;/span> &lt;span class="s">%&amp;gt;
&lt;/span>&lt;span class="s">&amp;lt;% # ... %&amp;gt;&lt;/span>
&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="sx">% end &lt;/span> &lt;span class="o">%&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="the-form-helper">關於 Form Helper&lt;/h2>
&lt;p>為了改善 Form Object 我開始去看 Form Helper 的原始碼。&lt;/p>
&lt;p>在 &lt;a href="https://github.com/rails/rails/blob/bdc581616b760d1e2be3795c6f0f3ab4b1e125a5/actionview/lib/action_view/helpers/form_helper.rb#L440">action_view/helpers/form_helper.rb#L440&lt;/a> 裡面，ActionView 會嘗試在我們傳入物件的時候用 &lt;code>apply_form_for_options!&lt;/code> 來處理。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="n">apply_form_for_options!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">record&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">object&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">options&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>而在 &lt;a href="https://github.com/rails/rails/blob/bdc581616b760d1e2be3795c6f0f3ab4b1e125a5/actionview/lib/action_view/helpers/form_helper.rb#L457-L474">&lt;code>apply_form_for_options!&lt;/code>&lt;/a> 方法中，我們可以發現他會設定 &lt;code>method&lt;/code> 和 &lt;code>url&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="n">action&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">method&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">object&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">respond_to?&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ss">:persisted?&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">object&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">persisted?&lt;/span> &lt;span class="p">?&lt;/span> &lt;span class="o">[&lt;/span>&lt;span class="ss">:edit&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">:patch&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="o">[&lt;/span>&lt;span class="ss">:new&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">:post&lt;/span>&lt;span class="o">]&lt;/span>
&lt;span class="c1"># ...&lt;/span>
&lt;span class="n">options&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="ss">:url&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">||=&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">options&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">key?&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ss">:format&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">polymorphic_path&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">record&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">format&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">options&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">delete&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ss">:format&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="k">else&lt;/span>
&lt;span class="n">polymorphic_path&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">record&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">{})&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>這表示如果我們的 Form Object 可以提供相同的介面給 Form Helper 的話，基本上我們就不用做什麼事情就能正確的設定 Method 和 URL 參數。&lt;/p>
&lt;h2 id="the-persisted">persisted? 方法&lt;/h2>
&lt;p>當 Form Helper 決定用 &lt;code>POST&lt;/code> 去產生新物件，或者用 &lt;code>PUT&lt;/code> 去更新一個現有物件時，他取決於 Model 的 &lt;code>persisted?&lt;/code> 方法。&lt;/p>
&lt;p>這表示當我們加入 &lt;code>persisted?&lt;/code> 方法到我們的 Form Object 之後，就能夠被偵測到。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="k">class&lt;/span> &lt;span class="nc">BaseForm&lt;/span>
&lt;span class="c1"># ...&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">initialize&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">record&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">params&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{})&lt;/span>
&lt;span class="vi">@record&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">record&lt;/span>
&lt;span class="k">super&lt;/span> &lt;span class="n">params&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">persisted?&lt;/span>
&lt;span class="vi">@record&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="vi">@record&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">persisted?&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>不過我們還可以再改善這個寫法，利用 ActiveSupport 提供的 &lt;a href="https://api.rubyonrails.org/classes/Module.html#method-i-delegate">&lt;code>delegate&lt;/code>&lt;/a> 來實作。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="k">class&lt;/span> &lt;span class="nc">BaseForm&lt;/span>
&lt;span class="c1"># ...&lt;/span>
&lt;span class="n">delegate&lt;/span> &lt;span class="ss">:persisted?&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">to&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="ss">:@record&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">allow_nil&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kp">true&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">initialize&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">record&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">params&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{})&lt;/span>
&lt;span class="vi">@record&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">record&lt;/span>
&lt;span class="k">super&lt;/span> &lt;span class="n">params&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="the-to_param-and-model_name">model_name 和 to_param&lt;/h2>
&lt;p>URL 是透過 &lt;a href="https://api.rubyonrails.org/classes/ActionDispatch/Routing/PolymorphicRoutes.html#method-i-polymorphic_path">&lt;code>polymorphic_path&lt;/code>&lt;/a> 生成的，他會使用 &lt;code>model_name&lt;/code> 和 &lt;code>to_param&lt;/code> 來產生路徑。&lt;/p>
&lt;p>所以我們可以像這樣在 Rails Console 嘗試：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&amp;gt; app.polymorphic_path&lt;span class="o">(&lt;/span>User.new&lt;span class="o">)&lt;/span>
&lt;span class="o">=&lt;/span>&amp;gt; &lt;span class="s2">&amp;#34;/users&amp;#34;&lt;/span>
&amp;gt; app.polymorphic_path&lt;span class="o">(&lt;/span>User.last&lt;span class="o">)&lt;/span>
&lt;span class="o">=&lt;/span>&amp;gt; &lt;span class="s2">&amp;#34;/users/1234&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>當我們加入 &lt;code>model_name&lt;/code> 和 &lt;code>to_param&lt;/code> 的 Delegate 到 Form Object 之後，我們就可以取得一樣的結果。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="n">delegate&lt;/span> &lt;span class="ss">:persisted?&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">:model_name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">:to_param&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">to&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="ss">:@record&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">allow_nil&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kp">true&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>再次確認效果：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&amp;gt; app.polymorphic_path&lt;span class="o">(&lt;/span>RegistrationForm.new&lt;span class="o">(&lt;/span>User.new&lt;span class="o">))&lt;/span>
&lt;span class="o">=&lt;/span>&amp;gt; &lt;span class="s2">&amp;#34;/users&amp;#34;&lt;/span>
&amp;gt; app.polymorphic_path&lt;span class="o">(&lt;/span>RegistrationForm.new&lt;span class="o">(&lt;/span>User.last&lt;span class="o">))&lt;/span>
&lt;span class="o">=&lt;/span>&amp;gt; &lt;span class="s2">&amp;#34;/users/1234&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>現在我們就有跟 Model 相同的介面可以使用。&lt;/p>
&lt;h2 id="load-attributes">讀取屬性&lt;/h2>
&lt;p>當我們可以讓 Form Helper 正確運作後，我們還是沒有辦法讓資料自動在編輯的情況下被自動載入。&lt;/p>
&lt;p>為了解決這個問題，我們可以調整我們的 &lt;code>initialize&lt;/code> 方法來讀取必要的欄位。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="k">class&lt;/span> &lt;span class="nc">RegistrationForm&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="no">BaseForm&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">initialize&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">record&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">params&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{})&lt;/span>
&lt;span class="n">attributes&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">record&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">slice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ss">:email&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">:password&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">merge&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">params&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">super&lt;/span> &lt;span class="n">record&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">params&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>另一種方法是透過 Attribute API 來支援這個功能，但是我們必須明確的在 Form Object 指定每個屬性。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="k">class&lt;/span> &lt;span class="nc">BaseForm&lt;/span>
&lt;span class="c1"># ...&lt;/span>
&lt;span class="kp">include&lt;/span> &lt;span class="no">ActiveModel&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="no">Attributes&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">initialize&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">record&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">params&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{})&lt;/span>
&lt;span class="vi">@record&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">record&lt;/span>
&lt;span class="n">attributes&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">record&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">attributes&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">slice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*.&lt;/span>&lt;span class="n">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">class&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">attribute_names&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">super&lt;/span> &lt;span class="n">attributes&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">merge&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">params&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="c1"># app/forms/registration_form.rb&lt;/span>
&lt;span class="k">class&lt;/span> &lt;span class="nc">RegistrationForm&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="no">BaseForm&lt;/span>
&lt;span class="n">attribute&lt;/span> &lt;span class="ss">:email&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">:string&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>不過我們必須注意 &lt;code>params&lt;/code> 的使用，Model 回傳的屬性會是 &lt;code>{&amp;quot;name&amp;quot; =&amp;gt; &amp;quot;Joy&amp;quot;}&lt;/code> 但是我們用 &lt;code>{name: &amp;quot;Joy&amp;quot;}&lt;/code> 的話，我們最後會得到混合字串和 Symbol 的 &lt;code>{&amp;quot;name&amp;quot; =&amp;gt; &amp;quot;Joy&amp;quot;, name: &amp;quot;Joy&amp;quot;}&lt;/code> 而且可能會讓我們在設定 Form Object 屬性時發生點問題。&lt;/p>
&lt;/blockquote>
&lt;h2 id="future-improve">後續改進&lt;/h2>
&lt;p>在目前的版本，我們必須將 Model 實體傳入到 Form Object 裡面，也許我們可以加入一些 DSL 去自動產生。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="c1"># Option 1&lt;/span>
&lt;span class="k">class&lt;/span> &lt;span class="nc">RegistrationForm&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="no">BaseForm&lt;/span>
&lt;span class="n">model_class&lt;/span> &lt;span class="s1">&amp;#39;User&amp;#39;&lt;/span>
&lt;span class="n">attribute&lt;/span> &lt;span class="ss">:name&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="c1"># Option 2&lt;/span>
&lt;span class="k">class&lt;/span> &lt;span class="nc">RegistrationForm&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="no">BaseForm&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="no">User&lt;/span>&lt;span class="o">]&lt;/span>
&lt;span class="n">attribute&lt;/span> &lt;span class="ss">:name&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>不過這樣的做法在比較複雜的系統是是需要考量的，不一定會是個好做法。&lt;/p>
&lt;p>舉例來說，我們已經在 Controller 或者其他物件讀取 &lt;code>User&lt;/code> 。但是我們無法將它傳給 Form Object 這表示我們的 Form Object 會永遠的在我們取用時讀取一次。
假設我們這是一個 Nested Form 的話，在這個情況還會導致 N+1 問題。&lt;/p>
&lt;p>這是另外一個主題需要去討論，當我們使用 Form Object 或者其他 Service Object 來重構的時候，我們可能減少了重複的程式碼卻造成我們的系統出現沒有被注意到的隱藏問題，或者讓整體變慢。&lt;/p>
&lt;h2 id="conclusion">總結&lt;/h2>
&lt;p>實際上我並沒有太說使用 Form Object 的經驗，不過我認為這應該是一個很常見的使用情境。
這個版本的 Form Object 還有很多限制，而且我也沒有完善考慮到所有的情況。&lt;/p>
&lt;p>不過我打算繼續在之後的工作中改進，並且嘗試保持單純。我認為並不是所有的情況都需要提供複雜的行為或者透過 Gem 來解決一些應該要很單純的情境。&lt;/p></content:encoded></item><item><title>複習 Rails 的 Autoloading 和 Reloading</title><link>https://blog.frost.tw/posts/2020/04/28/Review-the-Rails-Autoloading-and-Reloading/</link><category>Ruby</category><category>Rails</category><category>Autoloading</category><pubDate>Tue, 28 Apr 2020 00:31:53 +0800</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2020/04/28/Review-the-Rails-Autoloading-and-Reloading/</guid><description>&lt;p>在幾年前我有一篇文章討論 &lt;a href="https://blog.frost.tw/posts/2017/03/06/The-Rails-auto-reload-trap/">Autoloading&lt;/a> 的問題，這幾天剛好有同事在 Autoloading 和 Reloading 上也有類似的問題。&lt;/p>
&lt;p>所以我決定寫一篇文章來複習 Rails 5 和 6 的 Autoloading 的機制。&lt;/p></description><content:encoded>&lt;p>在幾年前我有一篇文章討論 &lt;a href="https://blog.frost.tw/posts/2017/03/06/The-Rails-auto-reload-trap/">Autoloading&lt;/a> 的問題，這幾天剛好有同事在 Autoloading 和 Reloading 上也有類似的問題。&lt;/p>
&lt;p>所以我決定寫一篇文章來複習 Rails 5 和 6 的 Autoloading 的機制。&lt;/p>
&lt;h2 id="why-autoloading">為什麼要 Autoloading&lt;/h2>
&lt;p>在開始討論 Autoloading 和 Reloading 之前，我想先花一點時間思考這個問題。&lt;/p>
&lt;p>像是 C、C++ 或者 Java 這類需要編譯的語言，他們通常不會需要 Autoload（自動載入）的功能，因為 Compiler（編譯器）已經需要的檔案包含在二進位檔案中。也因此我們經常會用 &lt;code>#include&lt;/code> 或 &lt;code>import&lt;/code> 來將需要的符號或者參照引用進來。&lt;/p>
&lt;p>如果像是 Ruby、PHP 或者 Node.js 這類在執行的時候才進行轉換的語言，通常表示我們的程式碼在執行前都不會被處理的。同時我們的程式碼也不會知道其他程式碼，直到我們用 &lt;code>require&lt;/code> 或者 &lt;code>include&lt;/code> 將他們從主程式引用進來。&lt;/p>
&lt;p>這兩種類型的語言實際上都是嘗試將程式碼分割為小檔案，不過對於直譯式語言來說如果我們將全部的檔案都引用的話，是無法跳過不需要的部分。&lt;/p>
&lt;p>在 Ruby 裡面有一個叫做 &lt;a href="https://ruby-doc.org/core-2.7.0/Module.html#method-i-autoload-3F">&lt;code>autoload&lt;/code>&lt;/a> 的關鍵字，它允許我們去定義「當常數（Constant）不存在時，要去讀取哪個指定的檔案。」來實現這個需求。&lt;/p>
&lt;p>這可能在我們載入大量程式碼的時候減少一些記憶體使用，不過我更相信 Autoloading 是用來幫助我們更容易的在大型專案中尋找到我們需要的程式碼。&lt;/p>
&lt;h2 id="the-require-method">require 方法&lt;/h2>
&lt;p>在我的 Code Review 裡面，我要求同事使用 &lt;code>require 'middleware/domain_rewriter'&lt;/code> 而不是 &lt;code>require_relative '../lib/middleware/domain_rewriter'&lt;/code> 去引用額外的 Middleware 在 Rails 的 &lt;code>config/application.rb&lt;/code>。&lt;/p>
&lt;p>不過實際上這並沒有正常運作， 在這個情況我們必須使用 &lt;code>require_relative&lt;/code> 才對。&lt;/p>
&lt;p>第一個問題是「為什麼我們可以在非相對的路徑使用 &lt;code>require&lt;/code> 呢？」&lt;/p>
&lt;p>在 Ruby 中，我們有一個全域變數叫做 &lt;code>$LOAD_PATH&lt;/code> 如果我們用 &lt;code>pp&lt;/code> 去顯示他的內容，我們會發現 Ruby 的安裝路徑是被放在裡面的。他是用來讓 Ruby 在我們嘗試引用某些東西時用來參考的搜尋路徑。&lt;/p>
&lt;p>如果我們有 &lt;code>Gemfile&lt;/code> 在專案目錄，那麼 Gem 安裝的路徑也會被加入到這個列表，這也是為什麼我們可以直接引用 Gem 而只需要將他們寫在 Gemfile 的理由。&lt;/p>
&lt;p>在我們知道 &lt;code>$LOAD_PATH&lt;/code> 提供給 &lt;code>require&lt;/code> 搜尋路徑後，我們無法直接在 &lt;code>config/application.rb&lt;/code> 去引用 &lt;code>lib/&lt;/code> 目錄的原因就非常的明顯了。&lt;/p>
&lt;p>基本上 Rails 是一個 Rack 為基礎的應用，因此通常會以 &lt;code>config.ru&lt;/code> 這個檔案作為起點啟動。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="c1"># frozen_string_literal: true&lt;/span>
&lt;span class="c1"># This file is used by Rack-based servers to start the application.&lt;/span>
&lt;span class="n">require_relative&lt;/span> &lt;span class="s2">&amp;#34;config/environment&amp;#34;&lt;/span>
&lt;span class="n">run&lt;/span> &lt;span class="no">Rails&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">application&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>這個檔案會繼續引用 &lt;code>config/environment.rb&lt;/code> 並且我們可以發現他引用了 &lt;code>config/application.rb&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="c1"># frozen_string_literal: true&lt;/span>
&lt;span class="c1"># Load the Rails application.&lt;/span>
&lt;span class="n">require_relative&lt;/span> &lt;span class="s2">&amp;#34;application&amp;#34;&lt;/span>
&lt;span class="c1"># Initialize the Rails application.&lt;/span>
&lt;span class="no">Rails&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">application&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">initialize!&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>很明顯的，在這裏 Rails 並沒有把 &lt;code>lib/&lt;/code> 放到 &lt;code>$LOAD_PATH&lt;/code> 裡面造成我們無法直接去引用裡面的檔案。&lt;/p>
&lt;h2 id="the-autoloading">Autoloading&lt;/h2>
&lt;p>既然我們知道我們可以用 &lt;code>require&lt;/code> 簡單的載入函式庫，但我們還是需要透過 &lt;code>require_relative&lt;/code> 去載入專案的程式碼，這在我們的程式碼增加時會讓人開始感到煩躁。&lt;/p>
&lt;p>從 Rails 6 之後開始使用 &lt;a href="https://github.com/fxn/zeitwerk">&lt;code>Zeitwerk&lt;/code>&lt;/a> 作為程式碼的載入器，我會用他來當作範例解釋，來減少我們討論後續複雜的行為。&lt;/p>
&lt;p>根據 Zeitwerk 的說明，我們可以看到載入的邏輯基本上如下：&lt;/p>
&lt;pre>&lt;code>lib/my_gem.rb -&amp;gt; MyGem
lib/my_gem/foo.rb -&amp;gt; MyGem::Foo
lib/my_gem/bar_baz.rb -&amp;gt; MyGem::BarBaz
lib/my_gem/woo/zoo.rb -&amp;gt; MyGem::Woo::Zoo
&lt;/code>&lt;/pre>&lt;p>這其實非常類似我們將檔案放在 &lt;code>app/controller&lt;/code> 或者 &lt;code>app/model&lt;/code> 下面的狀況，因為 Rails 會把這些目錄註冊給 Zeitwerk。&lt;/p>
&lt;blockquote>
&lt;p>某方面來說這也表示我們不一定需要在 &lt;code>app/controller&lt;/code> 目錄下使用 &lt;code>_controller&lt;/code> 作為檔案的結尾，不過我們通常不會使用這種難以區分用途的做法。&lt;/p>
&lt;/blockquote>
&lt;p>而 Zeitwerk 會使用 Ruby 的 &lt;code>autoload&lt;/code> 來載入這些 Class 也因此當我們設定 Autoload 路徑後，他會去掃描所有的檔案並把他登記到相關的 Class 上的 Autoload 列表。&lt;/p>
&lt;blockquote>
&lt;p>在我的記憶中舊版的 Rails 有他自己的 Autoloading 實作，會透過覆蓋掉部分 Kernel 的方法以及對 NameError 的捕捉來找到實際應該載入的檔案。&lt;/p>
&lt;/blockquote>
&lt;h2 id="the-reloading">Reloading&lt;/h2>
&lt;p>實際上我認為這個部分是大部分初級工程師嘗試自己用 &lt;code>require&lt;/code> 載入某些東西，但是修改某些檔案後就壞掉後，會覺得疑惑的地方。&lt;/p>
&lt;p>在 Zeitwerk 我們有 &lt;code>#enable_reloading&lt;/code> 選項可以讓我們能夠使用 &lt;code>#reload&lt;/code> 方法。在開發中 Reloading 功能是非常有幫助的，尤其是當我們修改了一些東西後不需要重新啟動伺服器。&lt;/p>
&lt;blockquote>
&lt;p>對編譯式的語言來說總會需要重新編譯和重新打開，不過還是有一些方法可以避免這件事情。&lt;/p>
&lt;/blockquote>
&lt;p>不過為什麼我們可以 &lt;code>#unload&lt;/code> 掉已經轉換過的程式碼呢？實際上這很看語言的特性，至少在 Ruby 裡面常數是一種被允許修改跟被移除的數值。&lt;/p>
&lt;p>當我們呼叫 &lt;code>#reload&lt;/code> 時，Zeitwerk 會 &lt;a href="https://github.com/fxn/zeitwerk/blob/806795d302840a7e96612b88ff45f231ea4318b0/lib/zeitwerk/loader.rb#L796">&lt;code>#unload&lt;/code>&lt;/a> 那些被載入的常數。同時會再將這些 Class 讀取一次，來將新的程式碼放到記憶體中。&lt;/p>
&lt;p>這也是為什麼當我們有一個頂層的常數被移除後，他下面的物件或模組也會被一起移除的原因。&lt;/p>
&lt;p>這其實是一個常見的錯誤，當我們在父物件的檔案同時定義了一個子物件並且在其他檔案呼叫時可能會出現錯誤。&lt;/p>
&lt;blockquote>
&lt;p>不過這可能不會在比較新的 Rails 發生，載入器通常會對他的父物件的檔案先嘗試載入一次。&lt;/p>
&lt;/blockquote>
&lt;p>在同樣的狀況下，類似的錯誤是我們定義了一個 &lt;code>API&lt;/code> 的命名空間在 Autoload 管理的目錄（像是 &lt;code>app/&lt;/code>）同時也定義在沒有被管理的目錄（像是 &lt;code>lib/&lt;/code>）裡面。&lt;/p>
&lt;p>當我們修改一些在 &lt;code>app/&lt;/code> 目錄下的檔案時，&lt;code>API&lt;/code> 會被移除，而 &lt;code>lib/&lt;/code> 定義的 &lt;code>API&lt;/code> 就永遠不會再被載入回來。&lt;/p>
&lt;p>這是因為 &lt;code>require&lt;/code> 認為這個檔案已經被載入，因此 Ruby 認為這個檔案不需要再次被載入，但他已經因為 Reloading 被移除了。&lt;/p>
&lt;p>以下是一個簡單的範例：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="c1"># frozen_string_literal: true&lt;/span>
&lt;span class="n">require_relative&lt;/span> &lt;span class="s1">&amp;#39;api&amp;#39;&lt;/span>
&lt;span class="n">pp&lt;/span> &lt;span class="n">defined?&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">API&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1"># =&amp;gt; &amp;#34;constant&amp;#34;&lt;/span>
&lt;span class="no">Object&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">send&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ss">:remove_const&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;API&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">require_relative&lt;/span> &lt;span class="s1">&amp;#39;api&amp;#39;&lt;/span>
&lt;span class="n">pp&lt;/span> &lt;span class="n">defined?&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">API&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1"># =&amp;gt; nil&lt;/span>
&lt;span class="nb">load&lt;/span> &lt;span class="s2">&amp;#34;api.rb&amp;#34;&lt;/span>
&lt;span class="n">pp&lt;/span> &lt;span class="n">defined?&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">API&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1"># &amp;#34;constant&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>require&lt;/code> 可以避免我們載入檔案兩次，不過 &lt;code>load&lt;/code> 並不會檢查，而 Zeitwerk 也覆蓋掉 &lt;a href="https://github.com/fxn/zeitwerk/blob/master/lib/zeitwerk/kernel.rb#L24">&lt;code>#require&lt;/code>&lt;/a> 方法來提供由 Zeitwerk 管理的類似的功能。&lt;/p>
&lt;p>基於以上的例子，我們大致上就能對 Rails 的 Autoloading 和 Reloading 有一個概念，並且幫助我們更合理的應用他們。&lt;/p>
&lt;h2 id="conclusion">總結&lt;/h2>
&lt;p>在最後，我還有一件事情要提一下。實際上 &lt;code>lib/&lt;/code> 也是被 Rails 管理的。不過他只能在 Rails 啟動之後使用，這也是為什麼我們無法在 &lt;code>config/application.rb&lt;/code> 使用的原因。&lt;/p>
&lt;blockquote>
&lt;p>在原始碼的&lt;a href="https://github.com/rails/rails/blob/758e4f8406e680a6cbf21b170749202c537a2576/railties/lib/rails/engine/configuration.rb#L53">這裏&lt;/a>定義了作為 Load Path 以及在&lt;a href="https://github.com/rails/rails/blob/c0d91a4f9da10094ccdb80e34d1be42ce1016c9a/railties/lib/rails/engine.rb#L570-L575">這裏&lt;/a>將他加入了 Load Path 中。&lt;/p>
&lt;/blockquote>
&lt;p>Autoloading 和 Reloading 是我們在開發時非常有用的工具，而 Zeitwerk 更讓我們非常容易的加入這個功能到專案中。如果你有專案不是使用 Rails 的話，我很推薦嘗試加入 Zeitwerk 並且在實踐中了解更多相關的知識。&lt;/p></content:encoded></item><item><title>TGONext: 資料庫變遷跟架構改變</title><link>https://blog.frost.tw/posts/2020/04/03/TGONext-Database-Migration-and-Architecture-Changing/</link><category>TGONext</category><category>架構</category><category>資料庫</category><category>心得</category><pubDate>Fri, 03 Apr 2020 21:14:56 +0800</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2020/04/03/TGONext-Database-Migration-and-Architecture-Changing/</guid><description>&lt;p>這次在開始討論關於架構的主題之前，我們的倒是讓我們提出一些問題。&lt;/p>
&lt;p>剛好在兩次聚會的期間，我的客戶因為一些錯誤的計畫讓 Migration 失敗了，所以我提出了關於在不停機的狀況下做 Migration 的規劃問題。&lt;/p></description><content:encoded>&lt;p>這次在開始討論關於架構的主題之前，我們的倒是讓我們提出一些問題。&lt;/p>
&lt;p>剛好在兩次聚會的期間，我的客戶因為一些錯誤的計畫讓 Migration 失敗了，所以我提出了關於在不停機的狀況下做 Migration 的規劃問題。&lt;/p>
&lt;h2 id="migrate-database-without-downtime">不停機的 Migration&lt;/h2>
&lt;p>實際上，在我的工作中大多客戶都是能接受停止一段時間來更新資料庫的新創公司類型。&lt;/p>
&lt;p>不過對於比較大的服務，將伺服器停止後進行更新基本上是很難被接受的。&lt;/p>
&lt;blockquote>
&lt;p>尤其是越來越多提供全球使用的服務，即使我們可以在某個區域暫停來停機，對於其他區域來說也不一定能被接受。&lt;/p>
&lt;/blockquote>
&lt;h3 id="the-mentee-s-experience">參與者的經驗&lt;/h3>
&lt;p>我認為包含我的大部分工程師都知道怎麼做，不過應該是有很多細節我們沒有預期到的。&lt;/p>
&lt;p>導師讓我們分享各自的經驗：&lt;/p>
&lt;ul>
&lt;li>不要去移除欄位&lt;/li>
&lt;li>避免框架的 Migration 移除東西&lt;/li>
&lt;li>複製並且重新命名資料表&lt;/li>
&lt;li>使用 Trigger 複製資料&lt;/li>
&lt;/ul>
&lt;p>其實大部分的做法我都在網路上看過，大家提出比較常見的作法就是避免去移除或者更改欄位名稱。&lt;/p>
&lt;h3 id="does-the-database-has-version-control">資料庫真的有版本控制嗎？&lt;/h3>
&lt;p>有些人提到因為在 Migiration 的過程中不能遺失資料，所以他們大多不刪除欄位或者在 Rollback （回滾）的時候刪除任何東西。也因此在討論的過程中，我們的導師點出了這樣一個問題。&lt;/p>
&lt;p>以原始碼來說我們可以跳到任一個版本而不會有任何副作用，這是因為原始碼大多是無狀態的。但是我們嘗試去改變資料庫的版本從 &lt;code>2020-03-28&lt;/code> 到 &lt;code>2020-01-01&lt;/code> 然後我們可能再次跳回 &lt;code>2020-03-28&lt;/code> 的版本而能讓所有跟 Rollback 之前完全一樣嗎？&lt;/p>
&lt;p>基本上這沒有一個準確的解答，大多會仰賴於我們的服務對這些資料的重視程度。不過在我們設計 Migration 的時候，確實應該要小心的選擇一個比較安全的做法。&lt;/p>
&lt;h3 id="the-performance-lost">效能損失&lt;/h3>
&lt;p>既然我們不會去刪除欄位，資料庫就會需要去讀取一個更大的 Row 來查詢東西而這可能會讓資料庫變慢。&lt;/p>
&lt;p>基本上這是因為 RDBMS 的資料庫大多是以 Row 為基礎來設計的才會有這樣的特性。而 NoSQL 通常以 Column 為基礎設計，因此 NoSQL 通常不會遇到這類問題。&lt;/p>
&lt;p>不過我們也有其他的選擇，像是透過修改重新命名資料表的方式來避免長成大表。先建立一個暫時的資料表套用變更後再去替換這個資料表。&lt;/p>
&lt;p>像是 GitHub 就有一個叫做 &lt;a href="https://github.com/github/gh-ost">gh-host&lt;/a> 的工具可以讓我們不用自己實作上面的流程。&lt;/p>
&lt;blockquote>
&lt;p>不過我們的導師也提醒我們，如果 Migration 的過程會花費很多時間我們可能會想要中途暫停，但是 &lt;code>gh-ost&lt;/code> 並不支援這樣的機制。&lt;/p>
&lt;/blockquote>
&lt;p>除了效能問題之外，我們也還有像是 Table-lock 和其他問題需要注意。&lt;/p>
&lt;blockquote>
&lt;p>在討論中我發現其實有很多資料庫的行為是我們已經知道的，但是在選擇方案時並沒有將這些東西連結起來去確認可能存在的風險。&lt;/p>
&lt;/blockquote>
&lt;h2 id="the-database-scalability">資料庫的擴充性&lt;/h2>
&lt;p>這算是前面問題的延伸，當我們討論到 RDBMS 和 NoSQL 有不同特性時，我們開始比較 MySQL/PostgreSQL 和 MongoDB 的設計。&lt;/p>
&lt;p>在 RDBMS 中我們通常會使用 B+ Tree 來建立 Index（索引），而我們的導師向我們提出問題：「為什麼 MongoDB 會選擇使用 B Tree 來建立索引？」&lt;/p>
&lt;p>為了加快查詢資料，其中一種方法是減少總查詢的筆數。在 RDBMS 我們通常會選擇使用 Shard（分片）或者 Partition（分區）來建立一個比較小的資料表子集合。&lt;/p>
&lt;p>在 B+ Tree 裡面，資料節點通常會連接著下一筆資料，這表示我們在 RDBMS 能有快速的範圍查詢。不過如果我們需要去建立一個 Shard 或者將資料切割到不同的資料庫，這反而變成一個讓 RDBMS 感到困難的問題，因為很難確定要將哪些資料節點放在一起切割出來同時還要考慮資料節點的連結關係。&lt;/p>
&lt;p>因為 MongoDB 使用了 B Tree，這表示可以非常容易的選出一個子樹就能切割，因為不需要擔心資料節點會連結在另一個子樹上的資料節點上。&lt;/p>
&lt;p>這種特性讓 MongoDB 更容易被拓展，但是同時缺點就包含了範圍查詢相對的慢，以及 Shard 機制可能因為某些原因頻繁的移動資料而造成 Disk I/O 上的壓力。&lt;/p>
&lt;blockquote>
&lt;p>這個討論其實給我了一些在未來建議其他人選用資料庫的靈感，每一個小的設計細節都會改變行為跟優缺點。&lt;/p>
&lt;/blockquote>
&lt;h2 id="the-architecture-changing">架構的改變&lt;/h2>
&lt;p>這其實是我們這次聚會預定討論的主題，我們的導師先讓我們分享一些當服務無法處理增加的請求時要怎麼做的想法。&lt;/p>
&lt;p>大致上歸納整理後，我們大概有這幾種方式：&lt;/p>
&lt;ul>
&lt;li>垂直升級 (像是增加記憶體、處理器)&lt;/li>
&lt;li>水平拓展 (增加更多同質的實體)&lt;/li>
&lt;li>加入快取&lt;/li>
&lt;li>加入隊列（Queue）&lt;/li>
&lt;li>增加限流機制（像是次數或者流量限制）&lt;/li>
&lt;li>將單機服務分割成不同的實體&lt;/li>
&lt;/ul>
&lt;p>接下來我們的導師讓我們分享何時會從其中一種模式換到另外一種，網路上有很多公司分享過他們的經驗，但是這些並不一定符合我們的情況。&lt;/p>
&lt;p>如同每一次的聚會，我們從討論每一種選擇的缺點開始。像是水平拓展雖然看似是一個不錯的選擇，但是假設我們有超過 300 台或者更多機器時，管理上是容易的嗎？進行改版時要花多久才能全部更新完畢？&lt;/p>
&lt;p>因此我們可能會想要合併或者減少我們所管理的總實體數量，我們的導師也讓我們思考一些使用 Microservice 的知名公司總共有多少微服務以及是否有一個管理數量的極限存在。&lt;/p>
&lt;p>我們也針對上面幾種模式討論各種選擇的優點跟缺點，這邊我選了幾個比較有趣的跟大家分享。&lt;/p>
&lt;blockquote>
&lt;p>在現實世界中我們大多不會只用一種模式，我覺得比較像是當作積木的感覺去組合或者分解來配合我們的業務需求。&lt;/p>
&lt;/blockquote>
&lt;h2 id="queue">Queue&lt;/h2>
&lt;p>這是我們討論比較多的部分，最開始我們是討論使用 Queue 的時機。&lt;/p>
&lt;p>舉例來說，如果我們有一些服務是非常要求即時回應的。那麼 Queue 的非同步特性可能會造成一些問題，而這樣的特性跟 Thread 是類似的。&lt;/p>
&lt;p>在現實中我們常常需要讓寫入資料庫的動作是依序執行的來避免 Race-Condition（競爭條件）也因此 Queue 通常會是依序執行的。&lt;/p>
&lt;p>另一方面，Queue 也通常會有一個容量的上限，如果我們接收了超過上限的請求就需要反過來阻塞使用者。&lt;/p>
&lt;p>這表示我們雖然可以透過使用 Queue 可以為資料庫爭取到緩衝，但同時也可能變成其他服務的瓶頸。&lt;/p>
&lt;blockquote>
&lt;p>這其實也符合在上一次聚會我的感想，不同的選項會有不同的缺點，而我們的工作是要小心地在這些選項中選擇一個恰當的方案。&lt;/p>
&lt;/blockquote>
&lt;h3 id="rabbitmq">RabbitMQ&lt;/h3>
&lt;p>我們也討論了幾個 Queue 服務的解決方案。RabbitMQ 是用 Erlang 所撰寫的，而 Erlang 有著能從失敗的 Process 恢復的特性。這表示在大多數情況下我們的 Queue 會需要兩倍的記憶體來確保能夠正確的恢復，因為我們有另一份備份在記憶體中，來確保失敗的 Process 可以被復原。&lt;/p>
&lt;h3 id="kafka">Kafka&lt;/h3>
&lt;p>我們的導師問我們，Kafka 是用 Java 寫的但是為什麼他跑得非常快？是什麼原因讓 Java 會慢？&lt;/p>
&lt;p>其中一個原因是 GC 會造成一些效能的問題，不過 Java 也提供了 &lt;code>Off-Heap&lt;/code> 的機制讓我們自己管理記憶體，因此 Kafka 能比正常狀況更快。&lt;/p>
&lt;p>而 Kafka 是由 Linkedin 所開發，主要專注在吞吐量（Throughput）上，這是因為對 Linkedin 來說吞吐量比較重要。我們的導師告訴我們，有些比較是沒有意義的因為他們嘗試比較同類型的服務，但是並沒有注意到這些服務想解決的問題不同。&lt;/p>
&lt;h2 id="region">區域&lt;/h2>
&lt;p>另一個有趣的討論是關於區域，在垂直升級的選項中哪個通常是難以升級的？通常是網路，也因此像是 AWS、GCP 和大多數大型的全球公司都會嘗試搭建他們自己的海纜或者機房在不同的國家。&lt;/p>
&lt;p>為了能夠在兩個區域高速交換資料，我們很難用購買 CPU、記憶體或者應䩞的方式改善。&lt;/p>
&lt;p>另一個問題是當我們有高可用性（High-Avalability）或者 Master-Master 架構的時候，如果我們其中一個資料中心停止運作的時候，有多少問題需要我們去解決？&lt;/p>
&lt;p>我們可能會有一些資料並沒有同步到另一個資料中心，假設主要的機房恢復的狀況下，要怎麼確保資料是一致的&lt;/p>
&lt;p>？以及我們主要的機房停止的狀況下，備援的機房是否有相同的硬體可以去支撐原本的請求呢？&lt;/p>
&lt;h2 id="conclusion">結論&lt;/h2>
&lt;p>在這次的聚會中我認為學到了一些關於選擇方案的技巧，在過去我經常很難去回答別人像是為什麼要使用 PostgreSQL 或者 MySQL 或是為什麼要使用 Ruby 這類問題。&lt;/p>
&lt;p>剛開始我認為這是因為我不夠專業的關係，不過我想原因可能是因為我並沒有去注意特性跟那些隱藏在功能後的細節。&lt;/p>
&lt;p>其實這是很好的機會去練習在缺點中去尋找更多資訊，我現在也嘗試改變我的習慣跟流程去實踐這個做法。&lt;/p></content:encoded></item><item><title>TGONext: 從缺點選擇架構</title><link>https://blog.frost.tw/posts/2020/03/15/TGONext-Choose-Architecture-by-Cons/</link><category>架構</category><category>微服務</category><category>資料庫</category><category>心得</category><category>TGONext</category><pubDate>Sun, 15 Mar 2020 03:02:32 +0800</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2020/03/15/TGONext-Choose-Architecture-by-Cons/</guid><description>&lt;p>這次聚會我們先簡單的回顧一下上一次的討論，然後就切換到了下一個主題。基於前一次聚會高併發的討論，我們模擬一個簡單的架構然後開始演進。&lt;/p></description><content:encoded>&lt;p>這次聚會我們先簡單的回顧一下上一次的討論，然後就切換到了下一個主題。基於前一次聚會高併發的討論，我們模擬一個簡單的架構然後開始演進。&lt;/p>
&lt;h2 id="the-trap-inside-the-suggested-way">建議方法中的陷阱&lt;/h2>
&lt;p>首先，我們有一個單體式的應用將 Web 伺服器跟資料庫都跑在同一台機器上。&lt;/p>
&lt;pre>&lt;code>+-----------------------+
|+---------------------+|
|| ||
|| Web Server ||
|| ||
|+---------------------+|
|+---------------------+|
|| ||
|| Database ||
|| ||
|+---------------------+|
+-----------------------+
&lt;/code>&lt;/pre>&lt;p>當請求量增加之後，我們可能會先把 Web 伺服器和資料庫分離到獨立的機器中。&lt;/p>
&lt;pre>&lt;code>+---------------------+ +---------------------+
| | | |
| Web Server &amp;lt;----------&amp;gt; Database |
| | | |
+---------------------+ +---------------------+
&lt;/code>&lt;/pre>&lt;p>當我們再次感覺到變慢的時候，我們可能會增加「快取伺服器」到我們的架構中。
像是增加一個快取伺服器到 Web 伺服器和資料庫之間。&lt;/p>
&lt;pre>&lt;code>+---------------------+ +---------------------+ +---------------------+
| | | | | |
| Web Server &amp;lt;------&amp;gt; Cache Server &amp;lt;------&amp;gt; Database |
| | | | | |
+---------------------+ +---------------------+ +---------------------+
&lt;/code>&lt;/pre>&lt;p>當我們的快取伺服器故障時，我們的服務會再重啟之後恢復正常嗎？&lt;/p>
&lt;blockquote>
&lt;p>實際上它可能不會在快取伺服器重啟後正常恢復，因為我們的快取伺服器遺失了所有資料同時 Web 伺服器依舊發出大量地請求到快取伺服器卻無法處理而轉送到資料庫上。&lt;/p>
&lt;/blockquote>
&lt;p>這就是所謂的「雪崩效應」，當一個服務發生故障時進而影響其他人變得不穩，最後造成整個服務停止。&lt;/p>
&lt;p>我們的導師建議我們在我們的團隊成員了解快取伺服器的優缺點和整個框架或套件使用後會如何運作之前，不要輕易的去增加快取伺服器。&lt;/p>
&lt;h2 id="will-microservice-rescue-us">微服務能解決這一切嗎？&lt;/h2>
&lt;p>如果我們想要避免雪崩效應，你可能會聯想到這幾年很熱門的微服務（Microservice）&lt;/p>
&lt;p>微服務是以「去中心化（Decentralize）」為目的設計的，這表示每個元件大多獨立運作而且很容易的重新部署。&lt;/p>
&lt;p>但是這其實有點太過理想，我們的服務經常會有一些相依於其他服務的情況。像是 Web 伺服器就經常的依賴於資料庫。&lt;/p>
&lt;p>這是另外一個關鍵我們需要在設計架構的時候去考慮的地方。&lt;/p>
&lt;p>目前在微服務中最熱門的相依問題解決方式是製作一種叫做「邊車（Sidecar）」的服務來控制每個元件間的溝通，因為邊車通常會知道其他服務的存活情況以及是否可以被連接，因此能夠回報跟管理他目前所負責的服務。&lt;/p>
&lt;p>我們的導師告訴我們架構大多是為了要解決某個問題才會被設計出來的。&lt;/p>
&lt;p>另一方面，我們如果要在微服務中找到問題，我們必須知道在這連續的呼叫中是在哪個服務停止的。這也表示微服務的系統需要有一個強大的紀錄追蹤機制來追蹤系統中的每一個事件。&lt;/p>
&lt;h2 id="which-is-paid-for-an-architecture-choice">選擇某種架構付出的代價&lt;/h2>
&lt;p>在我們學習了一些最近熱門的關鍵字之後，我們開始討論是否適合使用微服務。&lt;/p>
&lt;p>我們的導師告訴我們效能（Performance）涵蓋三個部分：&lt;/p>
&lt;ul>
&lt;li>吞吐量（Throughput）&lt;/li>
&lt;li>延遲（Latency）&lt;/li>
&lt;li>記憶體使用（Memory Footprint）&lt;/li>
&lt;/ul>
&lt;p>他們會互相影響，這表示如果我們選擇了其中一個作為目標其他的項目就會變成代價支付出去。&lt;/p>
&lt;p>在微服務系統中會將封包導向目標的服務，這也表示延遲會比其他架構還高得多。但是他的去中心化特性讓我們很容易的增加更多的元件來處理不斷增加的流量。&lt;/p>
&lt;p>微服務是透過延遲來交換更大的吞吐量，讓我們擁有處理大量請求的能力。&lt;/p>
&lt;p>也因此，如果我們的服務非常要求低延遲的話，微服務對我們的產品可能就不是一個好主意。&lt;/p>
&lt;h3 id="domain-driven-design">Domain-Driven Design&lt;/h3>
&lt;p>DDD 是我們討論的主題之一，我們的導師讓我們思考為什麼微服務變得熱門的同時 DDD 也同樣開始變得熱門。&lt;/p>
&lt;p>實際上我們可以發現他們相似的在意「領域（Domain）」，他們嘗試將讓每個服務都專注在某一個業務上。這和我們平常使用的 MVC 是非常不同的，不過這也說明了為什麼 DDD 的設計會更適合微服務的需要。&lt;/p>
&lt;p>另一方面，如果我們想要在公司中使用微服務。他通常取決於公司的規模或者在跨部門之前的溝通有些問題時，微服務可可能會是得不錯的選擇讓每個部門維護自己的服務。&lt;/p>
&lt;blockquote>
&lt;p>不過我們也需要注意過度的設計在我們自己的部門中，因為我們很可能只需要一個單體式的應用在我們的部門或公司。另一方面微服務也有不少需求需要滿足，如果在一個部門中擁有過多的為服務可能會造成另外的問題。&lt;/p>
&lt;/blockquote>
&lt;h2 id="the-data-consistency">資料的一致性&lt;/h2>
&lt;p>除了效能問題之外，資料在我們的架構中也是另一個重要的面向。每一個系統都會有他自己的狀態，而我們的服務則需要小心討論來決定使用強一致性或者最終一致性。&lt;/p>
&lt;p>舉例來說，一個銀行系統必須是強一致性的。至少你不會預期銀行在你存入一些錢之後，顯示並沒有這筆紀錄。卻在幾小時完成一致性的檢查後，才顯示出來。&lt;/p>
&lt;blockquote>
&lt;p>分散式系統其實也是一種資料一制的探討。&lt;/p>
&lt;/blockquote>
&lt;h2 id="the-database-evolution">資料庫的演進&lt;/h2>
&lt;p>在一個系統中，資料庫通常是最直接跟資料一致性有關聯的主題。因此我們的導師讓我們先比較 RDBMS（關連式資料庫）、NoSQL 和 NewSQL 的差異。&lt;/p>
&lt;h3 id="rdbms">RDBMS&lt;/h3>
&lt;p>在 RDBMS 之前還有一個叫做 Object-Orident Database （物件導向資料庫）的東西，雖然 PostgreSQL 有一部分的特性，但是我們並沒有繼續討論他。&lt;/p>
&lt;blockquote>
&lt;p>基本上這是我們討論演進的第一個階段，令一方面因為他算是非常常見因此我們並沒有在這個時候討論太多。&lt;/p>
&lt;/blockquote>
&lt;h3 id="nosql">NoSQL&lt;/h3>
&lt;p>在 NoSQL 的情況，我們透過將一致性作為代價來提高吞吐量。這也是為什麼 NoSQL 擁有很不錯的拓展性能讓我們非常簡單的去擴充。&lt;/p>
&lt;p>不過 NoSQL 必須在應用層實作很多東西，因為 RDBMS 幫我們處理了不少事情，但是 NoSQL 並沒有。&lt;/p>
&lt;blockquote>
&lt;p>另外一個特性是 NoSQL 是伴隨 SSD 的特性出現的，因此透過改變儲存資料的方式讓我們獲得高速的 Key-Value 資料存取能力。&lt;/p>
&lt;/blockquote>
&lt;h3 id="newsql">NewSQL&lt;/h3>
&lt;p>NewSQL 比較類似於 NoSQL 的反思，人們開始使思考 NoSQL 作為一個資料庫還有所不足。實際上有很多東西不應該在應用層實現，而應該讓資料庫幫助我們來完成。&lt;/p>
&lt;p>也因此開始開發 NewSQL 這種具備類似 RDBMS 的強一致性但是又有足夠的擴充能力的資料庫。&lt;/p>
&lt;blockquote>
&lt;p>目前 NewSQL 還沒有變的熱門，而且也沒有太多開放原始碼的解決方案。&lt;/p>
&lt;/blockquote>
&lt;h2 id="the-choose-of-database">資料庫的選擇&lt;/h2>
&lt;p>在前面的討論，我們的導師讓我們分享選用一個資料庫的觀點和理由。&lt;/p>
&lt;p>這裡有很多情況讓我們決定要選擇哪個資料庫：&lt;/p>
&lt;ul>
&lt;li>資料庫的功能&lt;/li>
&lt;li>使用的框架&lt;/li>
&lt;li>團隊成員&lt;/li>
&lt;li>客戶的偏好&lt;/li>
&lt;/ul>
&lt;p>實際上這沒有正確答案，就像前面在架構上的討論在不同的設計上會有不同的優缺點出現。&lt;/p>
&lt;h2 id="conclusion">總結&lt;/h2>
&lt;p>實際上這篇文章還是缺少了很多細節，不過太多東西我實在沒辦法一次性的記住。&lt;/p>
&lt;p>實際上在第一次聚會結束後我是有點擔心討論會止於一些計算或了解一些知識而已。&lt;/p>
&lt;p>不過這次聚會我們的導師讓我們學到了一些新的方法跟觀點能夠直接應用在工作上。&lt;/p>
&lt;p>最重要的是我們要在決定之前「找出計畫的缺點」並且重新檢視他，優點確實能給我們好處，但當系統發生問題的時候缺點才是我們需要面對的。&lt;/p>
&lt;p>也因此，我們需要去決定一個架構是對我們的產品傷害最小的，也就是大多數的缺點跟我們產品的需求是不會有太多衝突。&lt;/p></content:encoded></item><item><title>從 Functional Programming 重新思考程式設計</title><link>https://blog.frost.tw/posts/2020/03/14/Rethink-Programming-by-Functional/</link><category>Functional</category><category>C</category><category>Ruby</category><category>心得</category><pubDate>Sat, 14 Mar 2020 22:02:23 +0800</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2020/03/14/Rethink-Programming-by-Functional/</guid><description>&lt;p>因為時間的關係錯過了實體課程，不過利用 228 連假把&lt;a href="http://bit.ly/2IUIxWO">工作上用得到的函數式程式設計&lt;/a>這門課補完。&lt;/p>
&lt;p>在 Functional Programming（函數式程式設計）裡面有許多概念是可以提取出來應用的，如果你使用的語言有支援一定程度的特性的話，就能更做出更多的變化。&lt;/p></description><content:encoded>&lt;p>因為時間的關係錯過了實體課程，不過利用 228 連假把&lt;a href="http://bit.ly/2IUIxWO">工作上用得到的函數式程式設計&lt;/a>這門課補完。&lt;/p>
&lt;p>在 Functional Programming（函數式程式設計）裡面有許多概念是可以提取出來應用的，如果你使用的語言有支援一定程度的特性的話，就能更做出更多的變化。&lt;/p>
&lt;h2 id="the-flexible-design">更彈性的設計&lt;/h2>
&lt;p>以我工作上常用的 Ruby 作為例子我們可以用一個稍微極端的例子來看&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="c1"># 來源資料&lt;/span>
&lt;span class="n">users&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">[&lt;/span>
&lt;span class="o">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;Jimmy&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;male&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">180&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">72&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">70&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="o">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;Mary&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;female&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">160&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">50&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">65&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="o">[&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;Gary&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kp">nil&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">166&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">80&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">95&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="o">[&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;Bob&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;male&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">160&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">75&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">90&lt;/span>&lt;span class="o">]&lt;/span>
&lt;span class="o">]&lt;/span>
&lt;span class="c1"># Curry 化的 Function&lt;/span>
&lt;span class="n">gender_is&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">gender&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">item&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">gender&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">item&lt;/span> &lt;span class="p">}&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">curry&lt;/span>
&lt;span class="n">waistline_less_than&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">max&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">_args&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">waistline&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">max&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">waistline&lt;/span> &lt;span class="p">}&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">curry&lt;/span>
&lt;span class="n">health_users&lt;/span> &lt;span class="o">=&lt;/span>
&lt;span class="n">users&lt;/span>
&lt;span class="o">.&lt;/span>&lt;span class="n">filter&lt;/span> &lt;span class="k">do&lt;/span> &lt;span class="o">|&lt;/span>&lt;span class="n">user&lt;/span>&lt;span class="o">|&lt;/span>
&lt;span class="c1"># 利用語言特性跟 Curry 動態設定條件&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="n">user&lt;/span>
&lt;span class="k">when&lt;/span> &lt;span class="n">gender_is&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;male&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">then&lt;/span> &lt;span class="n">waistline_less_than&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">90&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">when&lt;/span> &lt;span class="n">gender_is&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;female&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">then&lt;/span> &lt;span class="n">waistline_less_than&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">80&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">else&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">_&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="kp">true&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="k">end&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">user&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="c1"># 因為 Bob 腰圍大於 90 因此被篩選掉&lt;/span>
&lt;span class="n">pp&lt;/span> &lt;span class="n">health_users&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>以 Ruby 來說 Matz（Ruby 語言之父）曾在他的&lt;a href="https://www.tenlong.com.tw/products/9789863473312">松本行弘談程式世界的未來&lt;/a>這本書中提過 Ruby 的一些語法是受到 Lisp 語言的影響，也因此在 Ruby 中保有了一些函數式語言的特性。&lt;/p>
&lt;p>實際上最實用的是 Ruby 在迭代器（Enumerator）提供了非常多函數式語言才有的方法，像是 &lt;code>map&lt;/code>、&lt;code>filter&lt;/code> 這類都能讓我們很輕鬆的篩選跟處理資料。&lt;/p>
&lt;h2 id="rethink-the-method-design">重新思考方法的設計&lt;/h2>
&lt;p>在函數式程式設計中，以課程裡面使用的 Elixir 作為例子，我們可以利用 Pattern Matching 的特性設計出像這樣的程式碼：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-elixir" data-lang="elixir">&lt;span class="n">defmodule&lt;/span> &lt;span class="nc">Server.Connection&lt;/span> &lt;span class="n">do&lt;/span>
&lt;span class="c1"># ...&lt;/span>
&lt;span class="n">def&lt;/span> &lt;span class="n">input&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;exit&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">socket&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="ss">:gen_tcp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">socket&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">def&lt;/span> &lt;span class="n">input&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;help&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">socket&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">socket&lt;/span> &lt;span class="o">|&amp;gt;&lt;/span> &lt;span class="nc">Server.Helper&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">print&lt;/span>
&lt;span class="n">def&lt;/span> &lt;span class="n">input&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">action&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">socket&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">socket&lt;/span> &lt;span class="o">|&amp;gt;&lt;/span> &lt;span class="nc">Server.Handler&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">process&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">action&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果是在我們熟悉的物件導向語言處理的話，就會變成類似像這樣的程式碼&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="k">class&lt;/span> &lt;span class="nc">Server&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="no">Connection&lt;/span>
&lt;span class="c1"># ...&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">input&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">action&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="n">action&lt;/span>
&lt;span class="k">when&lt;/span> &lt;span class="s2">&amp;#34;exit&amp;#34;&lt;/span> &lt;span class="k">then&lt;/span> &lt;span class="vi">@socket&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">close&lt;/span>
&lt;span class="k">when&lt;/span> &lt;span class="s2">&amp;#34;help&amp;#34;&lt;/span> &lt;span class="k">then&lt;/span> &lt;span class="no">Server&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="no">Helper&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">print_to&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="vi">@socket&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">else&lt;/span> &lt;span class="vi">@handler&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">process&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">action&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>有趣的地方在於，假設我們想要在 Ruby 裡面拓展更多「指令」的話就會讓 &lt;code>#input&lt;/code> 這個方法不斷地增長，最後我們會變成需要設計一個像是 Registry（註冊器）來管理這些指令。&lt;/p>
&lt;p>但是在支援 Pattern Matching 的函數式語言裡面，我們只需要將這些方法加以分類就可以很輕鬆的拓展出來，也因此像是在 Elixir 這類語言我們幾乎不需要使用到判斷式就能決定要做什麼，這也能讓程式碼在另一種形式上變得簡潔。&lt;/p>
&lt;blockquote>
&lt;p>以 Ruby 的語法檢查器 Rubocop 來說，一個方法基本上建議上只能有 10 ~ 15 行的內容，要符合一些最佳實踐的話通常會需要拆分很多方法跟物件來處理，也因此我常跟同事說我們應該試著在呼叫之前就做好判斷，讓每一個方法都明確知道自己該做些什麼。&lt;/p>
&lt;/blockquote>
&lt;h2 id="rethink-the-definition-of-state">重新思考狀態的定義&lt;/h2>
&lt;p>函數式語言之所以會被叫做 Functional 某方面來說也是跟數學非常有關係的，以數學的函式來說 &lt;code>f(x) = x + 1&lt;/code> 其實也只會有輸入跟輸出兩種情況，也因此在函數式語言比較難實現出狀態這樣的概念。&lt;/p>
&lt;p>如果我在 Ruby 想將一個資料（狀態）傳遞給下一個處理，在沒有應用物件的情況下就會需要像這樣寫：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="n">get_username&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">parse_json&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fetch&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">url&lt;/span>&lt;span class="p">)))&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>展開之後會像是這樣：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="n">response&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">fetch&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">url&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">parsed_json&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">parse_json&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">response&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">username&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_username&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">parsed_json&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>但實際上以物件導向的方式來處理的話我們會用 Instance Variable（實例變數）來保存狀態：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="k">class&lt;/span> &lt;span class="nc">User&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">initialize&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">url&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="vi">@url&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">url&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">username&lt;/span>
&lt;span class="n">parsed_json&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">fetch&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ss">:username&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">parsed_json&lt;/span>
&lt;span class="vi">@parsed_json&lt;/span> &lt;span class="o">||=&lt;/span> &lt;span class="no">JSON&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">parse&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">response&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">response&lt;/span>
&lt;span class="vi">@responsd&lt;/span> &lt;span class="o">||=&lt;/span> &lt;span class="no">Net&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="no">HTTP&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="vi">@url&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="no">User&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">new&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">url&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">username&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>透過這樣的方式使用者就能夠透過很簡單的方式直接的取得所需的資訊，而在 Elixir 中則會像這樣實現：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-elixir" data-lang="elixir">&lt;span class="n">defmodule&lt;/span> &lt;span class="nc">User&lt;/span> &lt;span class="n">do&lt;/span>
&lt;span class="n">def&lt;/span> &lt;span class="n">username&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">user&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">user&lt;/span> &lt;span class="o">|&amp;gt;&lt;/span> &lt;span class="nc">Map&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">fetch&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ss">:username&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">def&lt;/span> &lt;span class="n">load&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">url&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nc">HTTP&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">url&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">|&amp;gt;&lt;/span> &lt;span class="nc">JSON&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">parse&lt;/span>
&lt;span class="n">end&lt;/span>
&lt;span class="p">{&lt;/span>&lt;span class="ss">:ok&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">username&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nc">User&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">url&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">|&amp;gt;&lt;/span> &lt;span class="nc">User&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">username&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>因為沒有內部的狀態保存，所以通常會將狀態透過參數傳遞，雖然無法保存但是透過語言的特性依舊能夠恰當處理，甚至我們需要反思封裝狀態這件事情是否是在多數情況下「必要」的。&lt;/p>
&lt;p>有趣的是，我們平常享受 Ruby 的物件導向特性讓我們可以透過物件來保存狀態，但是在 CRuby 或者 mruby 每次處理也是需要將狀態當作參數傳遞進去的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="c1">// mruby
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="n">mrb_value&lt;/span> &lt;span class="nf">user_get_name&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mrb_state&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">mrb&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">mrb_value&lt;/span> &lt;span class="n">self&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">mrb_str_new_cstr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mrb&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;Username&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kt">void&lt;/span> &lt;span class="nf">init_user&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mrb_state&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">mrb&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">RClass&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">klass&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mrb_define_class&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mrb&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;User&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">mrb&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">object_class&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">mrb_define_method&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mrb&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">klass&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;username&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">user_get_name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">MRB_ARGS_NONE&lt;/span>&lt;span class="p">());&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>不過 C 語言不是函數式語言，方法頂多是一種指標而已。只是在非物件導向語言裡面，保存狀態通常都是透過參數傳遞。&lt;/p>
&lt;/blockquote>
&lt;p>像這樣去接觸不同的語言了且背後的設計是一件很有趣的事情，尤其是函數式語言在思考上跟物件導向語言差異很大的時候更能夠幫助我們反思為什麼要這樣設計，原本自己在物件導向語言的設計是否還有沒考慮到的地方。&lt;/p>
&lt;h2 id="impression">感想&lt;/h2>
&lt;p>第一次接觸 Elixir 跟函數式語言應該也是在一兩年前，也是因為課程的&lt;a href="https://taian.su/">泰安&lt;/a>老師在五倍紅寶石上課時介紹給我的。不過當時雖然也會寫 JavaScript 而且常常看到一些對於 Functional Programming 相關的文章，不過實際上對函數式程式設計還是處於一知半解的狀態。&lt;/p>
&lt;p>在課程中其實也有提到以 JavaScript 作為範例其實有點不適合，畢竟有一些特性跟功能以一個函數式語言來說還不太足夠。所以在上完這次的課程之後，原本寫起來覺得很卡的 Elixir 在正確理解一些正確的特性之後，就能很順利地使用。&lt;/p>
&lt;p>也趁著還有印象的時候趕快用 Elixir 和 Ruby 搭配寫了一款 &lt;a href="https://github.com/elct9620/elixir-mud">MUD&lt;/a> 類型遊戲練習，如果對寫 JavaScript 無法寫得乾淨有困擾或者想多善用一些語言特性，是很推薦試試看這門課程的。&lt;/p>
&lt;p>最後補上 MUD 遊戲製作中的畫面：&lt;/p>
&lt;p>&lt;img src="https://blog.frost.tw/images/2020-03-14-rethink-programming-by-functional/mud.gif" alt="MUD 有限狀態機">&lt;/p></content:encoded></item><item><title>重複利用的 Ansible Role 難題</title><link>https://blog.frost.tw/posts/2020/02/29/The-Reusable-Ansible-Role-Problem/</link><category>Ansible</category><category>DevOps</category><category>心得</category><category>Rails</category><category>Ruby on Rails</category><pubDate>Sat, 29 Feb 2020 17:59:46 +0800</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2020/02/29/The-Reusable-Ansible-Role-Problem/</guid><description>&lt;p>大概一年前左右，我開始製作一個 &lt;a href="https://www.ansible.com/">Ansible&lt;/a> 的 Playbook 來幫&lt;a href="https://5xruby.tw">五倍紅寶石&lt;/a>的客戶安裝環境。&lt;/p>
&lt;p>不過當我們的客戶增加之後，其實開始有點變的很難透過 Fork 的機制來管理不同客戶的 Playbook。&lt;/p>
&lt;p>這表示我必須先更新主要的 Playbook 然後再同步到每一個客戶的版本上，也因此我決定去把這些通用的部分拆成單獨的 Role 專案。&lt;/p></description><content:encoded>&lt;p>大概一年前左右，我開始製作一個 &lt;a href="https://www.ansible.com/">Ansible&lt;/a> 的 Playbook 來幫&lt;a href="https://5xruby.tw">五倍紅寶石&lt;/a>的客戶安裝環境。&lt;/p>
&lt;p>不過當我們的客戶增加之後，其實開始有點變的很難透過 Fork 的機制來管理不同客戶的 Playbook。&lt;/p>
&lt;p>這表示我必須先更新主要的 Playbook 然後再同步到每一個客戶的版本上，也因此我決定去把這些通用的部分拆成單獨的 Role 專案。&lt;/p>
&lt;h2 id="overview">概觀&lt;/h2>
&lt;p>目前的 Playbook 大致上是這樣的：&lt;/p>
&lt;pre>&lt;code>├── [1.0K] README.md
├── [ 96] group_vars
│   └── [1.2K] all.yml
├── [ 96] inventories
│   └── [ 309] local
├── [ 480] roles
│   ├── [ 96] 5xruby_user
│   ├── [ 96] application
│   ├── [ 96] compile_env
│   ├── [ 96] deploy_user
│   ├── [ 96] init
│   ├── [ 128] logrotate
│   ├── [ 160] nginx_with_passenger
│   ├── [ 96] node
│   ├── [ 160] postgresql_server
│   ├── [ 96] ruby
│   ├── [ 96] ssh
│   ├── [ 96] sudo
│   └── [ 128] yum_install_commons
└── [ 467] setup.yml
&lt;/code>&lt;/pre>&lt;p>當我們的客戶需要客製化他們的部署環境，我們會去 Fork 這份原始版本然後修改裡面的變數跟樣板。&lt;/p>
&lt;p>不過在更新的時候就很容易遇到因為修改差異造成的衝突。&lt;/p>
&lt;h2 id="target">目標&lt;/h2>
&lt;p>在 Ansible Galaxy 裡面提供了相依管理的功能，這讓我們可以透過製作 &lt;code>roles/requirements.yml&lt;/code> 來像像下面這樣管理：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-yml" data-lang="yml">- &lt;span class="k">src&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>https&lt;span class="p">:&lt;/span>//github.com/5xruby/ansible-ruby&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">version&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">0.1.0&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="k">src&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>https&lt;span class="p">:&lt;/span>//github.com/5xruby/ansible-nginx&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">version&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">0.1.0&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在我們執行 Playbook 之前，我們可以利用 &lt;code>ansible-galaxy install -r roles/requirements.yml&lt;/code> 來自動安裝對應的 Role，而且這能夠在 &lt;a href="https://github.com/ansible/awx">Ansible AWX&lt;/a>（或者 Ansible Tower）上面正常運作。&lt;/p>
&lt;p>看起來挺不錯的，不過實際上我遇到了一些問題。&lt;/p>
&lt;h2 id="nginx-modules">Nginx 模組&lt;/h2>
&lt;p>以 &lt;a href="https://rubyonrails.org/">Rails&lt;/a> 專案來說，我們有很多種網頁伺服器的選擇。&lt;/p>
&lt;p>如果我們選擇使用 &lt;a href="https://puma.io/">Puma&lt;/a> 的話，其實只需要將 Nginx 安裝並且設定為反向代理伺服器（Reverse Proxy）即可。&lt;/p>
&lt;p>但是我們決定使用 &lt;a href="https://www.phusionpassenger.com/">Passenger&lt;/a> 就必須將它編譯成一個 Nginx 模組。&lt;/p>
&lt;p>這表示假設我們希望能夠同時支援 Puma 和 Passenger 的話，新製作的 Nginx Role 需要包含關於 Passenger 的任務。&lt;/p>
&lt;p>我的第一個版本是利用 &lt;a href="https://docs.ansible.com/ansible/latest/modules/include_tasks_module.html">&lt;code>include_tasks&lt;/code>&lt;/a> 在 Passenger 被啟用的時候去增加額外的模組到 Nginx 上。&lt;/p>
&lt;p>但是假設我們未來要增加更多的 Nginx 模組，我們的 Nginx Role 會越變越大最後就跟現在的 Playbook 狀況一樣。&lt;/p>
&lt;h2 id="manual-dependencies">手動管理相依&lt;/h2>
&lt;p>在經過幾次嘗試之後，我找到一個還可以接受的方法來處理這個問題。&lt;/p>
&lt;ol>
&lt;li>產生一個內容為空陣列的 Fact 變數 &lt;code>nginx_module_options&lt;/code>&lt;/li>
&lt;li>遍歷 &lt;code>nginx_extar_modules&lt;/code> 陣列然後 &lt;code>import_role&lt;/code> 去執行相關的 Role&lt;/li>
&lt;li>再額外模組的原始碼下載後，將額外的編譯參數插入到 &lt;code>nginx_module_options&lt;/code> 這個 Fact 變數中&lt;/li>
&lt;/ol>
&lt;p>因此，在我們的 Playbook 裡面我們會像這樣設定相依：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="k">src&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>https&lt;span class="p">:&lt;/span>//github.com/5xruby/ansible-nginx&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">version&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">0.1.0&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="k">src&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>https&lt;span class="p">:&lt;/span>//github.com/5xruby/ansible-passenger&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">version&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">0.1.0&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>並且覆蓋 Nginx 的變數，增加 Nginx 模組的設定作為預設值在 &lt;code>group_vars/all.yml&lt;/code> 裡面套用到所有的 Web 節點上。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="k">nginx_extra_modules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;passenger&amp;#39;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>不過另外一個問題又緊接著解決了 Nginx 模組的問題出現。&lt;/p>
&lt;h2 id="the-role-dependencies">Role 的相依性&lt;/h2>
&lt;p>當我準備好 Nginx, Ruby, Node.js 跟其他部署 Rails 必要的 Role 後，我開始設定 Rails Role 的相依設定。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="k">dependencies&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="k">src&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>https&lt;span class="p">:&lt;/span>//github.com/5xruby/ansible-nginx&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="k">src&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>https&lt;span class="p">:&lt;/span>//github.com/5xruby/ansible-ruby&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="k">src&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>https&lt;span class="p">:&lt;/span>//github.com/5xruby/ansible-node&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="k">src&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>https&lt;span class="p">:&lt;/span>//github.com/5xruby/ansible-passenger&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>此時我執行我的 Playbook 去運行 Rails Role 的話，會從 Nginx Role 開始執行。&lt;/p>
&lt;p>這看起來沒什麼問題，不過我們會需要設定 &lt;code>nginx.conf&lt;/code> 並且將 &lt;code>root&lt;/code> 設定到 Rails 專案的 &lt;code>public&lt;/code> 目錄。&lt;/p>
&lt;p>如果 Nginx Role 在 Rails Role 之前執行，我們就會碰到 Nginx 啟動失敗的錯誤。&lt;/p>
&lt;blockquote>
&lt;p>我的第一個版本會透過 Nginx 來產生 &lt;code>root&lt;/code> 的目錄，並且設定好所有者跟使用者群組，但是這是有問題的。如果 &lt;code>deploy&lt;/code> 這個使用者是透過 Rails Role 來產生的話，就會發生因為還沒有產生好使用者而無法設定目錄擁有者的情況。&lt;/p>
&lt;/blockquote>
&lt;p>不過在釐清問題之後，這算是一個人為的設計失誤。&lt;/p>
&lt;p>「Nginx 真的是 Rails 的相依嗎？」&lt;/p>
&lt;p>如果我們使用 Puma 的話，我們可以把 Nginx 替換成任何反向代理伺服器，實際上我們並不需要依賴於 Nginx。&lt;/p>
&lt;h2 id="final-produce">最終成果&lt;/h2>
&lt;p>經過大概兩天的時間，最後終於完成了一個幾乎不太需要設定就能夠部署 Rails 伺服器的設計。&lt;/p>
&lt;pre>&lt;code>├── install.yml
├── group_vars
│ └── all.yml
├── inventory
├── playbooks
│ └── install-nginx.yml
│ └── install-postgres.yml
│ └── install-rails.yml
├── roles
│ └── requirements.yml
├── templates
└ ─── nginx.conf.j2
&lt;/code>&lt;/pre>&lt;p>基本上是非常簡單的，大多只需要使用 &lt;code>import_role: nginx&lt;/code> 這樣的語法去增加需要的 Role 即可。&lt;/p>
&lt;p>如果我們需要更多的客製化，只需要覆蓋掉原本的變數（像是 &lt;code>nginx_config_template&lt;/code>）並且將自訂的樣板放到 &lt;code>templates/nginx.conf.j2&lt;/code> 裡面。&lt;/p>
&lt;blockquote>
&lt;p>在這邊我只放了預設的 Nginx 設定檔在 Nginx Role 裡面，如果要啟用 Passenger 的話需要自己放一個 &lt;code>nginx.conf&lt;/code> 來設定。&lt;/p>
&lt;/blockquote>
&lt;h2 id="conclusion">結論&lt;/h2>
&lt;p>這算是一個很有趣的經驗來「解耦」一個部署腳本，作為一個工程師我們有很多規則可以去遵照來解耦程式碼。但是當你以一個維運的角度來看，要怎麼去製作一個可以重複利用跟管理的腳本呢？&lt;/p>
&lt;p>不過這個還是一個起步，我現在正在思考假設未來要升級的話該怎麼做。&lt;/p>
&lt;ul>
&lt;li>如何清理舊版本？&lt;/li>
&lt;li>如果資料庫要升級，是否需要部署新的伺服器？&lt;/li>
&lt;li>如果是用於製作 Cloud Image (像是 AMI）又該如何清理多餘的檔案？&lt;/li>
&lt;/ul>
&lt;p>DevOps 看起來似乎只要把工程師跟維運人員放在一起就可以做到，不過我認為要讓兩者能夠協作還是不容易的。&lt;/p></content:encoded></item><item><title>TGONext: 規劃高併發服務</title><link>https://blog.frost.tw/posts/2020/02/23/TGONext-The-plan-for-high-concurrency/</link><category>心得</category><category>TGONext</category><category>架構</category><pubDate>Sun, 23 Feb 2020 15:54:37 +0800</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2020/02/23/TGONext-The-plan-for-high-concurrency/</guid><description>&lt;p>昨天是 &lt;a href="https://next.tgonetworks.org/">TGONext&lt;/a> 的第一次聚會，在這個活動中我們會向台灣的一些高階主管學習。在開場結束後我們的導師 &lt;a href="https://blog.gcos.me/">Ant&lt;/a> 讓我們投票選出幾個想在這半年的時間內討論的題目。基本上我們預定討論四個主題，而「高併發」是我們的第一個主題。&lt;/p></description><content:encoded>&lt;p>昨天是 &lt;a href="https://next.tgonetworks.org/">TGONext&lt;/a> 的第一次聚會，在這個活動中我們會向台灣的一些高階主管學習。在開場結束後我們的導師 &lt;a href="https://blog.gcos.me/">Ant&lt;/a> 讓我們投票選出幾個想在這半年的時間內討論的題目。基本上我們預定討論四個主題，而「高併發」是我們的第一個主題。&lt;/p>
&lt;h2 id="what-is-high-concurrency">什麼是高併發&lt;/h2>
&lt;p>再開始的時候，我們的導師問了我們這個問題。&lt;/p>
&lt;blockquote>
&lt;p>要怎麼定義高併發？&lt;/p>
&lt;/blockquote>
&lt;p>基本上大家都是知道高併發簡單來說就是有大量使用者在使用我們服務的情況，不過要怎麼明確定義反而是從沒有仔細思考過的。&lt;/p>
&lt;p>不過定義上其實相對的單純，但是透過導師的引導我們開始思考更多東西。&lt;/p>
&lt;blockquote>
&lt;p>在短時間內能處理的請求就是併發，而這個短時間通常是以秒為單位。&lt;/p>
&lt;/blockquote>
&lt;p>基於這樣的定義，實際上最重要的事情就是&lt;/p>
&lt;blockquote>
&lt;p>我們需要確保我們的服務可以處理足夠的請求數否則就就沒有意義&lt;/p>
&lt;/blockquote>
&lt;h2 id="how-to-measure-the-concurrency">如何評估併發數&lt;/h2>
&lt;p>為了確保能處理大兩請求或者配合行銷團隊給我們的目標，我們需要正確的去測量我們的系統所能承受的併發數量，因此我們的導師請我們列出一些曾經用過或者聽過的工具。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://httpd.apache.org/docs/2.4/programs/ab.html">ab&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/wg/wrk">wrk&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/giltene/wrk2">wrk2&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://jmeter.apache.org/">JMeter&lt;/a>&lt;/li>
&lt;li>SaaS (提供類似功能的雲端服務)&lt;/li>
&lt;/ul>
&lt;p>因為這些工具其實還蠻常見的，我自己反而沒有在第一時間把他跟測量工具聯想起來。&lt;/p>
&lt;p>然後導師馬上問我們一個問題：「這些工具的結果是否會有差異？」&lt;/p>
&lt;p>我們基本上都沒有考慮過這個小細節，但是這卻對我們最後測量出來的結果很重要。&lt;/p>
&lt;p>舉例來說，像是 &lt;code>ab&lt;/code> 會在發出請求之前把所有的 Thread 產生好，再一次性的發送出去。這很容易造成我們取得比較差的成績，而且很可能不符合真實的使用情況。&lt;/p>
&lt;blockquote>
&lt;p>在測量併發能力的時候，我們需要注意是否符合真實世界的使用情況。&lt;/p>
&lt;/blockquote>
&lt;p>除此之外，還有一些東西需要在測試的時候小心處理。&lt;/p>
&lt;h3 id="the-test-machines-limit">硬體上的限制&lt;/h3>
&lt;p>假設我們想要模擬高併發請求在某一台機器上，但實際上為了達到這個併發量要產生的 Thread 數量已經超過機器的上限。那麼我們只會得到錯誤的結果，這時候我們可能就需要使用支援在多台機器上運作的工具，或者製作一些能控制工具的腳本來同時觸發某個測量工具在多台機器上面執行。&lt;/p>
&lt;h3 id="the-network-environment">網路環境&lt;/h3>
&lt;p>如果我們在 LAN 發出請求去測試，實際上發出去的請求跟壓力都會遠大於實際的情況。因此我們至少要將測試的機器部署在其他區域（Zone）並且考慮實際使用者所在的位置。&lt;/p>
&lt;blockquote>
&lt;p>另外一個被提到的地方是，我們在測試的是「能力」而不是「壓力」因此目的並不是為了要對伺服器施加壓力這兩種測試實際上是不太一樣的。&lt;/p>
&lt;/blockquote>
&lt;h3 id="the-toolss-calculator-method">工具的計算方式&lt;/h3>
&lt;p>在前面我們其實已經大致上討論過，但是導師還是特別將 &lt;code>wrk2&lt;/code> 提出來討論。因為有些工具並不是計算從請求發起到收到回應的這個時間差，這表示有些時候並不會完全符合真實的情況。&lt;/p>
&lt;p>另外，導師告訴我們 &lt;code>wrk2&lt;/code> 使用 &lt;a href="https://medium.com/@siddontang/the-coordinated-omission-problem-in-the-benchmark-tools-5d9abef79279">Coordinated Omission&lt;/a> 這個演算法，是相對接近真實世界的計算方式。&lt;/p>
&lt;h3 id="the-perfect-result">過度美好的結果&lt;/h3>
&lt;p>假設我們得到非常漂亮的結果，我們就需要去注意測試的方法跟工具。因為這表示我們可能在一些地方是我們沒有預期到的，因而提供了不同的結果給我們。&lt;/p>
&lt;h2 id="from-mau-to-qps">從 MAU 換算成 QPS&lt;/h2>
&lt;p>在現實世界中，QPS（每秒查詢次數）通常不是由開發團隊來決定的，他大多是仰賴於行銷團隊的目標或者老闆的計畫。&lt;/p>
&lt;p>這也表示我們通常只會得到 MAU（每月活躍用戶數）而不是一個明確的 QPS 數值。&lt;/p>
&lt;p>舉例來說，如果行銷團隊告訴我們下個月他們計畫讓每月活躍用戶成長到 100 萬人，至少要多少的 QPS 才能夠滿足行銷團隊的需求呢？&lt;/p>
&lt;p>經過短暫的討論跟推測，我們注意到了一些跟 Request 有關的線索。&lt;/p>
&lt;ul>
&lt;li>使用者並不會隨時在線上&lt;/li>
&lt;li>一個使用者的操作後面會有多個請求產生&lt;/li>
&lt;li>大部分的使用者會集中在特定的時間操作（Ex. 活動）&lt;/li>
&lt;/ul>
&lt;p>假設我們使用 80-20 法則來推斷有 80% 的使用者只會在 20% 的時間使用我們的服務。&lt;/p>
&lt;p>然後我們要定義每秒鐘使用者最大會產生的請求數，在這部分導師告訴我們從經驗上來看選擇「最常見的操作」並計算這個操作會產生的請求數會是一個比較合適的選擇。&lt;/p>
&lt;p>到此為止我們就獲得了有限的情報足以從 MAU 來計算 QPS 應有的數值。&lt;/p>
&lt;ul>
&lt;li>MAU: 100 百萬&lt;/li>
&lt;li>每秒使用者請求數: 每個動作 3 個 API Request&lt;/li>
&lt;li>活躍時間: 約集中在每天的 20% 時間內&lt;/li>
&lt;/ul>
&lt;p>所以我們就可以像這樣計算：&lt;/p>
&lt;blockquote>
&lt;p>(1 million * 3 API Request) / (30 * 0.2 * 86400) * 0.8 ~= 4.6 QPS&lt;/p>
&lt;/blockquote>
&lt;p>轉換成公式的話類似這樣：&lt;/p>
&lt;blockquote>
&lt;p>(每月活躍人數 * 請求數) / (一個月 * 20% 的時間 * 1 天 (以秒為單位)) * 80% 的使用者 ~= QPS&lt;/p>
&lt;/blockquote>
&lt;p>最後的結果遠低於我們預期的數字，但是他確實是基於數據而且有說服力的。&lt;/p>
&lt;p>因此，要達到目標我們設計的架構至少要允許每秒大於 4.6 的 QPS 才能夠滿足行銷團隊的需求。&lt;/p>
&lt;blockquote>
&lt;p>不過導師也提醒我們這個比例會因為不同情況而改變，但是我們可以透過網路上公開的報告來評估自己所在的產業或服務適合採取怎樣的比例配置。
2020/03/21 補充：根據導師的&lt;a href="https://blog.gcos.me/post/2020-03-11_how-software-architecture-meet-business-require-mau-sla-by-rps-slo/">文章&lt;/a>這邊的 QPS 應該是 RPS （每秒請求數量）比較準確，單個請求可能會產生多個查詢。&lt;/p>
&lt;/blockquote>
&lt;h2 id="onclusion">結論&lt;/h2>
&lt;p>這是我們第一部分的討論，雖然只花了一個半小時左右但是情報量其實已經非常的多。&lt;/p>
&lt;p>後面剩下的時間我們開始討論 SLI/SLO/SLA 和可用性造成的 QPS 下降，但是因為只剩下比較短的時間所以我們應該會在線上或者下次的聚會繼續討論，基本上我也會在討論完後稍微整理記錄下來。&lt;/p>
&lt;p>在這約兩小時跟導師和其他成員的討論後，我依舊認為在 TGONext 這個活動最重要的是跟導師學習他們在面對問題時的觀點。&lt;/p>
&lt;p>在這個高併發的討論中，我們從定義「高併發」到專注在技術上的「QPS」來檢視我們需要的目標，最後再將我們的經驗連結其他部門讓合作得以達成。&lt;/p>
&lt;p>這幾年不時會有「頭銜不重要」的說法出現，不過當你跟 TGONext 裡面的這些 CTO 或者其他高階人才學習後，你會發現我們跟他們的差別在於我們常常關注在錯誤的問題上，而且並不清楚該用什麼方法正確的處理。&lt;/p>
&lt;p>也因此我是很感謝 &lt;a href="https://tgonetworks.org/">TGONextworks&lt;/a> 提供這樣的機會給我們一個類似路標一樣的方向去學習更高階的技巧，而非因為自己在公司有個不錯的頭銜而自我滿足。&lt;/p></content:encoded></item></channel></rss>