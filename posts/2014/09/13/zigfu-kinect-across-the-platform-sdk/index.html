<!DOCTYPE html><html lang="zh-TW"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><title>Zigfu 跨平台的 Kinect SDK | 弦而時習之</title><meta name="theme-color" content="#EFEFEF"><meta name="author" content="蒼時弦也"><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name="description" content="之前和系上老師借了一個多學期的 Kinect 卻只有做完用 Mac 連接 Kinect 並且搭配 Unity3D 的功課，就一直沒有成果。暑假也即將結束，緊接而來的就是全力投入在畢業製作，不過在此之前，還是得先把答應老師的功課做完。雖然時間不足以製作一款遊戲，但是將 Zigfu 這款非常好用的工具使用介紹完整的說明，我想多少也算是能夠完成一部份的任務了！Zigfu 基本上是設計給 Web 使用的，"><meta name="keywords" content="遊戲,Kinect,Unity3D"><meta property="og:type" content="article"><meta property="og:title" content="Zigfu 跨平台的 Kinect SDK"><meta property="og:url" content="https://blog.frost.tw/posts/2014/09/13/zigfu-kinect-across-the-platform-sdk/"><meta property="og:site_name" content="弦而時習之"><meta property="og:description" content="之前和系上老師借了一個多學期的 Kinect 卻只有做完用 Mac 連接 Kinect 並且搭配 Unity3D 的功課，就一直沒有成果。暑假也即將結束，緊接而來的就是全力投入在畢業製作，不過在此之前，還是得先把答應老師的功課做完。雖然時間不足以製作一款遊戲，但是將 Zigfu 這款非常好用的工具使用介紹完整的說明，我想多少也算是能夠完成一部份的任務了！Zigfu 基本上是設計給 Web 使用的，"><meta property="og:locale" content="zh-TW"><meta property="og:image" content="https://user-image.logdown.io/user/52/blog/52/post/233228/7rGRv56mTYCE21bemCWe_%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-09-13%20%E4%B8%8B%E5%8D%883.01.19.png"><meta property="og:updated_time" content="2019-06-29T07:42:39.106Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Zigfu 跨平台的 Kinect SDK"><meta name="twitter:description" content="之前和系上老師借了一個多學期的 Kinect 卻只有做完用 Mac 連接 Kinect 並且搭配 Unity3D 的功課，就一直沒有成果。暑假也即將結束，緊接而來的就是全力投入在畢業製作，不過在此之前，還是得先把答應老師的功課做完。雖然時間不足以製作一款遊戲，但是將 Zigfu 這款非常好用的工具使用介紹完整的說明，我想多少也算是能夠完成一部份的任務了！Zigfu 基本上是設計給 Web 使用的，"><meta name="twitter:image" content="https://user-image.logdown.io/user/52/blog/52/post/233228/7rGRv56mTYCE21bemCWe_%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-09-13%20%E4%B8%8B%E5%8D%883.01.19.png"><link rel="publisher" href="https://plus.google.com/117236344655673213049"><meta property="fb:app_id" content="178355449110"><meta property="fb:pages" content="180666522388"><script type="application/ld+json">[
{
    "@context": "http://schema.org",
    "@type": "Blog",
    "name": "弦而時習之",
    "url": "https://blog.frost.tw",
    "image": "http://blog.frost.tw/icon-512.png",
    "description": "蒼時弦也的個人網誌，專注在前端、後端以及遊戲開發，大多使用 Ruby 和 Ruby on Rails 以及 Golang、JS 和 C 語言。",
    "sameAs": [
      "https://www.facebook.com/frost.tw/"
    ]
},
{
    "@context": "http://schema.org",
    "@type": "Person",
    "name": "蒼時弦也",
    "url": "https://blog.frost.tw",
    "sameAs": [
      "https://www.facebook.com/elct9620",
      "https://www.instagram.com/elct9620/",
      "https://twitter.com/elct9620",
      "https://plus.google.com/+%E8%92%BC%E6%99%82%E5%BC%A6%E4%B9%9F-plus",
      "https://www.linkedin.com/in/elct9620"
    ]
},
{
  "@context":"http://schema.org",
  "@type":"BlogPosting",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://blog.frost.tw/posts/2014/09/13/zigfu-kinect-across-the-platform-sdk/"
  },
  "headline":"Zigfu 跨平台的 Kinect SDK",
  "image": [
    
    "https://user-image.logdown.io/user/52/blog/52/post/233228/7rGRv56mTYCE21bemCWe_%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-09-13%20%E4%B8%8B%E5%8D%883.01.19.png",
    
    "http://blog.frost.tw/icon-512.png"
  ],
  "thumbnailUrl": "https://user-image.logdown.io/user/52/blog/52/post/233228/7rGRv56mTYCE21bemCWe_%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-09-13%20%E4%B8%8B%E5%8D%883.01.19.png", 
  "datePublished": "2014-09-12T20:02:00.000Z",
  "dateModified": "2019-06-29T07:42:39.106Z",
  "description":"之前和系上老師借了一個多學期的 Kinect 卻只有做完用 Mac 連接 Kinect 並且搭配 Unity3D 的功課，就一直沒有成果。暑假也即將結束，緊接而來的就是全力投入在畢業製作，不過在此之前，還是得先把答應老師的功課做完。雖然時間不足以製作一款遊戲，但是將 Zigfu 這款非常好用的工具使用介紹完整的說明，我想多少也算是能夠完成一部份的任務了！Zigfu 基本上是設計給 Web 使用的，因此目前支援是 JavaScript 和 Unity3D 兩款（Flash 過了半年依舊開發中⋯⋯）不過 Zigfu 卻替 Mac 使用者解決了一個問題，就是 OpenNI / OpenNI2 的安裝，沒有驅動就無法使用 Kinect 是 Mac 用戶的痛。不過很可惜的是，目前最新的 Mac 驅動只能順利與 Kinect 溝通一分鐘左右，之後就是當機。也因此，這系列的文章都是針對 Windows 所說明的，但是成品對 Mac 的支援是確定的，即使會當掉⋯⋯至於 Zigfu 大致上做了什麼呢？將驅動程式包裝起來，協助使用者安裝（Windows 使用者需要自己安裝驅動）並且提供 ZDK (SDK) 讓開發者可以用統一的界面，存取 Kinect（官方）、OpenNI、OpenNI2 的 Middleware。關於 OpenNI / OpenNI 2 的介紹，可以參考這篇文章。",
  "author": {
    "@type": "Person",
    "name": "蒼時弦也"
  },
  "publisher": {
    "@type": "Organization",
    "name": "蒼時弦也",
    "logo": "https://blog.frost.tw/icon-512.png"
  }
},
{
  "@context": "http://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
    "@type": "ListItem",
    "position": 1,
    "item": {
      "@id": "https://blog.frost.tw",
      "name": "弦而時習之 ",
      "image": "http://blog.frost.tw/icon-512.png"
    }
  },{
    "@type": "ListItem",
    "position": 2,
    "item": {
      "@id": "https://blog.frost.tw/posts/2014/09/13/zigfu-kinect-across-the-platform-sdk/",
      "name": "Zigfu 跨平台的 Kinect SDK",
      "image": "https://user-image.logdown.io/user/52/blog/52/post/233228/7rGRv56mTYCE21bemCWe_%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-09-13%20%E4%B8%8B%E5%8D%883.01.19.png"
    }
  }]
}
,
{
"@context": "https://schema.org",
  "@type": "Organization",
  "name": "蒼時弦也",
  "url": "https://blog.frost.tw",
  "logo": "https://blog.frost.tw/icon-512.png"
}
]</script><link rel="canonical" href="https://blog.frost.tw/posts/2014/09/13/zigfu-kinect-across-the-platform-sdk/"><link href="/icon-512.png" rel="icon"><link rel="alternate" href="/feed.xml" title="弦而時習之" type="application/rss+xml"><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--><link rel="stylesheet" href="/css/style.css" media="screen" type="text/css"><script async src="/js/turbolinks.js"></script></head><body><div id="fb-root" data-turbolinks-permanent></div><header id="header"><h1 id="sitename"><a href="/" class="hide-text logo--icon align-center">弦而時習之</a></h1><aside id="slogan" class="slogan align-center text-center"><h2 class="slogan__title">Aotokitsuruya</h2><p class="slogan__description">The Web is attracting me, so I start learning PHP, HTML, CSS and JavaScript. When I know about Ruby, I fall in love with it. Now, I working with my friend to design games using C++ and still learning web about Golang, Ruby and JavaScript. In the other side, I also be a designer, the reason why the web is attracted me.</p></aside></header><div id="wrapper"><article class="post article"><header class="article__header"><time datetime="2014-09-12T20:02:00.000Z" class="article__time--header">Sep.13</time><h1 class="article__title">Zigfu 跨平台的 Kinect SDK</h1></header><div class="article__entry"><p>之前和系上老師借了一個多學期的 Kinect 卻只有做完用 Mac 連接 Kinect 並且搭配 Unity3D 的功課，就一直沒有成果。<br>暑假也即將結束，緊接而來的就是全力投入在畢業製作，不過在此之前，還是得先把答應老師的功課做完。</p><p>雖然時間不足以製作一款遊戲，但是將 Zigfu 這款非常好用的工具使用介紹完整的說明，我想多少也算是能夠完成一部份的任務了！</p><hr><p>Zigfu 基本上是設計給 Web 使用的，因此目前支援是 JavaScript 和 Unity3D 兩款（Flash 過了半年依舊開發中⋯⋯）<br>不過 Zigfu 卻替 Mac 使用者解決了一個問題，就是 OpenNI / OpenNI2 的安裝，沒有驅動就無法使用 Kinect 是 Mac 用戶的痛。</p><blockquote><p>不過很可惜的是，目前最新的 Mac 驅動只能順利與 Kinect 溝通一分鐘左右，之後就是當機。<br>也因此，這系列的文章都是針對 Windows 所說明的，但是成品對 Mac 的支援是確定的，即使會當掉⋯⋯</p></blockquote><p>至於 Zigfu 大致上做了什麼呢？<br>將驅動程式包裝起來，協助使用者安裝（Windows 使用者需要自己安裝驅動）並且提供 ZDK (SDK) 讓開發者可以用統一的界面，存取 Kinect（官方）、OpenNI、OpenNI2 的 Middleware。</p><blockquote><p>關於 OpenNI / OpenNI 2 的介紹，可以參考<a href="https://viml.nchc.org.tw/blog/paper_info.PHP?CLASS_ID=1&amp;SUB_ID=1&amp;PAPER_ID=491" rel="external nofollow noopener noreferrer" target="_blank">這篇文章</a>。</p></blockquote><a id="more"></a><p>這篇文章會用 Unity3D 來解釋一些關於 Zigfu 的 ZDK 基本使用。<br>最基本的就是我們需要能透過 Zigfu 讀取到影像、深度、骨架等資料，才能夠繼續後續的開發與使用。</p><h3 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h3><p>首先，我們到官方網站的 <a href="https://zigfu.com/en/downloads/browserplugin/" rel="external nofollow noopener noreferrer" target="_blank">Plugin 下載頁面</a> 去下載 Plugin。<br>（Windows 用戶應該是不需要，至於使用的 Kinect 是 For Windows 還是 For Xbox 要注意驅動是否正確。）</p><p>完成之後，再到 <a href="https://zigfu.com/en/zdk/unity3d/" rel="external nofollow noopener noreferrer" target="_blank">Unity3D ZDK 下載頁面</a>下載適合 Unity3D 的 ZDK （是一個 Unitypackage 檔案，並且有含範例。）</p><p>之後在 Unity3D 開啟新專案，匯入 Custom Package 之後，就可以使用了。</p><p><strong>注意：因為 ZDK 是用 DLL 包裝的，所以你必須使用 Unity3D Pro 才能夠正常使用</strong></p><h3 id="了解-Zig-元件"><a href="#了解-Zig-元件" class="headerlink" title="了解 Zig 元件"></a>了解 Zig 元件</h3><p>如果有點開範例檔案，會發現每一個範例檔案都有一個叫做 <code>Zigfu</code> 的 GameObject 在場景上，而這個 <code>Zigfu</code> 物件，都附加了一個叫做 <code>Zig</code> 的 Script 在上面。</p><p>假設停用了 <code>Zigfu</code> 物件，那麼所有相關 Kinect 的功能都會失效，並且出現 <code>Failed load driver and middleware...</code> 這樣的錯誤。</p><p>那麼 <code>Zig</code> 這個 Script 做了些什麼呢？</p><figure class="highlight cs"><figcaption><span>Zig.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 略</span></span><br><span class="line">    <span class="keyword">public</span> ZigInputType inputType = ZigInputType.Auto;</span><br><span class="line">    <span class="comment">//public bool UpdateDepthmap = true;</span></span><br><span class="line">    <span class="comment">//public bool UpdateImagemap = false;</span></span><br><span class="line">    <span class="comment">//public bool UpdateLabelmap = false;</span></span><br><span class="line">    <span class="comment">//public bool AlignDepthToRGB = false;</span></span><br><span class="line">    <span class="keyword">public</span> ZigInputSettings settings = <span class="keyword">new</span> ZigInputSettings();</span><br><span class="line">    <span class="keyword">public</span> List&lt;GameObject&gt; listeners = <span class="keyword">new</span> List&lt;GameObject&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span> Verbose = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span> (<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> UNITY_WEBPLAYER</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">        Debug.LogError(<span class="string">"Depth camera input will not work in editor when target platform is Webplayer. Please change target platform to PC/Mac standalone."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        ZigInput.InputType = inputType;</span><br><span class="line">        ZigInput.Settings = settings;</span><br><span class="line">        <span class="comment">//ZigInput.UpdateDepth = UpdateDepthmap;</span></span><br><span class="line">        <span class="comment">//ZigInput.UpdateImage = UpdateImagemap;</span></span><br><span class="line">        <span class="comment">//ZigInput.UpdateLabelMap = UpdateLabelmap;</span></span><br><span class="line">        <span class="comment">//ZigInput.AlignDepthToRGB = AlignDepthToRGB;</span></span><br><span class="line">        ZigInput.Instance.AddListener(gameObject);</span><br><span class="line">true&#125;</span><br><span class="line"><span class="comment">// 略</span></span><br></pre></td></tr></table></figure><p>上面是節錄自 <code>Zig.cs</code> 這個檔案的內容，我們可以發現裡面對 <code>ZigInput</code> 設定了 <code>InputType</code> 跟 <code>Settings</code> 兩個數值。</p><p>在 Unity3D 裡面看到就會是像這樣：<br><img src="https://user-image.logdown.io/user/52/blog/52/post/233228/7rGRv56mTYCE21bemCWe_%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-09-13%20%E4%B8%8B%E5%8D%883.01.19.png" alt="螢幕快照 2014-09-13 下午3.01.19.png"></p><p>簡單來說 <code>Zig</code> 元件幫我們把「讀取方式」以及讀取的方式設定好了！</p><blockquote><p>在 InputType 裡面可以選擇 Auto / KinectSDK / OpenNI / OpenNI2 幾個選項，在預設的 Auto 狀況下，Zigfu 會自動依照 KinectSDK &gt; OpenNI2 &gt; OpenNI 的順序嘗試呼叫，當成功時就使用該驅動作為讀取 Kinect 資料的驅動。<br>Settings 裡面則會看到一些關於讀取資料的設定，像是是否要更新 Depth （深度資訊） 等等。</p></blockquote><p>最後，我們需要注意 <code>Awake</code> 方法的最後一行 <code>ZigInput.Instance.AddListener(gameObject)</code> 這一句程式碼。</p><blockquote><p>在程式開發慣例中 Instance 通常是指物件的實體（就 Zigfu 的設計上，應該是屬於<a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" rel="external nofollow noopener noreferrer" target="_blank">單例</a>的設計，簡單說就是只會存在一個。）</p></blockquote><p><code>gameObject</code> 在 Unity3D 通常是指自己本身，而 <code>AddListener</code> 在這邊指的是「當更新時也一併更新這個物件」的意思。</p><blockquote><p>Listener 基本上設計類似于<a href="https://zh.wikipedia.org/wiki/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F" rel="external nofollow noopener noreferrer" target="_blank">觀察者</a>這種慣例，在 Unity3D 就類似於 <code>Update</code> 的感覺，在 Zigfu 中選擇了自行實作，跟 Unity3D 分開處理。<br>某方面也算是比較恰當的做法，畢竟 Kinect 裡面有自己的硬體，跟 Unity3D 分離就可以不受玩家主機的硬體限制。</p></blockquote><h3 id="從-Kinect-讀取影像"><a href="#從-Kinect-讀取影像" class="headerlink" title="從 Kinect 讀取影像"></a>從 Kinect 讀取影像</h3><p>首先我們要在深入了解 <code>ZigInput</code> 的作用，我們可以從範例的 <code>ZigImageView.cs</code> 這個檔案了解到一些蛛絲馬跡。</p><figure class="highlight cs"><figcaption><span>ZigImageViewer.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 略</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Zig_Update</span>(<span class="params">ZigInput input</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        UpdateTexture(ZigInput.Image);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 略</span></span><br></pre></td></tr></table></figure><p>前面提到的 <code>AddListener</code> 動作中，每當 Kinect 更新畫面並且被 Zigfu 接收時，會做類似 Unity3dD 的 <code>Update</code> 動作，也就是上面這段程式碼所寫的 <code>Zig_Update</code> 方法。</p><p>從這段程式碼可以看到，如果我們需要讀取影像，可以從 <code>ZigInput</code> 拿到一個 <code>Image</code> 資料來使用。</p><blockquote><p>除了 <code>Image</code> 之外，我們還能拿到 <code>Depth</code> (深度) 以及 <code>Label Map</code> (標記)<br>不過 Label Map 在範例中是黑色的畫面，似乎也沒有人了解用途，因此就不多做討論。</p></blockquote><p>接下來，我們先產生新的場景（Scene / Ctrl + N）並且新增一個 Empty GameObject 用來放置 Zig 元件。</p><p><img src="https://user-image.logdown.io/user/52/blog/52/post/233228/yB4QZUyhRJC8zMc7IMgq_%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-09-13%20%E4%B8%8B%E5%8D%883.22.26.png" alt="螢幕快照 2014-09-13 下午3.22.26.png"></p><blockquote><p>產生好物件之後，就馬上把物件命名為 Zigfu 這會是一個好習慣，在中後期專案變大的時候，檔案跟物件沒有好好命名的話，就會碰到非常多問題。而團隊合作的時候更是明顯，因此別忘記修改物件名稱。</p></blockquote><p><img src="https://user-image.logdown.io/user/52/blog/52/post/233228/0CMHeh13QWi6FZjqn6wW_%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-09-13%20%E4%B8%8B%E5%8D%883.22.43.png" alt="螢幕快照 2014-09-13 下午3.22.43.png"></p><p>在 Zigfu 的 ZDK 匯入到 Unity3D 後，也已經自動對選單增加好所有可用的元件。<br>我們在 Script 類型的選件中選擇 Zig 就可以對 Zigfu 物件新增這個元件了！</p><p><img src="https://user-image.logdown.io/user/52/blog/52/post/233228/zmyH6trKQpKxGoQGnRnz_%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-09-13%20%E4%B8%8B%E5%8D%883.26.45.png" alt="螢幕快照 2014-09-13 下午3.26.45.png"></p><p>預設的 Zig 元件沒有開啟 Update Image 的選項，因此我們要自己勾選起來。<br>（上圖還是未勾選狀態）</p><p><img src="https://user-image.logdown.io/user/52/blog/52/post/233228/rHuuWqqOQOe2Fw8JrLt8_%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-09-13%20%E4%B8%8B%E5%8D%883.30.52.png" alt="螢幕快照 2014-09-13 下午3.30.52.png"></p><p>接著，我們會需要一個 Plane（平面）用來顯示 Kinect 讀取到的影像。</p><p><img src="https://user-image.logdown.io/user/52/blog/52/post/233228/Ae9OtZ2fQU6jz8FWUru0_%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-09-13%20%E4%B8%8B%E5%8D%883.32.26.png" alt="螢幕快照 2014-09-13 下午3.32.26.png"></p><p>接著調整 Plane（這邊我已經重新命名為 ImageViewer） 跟 Main Camera 讓平面可以順利被攝影機完整照到。</p><p><img src="https://user-image.logdown.io/user/52/blog/52/post/233228/E5ujAGCtTVOdJCErzlge_%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-09-13%20%E4%B8%8B%E5%8D%883.33.51.png" alt="螢幕快照 2014-09-13 下午3.33.51.png"></p><p>在開始之前，我們先用範例的 ImageViewer 元件來測試效果。<br>現在啟動遊戲的話，應該可以順利看到 Kinect 的 Camera 照到的影像被更新到 Plane 上。</p><blockquote><p>不過應該是上下顛倒的，不論是 WebCam 或者 Kinect 被照進去的狀況下都是這樣，旋轉一下就可以了！<br>影像有點暗是因為 3D 物件上面沒有打光，只要在場景上新增光源即可。</p></blockquote><h3 id="自定圖片讀取"><a href="#自定圖片讀取" class="headerlink" title="自定圖片讀取"></a>自定圖片讀取</h3><p>我們先將 <code>ZigImageViewer.cs</code> 的內容複製到一個新的檔案 <code>CustomImageViewer.cs</code> 並且以此為基礎修改出我們自己的「圖片讀取功能」</p><p><img src="https://user-image.logdown.io/user/52/blog/52/post/233228/Z5MfzZHuQiJIiz0dkmI8_%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-09-13%20%E4%B8%8B%E5%8D%884.11.40.png" alt="螢幕快照 2014-09-13 下午4.11.40.png"></p><p>並且把原本的 ImageViewer Panel 的 Script 改為 CustomImageViewer 來套用我們自己的讀取處理。<br>（這邊最好先執行看看，是否可以順利運作。要注意 <code>class ZigImageViewer</code> 得改為跟檔名一樣的 <code>class CustomImageViewer</code> 才會正常運作。）</p><p>修改之前，第一步是要了解範例的 ImageViewer 在做什麼。<br>下面會直接將解釋標記在程式碼中。</p><figure class="highlight cs"><figcaption><span>CustomImageViewer.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomImageViewer</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">true<span class="comment">// 指定繪製的目標（這邊直接畫在自身，所以不需要）</span></span><br><span class="line">true<span class="keyword">public</span> Renderer target;</span><br><span class="line">  <span class="comment">// 解析度設定，最高支援到 640x480 數值越低越順暢</span></span><br><span class="line">true<span class="keyword">public</span> ZigResolution TextureSize = ZigResolution.QQVGA_160x120;</span><br><span class="line">  <span class="comment">// 材質貼圖（用來存 Kinect 讀進來的影像）</span></span><br><span class="line">trueTexture2D texture;</span><br><span class="line">  <span class="comment">// 解析度資料</span></span><br><span class="line">trueResolutionData textureSize;</span><br><span class="line">true</span><br><span class="line">trueColor32[] outputPixels; <span class="comment">// 將影像轉換為像素陣列</span></span><br><span class="line">  </span><br><span class="line">true<span class="comment">// 讀取器的初始化</span></span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>	&#123;</span><br><span class="line">truetrue<span class="keyword">if</span> (target == <span class="literal">null</span>) &#123; <span class="comment">// 檢查是否有指定目標</span></span><br><span class="line">truetruetruetarget = renderer; <span class="comment">// 沒有的話就設定為自己</span></span><br><span class="line">truetrue&#125;</span><br><span class="line">    <span class="comment">// 將讀取的解析度轉換為解析度資料（後面會用來畫在材質上）</span></span><br><span class="line">truetruetextureSize = ResolutionData.FromZigResolution(TextureSize);</span><br><span class="line">    <span class="comment">// 產生新的 2D 材質（用剛剛轉換的解析度資料）</span></span><br><span class="line">truetruetexture = <span class="keyword">new</span> Texture2D(textureSize.Width, textureSize.Height);</span><br><span class="line">truetrue<span class="comment">// 設定材質的顯示方式（ Clamp 是填滿，另一個 Repeat 則是重複貼滿 ）</span></span><br><span class="line">    texture.wrapMode = TextureWrapMode.Clamp;</span><br><span class="line">    <span class="comment">// 設定 Plane 的材質為剛剛新增的材質</span></span><br><span class="line">truetruerenderer.material.mainTexture = texture;</span><br><span class="line">    <span class="comment">// 產生一組可以儲存影像像素資料的陣列</span></span><br><span class="line">truetrueoutputPixels = <span class="keyword">new</span> Color32[textureSize.Width * textureSize.Height];</span><br><span class="line">    <span class="comment">// 告訴 Zigfu 當畫面更新時要呼叫這個原件做更新處理</span></span><br><span class="line">truetrueZigInput.Instance.AddListener(gameObject);</span><br><span class="line">true&#125;</span><br><span class="line">true</span><br><span class="line">  <span class="comment">// 更新材質</span></span><br><span class="line">  <span class="comment">// 接收的是一個 ZigImage 資料</span></span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">UpdateTexture</span>(<span class="params">ZigImage image</span>)</span></span><br><span class="line"><span class="function"></span>	&#123;</span><br><span class="line">  	<span class="comment">// 讀取原始的影像資料（ Zigfu 會傳回像素陣列 ）</span></span><br><span class="line">truetrueColor32[] rawImageMap = image.data;</span><br><span class="line">    <span class="comment">// 將陣列換算成 2D 圖像的前置準備</span></span><br><span class="line">    <span class="comment">// 後面會詳細解釋這個部分</span></span><br><span class="line">truetrue<span class="keyword">int</span> srcIndex = <span class="number">0</span>;</span><br><span class="line">truetrue<span class="keyword">int</span> factorX = image.xres / textureSize.Width;</span><br><span class="line">truetrue<span class="keyword">int</span> factorY = ((image.yres / textureSize.Height) - <span class="number">1</span>) * image.xres;</span><br><span class="line">   	</span><br><span class="line">truetrue<span class="comment">// 反轉 Y 軸（因為讀取到的影響一開始是左右相反的，需要再轉回來一次）</span></span><br><span class="line">truetrue<span class="keyword">for</span> (<span class="keyword">int</span> y = textureSize.Height - <span class="number">1</span>; y &gt;= <span class="number">0</span>; --y, srcIndex += factorY) &#123;</span><br><span class="line">truetruetrue<span class="keyword">int</span> outputIndex = y * textureSize.Width;<span class="comment">// 輸出影像的陣列位置</span></span><br><span class="line">truetruetrue<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; textureSize.Width; ++x, srcIndex += factorX, ++outputIndex) &#123;</span><br><span class="line">truetruetruetrueoutputPixels[outputIndex] = rawImageMap[srcIndex]; <span class="comment">// 將像素資料複製到輸出影像</span></span><br><span class="line">truetruetrue&#125;</span><br><span class="line">truetrue&#125;</span><br><span class="line">truetruetexture.SetPixels32(outputPixels); <span class="comment">// 更新材質的像素資料</span></span><br><span class="line">truetruetexture.Apply(); <span class="comment">// 套用像素資料（材質內容被更新）</span></span><br><span class="line">true&#125;</span><br><span class="line">true</span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">Zig_Update</span>(<span class="params">ZigInput input</span>)</span></span><br><span class="line"><span class="function"></span>	&#123;</span><br><span class="line">truetrueUpdateTexture(ZigInput.Image);</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這邊會解釋兩個東西，一個是 Renderer (渲染器) 另一個是陣列轉為 2D 坐標的方法。</p><blockquote><p>Renderer 基本上會附加在每一個 Unity3D 上「可以被看到」的物件，他用來處理材質球跟材質如何繪製到模型上。<br>也因此，一旦 Renderer 被關掉，就無法看到物件，這邊用程式的方式設定材質球。</p></blockquote><p>至於陣列轉換為 2D 坐標的方法，其實就是非常簡單的數學邏輯。</p><p>假設有一個 10px 乘以 10px 的影像，那麼他就會有 10 * 10 = 100 個像素。<br>那麼第 11 個像素的坐標在哪裡呢？可以用下面的方式推算出來。</p><blockquote><p>位置 = (y * 寬) + x</p></blockquote><p>所以說 11 要先除以 10 會得到餘數 1 接著用 11 剪掉 1 就得到一個可以被「寬」整除的值，都計算完畢後，就可以知道第 11 個像素位置在 x = 0, y = 1 的位置（註：陣列中是從 0 ~ 99 所以算完會變成 0,1 的坐標）</p><p>多想幾次就會理解其中的原理了！</p><p>接下來，我們對 <code>UpdateTexture</code> 方法做一些小修改，讓畫面變成黑白的灰階畫面。</p><figure class="highlight cs"><figcaption><span>CustomImageViewer.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 略</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">UpdateTexture</span>(<span class="params">ZigImage image</span>)</span></span><br><span class="line"><span class="function"></span>	&#123;</span><br><span class="line">truetrueColor32[] rawImageMap = image.data;</span><br><span class="line">truetrue<span class="keyword">int</span> srcIndex = <span class="number">0</span>;</span><br><span class="line">truetrue<span class="keyword">int</span> factorX = image.xres / textureSize.Width;</span><br><span class="line">truetrue<span class="keyword">int</span> factorY = ((image.yres / textureSize.Height) - <span class="number">1</span>) * image.xres;</span><br><span class="line"></span><br><span class="line">truetrueColor buffer;</span><br><span class="line">    <span class="keyword">byte</span> grayscaleByte;</span><br><span class="line">truetrue<span class="comment">// invert Y axis while doing the update</span></span><br><span class="line">truetrue<span class="keyword">for</span> (<span class="keyword">int</span> y = textureSize.Height - <span class="number">1</span>; y &gt;= <span class="number">0</span>; --y, srcIndex += factorY) &#123;</span><br><span class="line">truetruetrue<span class="keyword">int</span> outputIndex = y * textureSize.Width;</span><br><span class="line">truetruetrue<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; textureSize.Width; ++x, srcIndex += factorX, ++outputIndex) &#123;</span><br><span class="line">truetruetruetruebuffer = <span class="keyword">new</span> Color(rawImageMap[srcIndex].r, rawImageMap[srcIndex].g, rawImageMap[srcIndex].b, rawImageMap[srcIndex].a);</span><br><span class="line">        grayscaleByte = (<span class="keyword">byte</span>)buffer.grayscale;</span><br><span class="line">truetruetruetrueoutputPixels[outputIndex] = <span class="keyword">new</span> Color32(grayscaleByte, grayscaleByte, grayscaleByte, (<span class="keyword">byte</span>)rawImageMap[srcIndex].a);</span><br><span class="line">truetruetrue&#125;</span><br><span class="line">truetrue&#125;</span><br><span class="line">truetruetexture.SetPixels32(outputPixels);</span><br><span class="line">truetruetexture.Apply();</span><br><span class="line">true&#125;</span><br><span class="line"><span class="comment">// 略</span></span><br></pre></td></tr></table></figure><p>首先，先增加 <code>Color buffer</code> 跟 <code>byte grayscaleByte</code> 方便處理。</p><blockquote><p>grayscale 只在 Color 下可以使用，而 Color32 則沒有這個功能，因此需要先手動將 Color32 轉為 Color</p></blockquote><p>接著 <code>buffer = new Color(rawImageMap[srcIndex].r, rawImageMap[srcIndex].g, rawImageMap[srcIndex].b, rawImageMap[srcIndex].a);</code> 基於拿到的顏色產生一個新的 Color。<br>因為 Color32 需要用 byte 指定顏色，因此我們用 <code>grayscaleByte = (byte)buffer.grayscale;</code> 將灰階化的數值轉為 byte 方便使用。</p><p>最後調整原本複製像素的方式，改為 <code>outputPixels[outputIndex] = new Color32(grayscaleByte, grayscaleByte, grayscaleByte, (byte)rawImageMap[srcIndex].a);</code> 將一個灰階版本的像素複製進去。</p><p>現在，執行遊戲的話就可以看到灰階的畫面。</p><p>這篇文章就到此告一段落，至於 Depth 跟 Label Map 的使用方式，基本上是一樣的。目前學習的東西用一般的 WebCam 也能做到，下一篇文章會討論關於骨架的使用。</p><footer class="article__footer"><div class="text-center"><div class="fb-share-button" data-href="https://blog.frost.tw/posts/2014/09/13/zigfu-kinect-across-the-platform-sdk/" data-layout="button_count"></div></div><p align="center"><a href="https://ko-fi.com/J3J78093" target="_blank" rel="external nofollow noopener noreferrer"><img height="36" style="border:0;height:36px" src="https://az743702.vo.msecnd.net/cdn/kofi5.png?v=0" border="0" alt="Buy Me a Coffee at ko-fi.com"></a></p><iframe scrolling="no" frameborder="0" style="display:block;margin:0 auto;height:212px" src="https://button.like.co/in/embed/elct9620/button?referrer=https://blog.frost.tw/posts/2014/09/13/zigfu-kinect-across-the-platform-sdk/"></iframe><ul class="article__tag-list"><li class="article__tag-list-item"><a class="article__tag-list-link" href="/tags/Kinect/">Kinect</a></li><li class="article__tag-list-item"><a class="article__tag-list-link" href="/tags/Unity3D/">Unity3D</a></li><li class="article__tag-list-item"><a class="article__tag-list-link" href="/tags/遊戲/">遊戲</a></li></ul></footer></div></article><div class="adv"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-2844969736316510" data-ad-slot="5530952976" data-ad-format="auto"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><section id="comment" class="comment-box"><h1 class="comment-box__title">留言</h1><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a rel="nofollow" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section></div><footer id="footer"><div id="copyright">&copy;2013 <a href="https://plus.google.com/117236344655673213049?rel=author" target="_blank" rel="external nofollow noopener noreferrer">蒼時弦也</a>. All right reversed.</div></footer><script type="text/javascript">window.disqus_shortname="revo-skill-frost",function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+window.disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5TQLRN" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><script>!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="//www.googletagmanager.com/gtm.js?id=GTM-5TQLRN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")</script><script>window.fbAsyncInit=function(){FB.init({appId:"178355449110",xfbml:!0,version:"v2.12"}),FB.AppEvents.logPageView()},function(e,n,t){var o,s=e.getElementsByTagName(n)[0];e.getElementById(t)||((o=e.createElement(n)).id=t,o.src="https://connect.facebook.net/zh_TW/sdk.js",o.async=!0,s.parentNode.insertBefore(o,s))}(document,"script","facebook-jssdk")</script><script src="/js/app.js"></script><div class="loading"></div></body></html>