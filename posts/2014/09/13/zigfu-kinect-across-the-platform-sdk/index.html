<!doctype html><html lang=zh-tw><head><title>Zigfu 跨平台的 Kinect SDK - 弦而時習之</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=description content="之前和系上老師借了一個多學期的 Kinect 卻只有做完用 Mac 連接 Kinect 並且搭配 Unity3D 的功課，就一直沒有成果。 暑假也即將結束，緊接而來的就是全力投入在畢業製作，不過在此之前，還是得先把答應老師的功課做完。
雖然時間不足以製作一款遊戲，但是將 Zigfu 這款非常好用的工具使用介紹完整的說明，我想多少也算是能夠 …"><meta name=created content="2014-09-13T00:00:00+0000"><meta name=modified content="0001-01-01T00:00:00+0000"><meta name=author content="蒼時弦也"><meta property="og:site_name" content="弦而時習之"><meta property="og:title" content="Zigfu 跨平台的 Kinect SDK"><meta property="og:url" content="https://blog.frost.tw/posts/2014/09/13/zigfu-kinect-across-the-platform-sdk/"><meta property="og:type" content="article"><meta name=theme-color content="#EFEFEF"><link href=https://blog.frost.tw/icon-512.png rel=icon><link rel=canonical href=https://blog.frost.tw/posts/2014/09/13/zigfu-kinect-across-the-platform-sdk/><script type=application/ld+json>[{"@context":"https://schema.org","@type":"WebPage","headline":"Zigfu 跨平台的 Kinect SDK","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","url":"https://blog.frost.tw/posts/2014/09/13/zigfu-kinect-across-the-platform-sdk/","description":"之前和系上老師借了一個多學期的 Kinect 卻只有做完用 Mac 連接 Kinect 並且搭配 Unity3D 的功課，就一直沒有成果。 暑假也即將結束，緊接而來的就是全力投入在畢業製作，不過在此之前，還是得先把答應老師的功課做完。\n雖然時間不足以製作一款遊戲，但是將 Zigfu 這款非常好用的工具使用介紹完整的說明，我想多少也算是能夠 …\n","keywords":["Kinect","遊戲","Unity3D"],"author":{"@type":"Person","name":"蒼時弦也"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.frost.tw/"},"publisher":{"@type":"Organization","name":"弦而時習之","url":"https://blog.frost.tw/"}},{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://blog.frost.tw/","name":"弦而時習之","image":"http://blog.frost.tw/icon-512.png"}},{"@type":"ListItem","position":2,"item":{"@id":"https://blog.frost.tw/posts/2014/09/13/zigfu-kinect-across-the-platform-sdk/","name":"Zigfu 跨平台的 Kinect SDK"}}]}]</script><link rel=stylesheet href=/css/styls.css><script async src=/js/turbolinks.min.js></script></head><body><div id=fb-root data-turbolinks-permanent></div><h1 id=sitename><a href=/ class="hide-text logo--icon align-center">弦而時習之</a></h1><aside id=slogan class="slogan align-center text-center"><h2 class=slogan__title>Aotokitsuruya</h2><p class=slogan__description>The Web is attracting me, so I start learning PHP, HTML, CSS and JavaScript. When I know about Ruby, I fall in love with it. Now, I working with my friend to design games using C++ and still learning web about Golang, Ruby and JavaScript. In the other side, I also be a designer, the reason why the web is attracted me.</p></aside><div id=wrapper><article class="post article" role=article><header class=article__header><time datetime=0001-01-01T00:00:00+0000 class=article__time--header role=time>Feb.13</time><h1 class=article__title>Zigfu 跨平台的 Kinect SDK</h1></header><div class=article__entry><nav class=translation></nav><p>之前和系上老師借了一個多學期的 Kinect 卻只有做完用 Mac 連接 Kinect 並且搭配 Unity3D 的功課，就一直沒有成果。
暑假也即將結束，緊接而來的就是全力投入在畢業製作，不過在此之前，還是得先把答應老師的功課做完。</p><p>雖然時間不足以製作一款遊戲，但是將 Zigfu 這款非常好用的工具使用介紹完整的說明，我想多少也算是能夠完成一部份的任務了！</p><hr><p>Zigfu 基本上是設計給 Web 使用的，因此目前支援是 JavaScript 和 Unity3D 兩款（Flash 過了半年依舊開發中⋯⋯）
不過 Zigfu 卻替 Mac 使用者解決了一個問題，就是 OpenNI / OpenNI2 的安裝，沒有驅動就無法使用 Kinect 是 Mac 用戶的痛。</p><blockquote><p>不過很可惜的是，目前最新的 Mac 驅動只能順利與 Kinect 溝通一分鐘左右，之後就是當機。
也因此，這系列的文章都是針對 Windows 所說明的，但是成品對 Mac 的支援是確定的，即使會當掉⋯⋯</p></blockquote><p>至於 Zigfu 大致上做了什麼呢？
將驅動程式包裝起來，協助使用者安裝（Windows 使用者需要自己安裝驅動）並且提供 ZDK (SDK) 讓開發者可以用統一的界面，存取 Kinect（官方）、OpenNI、OpenNI2 的 Middleware。</p><blockquote><p>關於 OpenNI / OpenNI 2 的介紹，可以參考<a href="https://viml.nchc.org.tw/blog/paper_info.PHP?CLASS_ID=1&SUB_ID=1&PAPER_ID=491">這篇文章</a>。</p></blockquote><p>這篇文章會用 Unity3D 來解釋一些關於 Zigfu 的 ZDK 基本使用。
最基本的就是我們需要能透過 Zigfu 讀取到影像、深度、骨架等資料，才能夠繼續後續的開發與使用。</p><h3 id=安裝>安裝</h3><p>首先，我們到官方網站的 <a href=https://zigfu.com/en/downloads/browserplugin/>Plugin 下載頁面</a> 去下載 Plugin。
（Windows 用戶應該是不需要，至於使用的 Kinect 是 For Windows 還是 For Xbox 要注意驅動是否正確。）</p><p>完成之後，再到 <a href=https://zigfu.com/en/zdk/unity3d/>Unity3D ZDK 下載頁面</a>下載適合 Unity3D 的 ZDK （是一個 Unitypackage 檔案，並且有含範例。）</p><p>之後在 Unity3D 開啟新專案，匯入 Custom Package 之後，就可以使用了。</p><p><strong>注意：因為 ZDK 是用 DLL 包裝的，所以你必須使用 Unity3D Pro 才能夠正常使用</strong></p><h3 id=了解-zig-元件>了解 Zig 元件</h3><p>如果有點開範例檔案，會發現每一個範例檔案都有一個叫做 <code>Zigfu</code> 的 GameObject 在場景上，而這個 <code>Zigfu</code> 物件，都附加了一個叫做 <code>Zig</code> 的 Script 在上面。</p><p>假設停用了 <code>Zigfu</code> 物件，那麼所有相關 Kinect 的功能都會失效，並且出現 <code>Failed load driver and middleware...</code> 這樣的錯誤。</p><p>那麼 <code>Zig</code> 這個 Script 做了些什麼呢？</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-cs data-lang=cs><span class=c1>// 略
</span><span class=c1></span>    <span class=k>public</span> <span class=n>ZigInputType</span> <span class=n>inputType</span> <span class=p>=</span> <span class=n>ZigInputType</span><span class=p>.</span><span class=n>Auto</span><span class=p>;</span>
    <span class=c1>//public bool UpdateDepthmap = true;
</span><span class=c1></span>    <span class=c1>//public bool UpdateImagemap = false;
</span><span class=c1></span>    <span class=c1>//public bool UpdateLabelmap = false;
</span><span class=c1></span>    <span class=c1>//public bool AlignDepthToRGB = false;
</span><span class=c1></span>    <span class=k>public</span> <span class=n>ZigInputSettings</span> <span class=n>settings</span> <span class=p>=</span> <span class=k>new</span> <span class=n>ZigInputSettings</span><span class=p>();</span>
    <span class=k>public</span> <span class=n>List</span><span class=p>&lt;</span><span class=n>GameObject</span><span class=p>&gt;</span> <span class=n>listeners</span> <span class=p>=</span> <span class=k>new</span> <span class=n>List</span><span class=p>&lt;</span><span class=n>GameObject</span><span class=p>&gt;();</span>
    <span class=k>public</span> <span class=kt>bool</span> <span class=n>Verbose</span> <span class=p>=</span> <span class=k>true</span><span class=p>;</span>
    
    <span class=k>void</span> <span class=n>Awake</span> <span class=p>()</span> <span class=p>{</span>
        <span class=cp>#if UNITY_WEBPLAYER
</span><span class=cp></span>        <span class=cp>#if UNITY_EDITOR
</span><span class=cp></span>        <span class=n>Debug</span><span class=p>.</span><span class=n>LogError</span><span class=p>(</span><span class=s>&#34;Depth camera input will not work in editor when target platform is Webplayer. Please change target platform to PC/Mac standalone.&#34;</span><span class=p>);</span>
        <span class=k>return</span><span class=p>;</span>
        <span class=cp>#endif
</span><span class=cp></span>        <span class=cp>#endif
</span><span class=cp></span>
        <span class=n>ZigInput</span><span class=p>.</span><span class=n>InputType</span> <span class=p>=</span> <span class=n>inputType</span><span class=p>;</span>
        <span class=n>ZigInput</span><span class=p>.</span><span class=n>Settings</span> <span class=p>=</span> <span class=n>settings</span><span class=p>;</span>
        <span class=c1>//ZigInput.UpdateDepth = UpdateDepthmap;
</span><span class=c1></span>        <span class=c1>//ZigInput.UpdateImage = UpdateImagemap;
</span><span class=c1></span>        <span class=c1>//ZigInput.UpdateLabelMap = UpdateLabelmap;
</span><span class=c1></span>        <span class=c1>//ZigInput.AlignDepthToRGB = AlignDepthToRGB;
</span><span class=c1></span>        <span class=n>ZigInput</span><span class=p>.</span><span class=n>Instance</span><span class=p>.</span><span class=n>AddListener</span><span class=p>(</span><span class=n>gameObject</span><span class=p>);</span>
	<span class=p>}</span>
<span class=c1>// 略
</span></code></pre></td></tr></table></div></div><p>上面是節錄自 <code>Zig.cs</code> 這個檔案的內容，我們可以發現裡面對 <code>ZigInput</code> 設定了 <code>InputType</code> 跟 <code>Settings</code> 兩個數值。</p><p>在 Unity3D 裡面看到就會是像這樣：
<img src=https://user-image.logdown.io/user/52/blog/52/post/233228/7rGRv56mTYCE21bemCWe_%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-09-13%20%E4%B8%8B%E5%8D%883.01.19.png alt="螢幕快照 2014-09-13 下午3.01.19.png"></p><p>簡單來說 <code>Zig</code> 元件幫我們把「讀取方式」以及讀取的方式設定好了！</p><blockquote><p>在 InputType 裡面可以選擇 Auto / KinectSDK / OpenNI / OpenNI2 幾個選項，在預設的 Auto 狀況下，Zigfu 會自動依照 KinectSDK > OpenNI2 > OpenNI 的順序嘗試呼叫，當成功時就使用該驅動作為讀取 Kinect 資料的驅動。
Settings 裡面則會看到一些關於讀取資料的設定，像是是否要更新 Depth （深度資訊） 等等。</p></blockquote><p>最後，我們需要注意 <code>Awake</code> 方法的最後一行 <code>ZigInput.Instance.AddListener(gameObject)</code> 這一句程式碼。</p><blockquote><p>在程式開發慣例中 Instance 通常是指物件的實體（就 Zigfu 的設計上，應該是屬於<a href=https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F>單例</a>的設計，簡單說就是只會存在一個。）</p></blockquote><p><code>gameObject</code> 在 Unity3D 通常是指自己本身，而 <code>AddListener</code> 在這邊指的是「當更新時也一併更新這個物件」的意思。</p><blockquote><p>Listener 基本上設計類似于<a href=https://zh.wikipedia.org/wiki/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F>觀察者</a>這種慣例，在 Unity3D 就類似於 <code>Update</code> 的感覺，在 Zigfu 中選擇了自行實作，跟 Unity3D 分開處理。
某方面也算是比較恰當的做法，畢竟 Kinect 裡面有自己的硬體，跟 Unity3D 分離就可以不受玩家主機的硬體限制。</p></blockquote><h3 id=從-kinect-讀取影像>從 Kinect 讀取影像</h3><p>首先我們要在深入了解 <code>ZigInput</code> 的作用，我們可以從範例的 <code>ZigImageView.cs</code> 這個檔案了解到一些蛛絲馬跡。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-cs data-lang=cs><span class=c1>// 略
</span><span class=c1></span>    <span class=k>void</span> <span class=n>Zig_Update</span><span class=p>(</span><span class=n>ZigInput</span> <span class=n>input</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=n>UpdateTexture</span><span class=p>(</span><span class=n>ZigInput</span><span class=p>.</span><span class=n>Image</span><span class=p>);</span>
    <span class=p>}</span>
<span class=c1>// 略
</span></code></pre></td></tr></table></div></div><p>前面提到的 <code>AddListener</code> 動作中，每當 Kinect 更新畫面並且被 Zigfu 接收時，會做類似 Unity3dD 的 <code>Update</code> 動作，也就是上面這段程式碼所寫的 <code>Zig_Update</code> 方法。</p><p>從這段程式碼可以看到，如果我們需要讀取影像，可以從 <code>ZigInput</code> 拿到一個 <code>Image</code> 資料來使用。</p><blockquote><p>除了 <code>Image</code> 之外，我們還能拿到 <code>Depth</code> (深度) 以及 <code>Label Map</code> (標記)
不過 Label Map 在範例中是黑色的畫面，似乎也沒有人了解用途，因此就不多做討論。</p></blockquote><p>接下來，我們先產生新的場景（Scene / Ctrl + N）並且新增一個 Empty GameObject 用來放置 Zig 元件。</p><p><img src=https://user-image.logdown.io/user/52/blog/52/post/233228/yB4QZUyhRJC8zMc7IMgq_%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-09-13%20%E4%B8%8B%E5%8D%883.22.26.png alt="螢幕快照 2014-09-13 下午3.22.26.png"></p><blockquote><p>產生好物件之後，就馬上把物件命名為 Zigfu 這會是一個好習慣，在中後期專案變大的時候，檔案跟物件沒有好好命名的話，就會碰到非常多問題。而團隊合作的時候更是明顯，因此別忘記修改物件名稱。</p></blockquote><p><img src=https://user-image.logdown.io/user/52/blog/52/post/233228/0CMHeh13QWi6FZjqn6wW_%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-09-13%20%E4%B8%8B%E5%8D%883.22.43.png alt="螢幕快照 2014-09-13 下午3.22.43.png"></p><p>在 Zigfu 的 ZDK 匯入到 Unity3D 後，也已經自動對選單增加好所有可用的元件。
我們在 Script 類型的選件中選擇 Zig 就可以對 Zigfu 物件新增這個元件了！</p><p><img src=https://user-image.logdown.io/user/52/blog/52/post/233228/zmyH6trKQpKxGoQGnRnz_%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-09-13%20%E4%B8%8B%E5%8D%883.26.45.png alt="螢幕快照 2014-09-13 下午3.26.45.png"></p><p>預設的 Zig 元件沒有開啟 Update Image 的選項，因此我們要自己勾選起來。
（上圖還是未勾選狀態）</p><p><img src=https://user-image.logdown.io/user/52/blog/52/post/233228/rHuuWqqOQOe2Fw8JrLt8_%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-09-13%20%E4%B8%8B%E5%8D%883.30.52.png alt="螢幕快照 2014-09-13 下午3.30.52.png"></p><p>接著，我們會需要一個 Plane（平面）用來顯示 Kinect 讀取到的影像。</p><p><img src=https://user-image.logdown.io/user/52/blog/52/post/233228/Ae9OtZ2fQU6jz8FWUru0_%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-09-13%20%E4%B8%8B%E5%8D%883.32.26.png alt="螢幕快照 2014-09-13 下午3.32.26.png"></p><p>接著調整 Plane（這邊我已經重新命名為 ImageViewer） 跟 Main Camera 讓平面可以順利被攝影機完整照到。</p><p><img src=https://user-image.logdown.io/user/52/blog/52/post/233228/E5ujAGCtTVOdJCErzlge_%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-09-13%20%E4%B8%8B%E5%8D%883.33.51.png alt="螢幕快照 2014-09-13 下午3.33.51.png"></p><p>在開始之前，我們先用範例的 ImageViewer 元件來測試效果。
現在啟動遊戲的話，應該可以順利看到 Kinect 的 Camera 照到的影像被更新到 Plane 上。</p><blockquote><p>不過應該是上下顛倒的，不論是 WebCam 或者 Kinect 被照進去的狀況下都是這樣，旋轉一下就可以了！
影像有點暗是因為 3D 物件上面沒有打光，只要在場景上新增光源即可。</p></blockquote><h3 id=自定圖片讀取>自定圖片讀取</h3><p>我們先將 <code>ZigImageViewer.cs</code> 的內容複製到一個新的檔案 <code>CustomImageViewer.cs</code> 並且以此為基礎修改出我們自己的「圖片讀取功能」</p><p><img src=https://user-image.logdown.io/user/52/blog/52/post/233228/Z5MfzZHuQiJIiz0dkmI8_%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-09-13%20%E4%B8%8B%E5%8D%884.11.40.png alt="螢幕快照 2014-09-13 下午4.11.40.png"></p><p>並且把原本的 ImageViewer Panel 的 Script 改為 CustomImageViewer 來套用我們自己的讀取處理。
（這邊最好先執行看看，是否可以順利運作。要注意 <code>class ZigImageViewer</code> 得改為跟檔名一樣的 <code>class CustomImageViewer</code> 才會正常運作。）</p><p>修改之前，第一步是要了解範例的 ImageViewer 在做什麼。
下面會直接將解釋標記在程式碼中。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-cs data-lang=cs><span class=k>public</span> <span class=k>class</span> <span class=nc>CustomImageViewer</span> <span class=p>:</span> <span class=n>MonoBehaviour</span> <span class=p>{</span>
	<span class=c1>// 指定繪製的目標（這邊直接畫在自身，所以不需要）
</span><span class=c1></span>	<span class=k>public</span> <span class=n>Renderer</span> <span class=n>target</span><span class=p>;</span>
  <span class=c1>// 解析度設定，最高支援到 640x480 數值越低越順暢
</span><span class=c1></span>	<span class=k>public</span> <span class=n>ZigResolution</span> <span class=n>TextureSize</span> <span class=p>=</span> <span class=n>ZigResolution</span><span class=p>.</span><span class=n>QQVGA_160x120</span><span class=p>;</span>
  <span class=c1>// 材質貼圖（用來存 Kinect 讀進來的影像）
</span><span class=c1></span>	<span class=n>Texture2D</span> <span class=n>texture</span><span class=p>;</span>
  <span class=c1>// 解析度資料
</span><span class=c1></span>	<span class=n>ResolutionData</span> <span class=n>textureSize</span><span class=p>;</span>
	
	<span class=n>Color32</span><span class=p>[]</span> <span class=n>outputPixels</span><span class=p>;</span> <span class=c1>// 將影像轉換為像素陣列
</span><span class=c1></span>  
	<span class=c1>// 讀取器的初始化
</span><span class=c1></span>	<span class=k>void</span> <span class=n>Start</span><span class=p>()</span>
	<span class=p>{</span>
		<span class=k>if</span> <span class=p>(</span><span class=n>target</span> <span class=p>==</span> <span class=k>null</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// 檢查是否有指定目標
</span><span class=c1></span>			<span class=n>target</span> <span class=p>=</span> <span class=n>renderer</span><span class=p>;</span> <span class=c1>// 沒有的話就設定為自己
</span><span class=c1></span>		<span class=p>}</span>
    <span class=c1>// 將讀取的解析度轉換為解析度資料（後面會用來畫在材質上）
</span><span class=c1></span>		<span class=n>textureSize</span> <span class=p>=</span> <span class=n>ResolutionData</span><span class=p>.</span><span class=n>FromZigResolution</span><span class=p>(</span><span class=n>TextureSize</span><span class=p>);</span>
    <span class=c1>// 產生新的 2D 材質（用剛剛轉換的解析度資料）
</span><span class=c1></span>		<span class=n>texture</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Texture2D</span><span class=p>(</span><span class=n>textureSize</span><span class=p>.</span><span class=n>Width</span><span class=p>,</span> <span class=n>textureSize</span><span class=p>.</span><span class=n>Height</span><span class=p>);</span>
		<span class=c1>// 設定材質的顯示方式（ Clamp 是填滿，另一個 Repeat 則是重複貼滿 ）
</span><span class=c1></span>    <span class=n>texture</span><span class=p>.</span><span class=n>wrapMode</span> <span class=p>=</span> <span class=n>TextureWrapMode</span><span class=p>.</span><span class=n>Clamp</span><span class=p>;</span>
    <span class=c1>// 設定 Plane 的材質為剛剛新增的材質
</span><span class=c1></span>		<span class=n>renderer</span><span class=p>.</span><span class=n>material</span><span class=p>.</span><span class=n>mainTexture</span> <span class=p>=</span> <span class=n>texture</span><span class=p>;</span>
    <span class=c1>// 產生一組可以儲存影像像素資料的陣列
</span><span class=c1></span>		<span class=n>outputPixels</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Color32</span><span class=p>[</span><span class=n>textureSize</span><span class=p>.</span><span class=n>Width</span> <span class=p>*</span> <span class=n>textureSize</span><span class=p>.</span><span class=n>Height</span><span class=p>];</span>
    <span class=c1>// 告訴 Zigfu 當畫面更新時要呼叫這個原件做更新處理
</span><span class=c1></span>		<span class=n>ZigInput</span><span class=p>.</span><span class=n>Instance</span><span class=p>.</span><span class=n>AddListener</span><span class=p>(</span><span class=n>gameObject</span><span class=p>);</span>
	<span class=p>}</span>
	
  <span class=c1>// 更新材質
</span><span class=c1></span>  <span class=c1>// 接收的是一個 ZigImage 資料
</span><span class=c1></span>	<span class=k>void</span> <span class=n>UpdateTexture</span><span class=p>(</span><span class=n>ZigImage</span> <span class=n>image</span><span class=p>)</span>
	<span class=p>{</span>
  	<span class=c1>// 讀取原始的影像資料（ Zigfu 會傳回像素陣列 ）
</span><span class=c1></span>		<span class=n>Color32</span><span class=p>[]</span> <span class=n>rawImageMap</span> <span class=p>=</span> <span class=n>image</span><span class=p>.</span><span class=n>data</span><span class=p>;</span>
    <span class=c1>// 將陣列換算成 2D 圖像的前置準備
</span><span class=c1></span>    <span class=c1>// 後面會詳細解釋這個部分
</span><span class=c1></span>		<span class=kt>int</span> <span class=n>srcIndex</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
		<span class=kt>int</span> <span class=n>factorX</span> <span class=p>=</span> <span class=n>image</span><span class=p>.</span><span class=n>xres</span> <span class=p>/</span> <span class=n>textureSize</span><span class=p>.</span><span class=n>Width</span><span class=p>;</span>
		<span class=kt>int</span> <span class=n>factorY</span> <span class=p>=</span> <span class=p>((</span><span class=n>image</span><span class=p>.</span><span class=n>yres</span> <span class=p>/</span> <span class=n>textureSize</span><span class=p>.</span><span class=n>Height</span><span class=p>)</span> <span class=p>-</span> <span class=m>1</span><span class=p>)</span> <span class=p>*</span> <span class=n>image</span><span class=p>.</span><span class=n>xres</span><span class=p>;</span>
   	
		<span class=c1>// 反轉 Y 軸（因為讀取到的影響一開始是左右相反的，需要再轉回來一次）
</span><span class=c1></span>		<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>y</span> <span class=p>=</span> <span class=n>textureSize</span><span class=p>.</span><span class=n>Height</span> <span class=p>-</span> <span class=m>1</span><span class=p>;</span> <span class=n>y</span> <span class=p>&gt;=</span> <span class=m>0</span><span class=p>;</span> <span class=p>--</span><span class=n>y</span><span class=p>,</span> <span class=n>srcIndex</span> <span class=p>+=</span> <span class=n>factorY</span><span class=p>)</span> <span class=p>{</span>
			<span class=kt>int</span> <span class=n>outputIndex</span> <span class=p>=</span> <span class=n>y</span> <span class=p>*</span> <span class=n>textureSize</span><span class=p>.</span><span class=n>Width</span><span class=p>;</span><span class=c1>// 輸出影像的陣列位置
</span><span class=c1></span>			<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>x</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>x</span> <span class=p>&lt;</span> <span class=n>textureSize</span><span class=p>.</span><span class=n>Width</span><span class=p>;</span> <span class=p>++</span><span class=n>x</span><span class=p>,</span> <span class=n>srcIndex</span> <span class=p>+=</span> <span class=n>factorX</span><span class=p>,</span> <span class=p>++</span><span class=n>outputIndex</span><span class=p>)</span> <span class=p>{</span>
				<span class=n>outputPixels</span><span class=p>[</span><span class=n>outputIndex</span><span class=p>]</span> <span class=p>=</span> <span class=n>rawImageMap</span><span class=p>[</span><span class=n>srcIndex</span><span class=p>];</span> <span class=c1>// 將像素資料複製到輸出影像
</span><span class=c1></span>			<span class=p>}</span>
		<span class=p>}</span>
		<span class=n>texture</span><span class=p>.</span><span class=n>SetPixels32</span><span class=p>(</span><span class=n>outputPixels</span><span class=p>);</span> <span class=c1>// 更新材質的像素資料
</span><span class=c1></span>		<span class=n>texture</span><span class=p>.</span><span class=n>Apply</span><span class=p>();</span> <span class=c1>// 套用像素資料（材質內容被更新）
</span><span class=c1></span>	<span class=p>}</span>
	
	<span class=k>void</span> <span class=n>Zig_Update</span><span class=p>(</span><span class=n>ZigInput</span> <span class=n>input</span><span class=p>)</span>
	<span class=p>{</span>
		<span class=n>UpdateTexture</span><span class=p>(</span><span class=n>ZigInput</span><span class=p>.</span><span class=n>Image</span><span class=p>);</span>
	<span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>這邊會解釋兩個東西，一個是 Renderer (渲染器) 另一個是陣列轉為 2D 坐標的方法。</p><blockquote><p>Renderer 基本上會附加在每一個 Unity3D 上「可以被看到」的物件，他用來處理材質球跟材質如何繪製到模型上。
也因此，一旦 Renderer 被關掉，就無法看到物件，這邊用程式的方式設定材質球。</p></blockquote><p>至於陣列轉換為 2D 坐標的方法，其實就是非常簡單的數學邏輯。</p><p>假設有一個 10px 乘以 10px 的影像，那麼他就會有 10 * 10 = 100 個像素。
那麼第 11 個像素的坐標在哪裡呢？可以用下面的方式推算出來。</p><blockquote><p>位置 = (y * 寬) + x</p></blockquote><p>所以說 11 要先除以 10 會得到餘數 1 接著用 11 剪掉 1 就得到一個可以被「寬」整除的值，都計算完畢後，就可以知道第 11 個像素位置在 x = 0, y = 1 的位置（註：陣列中是從 0 ~ 99 所以算完會變成 0,1 的坐標）</p><p>多想幾次就會理解其中的原理了！</p><p>接下來，我們對 <code>UpdateTexture</code> 方法做一些小修改，讓畫面變成黑白的灰階畫面。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-cs data-lang=cs><span class=c1>// 略
</span><span class=c1></span>  <span class=k>void</span> <span class=n>UpdateTexture</span><span class=p>(</span><span class=n>ZigImage</span> <span class=n>image</span><span class=p>)</span>
	<span class=p>{</span>
		<span class=n>Color32</span><span class=p>[]</span> <span class=n>rawImageMap</span> <span class=p>=</span> <span class=n>image</span><span class=p>.</span><span class=n>data</span><span class=p>;</span>
		<span class=kt>int</span> <span class=n>srcIndex</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
		<span class=kt>int</span> <span class=n>factorX</span> <span class=p>=</span> <span class=n>image</span><span class=p>.</span><span class=n>xres</span> <span class=p>/</span> <span class=n>textureSize</span><span class=p>.</span><span class=n>Width</span><span class=p>;</span>
		<span class=kt>int</span> <span class=n>factorY</span> <span class=p>=</span> <span class=p>((</span><span class=n>image</span><span class=p>.</span><span class=n>yres</span> <span class=p>/</span> <span class=n>textureSize</span><span class=p>.</span><span class=n>Height</span><span class=p>)</span> <span class=p>-</span> <span class=m>1</span><span class=p>)</span> <span class=p>*</span> <span class=n>image</span><span class=p>.</span><span class=n>xres</span><span class=p>;</span>

		<span class=n>Color</span> <span class=n>buffer</span><span class=p>;</span>
    <span class=kt>byte</span> <span class=n>grayscaleByte</span><span class=p>;</span>
		<span class=c1>// invert Y axis while doing the update
</span><span class=c1></span>		<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>y</span> <span class=p>=</span> <span class=n>textureSize</span><span class=p>.</span><span class=n>Height</span> <span class=p>-</span> <span class=m>1</span><span class=p>;</span> <span class=n>y</span> <span class=p>&gt;=</span> <span class=m>0</span><span class=p>;</span> <span class=p>--</span><span class=n>y</span><span class=p>,</span> <span class=n>srcIndex</span> <span class=p>+=</span> <span class=n>factorY</span><span class=p>)</span> <span class=p>{</span>
			<span class=kt>int</span> <span class=n>outputIndex</span> <span class=p>=</span> <span class=n>y</span> <span class=p>*</span> <span class=n>textureSize</span><span class=p>.</span><span class=n>Width</span><span class=p>;</span>
			<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>x</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>x</span> <span class=p>&lt;</span> <span class=n>textureSize</span><span class=p>.</span><span class=n>Width</span><span class=p>;</span> <span class=p>++</span><span class=n>x</span><span class=p>,</span> <span class=n>srcIndex</span> <span class=p>+=</span> <span class=n>factorX</span><span class=p>,</span> <span class=p>++</span><span class=n>outputIndex</span><span class=p>)</span> <span class=p>{</span>
				<span class=n>buffer</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Color</span><span class=p>(</span><span class=n>rawImageMap</span><span class=p>[</span><span class=n>srcIndex</span><span class=p>].</span><span class=n>r</span><span class=p>,</span> <span class=n>rawImageMap</span><span class=p>[</span><span class=n>srcIndex</span><span class=p>].</span><span class=n>g</span><span class=p>,</span> <span class=n>rawImageMap</span><span class=p>[</span><span class=n>srcIndex</span><span class=p>].</span><span class=n>b</span><span class=p>,</span> <span class=n>rawImageMap</span><span class=p>[</span><span class=n>srcIndex</span><span class=p>].</span><span class=n>a</span><span class=p>);</span>
        <span class=n>grayscaleByte</span> <span class=p>=</span> <span class=p>(</span><span class=kt>byte</span><span class=p>)</span><span class=n>buffer</span><span class=p>.</span><span class=n>grayscale</span><span class=p>;</span>
				<span class=n>outputPixels</span><span class=p>[</span><span class=n>outputIndex</span><span class=p>]</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Color32</span><span class=p>(</span><span class=n>grayscaleByte</span><span class=p>,</span> <span class=n>grayscaleByte</span><span class=p>,</span> <span class=n>grayscaleByte</span><span class=p>,</span> <span class=p>(</span><span class=kt>byte</span><span class=p>)</span><span class=n>rawImageMap</span><span class=p>[</span><span class=n>srcIndex</span><span class=p>].</span><span class=n>a</span><span class=p>);</span>
			<span class=p>}</span>
		<span class=p>}</span>
		<span class=n>texture</span><span class=p>.</span><span class=n>SetPixels32</span><span class=p>(</span><span class=n>outputPixels</span><span class=p>);</span>
		<span class=n>texture</span><span class=p>.</span><span class=n>Apply</span><span class=p>();</span>
	<span class=p>}</span>
<span class=c1>// 略
</span></code></pre></td></tr></table></div></div><p>首先，先增加 <code>Color buffer</code> 跟 <code>byte grayscaleByte</code> 方便處理。</p><blockquote><p>grayscale 只在 Color 下可以使用，而 Color32 則沒有這個功能，因此需要先手動將 Color32 轉為 Color</p></blockquote><p>接著 <code>buffer = new Color(rawImageMap[srcIndex].r, rawImageMap[srcIndex].g, rawImageMap[srcIndex].b, rawImageMap[srcIndex].a);</code> 基於拿到的顏色產生一個新的 Color。
因為 Color32 需要用 byte 指定顏色，因此我們用 <code>grayscaleByte = (byte)buffer.grayscale;</code> 將灰階化的數值轉為 byte 方便使用。</p><p>最後調整原本複製像素的方式，改為 <code>outputPixels[outputIndex] = new Color32(grayscaleByte, grayscaleByte, grayscaleByte, (byte)rawImageMap[srcIndex].a);</code> 將一個灰階版本的像素複製進去。</p><p>現在，執行遊戲的話就可以看到灰階的畫面。</p><p>這篇文章就到此告一段落，至於 Depth 跟 Label Map 的使用方式，基本上是一樣的。目前學習的東西用一般的 WebCam 也能做到，下一篇文章會討論關於骨架的使用。</p><footer class=article__footer><div class=text-center><div class=fb-share-button data-href="<%- page.permalink %>" data-layout=button_count></div></div><div class="text-center mt-1"><style>.bmc-button img{width:27px!important;margin-bottom:1px!important;box-shadow:none!important;border:none!important;vertical-align:middle!important}.bmc-button{line-height:36px!important;height:37px!important;text-decoration:none!important;display:inline-flex!important;color:#fff!important;background-color:#000!important;border-radius:3px!important;border:1px solid transparent!important;padding:1px 9px!important;font-size:22px!important;letter-spacing:.6px!important;box-shadow:0 1px 2px rgba(190,190,190,.5)!important;-webkit-box-shadow:0 1px 2px 2px rgba(190,190,190,.5)!important;margin:0 auto!important;font-family:cookie,cursive!important;-webkit-box-sizing:border-box!important;box-sizing:border-box!important;-o-transition:.3s all linear!important;-webkit-transition:.3s all linear!important;-moz-transition:.3s all linear!important;-ms-transition:.3s all linear!important;transition:.3s all linear!important}.bmc-button:hover,.bmc-button:active,.bmc-button:focus{-webkit-box-shadow:0 1px 2px 2px rgba(190,190,190,.5)!important;text-decoration:none!important;box-shadow:0 1px 2px 2px rgba(190,190,190,.5)!important;opacity:.85!important;color:#fff!important}</style><link href="https://fonts.googleapis.com/css?family=Cookie" rel=stylesheet><a class=bmc-button target=_blank href=https://www.buymeacoffee.com/aotoki><img src=https://bmc-cdn.nyc3.digitaloceanspaces.com/BMC-button-images/BMC-btn-logo.svg alt="Buy me a Coffee"><span style=margin-left:5px>Buy me a Coffee</span></a></div><iframe scrolling=no frameborder=0 style="display:block;margin:0 auto;height:212px" src="https://button.like.co/in/embed/elct9620/button?referrer=<%- page.permalink %>"></iframe><ul class=article__tag-list><li class=article__tag-list-item><a class=article__tag-list-link href=https://blog.frost.tw/tags/Kinect/>Kinect</a></li><li class=article__tag-list-item><a class=article__tag-list-link href=https://blog.frost.tw/tags/%E9%81%8A%E6%88%B2/>遊戲</a></li><li class=article__tag-list-item><a class=article__tag-list-link href=https://blog.frost.tw/tags/Unity3D/>Unity3D</a></li></ul></footer><aside class=related><header class=related__header><h3 class=related__title>相關文章</h3></header><ul><li class=related__item><a class=related__link href=/posts/2014/09/13/use-the-zigfu-skeleton-features/>使用 Zigfu 的骨架功能</a></li><li class=related__item><a class=related__link href=/posts/2014/01/03/unity3d-component-of-game-production/>Unity3D - 元件化的遊戲製作</a></li><li class=related__item><a class=related__link href=/posts/2014/12/07/tgdf-2014-i-want-to-make-a-game-again/>TGDF 2014：重燃的遊戲夢</a></li><li class=related__item><a class=related__link href=/posts/2014/10/05/unreal-engine-4-using-cpp-customize-pawn-object/>Unreal Engine 4 - 用 C++ 自訂 Pawn 物件</a></li><li class=related__item><a class=related__link href=/posts/2014/04/07/unreal-engine-4-collaboration-with-svn/>Unreal Engine 4 collaboration with SVN</a></li></ul></aside></div></article><div class=adv><script async src=//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-2844969736316510 data-ad-slot=5530952976 data-ad-format=auto></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div><section id=comment class=comment-box><h1 class=comment-box__title>留言</h1><div id=disqus_thread></div></div></section></div><footer id=footer><div id=copyright>&copy;2020 <a href="https://plus.google.com/117236344655673213049?rel=author" target=_blank rel=noreferrer>蒼時弦也</a>. All right reversed.</div></footer><script src=/js/app.min.6e03bcf752b31ab875459fbdd360c766632ead24687ffe499c4cf1f86e9fe489.js></script><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5TQLRN" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-5TQLRN');</script><script>window.fbAsyncInit=function(){FB.init({appId:'178355449110',xfbml:true,version:'v2.12'});FB.AppEvents.logPageView();};(function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(d.getElementById(id)){return;}
js=d.createElement(s);js.id=id;js.src="https://connect.facebook.net/zh_TW/sdk.js";js.async=true
js.defer=true
fjs.parentNode.insertBefore(js,fjs);}(document,'script','facebook-jssdk'));</script><div class=loading></div></body></html>