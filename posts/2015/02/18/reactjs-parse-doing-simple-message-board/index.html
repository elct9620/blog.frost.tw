<!DOCTYPE html><html lang="zh-TW"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><title>React.js + Parse 實做簡易留言板 | 弦而時習之</title><meta name="theme-color" content="#EFEFEF"><meta name="author" content="蒼時弦也"><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name="description" content="前一陣子 SITCON 文創組冬季訓練最後一天，我安排了這個課程給我們的新成員。雖然 SITCON 文創組看似是個需要「技術」的團隊，不過現實上我們倒是花很多時間在思考跟設計上，沒辦法找到設計相關科系的新成員稍稍遺憾。不過因為有製作網站的需求，因此安排了這個課程，透過學習 React.js 以及結合 Parse 去熟悉一些基本的前端技巧。注意事項：文中的範例全部都以 CoffeeScript 撰寫"><meta name="keywords" content="心得,SITCON,筆記,React.js"><meta property="og:type" content="article"><meta property="og:title" content="React.js + Parse 實做簡易留言板"><meta property="og:url" content="https://blog.frost.tw/posts/2015/02/18/reactjs-parse-doing-simple-message-board/"><meta property="og:site_name" content="弦而時習之"><meta property="og:description" content="前一陣子 SITCON 文創組冬季訓練最後一天，我安排了這個課程給我們的新成員。雖然 SITCON 文創組看似是個需要「技術」的團隊，不過現實上我們倒是花很多時間在思考跟設計上，沒辦法找到設計相關科系的新成員稍稍遺憾。不過因為有製作網站的需求，因此安排了這個課程，透過學習 React.js 以及結合 Parse 去熟悉一些基本的前端技巧。注意事項：文中的範例全部都以 CoffeeScript 撰寫"><meta property="og:locale" content="zh-TW"><meta property="og:image" content="http://blog.frost.tw/icon-512.png"><meta property="og:updated_time" content="2019-06-29T07:42:39.117Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="React.js + Parse 實做簡易留言板"><meta name="twitter:description" content="前一陣子 SITCON 文創組冬季訓練最後一天，我安排了這個課程給我們的新成員。雖然 SITCON 文創組看似是個需要「技術」的團隊，不過現實上我們倒是花很多時間在思考跟設計上，沒辦法找到設計相關科系的新成員稍稍遺憾。不過因為有製作網站的需求，因此安排了這個課程，透過學習 React.js 以及結合 Parse 去熟悉一些基本的前端技巧。注意事項：文中的範例全部都以 CoffeeScript 撰寫"><meta name="twitter:image" content="http://blog.frost.tw/icon-512.png"><link rel="publisher" href="https://plus.google.com/117236344655673213049"><meta property="fb:app_id" content="178355449110"><meta property="fb:pages" content="180666522388"><script type="application/ld+json">[
{
    "@context": "http://schema.org",
    "@type": "Blog",
    "name": "弦而時習之",
    "url": "https://blog.frost.tw",
    "image": "http://blog.frost.tw/icon-512.png",
    "description": "蒼時弦也的個人網誌，專注在前端、後端以及遊戲開發，大多使用 Ruby 和 Ruby on Rails 以及 Golang、JS 和 C 語言。",
    "sameAs": [
      "https://www.facebook.com/frost.tw/"
    ]
},
{
    "@context": "http://schema.org",
    "@type": "Person",
    "name": "蒼時弦也",
    "url": "https://blog.frost.tw",
    "sameAs": [
      "https://www.facebook.com/elct9620",
      "https://www.instagram.com/elct9620/",
      "https://twitter.com/elct9620",
      "https://plus.google.com/+%E8%92%BC%E6%99%82%E5%BC%A6%E4%B9%9F-plus",
      "https://www.linkedin.com/in/elct9620"
    ]
},
{
  "@context":"http://schema.org",
  "@type":"BlogPosting",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://blog.frost.tw/posts/2015/02/18/reactjs-parse-doing-simple-message-board/"
  },
  "headline":"React.js + Parse 實做簡易留言板",
  "image": [
    
    "http://blog.frost.tw/icon-512.png"
  ],
  
  "datePublished": "2015-02-18T05:04:00.000Z",
  "dateModified": "2019-06-29T07:42:39.117Z",
  "description":"前一陣子 SITCON 文創組冬季訓練最後一天，我安排了這個課程給我們的新成員。雖然 SITCON 文創組看似是個需要「技術」的團隊，不過現實上我們倒是花很多時間在思考跟設計上，沒辦法找到設計相關科系的新成員稍稍遺憾。不過因為有製作網站的需求，因此安排了這個課程，透過學習 React.js 以及結合 Parse 去熟悉一些基本的前端技巧。注意事項：文中的範例全部都以 CoffeeScript 撰寫本文不會提及 Browserify 的配置與應用（當天有介紹過，練習時是使用我配置好的 gulp task）這是在不考慮 UI/UX 以及美術的前提下製作的文中不會解釋太多 React.js / Flux 的基本概念（請上官網 or ReactJS.tw 社團學習）那麼，就開始吧！",
  "author": {
    "@type": "Person",
    "name": "蒼時弦也"
  },
  "publisher": {
    "@type": "Organization",
    "name": "蒼時弦也",
    "logo": "https://blog.frost.tw/icon-512.png"
  }
},
{
  "@context": "http://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
    "@type": "ListItem",
    "position": 1,
    "item": {
      "@id": "https://blog.frost.tw",
      "name": "弦而時習之 ",
      "image": "http://blog.frost.tw/icon-512.png"
    }
  },{
    "@type": "ListItem",
    "position": 2,
    "item": {
      "@id": "https://blog.frost.tw/posts/2015/02/18/reactjs-parse-doing-simple-message-board/",
      "name": "React.js + Parse 實做簡易留言板",
      "image": "http://blog.frost.tw/icon-512.png"
    }
  }]
}
,
{
"@context": "https://schema.org",
  "@type": "Organization",
  "url": "https://blog.frost.tw",
  "logo": "https://blog.frost.tw/icon-512.png"
}
]</script><link rel="canonical" href="https://blog.frost.tw/posts/2015/02/18/reactjs-parse-doing-simple-message-board/"><link href="/icon-512.png" rel="icon"><link rel="alternate" href="/feed.xml" title="弦而時習之" type="application/rss+xml"><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--><link rel="stylesheet" href="/css/style.css" media="screen" type="text/css"><script async src="/js/turbolinks.js"></script></head><body><div id="fb-root" data-turbolinks-permanent></div><header id="header"><h1 id="sitename"><a href="/" class="hide-text logo--icon align-center">弦而時習之</a></h1><aside id="slogan" class="slogan align-center text-center"><h2 class="slogan__title">Aotokitsuruya</h2><p class="slogan__description">The Web is attracting me, so I start learning PHP, HTML, CSS and JavaScript. When I know about Ruby, I fall in love with it. Now, I working with my friend to design games using C++ and still learning web about Golang, Ruby and JavaScript. In the other side, I also be a designer, the reason why the web is attracted me.</p></aside></header><div id="wrapper"><article class="post article"><header class="article__header"><time datetime="2015-02-18T05:04:00.000Z" class="article__time--header">Feb.18</time><h1 class="article__title">React.js + Parse 實做簡易留言板</h1></header><div class="article__entry"><p>前一陣子 SITCON 文創組冬季訓練最後一天，我安排了這個課程給我們的新成員。<br>雖然 SITCON 文創組看似是個需要「技術」的團隊，不過現實上我們倒是花很多時間在思考跟設計上，沒辦法找到設計相關科系的新成員稍稍遺憾。</p><p>不過因為有製作網站的需求，因此安排了這個課程，透過學習 React.js 以及結合 Parse 去熟悉一些基本的前端技巧。</p><p>注意事項：</p><ol><li>文中的範例全部都以 CoffeeScript 撰寫</li><li>本文不會提及 Browserify 的配置與應用（當天有介紹過，練習時是使用我配置好的 gulp task）</li><li>這是在不考慮 UI/UX 以及美術的前提下製作的</li><li>文中不會解釋太多 React.js / Flux 的基本概念（請上官網 or ReactJS.tw 社團學習）</li></ol><p>那麼，就開始吧！</p><a id="more"></a><h3 id="拆分元件"><a href="#拆分元件" class="headerlink" title="拆分元件"></a>拆分元件</h3><p>React.js 的 Component（元件）的概念，某種程度上是需要重新定義大家腦中 HTML / JS / CSS 配合的概念，而這個應用方式在很多時候其實能夠幫我們解決不少問題。<br>（個人認為很像 <a href="https://w3c.Github.io/webcomponents/spec/shadow/" rel="external nofollow noopener noreferrer" target="_blank">Shadow DOM</a> 的感覺）</p><p>而 Component 該怎麼拆分呢？簡單來說最小單位就像是一個 <code>&lt;button&gt;</code> 都可以視為一個 Component 只是要看需求。</p><blockquote><p>我們可以利用 Component 重新去定義一個 HTML 元素的效果 Ex. &lt;a&gt; 的 onClick 事件重新定義，但是又可以重複利用</p></blockquote><p>建構一個留言板我們會需要幾個元件：</p><ul><li>留言板主體（通常會叫做 <code>Application</code> 或者 <code>App</code>）<ul><li>留言顯示區域<ul><li>單篇留言</li></ul></li><li>留言表單</li></ul></li></ul><p>以一個最低限度結構的留言板來說，至少需要這幾種元件才能夠構成。</p><p>其實仔細看，會發現基本上也就跟常見的 MVC 框架在拆分 View 的技巧感覺很類似。</p><blockquote><p>不過就如同前面所說的，有時候 Component 也用於「重新定義」某個 HTML 的元素效果。<br>像是 <code>react-bootstrap</code> 就利用重新定制的 <code>&lt;Nav&gt;</code> <code>&lt;MenuItem&gt;</code> 等來表現 Navbar（像是實際上都只是反映單個 HTML 元素而已）</p></blockquote><h3 id="架構"><a href="#架構" class="headerlink" title="架構"></a>架構</h3><p>以 React.js 本身來說，實際上是不足以製作一個完整的 WebApp 的，因此才加入了 Flux 這套理論（我想不適合視為 Library / Framework 而是跟 MVC 類似的理論比較恰當）</p><p>原本的 React.js 其實只有定義了 Component 以及來自外部的「屬性」表現內部的「狀態」而已，但是若要跟 API 溝通並且進行讀取與寫入資料該如何表現呢？</p><p>這時候透過 Flux 所定義的架構就可以很輕鬆的實踐。</p><blockquote><p>Flux 架構是一個單向的流程，不管如何一定會從 Actions 開始出發（有時候也會回到 Actions）但是絕不會有返回的狀況</p></blockquote><ul><li>Actions/<ul><li>通常是處理 API 的部分，會透過 Dispatcher 對 Store 做出操作</li></ul></li><li>Constants/<ul><li>定義 Action 類型的輔助套件（可以不實作，但是缺點會是很容易因為輸入錯誤的字串而無法正常運作）</li></ul></li><li>Components/<ul><li>React.js 所定義的元件，會監聽 Store 的變動更新自身</li></ul></li><li>Store/<ul><li>主要儲存資料的地方，透過從 Dispatcher 收到的變更進行處理</li></ul></li><li>Dispatcher<ul><li>負責指派工作（其中包含了 waitFor() 可以等待一連串的動作完成）</li></ul></li></ul><p>在開發 React.js/Flux 的 WebApp 時，只要注意自己的控制流程是否依循著 Action -&gt; Dispatcher -&gt; Store -&gt; View (Component) 就可以知道自己是否在做正確的設計。</p><h3 id="建構元件"><a href="#建構元件" class="headerlink" title="建構元件"></a>建構元件</h3><p>我個人的習慣是以 React.js 的元件開始做起，因為可以直接看到最終的成果（即使還沒有跟 API 連接上，但也能看到不少基本效果）</p><h4 id="主體（Application）"><a href="#主體（Application）" class="headerlink" title="主體（Application）"></a>主體（Application）</h4><p>因為是留言板，所以這邊我用了 <code>GuestBook.cjsx</code> 而非 <code>Application.cjsx</code> 作為檔名。</p><blockquote><p>大家可能會預設情況是「只能有一個 Application 存在頁面」但對於 React.js 來說只是把不同的 Virtual DOM 更新到實際的 DOM 上面，因此是可以在一個頁面做多次 <code>render</code> 動作混合 React.js 跟傳統網頁的</p></blockquote><figure class="highlight coffee"><figcaption><span>components/GuestBook.cjsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###</span></span><br><span class="line"><span class="comment"># GuestBook</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># @cjsx React.DOM</span></span><br><span class="line"><span class="comment">###</span></span><br><span class="line"></span><br><span class="line">React = <span class="built_in">require</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line">Comments = <span class="built_in">require</span> <span class="string">'./Comments.cjsx'</span> <span class="comment"># 這之後會實作</span></span><br><span class="line">CommentForm = <span class="built_in">require</span> <span class="string">'./CommentForm.cjsx'</span> <span class="comment"># 同上</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = React.createClass &#123;</span><br><span class="line">  render: <span class="function">-&gt;</span></span><br><span class="line">    (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;CommentForm /&gt;</span><br><span class="line">        &lt;Comments /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大多數時候主體框架只是用於把各種子元件讀取進來而已，因此看起來非常的簡單。</p><blockquote><p>要注意的是，因為 React.js 把一個原件視為一個 DOM 物件，因此回傳時務必不能同時傳回兩個元件（這邊就用 <code>div</code> 包起來）</p></blockquote><h4 id="留言表單（CommentForm）"><a href="#留言表單（CommentForm）" class="headerlink" title="留言表單（CommentForm）"></a>留言表單（CommentForm）</h4><p>表單的實作上比較簡單，留言部份還包含了另一個子元件「單篇留言」因此就到下一階段再進行處理。</p><figure class="highlight coffee"><figcaption><span>components/CommentForm.cjsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###</span></span><br><span class="line"><span class="comment"># Comment Form</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># @cjsx React.DOM</span></span><br><span class="line"><span class="comment">###</span></span><br><span class="line"></span><br><span class="line">React = <span class="built_in">require</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line">CommentAction = <span class="built_in">require</span> <span class="string">'../actions/CommentAction.coffee'</span> <span class="comment"># 後面會實作 Comment Action</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = React.createClass &#123;</span><br><span class="line">  getInitialState: <span class="function">-&gt;</span></span><br><span class="line">  	<span class="comment"># React.js 的 State 都需要「事先定義」才能夠使用</span></span><br><span class="line">    &#123;</span><br><span class="line">      content: <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _onSubmit: <span class="function"><span class="params">(e)</span> -&gt;</span> <span class="comment"># 處理 Submit 的方法（收到的 e 就跟原生 JavaScript 拿到的 Event 是相同的）</span></span><br><span class="line">    CommentAction.create(@state.content) <span class="comment"># 呼叫 Action 執行某個任務（新增留言）</span></span><br><span class="line">    @setState &#123; content: <span class="string">""</span> &#125;</span><br><span class="line"></span><br><span class="line">    e.preventDefault() <span class="comment"># 取消原有的表單送出動作</span></span><br><span class="line"></span><br><span class="line">  _onChange: <span class="function"><span class="params">(e)</span> -&gt;</span></span><br><span class="line">    <span class="comment"># 這算是一種小技巧，我們會發現在 _onSubmit 方法要取得 textarea 的內容是很困難的</span></span><br><span class="line">    <span class="comment"># 因此就隨時將表單內容存到狀態中（再次時做表單處理）用於送出時使用</span></span><br><span class="line">    <span class="comment"># 不過要注意的是後面的 textarea 設定了 value=&#123;@state.content&#125; 可以確保使用者輸入的跟送出的結果是相同的</span></span><br><span class="line">    @setState &#123; content: e.target.value &#125;</span><br><span class="line"></span><br><span class="line">  render: <span class="function">-&gt;</span></span><br><span class="line">    (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;form onSubmit=&#123;@_onSubmit&#125;&gt;</span><br><span class="line">          &lt;textarea onChange=&#123;@_onChange&#125; placeholder=<span class="string">"Messages..."</span> value=&#123;@state.content&#125;&gt;&lt;/textarea&gt;</span><br><span class="line">          &lt;button type=<span class="string">"submit"</span>&gt;Submit&lt;/button&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>實際上，在 React.js 中的元件設計都是很簡單的，從目前的兩個例子就可以觀察到。</p><h4 id="留言區（Comments）"><a href="#留言區（Comments）" class="headerlink" title="留言區（Comments）"></a>留言區（Comments）</h4><p>前面的段落看到了 State （內部狀態）的使用，這邊則會看到 Props （外部傳入）的應用，以及動態產生元件時的運用。</p><figure class="highlight coffee"><figcaption><span>components/Comments.cjsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###</span></span><br><span class="line"><span class="comment"># Comments</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># @cjsx React.DOM</span></span><br><span class="line"><span class="comment">###</span></span><br><span class="line"></span><br><span class="line">React = <span class="built_in">require</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line">CommentStore = <span class="built_in">require</span> <span class="string">'../stores/CommentStore.coffee'</span> <span class="comment"># 後面也會實作 Store 的部分</span></span><br><span class="line">CommentAction = <span class="built_in">require</span> <span class="string">'../actions/CommentAction.coffee'</span></span><br><span class="line"></span><br><span class="line">CommentItem = <span class="built_in">require</span> <span class="string">'./CommentItem.cjsx'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = React.createClass &#123;</span><br><span class="line">  getInitialState: <span class="function">-&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">      comments: CommentStore.getAll() <span class="comment"># 初始化的時候從 Store 拿出目前儲存的資料</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _onChange: <span class="function">-&gt;</span></span><br><span class="line">    @setState &#123; comments: CommentStore.getAll() &#125; <span class="comment"># 更新目前儲存的資料</span></span><br><span class="line"></span><br><span class="line">  componentDidMount: <span class="function">-&gt;</span></span><br><span class="line">    CommentAction.load() <span class="comment"># 在元件被加入到頁面上時呼叫「讀取」動作進行 API 查詢</span></span><br><span class="line">    CommentStore.addChangeListener @_onChange <span class="comment"># 向 Store 登記「變更」事件以了解資料更新</span></span><br><span class="line"></span><br><span class="line">  componentWillUnmount: <span class="function">-&gt;</span></span><br><span class="line">    CommentStore.removeChangeListner @_onChange <span class="comment"># 當元件即將被移除時也解除事件監聽</span></span><br><span class="line"></span><br><span class="line">  generateCommentsItem: <span class="function">-&gt;</span></span><br><span class="line">    <span class="comment"># React.js 動態產生元件可以透過陣列的方式呈現，而每個元素則要給予一個 key 屬性</span></span><br><span class="line">    <span class="comment"># 這邊將狀態中儲存的留言資訊依序取出，然後放入對應的屬性</span></span><br><span class="line">    <span class="comment"># 這邊的 data.get() 用法是 Parse API 存取屬性的方式（一般情況使用 data.content 就可以了）</span></span><br><span class="line">    @state.comments.map (data) -&gt; </span><br><span class="line">      &lt;CommentItem key=&#123;data.id&#125; content=&#123;data.get(<span class="string">'content'</span>)&#125; createTime=&#123;data.get(<span class="string">'time'</span>).toString()&#125; /&gt;</span><br><span class="line"></span><br><span class="line">  render: <span class="function">-&gt;</span></span><br><span class="line">    (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;@generateCommentsItem()&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="留言內容（CommentItem）"><a href="#留言內容（CommentItem）" class="headerlink" title="留言內容（CommentItem）"></a>留言內容（CommentItem）</h4><p>這部分就沒有什麼好討論的，單純就是呈現上的應用（資料來自於屬性）</p><figure class="highlight coffee"><figcaption><span>components/CommentItem.cjsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###</span></span><br><span class="line"><span class="comment"># Comment Item</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># @cjsx React.DOM</span></span><br><span class="line"><span class="comment">###</span></span><br><span class="line"></span><br><span class="line">React = <span class="built_in">require</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = React.createClass &#123;</span><br><span class="line">  render: <span class="function">-&gt;</span></span><br><span class="line">    (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;@props.content&#125;&lt;/p&gt;</span><br><span class="line">        &lt;footer&gt;</span><br><span class="line">          &lt;span&gt;&#123;@props.createTime&#125;&lt;/span&gt;</span><br><span class="line">        &lt;/footer&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>這邊可以這樣想像「State」是一個私有屬性，只有元件自己可以操作。而「Props」則是 State 的變化體，只接受外部傳入的數值（父元件才有編輯的權限）這樣就比較能區分出使用上的時機</p></blockquote><h3 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h3><p>這邊會先解釋 Dispatcher 是因為後面的 Action 與 Store 都會需要使用到，因此必須先完成才能夠繼續進行。</p><blockquote><p>其實在實作元件之前先製作 Dispatcher 也沒有關係</p></blockquote><figure class="highlight coffee"><figcaption><span>Dispatcher.cjsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">###</span></span><br><span class="line"><span class="comment"># Dispatcher</span></span><br><span class="line"><span class="comment">###</span></span><br><span class="line"></span><br><span class="line">Dispatcher = <span class="built_in">require</span>(<span class="string">'flux'</span>).Dispatcher</span><br><span class="line"></span><br><span class="line"><span class="comment"># 簡單說就是做物件的繼承，在 Facebook 的範例會看到使用 Object.assign 去輔助</span></span><br><span class="line"><span class="comment"># 不過 Dispatcher 也可以利用 CoffeeScript 提供的 extends 來做擴充</span></span><br><span class="line"><span class="comment"># 後面的 Store 會因為要從 EventEmitter 的 prototype 繼承而無法做這件事情</span></span><br><span class="line"><span class="comment"># 關於 Object.assign 的用途，可以參考 ES6 相關文章的介紹</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDispatcher</span> <span class="keyword">extends</span> <span class="title">Dispatcher</span></span></span><br><span class="line">  handleViewAction: <span class="function"><span class="params">(action)</span> -&gt;</span> <span class="comment"># 擴充一個 handleViewAction 用來處理跟 View 相關的動作（大多數時候也只會有這一個）</span></span><br><span class="line">    @dispatch &#123; <span class="comment"># 觸發某些動作</span></span><br><span class="line">      source: <span class="string">'VIEW_ACTION'</span> <span class="comment"># 看到用全部大寫的物件，請合理猜測是使用 Constant 的時機（這邊文章都會用一般字串帶過）</span></span><br><span class="line">      action: action <span class="comment"># 將收到的動作物件一併傳給 Store</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> AppDispatcher</span><br></pre></td></tr></table></figure><h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>接下來我們要實作一個 Store 來儲存資料，至於該怎麼實作基本上是沒有限制的 Ex. Hash, Array 都可以</p><p>這裏會是這篇文章程式碼最多的一個部分，不過並不是什麼複雜的程式，大多數都是在描述「處理」事件上。</p><figure class="highlight coffee"><figcaption><span>stores/CommentStore.coffee</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">###</span></span><br><span class="line"><span class="comment"># CommentStore</span></span><br><span class="line"><span class="comment">###</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用 browserify 的功能，讓我們可以將 EventEmitter 在瀏覽器上實作（這個非常好用）</span></span><br><span class="line">EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter </span><br><span class="line"><span class="comment"># 如果是使用 ES6 就不需要這個輔助套件</span></span><br><span class="line">assign = <span class="built_in">require</span> <span class="string">'react/lib/Object.assign'</span> </span><br><span class="line"></span><br><span class="line">AppDispatcher = <span class="built_in">require</span> <span class="string">'../Dispatcher.coffee'</span></span><br><span class="line"></span><br><span class="line">_comments = [] <span class="comment"># 這邊用一個 Array 實作陣列的儲存（大多數時候從 API 撈出來也都是陣列，排序上可以依靠 API 而不需要自己處理，反而是專注在容易呈現會更好）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">dispather</span> = <span class="params">(payload)</span> -&gt;</span> <span class="comment"># 向 Dispatcher 登記需要一個處理程序，這部分就是在定義當 Dispatcher 被觸發時應該做什麼動作</span></span><br><span class="line">true<span class="comment"># 取出 Action 物件</span></span><br><span class="line">  <span class="comment"># Action 物件包含什麼都是看開發者高興的，只是我們通常會給一個 actionType 屬性</span></span><br><span class="line">  action = payload.action </span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> action.actionType <span class="comment"># 透過 actionType 屬性判斷該做什麼動作</span></span><br><span class="line">    <span class="keyword">when</span> <span class="string">'COMMENT_CREATE'</span> <span class="comment"># 這邊就是該用 Constant 的時候（這個範例會略過這個步驟）</span></span><br><span class="line">      _comments.unshift action.comment <span class="comment"># 在留言資料的最前面插入一筆（預設是逆序排序）</span></span><br><span class="line">      CommentStore.emitChange() <span class="comment"># 讓 Store 觸發 Change 事件通知 View 重新讀取</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">when</span> <span class="string">'COMMENT_LOAD'</span></span><br><span class="line">      _comments = action.comments <span class="comment"># 跟上面的 CREATE 不同，這次 action 包的是 comments （所有留言）</span></span><br><span class="line">      CommentStore.emitChange() <span class="comment"># 一樣要觸發 Change 事件讓 View 重新讀取</span></span><br><span class="line">      </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span> <span class="comment"># 這是非常重要的一行，如果沒有傳回 true 的話 Dispatcher 會判定任務失敗（Ex. 使用 waitFor 時造成中斷）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 這邊是將 EventEmitter.prototype 複製到一個空物件（並且作為我們後來的 Store）另一部分複製的就是我們目前正準備定義的方法</span></span><br><span class="line">CommentStore = assign &#123;&#125;, EventEmitter.prototype, &#123;</span><br><span class="line">  getAll: <span class="function">-&gt;</span></span><br><span class="line">    _comments</span><br><span class="line"></span><br><span class="line">  emitChange: <span class="function">-&gt;</span></span><br><span class="line">    @emit <span class="string">'CHANGE'</span></span><br><span class="line"></span><br><span class="line">  addChangeListener: <span class="function"><span class="params">(callback)</span> -&gt;</span></span><br><span class="line">    @on <span class="string">'CHANGE'</span>, callback</span><br><span class="line"></span><br><span class="line">  removeChangeListener: <span class="function"><span class="params">(callback)</span> -&gt;</span></span><br><span class="line">    @removeListener <span class="string">'CHANGE'</span>, callback</span><br><span class="line"></span><br><span class="line">  dispatherIndex: AppDispatcher.register( dispather ) <span class="comment"># 向 Dispatcher 登記（會拿到一個 ID 之後可以用於 watiFor 的應用）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = CommentStore</span><br></pre></td></tr></table></figure><p>表面上看起來似乎會覺得很複雜，不過稍微釐清思路之後其實也就是當 Dispatcher 送出一個 Callback 後做某些事情，再利用 Event 機制呼叫 View 上面的 Callback 而已。</p><blockquote><p>有沒有發現其實就是從 Action 開始呼叫 Dispatcher 然後再呼叫 Store 接著呼叫 View 呢？（而某些情況則會從 View 呼叫 Action 然後循環下去⋯⋯）</p></blockquote><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>其實我一直在思考「Ajax 的非同步 Callback 該在哪處理呢？」這個問題，最後得出的得答案是在 Action 裡面。<br>當收到 Response 之後，再決定對 Dispatcher 送些什麼 View Action 讓 Store 處理，最後反應在 View 上面。</p><figure class="highlight coffee"><figcaption><span>actions/CommentAction.coffee</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###</span></span><br><span class="line"><span class="comment"># Comment Action</span></span><br><span class="line"><span class="comment">###</span></span><br><span class="line"></span><br><span class="line">AppDispatcher = <span class="built_in">require</span> <span class="string">'../Dispatcher.coffee'</span></span><br><span class="line"></span><br><span class="line">Comment = Parse.Object.extend(<span class="string">"Comment"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  load: <span class="function">-&gt;</span></span><br><span class="line">    query = <span class="keyword">new</span> Parse.Query(Comment)</span><br><span class="line"></span><br><span class="line">    query.descending(<span class="string">'time'</span>).find(&#123; <span class="comment"># 排序上利用 Parse API 處理，而不是在 Store 中人工解決</span></span><br><span class="line">      success: <span class="function"><span class="params">(results)</span>-&gt;</span></span><br><span class="line">        AppDispatcher.handleViewAction &#123; <span class="comment"># 讓 Dispatcher 送出一個任務</span></span><br><span class="line">          actionType: <span class="string">'COMMENT_LOAD'</span></span><br><span class="line">          comments: results</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  create: <span class="function"><span class="params">(content)</span> -&gt;</span></span><br><span class="line">    comment = <span class="keyword">new</span> Comment</span><br><span class="line">    comment.save &#123;</span><br><span class="line">      content: content,</span><br><span class="line">      time: <span class="keyword">new</span> Date()</span><br><span class="line">    &#125;</span><br><span class="line">    .<span class="keyword">then</span> (object) -&gt;</span><br><span class="line">      AppDispatcher.handleViewAction &#123;</span><br><span class="line">        actionType: <span class="string">'COMMENT_CREATE'</span></span><br><span class="line">        comment: object</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本上就是 Parse API 的操作，官方文件都寫得很清楚，我就不多做討論了！</p><h3 id="Render"><a href="#Render" class="headerlink" title="Render"></a>Render</h3><p>最後就是呈現在網頁上，其實不難。</p><figure class="highlight coffee"><figcaption><span>app.cjsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###</span></span><br><span class="line"><span class="comment"># Application</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># @cjsx React.DOM</span></span><br><span class="line"><span class="comment">###</span></span><br><span class="line"></span><br><span class="line">React = <span class="built_in">require</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line">Guestbook = <span class="built_in">require</span> <span class="string">'./components/GuestBook.cjsx'</span></span><br><span class="line"></span><br><span class="line">Parse.initialize(<span class="string">"Application ID"</span>, <span class="string">"JavaScript Key"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function">-&gt;</span></span><br><span class="line">  React.render &lt;Guestbook /&gt;, <span class="built_in">document</span>.body</span><br></pre></td></tr></table></figure><p><code>React.render</code> 接收兩個參數，第一個是要 render 的元件，第二個是要放置的 DOM 元素。</p><p>簡單說，其實也可以這樣使用：</p><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">React.render &lt;Header /&gt;, <span class="built_in">document</span>.getElementById(<span class="string">"header"</span>)</span><br><span class="line">React.render &lt;Main /&gt;, <span class="built_in">document</span>.getElementById(<span class="string">"main"</span>)</span><br><span class="line">React.render &lt;Footer /&gt;, <span class="built_in">document</span>.getElementById(<span class="string">"footer"</span>)</span><br></pre></td></tr></table></figure><p>至於該如何運用，就取決於實際上的情況。</p><blockquote><p>我認為上面這種運用可以在網站從傳統的 Server-Client 轉變為 WebApp + API 架構的過渡期去應用<br>不用完整寫完 WebApp 就能開始套用，聽起來其實蠻不錯的。</p></blockquote><h3 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h3><p>這是冬季訓練大約花三小時講解的內容，做法是 Step by Step 並且在每個步驟講解。<br>如果是熟練的開發者，我想大概一個小時內就能夠做完或者更多的任務，至少就我的經驗來說，還沒有一個 WebApp Framework 可以讓我如此有彈性的開發（Ex. 可以用 <code>@getDOMNode()</code> 獲取原生的 DOM 做操作，在做整合 Library 時就很好用）</p><p>不過這幾年技術每天都在變化，像是當我熟悉 Flux 之後沒多久，又多了一個叫做 <a href="https://muut.com/riotjs/" rel="external nofollow noopener noreferrer" target="_blank">Riot.js</a> 的套件，說比 React.js 更輕量化（不過實際看過文件覺得沒有 React.js 這麼討喜）</p><p>雖然 React.js 在某些應用上非常的方便，不過我還是建議多學幾種應對不同的情況（不要都學到同一種情境的就好 XD）</p><footer class="article__footer"><div class="text-center"><div class="fb-share-button" data-href="https://blog.frost.tw/posts/2015/02/18/reactjs-parse-doing-simple-message-board/" data-layout="button_count"></div></div><p align="center"><a href="https://ko-fi.com/J3J78093" target="_blank" rel="external nofollow noopener noreferrer"><img height="36" style="border:0;height:36px" src="https://az743702.vo.msecnd.net/cdn/kofi5.png?v=0" border="0" alt="Buy Me a Coffee at ko-fi.com"></a></p><iframe scrolling="no" frameborder="0" style="display:block;margin:0 auto;height:212px" src="https://button.like.co/in/embed/elct9620/button?referrer=https://blog.frost.tw/posts/2015/02/18/reactjs-parse-doing-simple-message-board/"></iframe><ul class="article__tag-list"><li class="article__tag-list-item"><a class="article__tag-list-link" href="/tags/React-js/">React.js</a></li><li class="article__tag-list-item"><a class="article__tag-list-link" href="/tags/SITCON/">SITCON</a></li><li class="article__tag-list-item"><a class="article__tag-list-link" href="/tags/心得/">心得</a></li><li class="article__tag-list-item"><a class="article__tag-list-link" href="/tags/筆記/">筆記</a></li></ul></footer></div></article><div class="adv"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-2844969736316510" data-ad-slot="5530952976" data-ad-format="auto"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><section id="comment" class="comment-box"><h1 class="comment-box__title">留言</h1><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a rel="nofollow" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section></div><footer id="footer"><div id="copyright">&copy;2013 <a href="https://plus.google.com/117236344655673213049?rel=author" target="_blank" rel="external nofollow noopener noreferrer">蒼時弦也</a>. All right reversed.</div></footer><script type="text/javascript">window.disqus_shortname="revo-skill-frost",function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+window.disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5TQLRN" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><script>!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="//www.googletagmanager.com/gtm.js?id=GTM-5TQLRN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")</script><script>window.fbAsyncInit=function(){FB.init({appId:"178355449110",xfbml:!0,version:"v2.12"}),FB.AppEvents.logPageView()},function(e,n,t){var o,s=e.getElementsByTagName(n)[0];e.getElementById(t)||((o=e.createElement(n)).id=t,o.src="https://connect.facebook.net/zh_TW/sdk.js",o.async=!0,s.parentNode.insertBefore(o,s))}(document,"script","facebook-jssdk")</script><script src="/js/app.js"></script><div class="loading"></div></body></html>