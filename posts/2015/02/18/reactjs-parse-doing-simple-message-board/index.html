<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  
  <title>React.js + Parse 實做簡易留言板 | 弦而時習之</title>
  <meta name="theme-color" content="#EFEFEF">

  <meta name="author" content="蒼時弦也">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1">

  <meta name="description" content="前一陣子 SITCON 文創組冬季訓練最後一天，我安排了這個課程給我們的新成員。雖然 SITCON 文創組看似是個需要「技術」的團隊，不過現實上我們倒是花很多時間在思考跟設計上，沒辦法找到設計相關科系的新成員稍稍遺憾。 不過因為有製作網站的需求，因此安排了這個課程，透過學習 React.js 以及結合 Parse 去熟悉一些基本的前端技巧。 注意事項：  文中的範例全部都以 CoffeeScrip">
<meta name="keywords" content="心得,SITCON,筆記,React.js">
<meta property="og:type" content="article">
<meta property="og:title" content="React.js + Parse 實做簡易留言板">
<meta property="og:url" content="http://blog.frost.tw/posts/2015/02/18/reactjs-parse-doing-simple-message-board/">
<meta property="og:site_name" content="弦而時習之">
<meta property="og:description" content="前一陣子 SITCON 文創組冬季訓練最後一天，我安排了這個課程給我們的新成員。雖然 SITCON 文創組看似是個需要「技術」的團隊，不過現實上我們倒是花很多時間在思考跟設計上，沒辦法找到設計相關科系的新成員稍稍遺憾。 不過因為有製作網站的需求，因此安排了這個課程，透過學習 React.js 以及結合 Parse 去熟悉一些基本的前端技巧。 注意事項：  文中的範例全部都以 CoffeeScrip">
<meta property="og:locale" content="zh-TW">
<meta property="og:image" content="http://blog.frost.tw/icon-512.png">
<meta property="og:updated_time" content="2017-07-02T17:07:07.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="React.js + Parse 實做簡易留言板">
<meta name="twitter:description" content="前一陣子 SITCON 文創組冬季訓練最後一天，我安排了這個課程給我們的新成員。雖然 SITCON 文創組看似是個需要「技術」的團隊，不過現實上我們倒是花很多時間在思考跟設計上，沒辦法找到設計相關科系的新成員稍稍遺憾。 不過因為有製作網站的需求，因此安排了這個課程，透過學習 React.js 以及結合 Parse 去熟悉一些基本的前端技巧。 注意事項：  文中的範例全部都以 CoffeeScrip">
<meta name="twitter:image" content="http://blog.frost.tw/icon-512.png">
<link rel="publisher" href="https://plus.google.com/117236344655673213049">
<meta property="fb:app_id" content="205000946197077">

  <script type="application/ld+json">

{
  "@context":"http://schema.org",
  "@type":"Article",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://blog.frost.tw/posts/2015/02/18/reactjs-parse-doing-simple-message-board/"
  },
  "headline":"React.js + Parse 實做簡易留言板",
  "image": [
    
    "http://blog.frost.tw/icon-512.png"
  ],
  "datePublished": "2015-02-18T05:04:00.000Z",
  "dateModified": "2017-07-02T17:07:07.000Z",
  "description":"前一陣子 SITCON 文創組冬季訓練最後一天，我安排了這個課程給我們的新成員。雖然 SITCON 文創組看似是個需要「技術」的團隊，不過現實上我們倒是花很多時間在思考跟設計上，沒辦法找到設計相關科系的新成員稍稍遺憾。不過因為有製作網站的需求，因此安排了這個課程，透過學習 React.js 以及結合 Parse 去熟悉一些基本的前端技巧。注意事項：文中的範例全部都以 CoffeeScript 撰寫本文不會提及 Browserify 的配置與應用（當天有介紹過，練習時是使用我配置好的 gulp task）這是在不考慮 UI/UX 以及美術的前提下製作的文中不會解釋太多 React.js / Flux 的基本概念（請上官網 or ReactJS.tw 社團學習）那麼，就開始吧！",
  "author": {
    "@type": "Person",
    "name": "蒼時弦也"
  },
  "publisher": {
    "@type": "Organization",
    "name": "蒼時弦也",
    "logo": {
      "@type": "ImageObject",
      "url": "http://blog.forst.tw/logo-wide.png"
    }
  }
}

</script>


  <link href="/icon-512.png" rel="icon">
  <link rel="alternate" href="/feed.xml" title="弦而時習之" type="application/rss+xml">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <script async src="/js/turbolinks.js"></script>
</head>

  <body>
    <div id="fb-root" data-turbolinks-permanent></div>
    <header id="header">
      
<h1 id="sitename">
  <a href="/" class="hide-text logo--icon align-center">
  弦而時習之
  </a>
</h1>

<aside id="slogan" class="slogan align-center text-center">
  <h2 class="slogan__title">Aotokitsuruya</h2>
  <p class="slogan__description">The Web is attracting  me, so I start learning PHP, HTML, CSS and JavaScript. When I know about Ruby, I fall in love with it. Now, I working with my friend to design games using C++ and still learning web about Golang, Ruby and JavaScript. In the other side, I also be a designer, the reason why the web is attracted me.</p>
</aside>

    </header>
    <div id="wrapper">
      
<article class="post article">
  <header class="article__header">
    <time datetime="2015-02-18T05:04:00.000Z" class="article__time--header">
      Feb.18
    </time>
    
  
    <h1 class="article__title">React.js + Parse 實做簡易留言板</h1>
  


  </header>
  <div class="article__entry">
    
    <p>前一陣子 SITCON 文創組冬季訓練最後一天，我安排了這個課程給我們的新成員。<br>雖然 SITCON 文創組看似是個需要「技術」的團隊，不過現實上我們倒是花很多時間在思考跟設計上，沒辦法找到設計相關科系的新成員稍稍遺憾。</p>
<p>不過因為有製作網站的需求，因此安排了這個課程，透過學習 React.js 以及結合 Parse 去熟悉一些基本的前端技巧。</p>
<p>注意事項：</p>
<ol>
<li>文中的範例全部都以 CoffeeScript 撰寫</li>
<li>本文不會提及 Browserify 的配置與應用（當天有介紹過，練習時是使用我配置好的 gulp task）</li>
<li>這是在不考慮 UI/UX 以及美術的前提下製作的</li>
<li>文中不會解釋太多 React.js / Flux 的基本概念（請上官網 or ReactJS.tw 社團學習）</li>
</ol>
<p>那麼，就開始吧！</p>
<a id="more"></a>
<h3 id="拆分元件"><a href="#拆分元件" class="headerlink" title="拆分元件"></a>拆分元件</h3><p>React.js 的 Component（元件）的概念，某種程度上是需要重新定義大家腦中 HTML / JS / CSS 配合的概念，而這個應用方式在很多時候其實能夠幫我們解決不少問題。<br>（個人認為很像 <a href="http://w3c.Github.io/webcomponents/spec/shadow/" target="_blank" rel="noopener">Shadow DOM</a> 的感覺）</p>
<p>而 Component 該怎麼拆分呢？簡單來說最小單位就像是一個 <code>&lt;button&gt;</code> 都可以視為一個 Component 只是要看需求。</p>
<blockquote>
<p>我們可以利用 Component 重新去定義一個 HTML 元素的效果 Ex. &lt;a&gt; 的 onClick 事件重新定義，但是又可以重複利用</p>
</blockquote>
<p>建構一個留言板我們會需要幾個元件：</p>
<ul>
<li>留言板主體（通常會叫做 <code>Application</code> 或者 <code>App</code>）<ul>
<li>留言顯示區域<ul>
<li>單篇留言</li>
</ul>
</li>
<li>留言表單</li>
</ul>
</li>
</ul>
<p>以一個最低限度結構的留言板來說，至少需要這幾種元件才能夠構成。</p>
<p>其實仔細看，會發現基本上也就跟常見的 MVC 框架在拆分 View 的技巧感覺很類似。</p>
<blockquote>
<p>不過就如同前面所說的，有時候 Component 也用於「重新定義」某個 HTML 的元素效果。<br>像是 <code>react-bootstrap</code> 就利用重新定制的 <code>&lt;Nav&gt;</code> <code>&lt;MenuItem&gt;</code> 等來表現 Navbar（像是實際上都只是反映單個 HTML 元素而已）</p>
</blockquote>
<h3 id="架構"><a href="#架構" class="headerlink" title="架構"></a>架構</h3><p>以 React.js 本身來說，實際上是不足以製作一個完整的 WebApp 的，因此才加入了 Flux 這套理論（我想不適合視為 Library / Framework 而是跟 MVC 類似的理論比較恰當）</p>
<p>原本的 React.js 其實只有定義了 Component 以及來自外部的「屬性」表現內部的「狀態」而已，但是若要跟 API 溝通並且進行讀取與寫入資料該如何表現呢？</p>
<p>這時候透過 Flux 所定義的架構就可以很輕鬆的實踐。</p>
<blockquote>
<p>Flux 架構是一個單向的流程，不管如何一定會從 Actions 開始出發（有時候也會回到 Actions）但是絕不會有返回的狀況</p>
</blockquote>
<ul>
<li>Actions/<ul>
<li>通常是處理 API 的部分，會透過 Dispatcher 對 Store 做出操作</li>
</ul>
</li>
<li>Constants/<ul>
<li>定義 Action 類型的輔助套件（可以不實作，但是缺點會是很容易因為輸入錯誤的字串而無法正常運作）</li>
</ul>
</li>
<li>Components/<ul>
<li>React.js 所定義的元件，會監聽 Store 的變動更新自身</li>
</ul>
</li>
<li>Store/<ul>
<li>主要儲存資料的地方，透過從 Dispatcher 收到的變更進行處理</li>
</ul>
</li>
<li>Dispatcher<ul>
<li>負責指派工作（其中包含了 waitFor() 可以等待一連串的動作完成）</li>
</ul>
</li>
</ul>
<p>在開發 React.js/Flux 的 WebApp 時，只要注意自己的控制流程是否依循著 Action -&gt; Dispatcher -&gt; Store -&gt; View (Component) 就可以知道自己是否在做正確的設計。</p>
<h3 id="建構元件"><a href="#建構元件" class="headerlink" title="建構元件"></a>建構元件</h3><p>我個人的習慣是以 React.js 的元件開始做起，因為可以直接看到最終的成果（即使還沒有跟 API 連接上，但也能看到不少基本效果）</p>
<h4 id="主體（Application）"><a href="#主體（Application）" class="headerlink" title="主體（Application）"></a>主體（Application）</h4><p>因為是留言板，所以這邊我用了 <code>GuestBook.cjsx</code> 而非 <code>Application.cjsx</code> 作為檔名。</p>
<blockquote>
<p>大家可能會預設情況是「只能有一個 Application 存在頁面」但對於 React.js 來說只是把不同的 Virtual DOM 更新到實際的 DOM 上面，因此是可以在一個頁面做多次 <code>render</code> 動作混合 React.js 跟傳統網頁的</p>
</blockquote>
<figure class="highlight coffee"><figcaption><span>components/GuestBook.cjsx</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">###</span></div><div class="line"># GuestBook</div><div class="line">#</div><div class="line"># @cjsx React.DOM</div><div class="line">###</div><div class="line"></div><div class="line">React = <span class="built_in">require</span> <span class="string">'react'</span></div><div class="line"></div><div class="line">Comments = <span class="built_in">require</span> <span class="string">'./Comments.cjsx'</span> <span class="comment"># 這之後會實作</span></div><div class="line">CommentForm = <span class="built_in">require</span> <span class="string">'./CommentForm.cjsx'</span> <span class="comment"># 同上</span></div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = React.createClass &#123;</div><div class="line">  render: <span class="function">-&gt;</span></div><div class="line">    (</div><div class="line">      &lt;div&gt;</div><div class="line">        &lt;CommentForm /&gt;</div><div class="line">        &lt;Comments /&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    )</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>大多數時候主體框架只是用於把各種子元件讀取進來而已，因此看起來非常的簡單。</p>
<blockquote>
<p>要注意的是，因為 React.js 把一個原件視為一個 DOM 物件，因此回傳時務必不能同時傳回兩個元件（這邊就用 <code>div</code> 包起來）</p>
</blockquote>
<h4 id="留言表單（CommentForm）"><a href="#留言表單（CommentForm）" class="headerlink" title="留言表單（CommentForm）"></a>留言表單（CommentForm）</h4><p>表單的實作上比較簡單，留言部份還包含了另一個子元件「單篇留言」因此就到下一階段再進行處理。</p>
<figure class="highlight coffee"><figcaption><span>components/CommentForm.cjsx</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">###</span></div><div class="line"># Comment Form</div><div class="line">#</div><div class="line"># @cjsx React.DOM</div><div class="line">###</div><div class="line"></div><div class="line">React = <span class="built_in">require</span> <span class="string">'react'</span></div><div class="line"></div><div class="line">CommentAction = <span class="built_in">require</span> <span class="string">'../actions/CommentAction.coffee'</span> <span class="comment"># 後面會實作 Comment Action</span></div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = React.createClass &#123;</div><div class="line">  getInitialState: <span class="function">-&gt;</span></div><div class="line">  	<span class="comment"># React.js 的 State 都需要「事先定義」才能夠使用</span></div><div class="line">    &#123;</div><div class="line">      content: <span class="string">""</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">  _onSubmit: <span class="function"><span class="params">(e)</span> -&gt;</span> <span class="comment"># 處理 Submit 的方法（收到的 e 就跟原生 JavaScript 拿到的 Event 是相同的）</span></div><div class="line">    CommentAction.create(@state.content) <span class="comment"># 呼叫 Action 執行某個任務（新增留言）</span></div><div class="line">    @setState &#123; content: <span class="string">""</span> &#125;</div><div class="line"></div><div class="line">    e.preventDefault() <span class="comment"># 取消原有的表單送出動作</span></div><div class="line"></div><div class="line">  _onChange: <span class="function"><span class="params">(e)</span> -&gt;</span></div><div class="line">    <span class="comment"># 這算是一種小技巧，我們會發現在 _onSubmit 方法要取得 textarea 的內容是很困難的</span></div><div class="line">    <span class="comment"># 因此就隨時將表單內容存到狀態中（再次時做表單處理）用於送出時使用</span></div><div class="line">    <span class="comment"># 不過要注意的是後面的 textarea 設定了 value=&#123;@state.content&#125; 可以確保使用者輸入的跟送出的結果是相同的</span></div><div class="line">    @setState &#123; content: e.target.value &#125;</div><div class="line"></div><div class="line">  render: <span class="function">-&gt;</span></div><div class="line">    (</div><div class="line">      &lt;div&gt;</div><div class="line">        &lt;form onSubmit=&#123;@_onSubmit&#125;&gt;</div><div class="line">          &lt;textarea onChange=&#123;@_onChange&#125; placeholder=<span class="string">"Messages..."</span> value=&#123;@state.content&#125;&gt;&lt;/textarea&gt;</div><div class="line">          &lt;button type=<span class="string">"submit"</span>&gt;Submit&lt;/button&gt;</div><div class="line">        &lt;/form&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    )</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>實際上，在 React.js 中的元件設計都是很簡單的，從目前的兩個例子就可以觀察到。</p>
<h4 id="留言區（Comments）"><a href="#留言區（Comments）" class="headerlink" title="留言區（Comments）"></a>留言區（Comments）</h4><p>前面的段落看到了 State （內部狀態）的使用，這邊則會看到 Props （外部傳入）的應用，以及動態產生元件時的運用。</p>
<figure class="highlight coffee"><figcaption><span>components/Comments.cjsx</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">###</span></div><div class="line"># Comments</div><div class="line">#</div><div class="line"># @cjsx React.DOM</div><div class="line">###</div><div class="line"></div><div class="line">React = <span class="built_in">require</span> <span class="string">'react'</span></div><div class="line"></div><div class="line">CommentStore = <span class="built_in">require</span> <span class="string">'../stores/CommentStore.coffee'</span> <span class="comment"># 後面也會實作 Store 的部分</span></div><div class="line">CommentAction = <span class="built_in">require</span> <span class="string">'../actions/CommentAction.coffee'</span></div><div class="line"></div><div class="line">CommentItem = <span class="built_in">require</span> <span class="string">'./CommentItem.cjsx'</span></div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = React.createClass &#123;</div><div class="line">  getInitialState: <span class="function">-&gt;</span></div><div class="line">    &#123;</div><div class="line">      comments: CommentStore.getAll() <span class="comment"># 初始化的時候從 Store 拿出目前儲存的資料</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">  _onChange: <span class="function">-&gt;</span></div><div class="line">    @setState &#123; comments: CommentStore.getAll() &#125; <span class="comment"># 更新目前儲存的資料</span></div><div class="line"></div><div class="line">  componentDidMount: <span class="function">-&gt;</span></div><div class="line">    CommentAction.load() <span class="comment"># 在元件被加入到頁面上時呼叫「讀取」動作進行 API 查詢</span></div><div class="line">    CommentStore.addChangeListener @_onChange <span class="comment"># 向 Store 登記「變更」事件以了解資料更新</span></div><div class="line"></div><div class="line">  componentWillUnmount: <span class="function">-&gt;</span></div><div class="line">    CommentStore.removeChangeListner @_onChange <span class="comment"># 當元件即將被移除時也解除事件監聽</span></div><div class="line"></div><div class="line">  generateCommentsItem: <span class="function">-&gt;</span></div><div class="line">    <span class="comment"># React.js 動態產生元件可以透過陣列的方式呈現，而每個元素則要給予一個 key 屬性</span></div><div class="line">    <span class="comment"># 這邊將狀態中儲存的留言資訊依序取出，然後放入對應的屬性</span></div><div class="line">    <span class="comment"># 這邊的 data.get() 用法是 Parse API 存取屬性的方式（一般情況使用 data.content 就可以了）</span></div><div class="line">    @state.comments.map (data) -&gt; </div><div class="line">      &lt;CommentItem key=&#123;data.id&#125; content=&#123;data.get(<span class="string">'content'</span>)&#125; createTime=&#123;data.get(<span class="string">'time'</span>).toString()&#125; /&gt;</div><div class="line"></div><div class="line">  render: <span class="function">-&gt;</span></div><div class="line">    (</div><div class="line">      &lt;div&gt;</div><div class="line">        &#123;@generateCommentsItem()&#125;</div><div class="line">      &lt;/div&gt;</div><div class="line">    )</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="留言內容（CommentItem）"><a href="#留言內容（CommentItem）" class="headerlink" title="留言內容（CommentItem）"></a>留言內容（CommentItem）</h4><p>這部分就沒有什麼好討論的，單純就是呈現上的應用（資料來自於屬性）</p>
<figure class="highlight coffee"><figcaption><span>components/CommentItem.cjsx</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">###</span></div><div class="line"># Comment Item</div><div class="line">#</div><div class="line"># @cjsx React.DOM</div><div class="line">###</div><div class="line"></div><div class="line">React = <span class="built_in">require</span> <span class="string">'react'</span></div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = React.createClass &#123;</div><div class="line">  render: <span class="function">-&gt;</span></div><div class="line">    (</div><div class="line">      &lt;div&gt;</div><div class="line">        &lt;p&gt;&#123;@props.content&#125;&lt;/p&gt;</div><div class="line">        &lt;footer&gt;</div><div class="line">          &lt;span&gt;&#123;@props.createTime&#125;&lt;/span&gt;</div><div class="line">        &lt;/footer&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    )</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>這邊可以這樣想像「State」是一個私有屬性，只有元件自己可以操作。而「Props」則是 State 的變化體，只接受外部傳入的數值（父元件才有編輯的權限）這樣就比較能區分出使用上的時機</p>
</blockquote>
<h3 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h3><p>這邊會先解釋 Dispatcher 是因為後面的 Action 與 Store 都會需要使用到，因此必須先完成才能夠繼續進行。</p>
<blockquote>
<p>其實在實作元件之前先製作 Dispatcher 也沒有關係</p>
</blockquote>
<figure class="highlight coffee"><figcaption><span>Dispatcher.cjsx</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">###</span></div><div class="line"># Dispatcher</div><div class="line">###</div><div class="line"></div><div class="line">Dispatcher = <span class="built_in">require</span>(<span class="string">'flux'</span>).Dispatcher</div><div class="line"></div><div class="line"><span class="comment"># 簡單說就是做物件的繼承，在 Facebook 的範例會看到使用 Object.assign 去輔助</span></div><div class="line"><span class="comment"># 不過 Dispatcher 也可以利用 CoffeeScript 提供的 extends 來做擴充</span></div><div class="line"><span class="comment"># 後面的 Store 會因為要從 EventEmitter 的 prototype 繼承而無法做這件事情</span></div><div class="line"><span class="comment"># 關於 Object.assign 的用途，可以參考 ES6 相關文章的介紹</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDispatcher</span> <span class="keyword">extends</span> <span class="title">Dispatcher</span></span></div><div class="line">  handleViewAction: <span class="function"><span class="params">(action)</span> -&gt;</span> <span class="comment"># 擴充一個 handleViewAction 用來處理跟 View 相關的動作（大多數時候也只會有這一個）</span></div><div class="line">    @dispatch &#123; <span class="comment"># 觸發某些動作</span></div><div class="line">      source: <span class="string">'VIEW_ACTION'</span> <span class="comment"># 看到用全部大寫的物件，請合理猜測是使用 Constant 的時機（這邊文章都會用一般字串帶過）</span></div><div class="line">      action: action <span class="comment"># 將收到的動作物件一併傳給 Store</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> AppDispatcher</div></pre></td></tr></table></figure>
<h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>接下來我們要實作一個 Store 來儲存資料，至於該怎麼實作基本上是沒有限制的 Ex. Hash, Array 都可以</p>
<p>這裏會是這篇文章程式碼最多的一個部分，不過並不是什麼複雜的程式，大多數都是在描述「處理」事件上。</p>
<figure class="highlight coffee"><figcaption><span>stores/CommentStore.coffee</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">###</span></div><div class="line"># CommentStore</div><div class="line">###</div><div class="line"></div><div class="line"><span class="comment"># 利用 browserify 的功能，讓我們可以將 EventEmitter 在瀏覽器上實作（這個非常好用）</span></div><div class="line">EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter </div><div class="line"><span class="comment"># 如果是使用 ES6 就不需要這個輔助套件</span></div><div class="line">assign = <span class="built_in">require</span> <span class="string">'react/lib/Object.assign'</span> </div><div class="line"></div><div class="line">AppDispatcher = <span class="built_in">require</span> <span class="string">'../Dispatcher.coffee'</span></div><div class="line"></div><div class="line">_comments = [] <span class="comment"># 這邊用一個 Array 實作陣列的儲存（大多數時候從 API 撈出來也都是陣列，排序上可以依靠 API 而不需要自己處理，反而是專注在容易呈現會更好）</span></div><div class="line"><span class="function"></span></div><div class="line"><span class="title">dispather</span> = <span class="params">(payload)</span> -&gt; <span class="comment"># 向 Dispatcher 登記需要一個處理程序，這部分就是在定義當 Dispatcher 被觸發時應該做什麼動作</span></div><div class="line">true<span class="comment"># 取出 Action 物件</span></div><div class="line">  <span class="comment"># Action 物件包含什麼都是看開發者高興的，只是我們通常會給一個 actionType 屬性</span></div><div class="line">  action = payload.action </div><div class="line"></div><div class="line">  <span class="keyword">switch</span> action.actionType <span class="comment"># 透過 actionType 屬性判斷該做什麼動作</span></div><div class="line">    <span class="keyword">when</span> <span class="string">'COMMENT_CREATE'</span> <span class="comment"># 這邊就是該用 Constant 的時候（這個範例會略過這個步驟）</span></div><div class="line">      _comments.unshift action.comment <span class="comment"># 在留言資料的最前面插入一筆（預設是逆序排序）</span></div><div class="line">      CommentStore.emitChange() <span class="comment"># 讓 Store 觸發 Change 事件通知 View 重新讀取</span></div><div class="line"></div><div class="line">    <span class="keyword">when</span> <span class="string">'COMMENT_LOAD'</span></div><div class="line">      _comments = action.comments <span class="comment"># 跟上面的 CREATE 不同，這次 action 包的是 comments （所有留言）</span></div><div class="line">      CommentStore.emitChange() <span class="comment"># 一樣要觸發 Change 事件讓 View 重新讀取</span></div><div class="line">      </div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span> <span class="comment"># 這是非常重要的一行，如果沒有傳回 true 的話 Dispatcher 會判定任務失敗（Ex. 使用 waitFor 時造成中斷）</span></div><div class="line"></div><div class="line"><span class="comment"># 這邊是將 EventEmitter.prototype 複製到一個空物件（並且作為我們後來的 Store）另一部分複製的就是我們目前正準備定義的方法</span></div><div class="line">CommentStore = assign &#123;&#125;, EventEmitter.prototype, &#123;</div><div class="line">  getAll: <span class="function">-&gt;</span></div><div class="line">    _comments</div><div class="line"></div><div class="line">  emitChange: <span class="function">-&gt;</span></div><div class="line">    @emit <span class="string">'CHANGE'</span></div><div class="line"></div><div class="line">  addChangeListener: <span class="function"><span class="params">(callback)</span> -&gt;</span></div><div class="line">    @on <span class="string">'CHANGE'</span>, callback</div><div class="line"></div><div class="line">  removeChangeListener: <span class="function"><span class="params">(callback)</span> -&gt;</span></div><div class="line">    @removeListener <span class="string">'CHANGE'</span>, callback</div><div class="line"></div><div class="line">  dispatherIndex: AppDispatcher.register( dispather ) <span class="comment"># 向 Dispatcher 登記（會拿到一個 ID 之後可以用於 watiFor 的應用）</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = CommentStore</div></pre></td></tr></table></figure>
<p>表面上看起來似乎會覺得很複雜，不過稍微釐清思路之後其實也就是當 Dispatcher 送出一個 Callback 後做某些事情，再利用 Event 機制呼叫 View 上面的 Callback 而已。</p>
<blockquote>
<p>有沒有發現其實就是從 Action 開始呼叫 Dispatcher 然後再呼叫 Store 接著呼叫 View 呢？（而某些情況則會從 View 呼叫 Action 然後循環下去⋯⋯）</p>
</blockquote>
<h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>其實我一直在思考「Ajax 的非同步 Callback 該在哪處理呢？」這個問題，最後得出的得答案是在 Action 裡面。<br>當收到 Response 之後，再決定對 Dispatcher 送些什麼 View Action 讓 Store 處理，最後反應在 View 上面。</p>
<figure class="highlight coffee"><figcaption><span>actions/CommentAction.coffee</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">###</span></div><div class="line"># Comment Action</div><div class="line">###</div><div class="line"></div><div class="line">AppDispatcher = <span class="built_in">require</span> <span class="string">'../Dispatcher.coffee'</span></div><div class="line"></div><div class="line">Comment = Parse.Object.extend(<span class="string">"Comment"</span>)</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  load: <span class="function">-&gt;</span></div><div class="line">    query = <span class="keyword">new</span> Parse.Query(Comment)</div><div class="line"></div><div class="line">    query.descending(<span class="string">'time'</span>).find(&#123; <span class="comment"># 排序上利用 Parse API 處理，而不是在 Store 中人工解決</span></div><div class="line">      success: <span class="function"><span class="params">(results)</span>-&gt;</span></div><div class="line">        AppDispatcher.handleViewAction &#123; <span class="comment"># 讓 Dispatcher 送出一個任務</span></div><div class="line">          actionType: <span class="string">'COMMENT_LOAD'</span></div><div class="line">          comments: results</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">  create: <span class="function"><span class="params">(content)</span> -&gt;</span></div><div class="line">    comment = <span class="keyword">new</span> Comment</div><div class="line">    comment.save &#123;</div><div class="line">      content: content,</div><div class="line">      time: <span class="keyword">new</span> Date()</div><div class="line">    &#125;</div><div class="line">    .<span class="keyword">then</span> (object) -&gt;</div><div class="line">      AppDispatcher.handleViewAction &#123;</div><div class="line">        actionType: <span class="string">'COMMENT_CREATE'</span></div><div class="line">        comment: object</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>基本上就是 Parse API 的操作，官方文件都寫得很清楚，我就不多做討論了！</p>
<h3 id="Render"><a href="#Render" class="headerlink" title="Render"></a>Render</h3><p>最後就是呈現在網頁上，其實不難。</p>
<figure class="highlight coffee"><figcaption><span>app.cjsx</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">###</span></div><div class="line"># Application</div><div class="line">#</div><div class="line"># @cjsx React.DOM</div><div class="line">###</div><div class="line"></div><div class="line">React = <span class="built_in">require</span> <span class="string">'react'</span></div><div class="line"></div><div class="line">Guestbook = <span class="built_in">require</span> <span class="string">'./components/GuestBook.cjsx'</span></div><div class="line"></div><div class="line">Parse.initialize(<span class="string">"Application ID"</span>, <span class="string">"JavaScript Key"</span>);</div><div class="line"></div><div class="line"><span class="built_in">window</span>.onload = <span class="function">-&gt;</span></div><div class="line">  React.render &lt;Guestbook /&gt;, <span class="built_in">document</span>.body</div></pre></td></tr></table></figure>
<p><code>React.render</code> 接收兩個參數，第一個是要 render 的元件，第二個是要放置的 DOM 元素。</p>
<p>簡單說，其實也可以這樣使用：</p>
<figure class="highlight coffee"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">React.render &lt;Header /&gt;, <span class="built_in">document</span>.getElementById(<span class="string">"header"</span>)</div><div class="line">React.render &lt;Main /&gt;, <span class="built_in">document</span>.getElementById(<span class="string">"main"</span>)</div><div class="line">React.render &lt;Footer /&gt;, <span class="built_in">document</span>.getElementById(<span class="string">"footer"</span>)</div></pre></td></tr></table></figure>
<p>至於該如何運用，就取決於實際上的情況。</p>
<blockquote>
<p>我認為上面這種運用可以在網站從傳統的 Server-Client 轉變為 WebApp + API 架構的過渡期去應用<br>不用完整寫完 WebApp 就能開始套用，聽起來其實蠻不錯的。</p>
</blockquote>
<h3 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h3><p>這是冬季訓練大約花三小時講解的內容，做法是 Step by Step 並且在每個步驟講解。<br>如果是熟練的開發者，我想大概一個小時內就能夠做完或者更多的任務，至少就我的經驗來說，還沒有一個 WebApp Framework 可以讓我如此有彈性的開發（Ex. 可以用 <code>@getDOMNode()</code> 獲取原生的 DOM 做操作，在做整合 Library 時就很好用）</p>
<p>不過這幾年技術每天都在變化，像是當我熟悉 Flux 之後沒多久，又多了一個叫做 <a href="https://muut.com/riotjs/" target="_blank" rel="noopener">Riot.js</a> 的套件，說比 React.js 更輕量化（不過實際看過文件覺得沒有 React.js 這麼討喜）</p>
<p>雖然 React.js 在某些應用上非常的方便，不過我還是建議多學幾種應對不同的情況（不要都學到同一種情境的就好 XD）</p>

    
    <footer class="article__footer">
      
        <div class="text-center">
          <div class="fb-share-button"
               data-href="http://blog.frost.tw/posts/2015/02/18/reactjs-parse-doing-simple-message-board/"
               data-layout="button_count">
          </div>
        </div>
        <p align="center">
          <a href='https://ko-fi.com/J3J78093' target='_blank'>
            <img height='36' style='border:0px;height:36px;' src='https://az743702.vo.msecnd.net/cdn/kofi5.png?v=0' border='0' alt='Buy Me a Coffee at ko-fi.com' />
          </a>
        </p>
      
    </footer>
  </div>
</article>


  
    <div class="adv">
      <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
      <!-- 網誌_文末廣告 (Hexo) -->
      <ins class="adsbygoogle"
      style="display:block"
      data-ad-client="ca-pub-2844969736316510"
      data-ad-slot="5530952976"
      data-ad-format="auto"></ins>
      <script>
      (adsbygoogle = window.adsbygoogle || []).push({});
      </script>
    </div>
  

  
<section id="comment" class="comment-box">
  <h1 class="comment-box__title">留言</h1>

  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></noscript>
  </div>
</section>






    </div>
    <footer id="footer">
      <div id="copyright">
  &copy;2013 <a href="https://plus.google.com/117236344655673213049?rel=author" target="_blank">蒼時弦也</a>. All right reversed.
</div>

    </footer>
    

  
  <script type="text/javascript">
  var disqus_shortname = 'revo-skill-frost';

  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  }());
  </script>
  

  
  <!-- Google Tag Manager -->
  <noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5TQLRN"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-5TQLRN');</script>
  <!-- End Google Tag Manager -->
  

  <script>(function(d, s, id) {
      var js, fjs = d.getElementsByTagName(s)[0];
      if (d.getElementById(id)) return;
      js = d.createElement(s); js.id = id;
      js.src = 'https://connect.facebook.net/zh_TW/sdk.js#xfbml=1&version=v2.12&appId=205000946197077&autoLogAppEvents=1';
      fjs.parentNode.insertBefore(js, fjs);
      }(document, 'script', 'facebook-jssdk'));</script>

  <script src="/js/app.js"></script>


    <div class="loading"></div>
  </body>
</html>
