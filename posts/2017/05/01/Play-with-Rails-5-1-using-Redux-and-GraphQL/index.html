<!DOCTYPE html>
<html lang="zh-TW" >
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>用 Redux 跟 GraphQL 玩 Rails 5.1 | 弦而時習之</title>
  <meta name="theme-color" content="#EFEFEF">

  <meta name="author" content="蒼時弦也">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <meta name="description" content="上週五在處理網址續費的時候，發現幫老爸公司管理的網址已經多到一個程度。所以就決定把手邊可以轉移的服務都往 Gandi 丟過去。畢竟粗略估算可以達到 Grid B 的費率（實際上只有九五折）不過考量到有 API 能夠管理，以及一些自動化的手段，雖然相對還是稍微貴了一點，但是省去後續不少麻煩確實是有利的。 也因為這樣，就打算以串 Gandi 的 API 來練手一下，原本是想做完管理 Domain 的部">
<meta name="keywords" content="Rails,Redux,GraphQL">
<meta property="og:type" content="article">
<meta property="og:title" content="用 Redux 跟 GraphQL 玩 Rails 5.1">
<meta property="og:url" content="https://blog.frost.tw/posts/2017/05/01/Play-with-Rails-5-1-using-Redux-and-GraphQL/">
<meta property="og:site_name" content="弦而時習之">
<meta property="og:description" content="上週五在處理網址續費的時候，發現幫老爸公司管理的網址已經多到一個程度。所以就決定把手邊可以轉移的服務都往 Gandi 丟過去。畢竟粗略估算可以達到 Grid B 的費率（實際上只有九五折）不過考量到有 API 能夠管理，以及一些自動化的手段，雖然相對還是稍微貴了一點，但是省去後續不少麻煩確實是有利的。 也因為這樣，就打算以串 Gandi 的 API 來練手一下，原本是想做完管理 Domain 的部">
<meta property="og:locale" content="zh-TW">
<meta property="og:image" content="http://blog.frost.tw/icon-512.png">
<meta property="og:updated_time" content="2017-07-02T17:07:07.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="用 Redux 跟 GraphQL 玩 Rails 5.1">
<meta name="twitter:description" content="上週五在處理網址續費的時候，發現幫老爸公司管理的網址已經多到一個程度。所以就決定把手邊可以轉移的服務都往 Gandi 丟過去。畢竟粗略估算可以達到 Grid B 的費率（實際上只有九五折）不過考量到有 API 能夠管理，以及一些自動化的手段，雖然相對還是稍微貴了一點，但是省去後續不少麻煩確實是有利的。 也因為這樣，就打算以串 Gandi 的 API 來練手一下，原本是想做完管理 Domain 的部">
<meta name="twitter:image" content="http://blog.frost.tw/icon-512.png">
<link rel="publisher" href="https://plus.google.com/117236344655673213049">
<meta property="fb:app_id" content="178355449110">

  <meta property="fb:pages" content="180666522388">
  <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Blog",
    "name": "弦而時習之",
    "url": "https://blog.frost.tw",
    "image": "http://blog.frost.tw/icon-512.png",
    "description": "蒼時弦也的個人網誌，專注在前端、後端以及遊戲開發，大多使用 Ruby 和 Ruby on Rails 以及 Golang、JS 和 C 語言。",
    "sameAs": [
      "https://www.facebook.com/frost.tw/"
    ]
}
</script>
<script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Person",
    "name": "蒼時弦也",
    "url": "https://blog.frost.tw",
    "sameAs": [
      "https://www.facebook.com/elct9620",
      "https://www.instagram.com/elct9620/",
      "https://twitter.com/elct9620",
      "https://plus.google.com/+%E8%92%BC%E6%99%82%E5%BC%A6%E4%B9%9F-plus",
      "https://www.linkedin.com/in/elct9620"
    ]
}
</script>


<script type="application/ld+json">
{
  "@context":"http://schema.org",
  "@type":"Article",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://blog.frost.tw/posts/2017/05/01/Play-with-Rails-5-1-using-Redux-and-GraphQL/"
  },
  "headline":"用 Redux 跟 GraphQL 玩 Rails 5.1",
  "image": [
    
    "http://blog.frost.tw/icon-512.png"
  ],
  "datePublished": "2017-05-01T15:09:40.000Z",
  "dateModified": "2017-07-02T17:07:07.000Z",
  "description":"上週五在處理網址續費的時候，發現幫老爸公司管理的網址已經多到一個程度。所以就決定把手邊可以轉移的服務都往 Gandi 丟過去。畢竟粗略估算可以達到 Grid B 的費率（實際上只有九五折）不過考量到有 API 能夠管理，以及一些自動化的手段，雖然相對還是稍微貴了一點，但是省去後續不少麻煩確實是有利的。也因為這樣，就打算以串 Gandi 的 API 來練手一下，原本是想做完管理 Domain 的部分，不過沒想到在實作一些技術面上的東西花了不少時間，只做完簡單的價格查詢。",
  "author": {
    "@type": "Person",
    "name": "蒼時弦也"
  },
  "publisher": {
    "@type": "Organization",
    "name": "蒼時弦也",
    "logo": {
      "@type": "ImageObject",
      "url": "http://blog.forst.tw/logo-wide.png"
    }
  }
}
</script>
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
    "@type": "ListItem",
    "position": 1,
    "item": {
      "@id": "https://blog.frost.tw",
      "name": "弦而時習之 ",
      "image": "http://blog.frost.tw/icon-512.png"
    }
  },{
    "@type": "ListItem",
    "position": 2,
    "item": {
      "@id": "https://blog.frost.tw/posts/2017/05/01/Play-with-Rails-5-1-using-Redux-and-GraphQL/",
      "name": "用 Redux 跟 GraphQL 玩 Rails 5.1",
      "image": "http://blog.frost.tw/icon-512.png"
    }
  }]
}
</script>




  
  <link rel="canonical" href="https://blog.frost.tw/posts/2017/05/01/Play-with-Rails-5-1-using-Redux-and-GraphQL/">
  
  <link href="/icon-512.png" rel="icon">
  <link rel="alternate" href="/feed.xml" title="弦而時習之" type="application/rss+xml">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <script async src="/js/turbolinks.js"></script>
</head>

  <body>
    <div id="fb-root" data-turbolinks-permanent></div>
    <header id="header">
      
<h1 id="sitename">
  <a href="/" class="hide-text logo--icon align-center">
  弦而時習之
  </a>
</h1>

<aside id="slogan" class="slogan align-center text-center">
  <h2 class="slogan__title">Aotokitsuruya</h2>
  <p class="slogan__description">The Web is attracting  me, so I start learning PHP, HTML, CSS and JavaScript. When I know about Ruby, I fall in love with it. Now, I working with my friend to design games using C++ and still learning web about Golang, Ruby and JavaScript. In the other side, I also be a designer, the reason why the web is attracted me.</p>
</aside>

    </header>
    <div id="wrapper">
      
<article class="post article">
  <header class="article__header">
    <time datetime="2017-05-01T15:09:40.000Z" class="article__time--header">
      May.01
    </time>
    
  
    <h1 class="article__title">用 Redux 跟 GraphQL 玩 Rails 5.1</h1>
  


  </header>
  <div class="article__entry">
    
    <p>上週五在處理網址續費的時候，發現幫老爸公司管理的網址已經多到一個程度。所以就決定把手邊可以轉移的服務都往 Gandi 丟過去。畢竟粗略估算可以達到 Grid B 的費率（實際上只有九五折）不過考量到有 API 能夠管理，以及一些自動化的手段，雖然相對還是稍微貴了一點，但是省去後續不少麻煩確實是有利的。</p>
<p>也因為這樣，就打算以串 Gandi 的 API 來練手一下，原本是想做完管理 Domain 的部分，不過沒想到在實作一些技術面上的東西花了不少時間，只做完簡單的價格查詢。</p>
<a id="more"></a>
<p>根據我的習慣，我通常會在新專案使用新的技術，這次是使用 Rails 5.1 支援 Webpack 的功能搭配上 Redux 和 GraphQL 來應用。我學 React 的時間是在 Redux 出來之前，所以一直都使用手刻 Flux 架構的方式去寫。</p>
<p>而 GraphQL 之前因為沒有成熟的 Ruby Gem 也一直沒有去碰，最近除了有相容 Rails 之外，也出現了透過 ActiveRecord 的 Association Reflect 去解決 GraphQL 會出現 N+1 問題的 Gem 讓我總算是下定決心去嘗試看看。</p>
<p>這個專案我自己的規劃是這樣的：</p>
<ul>
<li>Dashboard<ul>
<li>Domain Manager<ul>
<li>Auto Renew</li>
<li>DNS Zone<ul>
<li>CloudFlare Intergate</li>
</ul>
</li>
<li>DNSSEC</li>
</ul>
</li>
<li>SSL Manager<ul>
<li>Auto Renew</li>
<li>Auto Deploy</li>
</ul>
</li>
</ul>
</li>
<li><p>API</p>
<ul>
<li>GraphQL (Front-end)</li>
<li>RESTFul API (3rd-party)</li>
</ul>
<p>大致上定位是基於 Gandi 給的 API 做自動化的管理，以及在一些服務上的部署可以有效率的處理（會整合 DevOps 之類的）</p>
</li>
</ul>
<hr>
<p>不過既然要買網址，所以就需要先了解 Gandi 上的收費以及可以購買的網址。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem <span class="string">'gandi'</span></span><br></pre></td></tr></table></figure>
<p>運氣不錯，已經有人將原本的 XMLRPC API 封裝成一個 Gem 可以用很簡單的方式來操作。</p>
<blockquote>
<p>如果像我一樣使用 Ruby 2.4 因為 XMLRPC 已經從 Core 移除，所要自行追加 <code>gem &#39;xmlrpc&#39;</code> 來補齊功能。</p>
</blockquote>
<p>這個 Gem 的使用方法大致上如下：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">api = Gandi::Session.new(ENV[<span class="string">'GANDI_API_TOKEN'</span>])</span><br><span class="line">api.domain.list <span class="comment"># 顯示帳號下所有的 Domain</span></span><br></pre></td></tr></table></figure>
<p>不過對於 Rails 來說其實不容易使用，既然是第三方的 API 就先封裝成一個 Service 物件比較容易處理。<br>至於建立 API Client 實例的動作也可以封裝一下方便使用。</p>
<figure class="highlight ruby"><figcaption><span>config/initializers/gandi.rb</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frozen_string_literal: true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># :nodoc:</span></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Gandi</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">api</span></span></span><br><span class="line">    options = &#123;&#125;</span><br><span class="line">    options[<span class="symbol">:env</span>] = <span class="symbol">:test</span> <span class="keyword">unless</span> Rails.env.production?</span><br><span class="line">    @api <span class="params">||</span>= Gandi::Session.new(Settings.gandi.token, options)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>我習慣會使用 <code>SettingsLogic</code> 這個 Gem 來管理設定，這邊也可以將 <code>Settings.gandi.token</code> 替換成 <code>ENV[&#39;GANDI_API_TOKEN&#39;]</code>  之類的。</p>
<blockquote>
<p>因為 Gandi 有提供測試環境，所以在非 Production 時一律採用測試環境。</p>
</blockquote>
<p>接下來就是封裝 Gandi 的價格查詢（<code>Catalog</code>）成為一個 Service 供系統使用（可能是歐洲服務商的關係，API 相當慢，在本地端足存一份副本會好很多。）</p>
<figure class="highlight ruby"><figcaption><span>app/services/domain/price_services.rb</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frozen_string_literal: true</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Domain</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">PriceService</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(currency = <span class="symbol">:EUR</span>, grid = <span class="symbol">:A</span>)</span></span></span><br><span class="line">        @currency = currency</span><br><span class="line">        @grid = grid</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query</span><span class="params">(query)</span></span></span><br><span class="line">        query = &#123;<span class="symbol">product:</span> query.merge(<span class="symbol">type:</span> <span class="symbol">:domain</span>)&#125;</span><br><span class="line">        Gandi.api.catalog.list(query, @currency, @grid)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">all</span></span></span><br><span class="line">        query(&#123;&#125;)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>基本上就是對原本的 Gandi 做簡單的封裝，現在透過 <code>Domain::PriceService.new.all</code> 就可以輕鬆存取到需要的價格資訊。<br>不過因為要匯入到本地的資料庫，回傳的資料結構並不是我所期望的狀況，所以就再做了一層封裝。</p>
<figure class="highlight ruby"><figcaption><span>app/services/domain/price_services.rb</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frozen_string_literal: true</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Domain</span></span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">PriceService</span></span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Result</span> &lt; Array</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">to_domain</span></span></span><br><span class="line">                map &#123; <span class="params">|item|</span> build_domain(item) &#125;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            private</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">build_domain</span><span class="params">(item)</span></span></span><br><span class="line">                CatalogDomain.new(</span><br><span class="line">                    <span class="symbol">description:</span> item.product.description,</span><br><span class="line">                    <span class="symbol">action:</span> item.action.name.parameterize(<span class="symbol">separator:</span> <span class="string">'_'</span>),</span><br><span class="line">                    <span class="symbol">phase:</span> item.action&amp;.params&amp;.tld_phase,</span><br><span class="line">                    <span class="symbol">price:</span> convert_to_price(item),</span><br><span class="line">                    <span class="symbol">grid:</span> item.unit_price.first.grid</span><br><span class="line">                )</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">convert_to_price</span><span class="params">(item)</span></span></span><br><span class="line">                Money.from_amout(</span><br><span class="line">                    item.unit_price.first.price,</span><br><span class="line">                    item.unit_price.first.currency</span><br><span class="line">                )</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 略</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">query</span><span class="params">(query)</span></span></span><br><span class="line">            <span class="comment"># ...</span></span><br><span class="line">            Result.new(Gandi.api.catalog.list(query, @currency, @grid))</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>如此一來，我就可以用 <code>Domain::PriceService.new.all.to_domain</code> 轉成對應的 Model 方便匯入的動作。</p>
<ul>
<li>Gandi 這個 Gem 已經用 Hashie 封裝過，所以可以透過類似物件的方式存取屬性</li>
<li>因為主要是使用的是台幣，但是也希望儲存不同幣種的價格所以使用了 <code>Money</code> Gem 的功能</li>
</ul>
<p>至於 Model 的部分就不多論敘，不過因為域名的資料現在有約 4000 筆，所以需要借助 <code>activerecord-import</code> 這個 Gem 做一次性的匯入，即使透過 Rails 的 Batch 功能也沒有辦法高效率的做匯入。</p>
<p>不過，在 Gandi 回傳的資料會有以下情況。</p>
<ul>
<li><code>action</code> 的差異：新增、轉入、續約等等</li>
<li><code>phase</code> 的差異：已上線、日升期等等（域名術語，日升期這類是給商標註冊者購買或者預先用高價保留域名用的）</li>
</ul>
<p>所以如果再沒有對這些欄位增加限制的話，就會碰到匯入時重複的問題而發生錯誤。</p>
<p>所以在寫 Migration 的時候要補上下面的索引來增加限制。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_index [<span class="symbol">:description</span>, <span class="symbol">:action</span>, <span class="symbol">:phase</span>, <span class="symbol">:currency</span>, <span class="symbol">:grid</span>],</span><br><span class="line">          <span class="symbol">name:</span> <span class="symbol">:catalog_domain_constriant</span>,</span><br><span class="line">          <span class="symbol">unique:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>要這樣做的理由，是因為 <code>activerecord-import</code> 支援 <code>ON CONFLICT</code> 的 SQL 語法，在 PostgreSQL 上可以在碰到重複的資料改為對特定欄位更新，而不是插入一筆資料。</p>
<p>於是就可以撰寫一個 Rake Task 來處理定期同步價格的任務。</p>
<figure class="highlight ruby"><figcaption><span>lib/tasks/domain.rb</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frozen_string_literal: true</span></span><br><span class="line"></span><br><span class="line">namespace <span class="symbol">:domain</span> <span class="keyword">do</span></span><br><span class="line">  desc <span class="string">'Load domain prices from Gandi'</span></span><br><span class="line">  task <span class="symbol">:refresh</span>, [<span class="symbol">:currency</span>, <span class="symbol">:grid</span>] =&gt; [<span class="symbol">:environment</span>] <span class="keyword">do</span> <span class="params">|_, args|</span></span><br><span class="line">    currency = args[<span class="symbol">:currency</span>] <span class="params">||</span> <span class="symbol">:EUR</span></span><br><span class="line">    grid = args[<span class="symbol">:grid</span>] <span class="params">||</span> <span class="symbol">:A</span></span><br><span class="line">    domains = Domain::PriceService.new(currency, grid).all.to_domain</span><br><span class="line">    CatalogDomain.import domains, <span class="symbol">on_duplicate_key_update:</span> &#123;</span><br><span class="line">      <span class="symbol">conflict_target:</span> [<span class="symbol">:description</span>, <span class="symbol">:action</span>, <span class="symbol">:phase</span>, <span class="symbol">:grid</span>, <span class="symbol">:currency</span>],</span><br><span class="line">      <span class="symbol">columns:</span> [<span class="symbol">:price</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    puts <span class="string">"Total <span class="subst">#&#123;domains.size&#125;</span> rows in <span class="subst">#&#123;currency&#125;</span> loaded."</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>透過 <code>on_duplicate_key_update</code> 的設定，就可以在碰到相同的資料時只更新價格，如此一來就可以利用 CronJob 來每天同步當日最新的價格資訊。</p>
<p>到此為止，就「域名資料」的部分就算是已經處理完畢了。</p>
<p>接下來對 GraphQL 設定，依照教學配置好之後，要先讓 GraphQL 可以支援顯示我們需要的資料。</p>
<figure class="highlight ruby"><figcaption><span>app/graphql/types/query_type.rb</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frozen_string_literal: true</span></span><br><span class="line"></span><br><span class="line">Types::QueryType = GraphQL::ObjectType.define <span class="keyword">do</span></span><br><span class="line">  name <span class="string">'Query'</span></span><br><span class="line"></span><br><span class="line">  field <span class="symbol">:domains</span> <span class="keyword">do</span></span><br><span class="line">    type types[Types::CatalogDomainType]</span><br><span class="line">    argument <span class="symbol">:tld</span>, types.String</span><br><span class="line">    resolve -&gt;(obj, args, ctx) &#123;</span><br><span class="line">      <span class="keyword">if</span> args[<span class="symbol">:tld</span>]</span><br><span class="line">        CatalogDomain.where(<span class="string">'description LIKE ?'</span>, <span class="string">"%<span class="subst">#&#123;args[<span class="symbol">:tld</span>]&#125;</span>%"</span>)</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        CatalogDomain.all</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>這邊先簡單的支援查詢域名的功能，先不討論透過幣種或者價格來查詢，先讓使用者可以查詢現有可以註冊的域名有哪些類型即可。</p>
<blockquote>
<p>至於 <code>CatalogDomainType</code> 只是單純的設定欄位而已，這邊就跳過不多做討論。</p>
</blockquote>
<p>另外似乎是因為資料蠻多的關係，連生成 JSON 都有點慢，所以這邊額外設定了 <code>oj</code> 這個 Gem 來加速（大約是十倍快）</p>
<figure class="highlight ruby"><figcaption><span>config/initializers/oj.rb</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frozen_string_literal: true</span></span><br><span class="line"></span><br><span class="line">Oj::Rails.set_encoder</span><br><span class="line">Oj::Rails.set_decoder</span><br><span class="line">Oj::Rails.optimize(Array, BigDecimal, Hash, Range, Regexp, Time)</span><br></pre></td></tr></table></figure>
<p>到這邊，我們的 Backend 就全部完成處置，接下來就是要讓前端可以使用這些資料來呈現。</p>
<p>首先到原本的 Layout 上面追加 Webpack 的 JS 檔案。<br>（預設還是傳統的方式，所以要手動加上由 Webpack 生成的版本）</p>
<figure class="highlight erb"><figcaption><span>app/views/layout/application.html.erb</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- 略 ---&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">%=</span></span></span><span class="ruby"> javascript_pack_tag    <span class="string">'application'</span> </span><span class="xml"><span class="tag">%&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 略 ---&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>接下來開啟 Rails 的 Webpack 伺服器（<code>./bin/webpack-dev-server</code>）之前使用 beta1 的時候還有 Watcher 的選項，不過正式版似乎去掉了，不過用 dev-server 效果基本上是相同的。</p>
<blockquote>
<p>要注意的是，強烈不建議 Webpack 跟原本的 Sprocket 混用，除了自己會搞混之外，原有的 ExecJS 也挺容易出錯的，統一寫在 <code>app/javascript/packs</code> 會是不錯的選擇。</p>
</blockquote>
<p>接下來安裝一下需要的套件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add react redux react-redux react-dom redux-observable rxjs prop-types immutable redux-thunk</span><br></pre></td></tr></table></figure>
<blockquote>
<p>關於 UI 互動上，我偏向 RxJS 的解法，所以採用的是 <code>redux-observable</code> 的方式，至於 <code>redux-thunk</code> 因為不熟，大多教學都會裝一下，所以這邊單純跟風。</p>
</blockquote>
<p>首先，先來處理 Reducer 的部分，這邊直接利用 Immutable 的 <code>fromJS</code> 直接把資料轉換。不過筆數這麼多的情況下，其實是不建議這樣做的，不過暫時還沒有找到恰當的處理方式，所以就先這樣做。</p>
<figure class="highlight js"><figcaption><span>app/javascript/packs/reducers/domain.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; List, fromJS &#125; <span class="keyword">from</span> <span class="string">'immutable'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  QUERY_DOMAIN,</span><br><span class="line">  RECEIVED_DOMAIN,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'../constriants'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initState = <span class="built_in">Map</span>(&#123;</span><br><span class="line">  fetching: <span class="literal">true</span>,</span><br><span class="line">  domains: List([]),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> domainReducer = <span class="function">(<span class="params">state = initState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> START_REQUEST: &#123;</span><br><span class="line">      <span class="keyword">return</span> state.set(<span class="string">'fetching'</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> FINISHED_REQUEST: &#123;</span><br><span class="line">      <span class="keyword">return</span> state.set(<span class="string">'fetching'</span>, <span class="literal">false</span>)</span><br><span class="line">                  .set(<span class="string">'data'</span>, fromJS(action.response.data.domains));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> domainReducer;</span><br></pre></td></tr></table></figure>
<p>關於 <code>constriants</code> 就不多做說明，從以前的習慣就是會開一個目錄（或者檔案）把全部的 Action Type 統一塞在裡面管理，雖然說直接寫字串沒什麼問題，但是難免出錯，這種統一管理的方式倒是可以避免一些人為疏失。</p>
<p>接下來對 Action 做處理。</p>
<figure class="highlight js"><figcaption><span>app/javascript/packs/action/domain.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ajax &#125; <span class="keyword">from</span> <span class="string">'rxjs/observable/dom/ajax'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'rxjs'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  QUERY_DOMAIN,</span><br><span class="line">  RECEIVED_DOMAIN,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'../constriants'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ENDPOINT = <span class="string">'/graphql'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> queryDomain = <span class="function"><span class="params">query</span> =&gt;</span> (</span><br><span class="line">  &#123;</span><br><span class="line">    type: QUERY_DOMAIN,</span><br><span class="line">    payload: <span class="built_in">JSON</span>.stringify(&#123; query &#125;),</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> receivedDomain = <span class="function"><span class="params">response</span> =&gt;</span> (</span><br><span class="line">  &#123;</span><br><span class="line">    type: RECEIVED_DOMAIN,</span><br><span class="line">    response,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> queryDomainEpic = <span class="function"><span class="params">action$</span> =&gt;</span> (</span><br><span class="line">  action$.ofType(QUERY_DOMAIN)</span><br><span class="line">         .debounceTime(<span class="number">1000</span>)</span><br><span class="line">         .mergeMap(<span class="function"><span class="params">action</span> =&gt;</span></span><br><span class="line">           ajax(&#123; <span class="attr">url</span>: ENDPOINT, <span class="attr">method</span>: <span class="string">'POST'</span>, <span class="attr">headers</span>: &#123; <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span> &#125;, <span class="attr">body</span>: action.payload &#125;)</span><br><span class="line">           .map(<span class="function"><span class="params">result</span> =&gt;</span> receivedDomain(result.response)),</span><br><span class="line">         )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>基本上跟一般的 Redux 沒有太大的差別，比較特別的是以 <code>Epic</code> 結尾的這個動作，這個就是 <code>redux-observable</code> 所提供的特殊 Action 行為，可以把它視為 Action 的管理者。</p>
<p>裡面的實作則是透過 RxJS 所實現的，簡單說就是碰到 <code>QUERY_DOMAIN</code> 類型的動作，先等待 1000ms 確認沒有其他操作後，用「最後一次」的操作繼續，並且合併另一個動作（Ajax 查詢）繼續進行。</p>
<p>此時的 <code>QUERY_DOMAIN</code> 被觸發後，會再等待被合併的 Ajax 查詢完成後才一起回傳。而這個 Ajax 查詢則是我們要做的 GraphQL 查詢。</p>
<p>接下來把焦點放到查詢畫面的元件上，這邊我們只討論做 Dispatch 的這個動作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="keyword">this</span>.props.dispatch(startRequest(<span class="string">'&#123;domains &#123; description, price, currency &#125;&#125;'</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">onSearchChange() &#123;</span><br><span class="line">  <span class="keyword">const</span> tld = <span class="keyword">this</span>.text.input.value;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">search</span>: tld &#125;);</span><br><span class="line">  <span class="keyword">this</span>.props.dispatch(</span><br><span class="line">    startRequest(<span class="string">`&#123;domains(tld: "<span class="subst">$&#123;tld&#125;</span>") &#123; description, price, currency &#125;&#125;`</span>),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>實際上也是很淺顯易懂的，在前面的 Action 中我們是採取直接將整個 GraphQL 傳入的方式，所以在觸發動作時也是直接將查詢寫到裡面。</p>
<blockquote>
<p>還不熟悉 Redux 綁定輸入框的方式，因為有點晚了所以直接用 <code>ref</code> 的做法做綁定。</p>
</blockquote>
<p>到這邊眼尖讀者可能會發現，我們並沒有去呼叫 <code>queryDomainEpic</code> 但是似乎卻自己運作起來了，這部分是 <code>redux-observable</code> 的特性，也就是說我們將呼叫實際動作的任務交給 <code>Epic</code> 來管理。</p>
<p>最後要統整一下所有的 <code>Epic</code> 整合到 Redux 裡面（跟 Reducers 類似）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const epics = combineEpics(queryDomainEpic);</span><br><span class="line">const epicMiddleware = createEpicMiddleware(epics);</span><br><span class="line"></span><br><span class="line">const store = createStore(</span><br><span class="line">    applyMiddleware(epicMiddleware),</span><br><span class="line">    reducers</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>接下來就會正常運作了！</p>
<hr>
<p>其實這樣的進度大約花了快一天左右的時間，雖然中間有跑去設定 <code>pry</code> 跟打遊戲之類的，不過整體上來說要反覆的把 Redux 練熟之外，還要掌握 GraphQL 的應用，也是要花上不少時間在上面的。</p>
<p>不過學技術就是這樣，當原本的技術熟悉到一個程度後，做起來當然是非常熟練的。不過如果不願意花時間在新技術上，就會一直沒辦法便的熟練，雖然目前有遊戲跟很多坑的關係，其實也不太能練新技術。但是有機會的話，還是會想在各種專案上做一些嘗試，來看看自己到底能做到怎麼樣的效果。</p>
<p>這篇文章大多是省略了查文件就可以做到的部分，所以看起來挺簡單的。不過要查完文件後再踩雷之後做出來，倒也是一件不太容易的事情。不過 Rails 5.1 提供了 Webpack 環境以及一些好用的 Gem 倒是大大改善不少在這部分所浪費掉的時間。</p>
<p>雖然沒有如預期的完成到最基本可以購買域名，但是整體上來說倒是累積了不少經驗。</p>

    
    <footer class="article__footer">
      
        <div class="text-center">
          <div class="fb-share-button" data-href="https://blog.frost.tw/posts/2017/05/01/Play-with-Rails-5-1-using-Redux-and-GraphQL/" data-layout="button_count">
          </div>
        </div>
        <p align="center">
          <a href="https://ko-fi.com/J3J78093" target="_blank">
            <img height="36" style="border:0px;height:36px;" src="https://az743702.vo.msecnd.net/cdn/kofi5.png?v=0" border="0" alt="Buy Me a Coffee at ko-fi.com">
          </a>
        </p>
        <iframe scrolling="no" frameborder="0" style="display: block; margin: 0 auto; height: 212px;" src="https://button.like.co/in/embed/elct9620/button?referrer=https://blog.frost.tw/posts/2017/05/01/Play-with-Rails-5-1-using-Redux-and-GraphQL/"></iframe>
        
          <ul class="article__tag-list"><li class="article__tag-list-item"><a class="article__tag-list-link" href="/tags/GraphQL/">GraphQL</a></li><li class="article__tag-list-item"><a class="article__tag-list-link" href="/tags/Rails/">Rails</a></li><li class="article__tag-list-item"><a class="article__tag-list-link" href="/tags/Redux/">Redux</a></li></ul>
        
      
    </footer>
  </div>
</article>


  
    <div class="adv">
      <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
      <!-- 網誌_文末廣告 (Hexo) -->
      <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-2844969736316510" data-ad-slot="5530952976" data-ad-format="auto"></ins>
      <script>
      (adsbygoogle = window.adsbygoogle || []).push({});
      </script>
    </div>
  

  
<section id="comment" class="comment-box">
  <h1 class="comment-box__title">留言</h1>

  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>






    </div>
    <footer id="footer">
      <div id="copyright">
  &copy;2013 <a href="https://plus.google.com/117236344655673213049?rel=author" target="_blank">蒼時弦也</a>. All right reversed.
</div>

    </footer>
    

  <script type="text/javascript">
  window.disqus_shortname = 'revo-skill-frost';

  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + window.disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  }());
  
  </script>

  
  <!-- Google Tag Manager -->
  <noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5TQLRN" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-5TQLRN');</script>
  <!-- End Google Tag Manager -->
  

  <script>
    window.fbAsyncInit = function() {
      FB.init({
        appId      : '178355449110',
        xfbml      : true,
        version    : 'v2.12'
      });

      FB.AppEvents.logPageView();

    };

    (function(d, s, id){
       var js, fjs = d.getElementsByTagName(s)[0];
       if (d.getElementById(id)) {return;}
       js = d.createElement(s); js.id = id;
       js.src = "https://connect.facebook.net/zh_TW/sdk.js";
       js.async = true
       fjs.parentNode.insertBefore(js, fjs);
     }(document, 'script', 'facebook-jssdk'));
  </script>

  <script src="/js/app.js"></script>


    <div class="loading"></div>
  </body>
</html>
