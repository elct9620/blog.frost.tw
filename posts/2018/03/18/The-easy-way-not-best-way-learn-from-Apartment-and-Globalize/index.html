<!DOCTYPE html>
<html lang="zh-TW">
  <head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>Apartment 與 Globalize 隱藏在方便背後的陷阱 | 弦而時習之</title>
  <meta name="theme-color" content="#EFEFEF">

  <meta name="author" content="蒼時弦也">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <meta name="description" content="手邊有一個專案剛好是需要滿足「多網站」並且每個網站都能夠「多語言切換」這兩個條件，在這兩個解決方案中最好處理的就是 Apartment 和 Globalize 這兩個 Ruby Gem 了。 不過，在某些情況卻變成了問題。幸好運氣不錯的是還在開發階段，還有辦法將這個問題透過替換 Gem 進行修正。">
<meta name="keywords" content="筆記,Ruby on Rails,Gem">
<meta property="og:type" content="article">
<meta property="og:title" content="Apartment 與 Globalize 隱藏在方便背後的陷阱">
<meta property="og:url" content="https://blog.frost.tw/posts/2018/03/18/The-easy-way-not-best-way-learn-from-Apartment-and-Globalize/">
<meta property="og:site_name" content="弦而時習之">
<meta property="og:description" content="手邊有一個專案剛好是需要滿足「多網站」並且每個網站都能夠「多語言切換」這兩個條件，在這兩個解決方案中最好處理的就是 Apartment 和 Globalize 這兩個 Ruby Gem 了。 不過，在某些情況卻變成了問題。幸好運氣不錯的是還在開發階段，還有辦法將這個問題透過替換 Gem 進行修正。">
<meta property="og:locale" content="zh-TW">
<meta property="og:image" content="http://blog.frost.tw/icon-512.png">
<meta property="og:updated_time" content="2019-06-29T15:43:47.223Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Apartment 與 Globalize 隱藏在方便背後的陷阱">
<meta name="twitter:description" content="手邊有一個專案剛好是需要滿足「多網站」並且每個網站都能夠「多語言切換」這兩個條件，在這兩個解決方案中最好處理的就是 Apartment 和 Globalize 這兩個 Ruby Gem 了。 不過，在某些情況卻變成了問題。幸好運氣不錯的是還在開發階段，還有辦法將這個問題透過替換 Gem 進行修正。">
<meta name="twitter:image" content="http://blog.frost.tw/icon-512.png">
<link rel="publisher" href="https://plus.google.com/117236344655673213049">
<meta property="fb:app_id" content="178355449110">

  <meta property="fb:pages" content="180666522388">
  <script type="application/ld+json">
  [
{
    "@context": "https://schema.org",
    "@type": "Blog",
    "name": "弦而時習之",
    "url": "https://blog.frost.tw",
    "image": "http://blog.frost.tw/icon-512.png",
    "description": "蒼時弦也的個人網誌，專注在前端、後端以及遊戲開發，大多使用 Ruby 和 Ruby on Rails 以及 Golang、JS 和 C 語言。",
    "sameAs": [
      "https://www.facebook.com/frost.tw/"
    ]
},
{
    "@context": "https://schema.org",
    "@type": "Person",
    "name": "蒼時弦也",
    "url": "https://blog.frost.tw",
    "sameAs": [
      "https://www.facebook.com/elct9620",
      "https://www.instagram.com/elct9620/",
      "https://twitter.com/elct9620",
      "https://plus.google.com/+%E8%92%BC%E6%99%82%E5%BC%A6%E4%B9%9F-plus",
      "https://www.linkedin.com/in/elct9620"
    ]
},
{
  "@context":"https://schema.org",
  "@type":"BlogPosting",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://blog.frost.tw/posts/2018/03/18/The-easy-way-not-best-way-learn-from-Apartment-and-Globalize/"
  },
  "headline":"Apartment 與 Globalize 隱藏在方便背後的陷阱",
  "image": [
    
    "http://blog.frost.tw/icon-512.png"
  ],
  
  "datePublished": "2018-03-18T15:59:56.000Z",
  "dateModified": "2019-06-29T15:43:47.223Z",
  "description":"手邊有一個專案剛好是需要滿足「多網站」並且每個網站都能夠「多語言切換」這兩個條件，在這兩個解決方案中最好處理的就是 Apartment 和 Globalize 這兩個 Ruby Gem 了。不過，在某些情況卻變成了問題。幸好運氣不錯的是還在開發階段，還有辦法將這個問題透過替換 Gem 進行修正。",
  "author": {
    "@type": "Person",
    "name": "蒼時弦也"
  },
  "publisher": {
    "@type": "Organization",
    "name": "蒼時弦也",
    "logo": "https://blog.frost.tw/icon-512.png"
  }
},
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
    "@type": "ListItem",
    "position": 1,
    "item": {
      "@id": "https://blog.frost.tw",
      "name": "弦而時習之 ",
      "image": "http://blog.frost.tw/icon-512.png"
    }
  },{
    "@type": "ListItem",
    "position": 2,
    "item": {
      "@id": "https://blog.frost.tw/posts/2018/03/18/The-easy-way-not-best-way-learn-from-Apartment-and-Globalize/",
      "name": "Apartment 與 Globalize 隱藏在方便背後的陷阱",
      "image": "http://blog.frost.tw/icon-512.png"
    }
  }]
}
,
{
"@context": "https://schema.org",
  "@type": "Organization",
  "name": "蒼時弦也",
  "url": "https://blog.frost.tw",
  "logo": "https://blog.frost.tw/icon-512.png"
}
]
</script>



  <link rel="canonical" href="https://blog.frost.tw/posts/2018/03/18/The-easy-way-not-best-way-learn-from-Apartment-and-Globalize/">
  <link href="/icon-512.png" rel="icon">
  <link rel="alternate" href="/feed.xml" title="弦而時習之" type="application/rss+xml">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <script async src="/js/turbolinks.js"></script>
  
  
</head>

  <body>
    <div id="fb-root" data-turbolinks-permanent></div>
    <header id="header">
      
<h1 id="sitename">
  <a href="/" class="hide-text logo--icon align-center">
  弦而時習之
  </a>
</h1>

<aside id="slogan" class="slogan align-center text-center">
  <h2 class="slogan__title">Aotokitsuruya</h2>
  <p class="slogan__description">The Web is attracting  me, so I start learning PHP, HTML, CSS and JavaScript. When I know about Ruby, I fall in love with it. Now, I working with my friend to design games using C++ and still learning web about Golang, Ruby and JavaScript. In the other side, I also be a designer, the reason why the web is attracted me.</p>
</aside>

    </header>
    <div id="wrapper">
      
<article class="post article">
  <header class="article__header">
    <time datetime="2018-03-18T15:59:56.000Z" class="article__time--header">
      Mar.18
    </time>
    
  
    <h1 class="article__title">Apartment 與 Globalize 隱藏在方便背後的陷阱</h1>
  


  </header>
  <div class="article__entry">
    
    <p>手邊有一個專案剛好是需要滿足「多網站」並且每個網站都能夠「多語言切換」這兩個條件，在這兩個解決方案中最好處理的就是 Apartment 和 Globalize 這兩個 Ruby Gem 了。</p>
<p>不過，在某些情況卻變成了問題。幸好運氣不錯的是還在開發階段，還有辦法將這個問題透過替換 Gem 進行修正。</p>
<a id="more"></a>
<p>首先，我們先來大概了解 Apartment 和 Globalize 這兩個 Ruby Gem 是擔任怎樣的任務。</p>
<h2 id="Apartment"><a href="#Apartment" class="headerlink" title="Apartment"></a>Apartment</h2><p>Apartment 是一個 Multi-Tenancy (多租戶) 的套件，可以協助我們利用同樣的程式碼架設功能完全相同的多個網站。在一般的解決方案來說，就是自動切換連接的資料庫來達成這個效果。</p>
<p>另外，在 PostgreSQL 中則有 <a href="https://www.postgresql.org/docs/9.5/static/ddl-schemas.html" rel="external nofollow noopener noreferrer" target="_blank">Schema</a> 這個機制，可以讓我們在同一個資料庫做出類似 Namespace （命名空間）的效果。</p>
<p>透過 <code>SET SEARCH_PATH = &#39;site1, public&#39;</code> 的設定後，當我們嘗試 <code>SELECT * FROM users</code> 的時候，就會先去找 <code>site1.users</code> 再去找 <code>public.users</code> （預設）的資料表，這對開發多用戶類型的系統有相當大的優勢。</p>
<blockquote>
<p>不過這在大規模的網站（像是 Shopify 之類服務）在 Ruby on Rails 上就不會是個好選擇，會有效能和記憶體上的瓶頸。所以在設計上要考量應用的情境和規模。</p>
</blockquote>
<h2 id="Globalize"><a href="#Globalize" class="headerlink" title="Globalize"></a>Globalize</h2><p>Globalize 可以幫助我們對 Model 設定，讓特定幾個欄位的值能夠依照當下 <code>I18n.locale</code> 設定的數值來自動反映出不同語言的呈現。原理上來說其實也相當簡單，他會產生一個 <code>post_translations</code> 資料表，並且記錄語言和需要翻譯的欄位。</p>
<p>使用方法如下：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Post</span> &lt; ApplicationRecord</span></span><br><span class="line">  translates <span class="symbol">:title</span>, <span class="symbol">:content</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>如此一來就能夠自動的呈現出對應的語言（如果有存到對應語言的資料）</p>
<h2 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h2><p>會發生問題其實是稍微特殊的案例，因為這個專案需要針對每次的活動產生一個新網站，但是又需要支援多語言。原本想要支援多語言，其實我們可以單純用 Apartment 去開設不同語言的網站。</p>
<p>但是因為這個「機制」被開設活動網站所佔用，所以我們只好借用 Globalize 的功能來完成多語言的呈現。</p>
<p>一般的使用上並不會有問題，不過當我們碰到「共用」的資料表（不管在哪個網站都會用這張資料表），就會發生問題。</p>
<p>因為是多網站，所以需要有一張表儲存目前存在的網站：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Apartment.configure <span class="keyword">do</span> <span class="params">|config|</span></span><br><span class="line">  config.excluded_models = <span class="string">%w[Site]</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>因為每個網站的名稱都需要有中文和英文版本，所以很自然的補上了翻譯的設定：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Site</span> &lt; ApplicationRecord</span></span><br><span class="line"> translates <span class="symbol">:name</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>還有將 Migration 資訊也設定後，嘗試運行 <code>rake db:migrate</code> <strong>表現上</strong>是正常的。不過這是在<strong>完全沒有 Site 資料</strong>的情況下。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">up</span></span></span><br><span class="line">  Site.create_translation_table!(</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="symbol">name:</span> <span class="symbol">:string</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="symbol">migrate_data:</span> <span class="literal">true</span></span><br><span class="line">  )</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>當我們在做 Migrate 的時候，是不希望遺失資料。所以會將 <code>migrate_data</code> 選項開啟，不過這也造成了第一個我們發現第一個問題——Globalize 生成的 <code>CREATE TABLE</code> 是錯誤的。</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>從 Globalize 的<a href="https://github.com/globalize/globalize/blob/master/lib/globalize/active_record/migration.rb#L81" rel="external nofollow noopener noreferrer" target="_blank">原始碼</a>可以看到下面這段：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.references table_name.sub(<span class="regexp">/^<span class="subst">#&#123;table_name_prefix&#125;</span>/</span>, <span class="string">''</span>).singularize, <span class="symbol">:null</span> =&gt; <span class="literal">false</span>, <span class="symbol">:index</span> =&gt; <span class="literal">false</span>, <span class="symbol">:type</span> =&gt; column_type(model.primary_key).to_sym</span><br></pre></td></tr></table></figure>
<p>他會依據對應的 Model 來取出 <code>table_name</code> 這個參數，但是 <code>table_name</code> 因為 Apartment 要確保他是切換在正確的網站上，所以會從 <code>sites</code> 變成了 <code>public.sites</code> 來避免出問題。</p>
<p>基於這樣的設計，原本應該是要叫做 <code>site_id</code> 的欄位名稱，就變成了 <code>public.site_id</code> 存在於資料庫上。當 Globalize 嘗試把原本在 <code>sites</code> 資料表上的 <code>name</code> 欄位複製到翻譯的資料表上時，運行的 SQL 查詢就會恢復正常。</p>
<p>因為 Apartment 是對資料表層級的調整，所以在這樣的狀態下，在 Ruby on Rails 中的 ActiveRecord 預期會有的 <code>site_id</code> 欄位變成了 <code>public.site_id</code> 就會發生「找不到欄位」的錯誤。</p>
<p>不過這個問題並沒有想像中的困難，從原始碼可以看到清除 <code>table_name_prefix</code> 的機制。我們可以善加利用這個特性，在執行 Migrate 的階段暫時性的設定 <code>table_name_prefix</code> 在 Model 上就能正常運行。</p>
<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>不過，當 <code>Site</code> 是跨網站的資料表時，我們也預期 <code>Site::Translation</code> 這個由 Globalize 動態生成的 Model 也應該要是跨網站的（否則 Apartment 會因為沒有指定到共用資料表，而無法取得正確的翻譯資訊。）</p>
<p>所以我們理所當然的增加了這樣的設定：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Apartment.configure <span class="keyword">do</span> <span class="params">|config|</span></span><br><span class="line">  config.excluded_models = <span class="string">%w[Site Site::Translation]</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>這時候我們再次執行 <code>rake db:migrate</code> 卻發現出現了「資料表已存在」的錯誤。仔細一看，又是 Globalize 生成錯誤的 <code>CREATE TABLE</code> 查詢。</p>
<blockquote>
<p>注意，這是在 Site 有存在資料的情況下，因為 Apartment 在已存在的 Schema 會採取跑 Migrate 的方式更新資料結構。</p>
</blockquote>
<p>來去追查原因，原來在產生翻譯資料表 <code>site_translations</code> 的時候，資料表名稱是透過一個叫做 <code>translations_table_name</code> 的方法所定義，而這個方法則源自於 Globalize 對 Model 的擴充。</p>
<p>從 Globalize <a href="https://github.com/globalize/globalize/blob/master/lib/globalize/active_record/class_methods.rb#L51" rel="external nofollow noopener noreferrer" target="_blank">原始碼</a>可以發現：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">translation_class</span></span></span><br><span class="line">  @translation_class <span class="params">||</span>= <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.const_defined?(<span class="symbol">:Translation</span>, <span class="literal">false</span>)</span><br><span class="line">      klass = <span class="keyword">self</span>.const_get(<span class="symbol">:Translation</span>, <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      klass = <span class="keyword">self</span>.const_set(<span class="symbol">:Translation</span>, Class.new(Globalize::ActiveRecord::Translation))</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    klass.belongs_to <span class="symbol">:globalized_model</span>,</span><br><span class="line">      <span class="symbol">class_name:</span> <span class="keyword">self</span>.name,</span><br><span class="line">      <span class="symbol">foreign_key:</span> translation_options[<span class="symbol">:foreign_key</span>],</span><br><span class="line">      <span class="symbol">inverse_of:</span> <span class="symbol">:translations</span>,</span><br><span class="line">      <span class="symbol">touch:</span> translation_options.fetch(<span class="symbol">:touch</span>, <span class="literal">false</span>)</span><br><span class="line">    klass</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">translations_table_name</span></span></span><br><span class="line">  translation_class.table_name</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>他會透過剛剛動態生成的 <code>Site::Translation</code> Model 來推斷該用什麼當做資料表的名稱。在正常的狀況下，我們會理所當然的認為是 <code>site_translations</code>。</p>
<p>不過，我們使用的是 Apartment 來產生多網站的效果，也就是說名稱會變成 <code>site1.site_translations</code> 但是因為我們剛剛又設定了這是一張「共用資料表」所以就被改為 <code>public.site_translations</code> 了。</p>
<p>到目前為止其實都沒有問題，不過 Apartment 為了讓維護資料表是簡單的，所以實際上每一個網站的資料表會是完全一樣（直接重複所有 Migrate 動作，即使沒用到）</p>
<p>假設我們有 10 筆 Site 資料，那們就會變成嘗試 <code>CREATE TABLE</code> 10 次 <code>public.site_translations</code> 這個資料表，也就理所當然地會出現「資料表已存在」的錯誤。</p>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>身為 Ruby on Rails 開發者，我們通常習慣於採取「已知可行」的現有解決方案，透過社群的力量共同維護一份穩定的套件來對應各種不同的情況。也因此，我們經常性地將很多細節封裝起來，造成許多人並不了解其底層的運作原理。</p>
<p>這也是為什麼會踩到這個陷阱的原因，因為即使是兩個知名的 Ruby Gem 兩邊的團隊也不見得會預想到「有人會想這樣使用」也不會去採取對應的措施。</p>
<p>可以的話，盡可能的進行事前的評估和測試（雖然本文的案例其實有點極端），就可以避免不少方法。</p>
<blockquote>
<p>最後的解法是替換成使用 PostgreSQL JSON 欄位特性的 Gem 避開產生新資料表的問題，更換後的成本需要擔心的大概是 SQL 查詢受影響的程度。</p>
</blockquote>

    
    <footer class="article__footer">
      
        <div class="text-center">
          <div class="fb-share-button" data-href="https://blog.frost.tw/posts/2018/03/18/The-easy-way-not-best-way-learn-from-Apartment-and-Globalize/" data-layout="button_count">
          </div>
        </div>
        <div class="text-center mt-1">
          <style>.bmc-button img{width: 27px !important;margin-bottom: 1px !important;box-shadow: none !important;border: none !important;vertical-align: middle !important;}.bmc-button{line-height: 36px !important;height:37px !important;text-decoration: none !important;display:inline-flex !important;color:#ffffff !important;background-color:#000000 !important;border-radius: 3px !important;border: 1px solid transparent !important;padding: 1px 9px !important;font-size: 22px !important;letter-spacing:0.6px !important;box-shadow: 0px 1px 2px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;margin: 0 auto !important;font-family:'Cookie', cursive !important;-webkit-box-sizing: border-box !important;box-sizing: border-box !important;-o-transition: 0.3s all linear !important;-webkit-transition: 0.3s all linear !important;-moz-transition: 0.3s all linear !important;-ms-transition: 0.3s all linear !important;transition: 0.3s all linear !important;}.bmc-button:hover, .bmc-button:active, .bmc-button:focus {-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;text-decoration: none !important;box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;opacity: 0.85 !important;color:#ffffff !important;}</style><link href="https://fonts.googleapis.com/css?family=Cookie" rel="stylesheet"><a class="bmc-button" target="_blank" href="https://www.buymeacoffee.com/aotoki" rel="external nofollow noopener noreferrer"><img src="https://bmc-cdn.nyc3.digitaloceanspaces.com/BMC-button-images/BMC-btn-logo.svg" alt="Buy me a Coffee"><span style="margin-left:5px">Buy me a Coffee</span></a>
        </div>
        <iframe scrolling="no" frameborder="0" style="display: block; margin: 0 auto; height: 212px;" src="https://button.like.co/in/embed/elct9620/button?referrer=https://blog.frost.tw/posts/2018/03/18/The-easy-way-not-best-way-learn-from-Apartment-and-Globalize/"></iframe>
        
          <ul class="article__tag-list"><li class="article__tag-list-item"><a class="article__tag-list-link" href="/tags/Gem/">Gem</a></li><li class="article__tag-list-item"><a class="article__tag-list-link" href="/tags/Ruby-on-Rails/">Ruby on Rails</a></li><li class="article__tag-list-item"><a class="article__tag-list-link" href="/tags/筆記/">筆記</a></li></ul>
        
      
    </footer>
  </div>
</article>


  
    <div class="adv">
      <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
      <!-- 網誌_文末廣告 (Hexo) -->
      <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-2844969736316510" data-ad-slot="5530952976" data-ad-format="auto"></ins>
      <script>
      (adsbygoogle = window.adsbygoogle || []).push({});
      </script>
    </div>
  

  
<section id="comment" class="comment-box">
  <h1 class="comment-box__title">留言</h1>

  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a rel="nofollow" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>






    </div>
    <footer id="footer">
      <div id="copyright">
  &copy;2013 <a href="https://plus.google.com/117236344655673213049?rel=author" target="_blank" rel="external nofollow noopener noreferrer">蒼時弦也</a>. All right reversed.
</div>

    </footer>
    

  <script type="text/javascript">
  window.disqus_shortname = 'revo-skill-frost';

  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + window.disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  }());
  
  </script>

  
  <!-- Google Tag Manager -->
  <noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5TQLRN" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-5TQLRN');</script>
  <!-- End Google Tag Manager -->
  

  <script>
    window.fbAsyncInit = function() {
      FB.init({
        appId      : '178355449110',
        xfbml      : true,
        version    : 'v2.12'
      });

      FB.AppEvents.logPageView();

    };

    (function(d, s, id){
       var js, fjs = d.getElementsByTagName(s)[0];
       if (d.getElementById(id)) {return;}
       js = d.createElement(s); js.id = id;
       js.src = "https://connect.facebook.net/zh_TW/sdk.js";
       js.async = true
       fjs.parentNode.insertBefore(js, fjs);
     }(document, 'script', 'facebook-jssdk'));
  </script>

  <script src="/js/app.js"></script>


    <div class="loading"></div>
  </body>
</html>
