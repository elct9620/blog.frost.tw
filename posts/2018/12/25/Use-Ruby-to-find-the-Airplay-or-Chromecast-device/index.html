<!DOCTYPE html>
<html lang="zh-TW">
  <head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>用 Ruby 來尋找區網中的 Airplay、Chromecast | 弦而時習之</title>
  <meta name="theme-color" content="#EFEFEF">

  <meta name="author" content="蒼時弦也">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <meta name="description" content="從雲端開始熱門起來後，為了能能讓提供不同服務的伺服器能夠被自動的偵測，我們在許多雲端相關的工具都會看到 Service Discovery 這個名詞。 不過，除了雲端上的服務能夠透過這樣的機制互相「發現」對方，我們也可以在區網中用類似的方法找到「提供服務」的裝置。 這就要從 mDNS (Multicast DNS) 和 DNS-SD (DNS-based Service Discovery) 開始">
<meta name="keywords" content="心得,Ruby,mDNS,DNS-SD">
<meta property="og:type" content="article">
<meta property="og:title" content="用 Ruby 來尋找區網中的 Airplay、Chromecast">
<meta property="og:url" content="https://blog.frost.tw/posts/2018/12/25/Use-Ruby-to-find-the-Airplay-or-Chromecast-device/">
<meta property="og:site_name" content="弦而時習之">
<meta property="og:description" content="從雲端開始熱門起來後，為了能能讓提供不同服務的伺服器能夠被自動的偵測，我們在許多雲端相關的工具都會看到 Service Discovery 這個名詞。 不過，除了雲端上的服務能夠透過這樣的機制互相「發現」對方，我們也可以在區網中用類似的方法找到「提供服務」的裝置。 這就要從 mDNS (Multicast DNS) 和 DNS-SD (DNS-based Service Discovery) 開始">
<meta property="og:locale" content="zh-TW">
<meta property="og:image" content="https://blog.frost.tw/images/2018-12-25-use-ruby-to-find-the-airplay-or-chromecast-device/thumbnail.jpg">
<meta property="og:updated_time" content="2019-06-29T15:43:47.253Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="用 Ruby 來尋找區網中的 Airplay、Chromecast">
<meta name="twitter:description" content="從雲端開始熱門起來後，為了能能讓提供不同服務的伺服器能夠被自動的偵測，我們在許多雲端相關的工具都會看到 Service Discovery 這個名詞。 不過，除了雲端上的服務能夠透過這樣的機制互相「發現」對方，我們也可以在區網中用類似的方法找到「提供服務」的裝置。 這就要從 mDNS (Multicast DNS) 和 DNS-SD (DNS-based Service Discovery) 開始">
<meta name="twitter:image" content="https://blog.frost.tw/images/2018-12-25-use-ruby-to-find-the-airplay-or-chromecast-device/thumbnail.jpg">
<link rel="publisher" href="https://plus.google.com/117236344655673213049">
<meta property="fb:app_id" content="178355449110">

  <meta property="fb:pages" content="180666522388">
  <script type="application/ld+json">
  [
{
    "@context": "https://schema.org",
    "@type": "Blog",
    "name": "弦而時習之",
    "url": "https://blog.frost.tw",
    "image": "http://blog.frost.tw/icon-512.png",
    "description": "蒼時弦也的個人網誌，專注在前端、後端以及遊戲開發，大多使用 Ruby 和 Ruby on Rails 以及 Golang、JS 和 C 語言。",
    "sameAs": [
      "https://www.facebook.com/frost.tw/"
    ]
},
{
    "@context": "https://schema.org",
    "@type": "Person",
    "name": "蒼時弦也",
    "url": "https://blog.frost.tw",
    "sameAs": [
      "https://www.facebook.com/elct9620",
      "https://www.instagram.com/elct9620/",
      "https://twitter.com/elct9620",
      "https://plus.google.com/+%E8%92%BC%E6%99%82%E5%BC%A6%E4%B9%9F-plus",
      "https://www.linkedin.com/in/elct9620"
    ]
},
{
  "@context":"https://schema.org",
  "@type":"BlogPosting",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://blog.frost.tw/posts/2018/12/25/Use-Ruby-to-find-the-Airplay-or-Chromecast-device/"
  },
  "headline":"用 Ruby 來尋找區網中的 Airplay、Chromecast",
  "image": [
    
    "https://blog.frost.tw/images/2018-12-25-use-ruby-to-find-the-airplay-or-chromecast-device/thumbnail.jpg",
    
    "http://blog.frost.tw/icon-512.png"
  ],
  "thumbnailUrl": "https://blog.frost.tw/images/2018-12-25-use-ruby-to-find-the-airplay-or-chromecast-device/thumbnail.jpg", 
  "datePublished": "2018-12-25T10:42:06.000Z",
  "dateModified": "2019-06-29T15:43:47.253Z",
  "description":"從雲端開始熱門起來後，為了能能讓提供不同服務的伺服器能夠被自動的偵測，我們在許多雲端相關的工具都會看到 Service Discovery 這個名詞。不過，除了雲端上的服務能夠透過這樣的機制互相「發現」對方，我們也可以在區網中用類似的方法找到「提供服務」的裝置。這就要從 mDNS (Multicast DNS) 和 DNS-SD (DNS-based Service Discovery) 開始談起。",
  "author": {
    "@type": "Person",
    "name": "蒼時弦也"
  },
  "publisher": {
    "@type": "Organization",
    "name": "蒼時弦也",
    "logo": "https://blog.frost.tw/icon-512.png"
  }
},
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
    "@type": "ListItem",
    "position": 1,
    "item": {
      "@id": "https://blog.frost.tw",
      "name": "弦而時習之 ",
      "image": "http://blog.frost.tw/icon-512.png"
    }
  },{
    "@type": "ListItem",
    "position": 2,
    "item": {
      "@id": "https://blog.frost.tw/posts/2018/12/25/Use-Ruby-to-find-the-Airplay-or-Chromecast-device/",
      "name": "用 Ruby 來尋找區網中的 Airplay、Chromecast",
      "image": "https://blog.frost.tw/images/2018-12-25-use-ruby-to-find-the-airplay-or-chromecast-device/thumbnail.jpg"
    }
  }]
}
,
{
"@context": "https://schema.org",
  "@type": "Organization",
  "name": "蒼時弦也",
  "url": "https://blog.frost.tw",
  "logo": "https://blog.frost.tw/icon-512.png"
}
]
</script>



  <link rel="canonical" href="https://blog.frost.tw/posts/2018/12/25/Use-Ruby-to-find-the-Airplay-or-Chromecast-device/">
  <link href="/icon-512.png" rel="icon">
  <link rel="alternate" href="/feed.xml" title="弦而時習之" type="application/rss+xml">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <script async src="/js/turbolinks.js"></script>
  
  
</head>

  <body>
    <div id="fb-root" data-turbolinks-permanent></div>
    <header id="header">
      
<h1 id="sitename">
  <a href="/" class="hide-text logo--icon align-center">
  弦而時習之
  </a>
</h1>

<aside id="slogan" class="slogan align-center text-center">
  <h2 class="slogan__title">Aotokitsuruya</h2>
  <p class="slogan__description">The Web is attracting  me, so I start learning PHP, HTML, CSS and JavaScript. When I know about Ruby, I fall in love with it. Now, I working with my friend to design games using C++ and still learning web about Golang, Ruby and JavaScript. In the other side, I also be a designer, the reason why the web is attracted me.</p>
</aside>

    </header>
    <div id="wrapper">
      
<article class="post article">
  <header class="article__header">
    <time datetime="2018-12-25T10:42:06.000Z" class="article__time--header">
      Dec.25
    </time>
    
  
    <h1 class="article__title">用 Ruby 來尋找區網中的 Airplay、Chromecast</h1>
  


  </header>
  <div class="article__entry">
    
    <p>從雲端開始熱門起來後，為了能能讓提供不同服務的伺服器能夠被自動的偵測，我們在許多雲端相關的工具都會看到 Service Discovery 這個名詞。</p>
<p>不過，除了雲端上的服務能夠透過這樣的機制互相「發現」對方，我們也可以在區網中用類似的方法找到「提供服務」的裝置。</p>
<p>這就要從 mDNS (Multicast DNS) 和 DNS-SD (DNS-based Service Discovery) 開始談起。</p>
<a id="more"></a>
<h2 id="概觀"><a href="#概觀" class="headerlink" title="概觀"></a>概觀</h2><p>想要可以發現區網的裝置，我們需要先搞懂 mDNS 和 DNS-SD 這兩個東西在做些什麼。簡單來說 mDNS 就是對區網做「廣播」而廣播的內容則是我們熟悉的 DNS Query。當其他有在關注 mDNS 的裝置注意到之後，就會把回應廣播回區網上。也因為這樣的特性，我們不需要特別在區網架設一個 DNS 伺服器，因為我們會直接在這個區網中交換有興趣的訊息。</p>
<p>而 DNS-SD 其實是由 Apple 所提出的，如果看到 Bonjour 大致上他們可能是同一個東西。簡單來說就是基於 mDNS 在區網用特定的規則「查詢」和「回應」就能讓某個裝置辨識出另一個裝置有提供的服務，從而做到 Service Discovery 的功能。</p>
<blockquote>
<p>Bonjour 是不是相等 DNS-SD 資料不多，所以我不太敢直接斷定是同樣的東西，不過 DNS-SD 文件上是會出現 Bonjour 這個名詞的。</p>
</blockquote>
<h2 id="Ruby-的-Resolv-標準函式庫"><a href="#Ruby-的-Resolv-標準函式庫" class="headerlink" title="Ruby 的 Resolv 標準函式庫"></a>Ruby 的 Resolv 標準函式庫</h2><p>基本上 <code>Resolv</code> 這個函式庫存在感低到我都懷疑他為什麼一直在 Ruby 原始碼中活得好好的，沒有被切割出來。不過如果我們想產生 DNS 查詢的封包，就得靠他來實現。</p>
<blockquote>
<p>原本我是看著這篇<a href="https://routley.io/tech/2017/12/28/hand-writing-dns-messages.html" rel="external nofollow noopener noreferrer" target="_blank">文章</a>透過 Python 來實作產生和解析封包的功能，但是想起來我曾經對 Ruby 送過 PR 剛好就是 Resolv 相關的。</p>
</blockquote>
<p>先來一段 <code>Resolv::DNS</code> 的官方使用，讓我們快速了解一下怎麼送出 DNS 查詢。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'resolv'</span></span><br><span class="line"></span><br><span class="line">Resolv::DNS.new</span><br><span class="line">           .each_resource(<span class="string">'frost.tw'</span>, Resolv::DNS::Resource::IN::A) <span class="keyword">do</span> <span class="params">|record|</span></span><br><span class="line">             pp record</span><br><span class="line">           <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>如此一來就可以查詢到 <code>frost.tw</code> 的 A 紀錄有哪些，那麼從前面的介紹來看假設 mDNS 也是使用 DNS 封包來互動的話，是不是就表示 <code>Resolv::DNS</code> 已經提供了足夠我們實現 mDNS 和 DNS-SD 的必要實作了呢？</p>
<h2 id="監聽-mDNS-封包"><a href="#監聽-mDNS-封包" class="headerlink" title="監聽 mDNS 封包"></a>監聽 mDNS 封包</h2><p>跟我們平常使用的 <code>Socket</code> 功能比起來要正確的設定 <code>UDPSocket</code> 才能夠順利加入一個 <a href="https://en.wikipedia.org/wiki/Multicast" rel="external nofollow noopener noreferrer" target="_blank">Multicast 群組</a>，然後接收裡面的訊息。</p>
<p>根據 <a href="https://en.wikipedia.org/wiki/Multicast_DNS" rel="external nofollow noopener noreferrer" target="_blank">mDNS 定義</a>的 Multicast IPv4 位置，我們需要監聽 <code>224.0.0.251</code> 上的 <code>5353</code> 埠就可以收到 mDNS 的封包，剛開始我們可能會覺得像這樣實作應該就可以了。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'socket'</span></span><br><span class="line"></span><br><span class="line">socket = UDPSocket.new</span><br><span class="line">socket.bind(<span class="string">'224.0.0.251'</span>, <span class="number">5353</span>)</span><br></pre></td></tr></table></figure>
<p>不過馬上就會得到 <code>Errno::EADDRINUSE (Address already in use - bind(2) for &quot;224.0.0.251&quot; port 5353)</code> 這樣的錯誤訊息，所以我們需要對這個 UDPSocket 做一些設定，讓他以「加入 Multicast 群組成員」的形式運作。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">membership = IPAddr.new(<span class="string">'224.0.0.251'</span>).hton + IPAddr.new(<span class="string">'0.0.0.0'</span>).hton</span><br><span class="line">socket = UDPSocket.new</span><br><span class="line"></span><br><span class="line">socket.setsockopt(<span class="symbol">:IPPROTO_IP</span>, <span class="symbol">:IP_ADD_MEMBERSHIP</span>, membership)</span><br><span class="line">socket.setsockopt(<span class="symbol">:SOL_SOCKET</span>, <span class="symbol">:SO_REUSEPORT</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">socket.bind(<span class="string">'0.0.0.0'</span>, <span class="number">5353</span>)</span><br></pre></td></tr></table></figure>
<p>上述的程式碼簡單來說做了這幾件事情：</p>
<ol>
<li>設定 Socket 要加入 <code>224.0.0.251</code> 作為成員</li>
<li>設定 Socket 允許重複使用 5353 這個 Port</li>
</ol>
<p>設定 5353 Port 可以被重複使用是因為在這個裝置上可能還有其他服務存在，他也會需要關注 mDNS 或者做出廣播，所以我們可能會跟其他人共用這個 Port。</p>
<p>而加入 <code>224.0.0.251</code> 成員就相對不容易理解了，對沒學過網路相關知識的人來說還真的不太好好懂（所以特地查了一下資料）</p>
<p>我們先看 <code>setsockopt</code> 在 Ruby 原始碼做了什麼，才會知道上面這段的意思。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 略</span><br><span class="line"><span class="keyword">if</span> (setsockopt(fptr-&gt;fd, level, option, v, vlen) &lt; <span class="number">0</span>)</span><br><span class="line">        rsock_sys_fail_path(<span class="string">"setsockopt(2)"</span>, fptr-&gt;pathv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> INT2FIX(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>在實作上 Ruby 會直接去呼叫 C API 來做這件事情，而 <code>level</code>, <code>option</code>, <code>v</code> 就是我們從 Ruby 傳入的數值。</p>
<p>接下來再看看我查到的 <code>IP_ADDD_MEMBERSHIP</code> 的 C API <a href="https://www.tldp.org/HOWTO/Multicast-HOWTO-6.html" rel="external nofollow noopener noreferrer" target="_blank">使用說明</a>（嚴格上來說是 Multicast 的說明）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_multiaddr</span>;</span>   <span class="comment">/* IP multicast address of group */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_interface</span>;</span>   <span class="comment">/* local IP address of interface */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsockopt (socket, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;mreq, <span class="keyword">sizeof</span>(mreq));</span><br></pre></td></tr></table></figure>
<p>實際上跟 Ruby 的版本幾乎沒有差別，最主要的是 <code>ip_mreq</code> 是一個資料結構，我們要怎樣才能夠正確的傳遞進去呢？</p>
<p>先看看 <code>IPAddr.new(&#39;224.0.0.251&#39;).hton</code> 執行後會得到什麼？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">irb(main):003:0&gt; IPAddr.new(<span class="string">'224.0.0.251'</span>).hton</span><br><span class="line">=&gt; <span class="string">"\xE0\x00\x00\xFB"</span></span><br></pre></td></tr></table></figure>
<p>那麼跟 <code>0.0.0.0</code> 的 <code>IPAddr#hton</code> 相加之後，因為是字串所以會變成像這樣</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">irb(main):004:0&gt; IPAddr.new(<span class="string">'224.0.0.251'</span>).hton + IPAddr.new(<span class="string">'0.0.0.0'</span>).hton</span><br><span class="line">=&gt; <span class="string">"\xE0\x00\x00\xFB\x00\x00\x00\x00"</span></span><br></pre></td></tr></table></figure>
<p>我們再回去看 Ruby 在 <code>setsockopt</code> 實作中，遇到 <code>String</code> 時，會怎樣處理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *v;</span><br><span class="line"></span><br><span class="line"># 略</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (TYPE(val)) &#123;</span><br><span class="line">      # 略</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        StringValue(val);</span><br><span class="line">        v = RSTRING_PTR(val);</span><br><span class="line">        vlen = RSTRING_SOCKLEN(val);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"># C API 呼叫處</span><br></pre></td></tr></table></figure>
<p>簡單說就是直接弄成一段 <code>char</code> 陣列，基本上我們在 C 裡面只要大小一樣直接對到結構上基本上是會運作的，於是我們就很自然的利用 Ruby 的字串變成一個在 C 裡面的 <code>ip_mreq</code> 資料結構，順利的傳遞進去了。</p>
<p>至於 <code>#hton</code> 是什麼呢？他是 <code>Host Byte Order to Network Byte Order</code> 的縮寫，簡單說在處理網路封包的時候需要知道 IP 位置，所以有一個特殊的格式，但是因為作業系統差異，存位置的規格可能有差異，所以送到網路上時會統一轉成網路用的位元順序。</p>
<p>總而言之，我們目前可以順利的接收到來自 mDNS 的廣播封包拉！</p>
<h2 id="解析封包"><a href="#解析封包" class="headerlink" title="解析封包"></a>解析封包</h2><p>首先，我們先把上面的程式碼簡單重構成下面這樣的結構</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'socket'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'resolv'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'awesome_print'</span></span><br><span class="line"></span><br><span class="line">MDNS_PORT = <span class="number">5353</span></span><br><span class="line">MDNS_ADDRESS = <span class="string">'224.0.0.251'</span>.freeze</span><br><span class="line">BIND_ADDRESS = <span class="string">'0.0.0.0'</span>.freeze</span><br><span class="line"></span><br><span class="line">M_MEMBERSHIP = IPAddr.new(MDNS_ADDRESS).hton + IPAddr.new(BIND_ADDRESS).hton</span><br><span class="line"></span><br><span class="line"><span class="comment"># :nodoc:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MDNS</span></span></span><br><span class="line">  <span class="keyword">include</span> Enumerable</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></span><br><span class="line">    @socket = UDPSocket.new</span><br><span class="line">    @socket.setsockopt(<span class="symbol">:IPPROTO_IP</span>, <span class="symbol">:IP_ADD_MEMBERSHIP</span>, M_MEMBERSHIP)</span><br><span class="line">    @socket.setsockopt(<span class="symbol">:SOL_SOCKET</span>, <span class="symbol">:SO_REUSEPORT</span>, <span class="number">1</span>)</span><br><span class="line">    @socket.bind(BIND_ADDRESS, MDNS_PORT)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">each</span><span class="params">(&amp;_block)</span></span></span><br><span class="line">    loop <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">yield</span> @socket.recvfrom(<span class="number">4096</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">mdns = MDNS.new</span><br><span class="line">mdns.each <span class="keyword">do</span> <span class="params">|packet|</span></span><br><span class="line">  ap packet</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>執行之後，稍微等待一段時間就可以收到類似像這樣的封包資訊</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    [<span class="number">0</span>] <span class="string">"\x00\x00\x84\x00\x00\x00\x00\x02\x00\x00\x00\x01\aAndroid\x05local\x00\x00\x01\x80\x01\x00\x00\x00x\x00\x04\xAC\x1F\x01\xC0\xC0\f\x00\x1C\x80\x01\x00\x00\x00x\x00\x10\xFE\x80\x00\x00\x00\x00\x00\x00\xAEc\xBE\xFF\xFE\xC21;\xC0\f\x00/\x80\x01\x00\x00\x00x\x00\b\xC0\f\x00\x04@\x00\x00\b"</span>,</span><br><span class="line">    [<span class="number">1</span>] [</span><br><span class="line">        [<span class="number">0</span>] <span class="string">"AF_INET"</span>,</span><br><span class="line">        [<span class="number">1</span>] <span class="number">5353</span>,</span><br><span class="line">        [<span class="number">2</span>] <span class="string">"172.31.1.192"</span>,</span><br><span class="line">        [<span class="number">3</span>] <span class="string">"172.31.1.192"</span></span><br><span class="line">    ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>那麼我們該如何解析呢？因為封包內容其實就是 DNS 查詢（或者回應）所以我們只需要透過 <code>Resolv::DNS::Message</code> 的 <code>#decode</code> 去解析就可以知道內容了！</p>
<blockquote>
<p>比較痛苦的大概是 <code>Resolv::DNS</code> 本身是 Class 所以無法用 <code>include</code> 進來使用，要打很長 Class Name XD</p>
</blockquote>
<p>我們稍微調整讀取封包的程式，改成這個樣子</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mdns = MDNS.new</span><br><span class="line">mdns.each <span class="keyword">do</span> <span class="params">|packet, _addr|</span></span><br><span class="line">  ap Resolv::DNS::Message.decode(packet)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>執行後就可以看到 <code>Resolv::DNS::Message</code> 物件被產生，然後裡面包含了各種類型的 DNS 查詢。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&lt;Resolv::DNS::Message:0x00007ff3dc0b8420 <span class="doctag">@id</span>=0, <span class="doctag">@qr</span>=0, <span class="doctag">@opcode</span>=0, <span class="doctag">@aa</span>=0, <span class="doctag">@tc</span>=0, <span class="doctag">@rd</span>=0, <span class="doctag">@ra</span>=0, <span class="doctag">@rcode</span>=0, <span class="doctag">@question</span>=[[#&lt;Resolv::DNS::Name: _airplay._tcp.local.&gt;, Resolv::DNS::Resource::Generic::Type12_Class32769]], <span class="doctag">@answer</span>=[[#&lt;Resolv::DNS::Name: _airplay._tcp.local.&gt;, 4487, #&lt;Resolv::DNS::Resource::IN::PTR:0x00007ff3de822790 <span class="doctag">@name</span>=#&lt;Resolv::DNS::Name: \xE8\x87\xA5\xE5\xAE\xA4._airplay._tcp.local.&gt;, <span class="doctag">@ttl</span>=4487&gt;]], <span class="doctag">@authority</span>=[], <span class="doctag">@additional</span>=[]&gt;</span></span><br><span class="line"><span class="comment">#&lt;Resolv::DNS::Message:0x00007ff3de820ff8 <span class="doctag">@id</span>=0, <span class="doctag">@qr</span>=0, <span class="doctag">@opcode</span>=0, <span class="doctag">@aa</span>=0, <span class="doctag">@tc</span>=0, <span class="doctag">@rd</span>=0, <span class="doctag">@ra</span>=0, <span class="doctag">@rcode</span>=0, <span class="doctag">@question</span>=[[#&lt;Resolv::DNS::Name: _airplay._tcp.local.&gt;, Resolv::DNS::Resource::IN::PTR]], <span class="doctag">@answer</span>=[[#&lt;Resolv::DNS::Name: _airplay._tcp.local.&gt;, 4486, #&lt;Resolv::DNS::Resource::IN::PTR:0x00007ff3dc0e3198 <span class="doctag">@name</span>=#&lt;Resolv::DNS::Name: \xE8\x87\xA5\xE5\xAE\xA4._airplay._tcp.local.&gt;, <span class="doctag">@ttl</span>=4486&gt;]], <span class="doctag">@authority</span>=[], <span class="doctag">@additional</span>=[]&gt;</span></span><br></pre></td></tr></table></figure>
<p>不過有些是查詢，有些則是回應，我們先把回應區分出來。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mdns = MDNS.new</span><br><span class="line">mdns.each <span class="keyword">do</span> <span class="params">|packet, _addr|</span></span><br><span class="line">  message = Resolv::DNS::Message.decode(packet)</span><br><span class="line">  <span class="keyword">next</span> <span class="keyword">if</span> message.qr.zero?</span><br><span class="line"></span><br><span class="line">  ap message</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在 <code>Resolve::DNS::Message</code> 物件上有一個叫做 <code>qr</code> 的屬性，當他是 0 的時候表示這是一個「查詢」而 1 的時候，就是回應，所以只需要排除是 0 的訊息。</p>
<h2 id="根據-DNS-SD-篩選出-Airplay-Chromecast-裝置"><a href="#根據-DNS-SD-篩選出-Airplay-Chromecast-裝置" class="headerlink" title="根據 DNS-SD 篩選出 Airplay / Chromecast 裝置"></a>根據 DNS-SD 篩選出 Airplay / Chromecast 裝置</h2><p>首先我們要先搞懂幾個 DNS-SD 的規則，才能夠找到我們希望找到的資訊。</p>
<ol>
<li>DNS-SD 的 FQDN 結構</li>
<li>DNS-SD 會使用的 Record</li>
</ol>
<p>關於 FQDN 結構，我們會看到三種</p>
<ol>
<li>&lt; Service &gt;.&lt; Domain &gt;</li>
<li>&lt; Instance &gt;.&lt; Service &gt;.&lt; Domain &gt;</li>
<li>&lt; Hostname &gt;</li>
</ol>
<p>扣掉第三種不算，因為他就是 Host Name 之外，以 Airplay 裝置會這樣表示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_airplay._tcp_.local</span><br></pre></td></tr></table></figure>
<p>基本上在區網使用 <code>.local</code> 是必然的，然後 <code>_tcp</code> 暴露出了他是透過 TCP 連線，而 <code>_airplay</code> 就是這個服務的類型。</p>
<p>以我的房間為例，我有一台 Sonos One 音響叫做「臥室」那在 mDNS 中就可以查到 <code>臥室._airplay._tcp.local</code> 這個 DNS 紀錄。</p>
<p>至於會用到的 DNS Record 則有四種</p>
<ol>
<li>PTR (Pointer Record)</li>
<li>SRV (Service Record)</li>
<li>A (Address Record)</li>
<li>TXT (Text Record)</li>
</ol>
<p>簡單說 PTR 是一個指標，他會回應一個 Instance 給我們，讓我們知道該去問誰要這個 Service 的資訊，而 SRV / TXT 則提供了這個 Service 的 Port &amp; Hostname 資訊，以及一些 Metadata 讓我們可以了解這個服務。</p>
<p>最後 A (or AAAA) 則會在我們詢問 Hostname 時回應區網的 IP 位置，讓我們知道該連到哪裡。</p>
<blockquote>
<p>這個機制看起來很聰明，有興趣的話可以參考 Spotify 的 <a href="https://labs.spotify.com/2017/03/31/spotifys-lovehate-relationship-with-dns/" rel="external nofollow noopener noreferrer" target="_blank">DNS-SD</a> 文章，跟這個其實很像。</p>
</blockquote>
<p>所以整體流程會變成像這樣</p>
<ol>
<li>詢問 <code>PTR _airplay._tcp.local</code> 獲得 <code>_airplar._tcp.local PTR 臥室._airplay_.tcp.local</code> 的回答</li>
<li>詢問 <code>SRV 臥室._airplay_.tcp.local</code> 獲得 <code>臥室._airplay_.tcp.local SRV 0 0 7000 Sonos-0xAF.local</code> 的回答</li>
<li>詢問 <code>A Sonos-0xAF.local</code> 獲得 <code>Sonos-0xAF.local A 172.31.1.166</code> 的回答</li>
</ol>
<p>基於這些情報，我們可以彙整出：</p>
<ol>
<li>有一個裝置叫做「臥室」</li>
<li>IP 位置是 <code>172.31.1.166</code></li>
<li>使用 7000 Port 可以和他建立連線</li>
</ol>
<p>那麼，我們稍微調整一下程式碼讓我們可以拿到 PTR 來顯示詳細資訊。</p>
<blockquote>
<p>DNS-SD 的 <a href="https://tools.ietf.org/html/rfc6763" rel="external nofollow noopener noreferrer" target="_blank">RFC6763</a> 提到回應 PTR 時要把 SRV / TXT / A 都一起回覆，理論上我們是不太需要重複詢問 SRV / TXT / A 的，不過因為除了 PTR 會把 TTL 設定的比較長，其他都會設定為短時間，好在一段時間後確認 IP 是否有變動之類的。</p>
</blockquote>
<p>我們先稍微重構一下，讓 <code>MDNS</code> 可以指篩選出我們有興趣的 PTR Record 回應給我們。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># :nodoc:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MDNS</span></span></span><br><span class="line">  <span class="keyword">include</span> Enumerable</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 略</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">listen</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> @thread</span><br><span class="line"></span><br><span class="line">    @thread = Thread.new <span class="keyword">do</span></span><br><span class="line">      loop <span class="keyword">do</span></span><br><span class="line">        packet, = @socket.recvfrom(<span class="number">4096</span>)</span><br><span class="line">        reply = Resolv::DNS::Message.decode(packet)</span><br><span class="line">        <span class="keyword">next</span> <span class="keyword">if</span> reply.qr.zero?</span><br><span class="line">        <span class="keyword">next</span> <span class="keyword">if</span> ptr?(reply)</span><br><span class="line"></span><br><span class="line">        @replies &lt;&lt; reply</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">each</span><span class="params">(&amp;_block)</span></span></span><br><span class="line">    loop <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">yield</span> @replies.shift <span class="keyword">until</span> @replies.empty?</span><br><span class="line">      sleep <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  private</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">ptr?</span><span class="params">(reply)</span></span></span><br><span class="line">    reply.answer.reduce(<span class="literal">true</span>) <span class="keyword">do</span> <span class="params">|prev, (_, _, data)|</span></span><br><span class="line">      prev &amp; data.is_a?(Resolv::DNS::Resource::IN::PTR)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">mdns = MDNS.new</span><br><span class="line">mdns.listen</span><br><span class="line">mdns.each <span class="keyword">do</span> <span class="params">|reply|</span></span><br><span class="line">  reply.each_answer <span class="keyword">do</span> <span class="params">|name, _, _|</span></span><br><span class="line">    ap name</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>執行後會獲得類似這樣的的訊息，因為 PTR 回應的是 Instance Name 所以是預期的結果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#&lt;Resolv::DNS::Name: 臥室._airplay._tcp.local.&gt;</span><br><span class="line">#&lt;Resolv::DNS::Name: Sonos-7828CAC4542C.local.&gt;</span><br><span class="line">#&lt;Resolv::DNS::Name: 7828CAC4542C@臥室._raop._tcp.local.&gt;</span><br></pre></td></tr></table></figure>
<p>如此一來，我們只要稍加修改就可以篩選出是提供 Airplay / Chromecast 的裝置。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Airplay 有兩種</span></span><br><span class="line">airplay = Resolv::DNS::Name.create(<span class="string">'_airplay._tcp.local.'</span>)</span><br><span class="line">raop = Resolv::DNS::Name.create(<span class="string">'_raop._tcp.local.'</span>)</span><br><span class="line"><span class="comment"># Chromecast</span></span><br><span class="line">chromecast = Resolv::DNS::Name.create(<span class="string">'_googlecast._tcp.local.)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mdns.each do |reply|</span></span><br><span class="line"><span class="string">  reply.each_answer do |name, _, _|</span></span><br><span class="line"><span class="string">    next unless name.subdomain_of?(airplay)</span></span><br><span class="line"><span class="string">    next unless name.subdomain_of?(raop)</span></span><br><span class="line"><span class="string">    next unless name.subdomain_of?(chromecast)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    ap name</span></span><br><span class="line"><span class="string">  end</span></span><br><span class="line"><span class="string">end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>另外我們可以透過 <code>reply.each_addationial</code> 獲取更多資訊，不過可惜的是 <code>Resolv::DNS::Message</code> 在解析時可能因為某些關係只能知道他是 <code>PTR</code> 但是無法正確解析，就會獲得 <code>Generic::Type12_XXXX</code> 這種類型的物件，反而不好處理。</p>
</blockquote>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>在做這個技術測試的時候，發現蠻多情境下大家都是串 C API 然後去呼叫作業系統提供的 DNS-SD 機制來實作，不過在了解原理的狀況下，其實我們還是可以靠純 Ruby 的方式實現一定程度的 DNS-SD 機制。</p>
<p>那麼，這個技術有什麼用途嗎？在五倍的 IoT 專案 <a href="https://tamashii.io" rel="external nofollow noopener noreferrer" target="_blank">Tamashii</a> 當時因為裝置很多的關係，我們就有研究過透過 DNS-SD 去找到區網內的裝置，然後讓他能夠一次性的套用或者修改設定，不過礙於各種因素就暫時沒有把他實作出來。</p>
<p>這次重新審視之後發現其實還是非常有用的，近期應該會更新一個在 Tamashii 專案下可以使用的 DNS-SD Gem 吧！</p>
<blockquote>
<p>礙於篇幅，其實還有下篇 - 偽裝成 Airplay 裝置的系列，不過就先到這裡告一段落吧！</p>
</blockquote>

    
    <footer class="article__footer">
      
        <div class="text-center">
          <div class="fb-share-button" data-href="https://blog.frost.tw/posts/2018/12/25/Use-Ruby-to-find-the-Airplay-or-Chromecast-device/" data-layout="button_count">
          </div>
        </div>
        <div class="text-center mt-1">
          <style>.bmc-button img{width: 27px !important;margin-bottom: 1px !important;box-shadow: none !important;border: none !important;vertical-align: middle !important;}.bmc-button{line-height: 36px !important;height:37px !important;text-decoration: none !important;display:inline-flex !important;color:#ffffff !important;background-color:#000000 !important;border-radius: 3px !important;border: 1px solid transparent !important;padding: 1px 9px !important;font-size: 22px !important;letter-spacing:0.6px !important;box-shadow: 0px 1px 2px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;margin: 0 auto !important;font-family:'Cookie', cursive !important;-webkit-box-sizing: border-box !important;box-sizing: border-box !important;-o-transition: 0.3s all linear !important;-webkit-transition: 0.3s all linear !important;-moz-transition: 0.3s all linear !important;-ms-transition: 0.3s all linear !important;transition: 0.3s all linear !important;}.bmc-button:hover, .bmc-button:active, .bmc-button:focus {-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;text-decoration: none !important;box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;opacity: 0.85 !important;color:#ffffff !important;}</style><link href="https://fonts.googleapis.com/css?family=Cookie" rel="stylesheet"><a class="bmc-button" target="_blank" href="https://www.buymeacoffee.com/aotoki" rel="external nofollow noopener noreferrer"><img src="https://bmc-cdn.nyc3.digitaloceanspaces.com/BMC-button-images/BMC-btn-logo.svg" alt="Buy me a Coffee"><span style="margin-left:5px">Buy me a Coffee</span></a>
        </div>
        <iframe scrolling="no" frameborder="0" style="display: block; margin: 0 auto; height: 212px;" src="https://button.like.co/in/embed/elct9620/button?referrer=https://blog.frost.tw/posts/2018/12/25/Use-Ruby-to-find-the-Airplay-or-Chromecast-device/"></iframe>
        
          <ul class="article__tag-list"><li class="article__tag-list-item"><a class="article__tag-list-link" href="/tags/DNS-SD/">DNS-SD</a></li><li class="article__tag-list-item"><a class="article__tag-list-link" href="/tags/Ruby/">Ruby</a></li><li class="article__tag-list-item"><a class="article__tag-list-link" href="/tags/mDNS/">mDNS</a></li><li class="article__tag-list-item"><a class="article__tag-list-link" href="/tags/心得/">心得</a></li></ul>
        
      
    </footer>
  </div>
</article>


  
    <div class="adv">
      <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
      <!-- 網誌_文末廣告 (Hexo) -->
      <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-2844969736316510" data-ad-slot="5530952976" data-ad-format="auto"></ins>
      <script>
      (adsbygoogle = window.adsbygoogle || []).push({});
      </script>
    </div>
  

  
<section id="comment" class="comment-box">
  <h1 class="comment-box__title">留言</h1>

  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a rel="nofollow" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>






    </div>
    <footer id="footer">
      <div id="copyright">
  &copy;2013 <a href="https://plus.google.com/117236344655673213049?rel=author" target="_blank" rel="external nofollow noopener noreferrer">蒼時弦也</a>. All right reversed.
</div>

    </footer>
    

  <script type="text/javascript">
  window.disqus_shortname = 'revo-skill-frost';

  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + window.disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  }());
  
  </script>

  
  <!-- Google Tag Manager -->
  <noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5TQLRN" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-5TQLRN');</script>
  <!-- End Google Tag Manager -->
  

  <script>
    window.fbAsyncInit = function() {
      FB.init({
        appId      : '178355449110',
        xfbml      : true,
        version    : 'v2.12'
      });

      FB.AppEvents.logPageView();

    };

    (function(d, s, id){
       var js, fjs = d.getElementsByTagName(s)[0];
       if (d.getElementById(id)) {return;}
       js = d.createElement(s); js.id = id;
       js.src = "https://connect.facebook.net/zh_TW/sdk.js";
       js.async = true
       fjs.parentNode.insertBefore(js, fjs);
     }(document, 'script', 'facebook-jssdk'));
  </script>

  <script src="/js/app.js"></script>


    <div class="loading"></div>
  </body>
</html>
