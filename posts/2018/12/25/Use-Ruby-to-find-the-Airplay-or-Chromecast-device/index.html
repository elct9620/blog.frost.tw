<!doctype html><html lang=zh-tw><head><title>用 Ruby 來尋找區網中的 Airplay、Chromecast - 弦而時習之</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=description content="從雲端開始熱門起來後，為了能能讓提供不同服務的伺服器能夠被自動的偵測，我們在許多雲端相關的工具都會看到 Service Discovery 這個名詞。
不過，除了雲端上的服務能夠透過這樣的機制互相「發現」對方，我們也可以在區網中用類似的方法找到「提供服務」的裝置。
這就要從 mDNS (Multicast DNS) 和 DNS-SD …"><meta name=created content="2018-12-25T00:00:00+0000"><meta name=modified content="2018-12-25T18:42:06+0000"><meta name=author content="蒼時弦也"><meta property="og:site_name" content="弦而時習之"><meta property="og:title" content="用 Ruby 來尋找區網中的 Airplay、Chromecast"><meta property="og:url" content="https://blog.frost.tw/posts/2018/12/25/Use-Ruby-to-find-the-Airplay-or-Chromecast-device/"><meta property="og:type" content="article"><meta property="og:image" content="https://blog.frost.tw/images/2018-12-25-use-ruby-to-find-the-airplay-or-chromecast-device/thumbnail.jpg"><meta name=theme-color content="#EFEFEF"><link href=https://blog.frost.tw/icon-512.png rel=icon><link rel=canonical href=https://blog.frost.tw/posts/2018/12/25/Use-Ruby-to-find-the-Airplay-or-Chromecast-device/><script type=application/ld+json>[{"@context":"https://schema.org","@type":"WebPage","headline":"用 Ruby 來尋找區網中的 Airplay、Chromecast","datePublished":"2018-12-25T18:42:06Z","dateModified":"2018-12-25T18:42:06Z","url":"https://blog.frost.tw/posts/2018/12/25/Use-Ruby-to-find-the-Airplay-or-Chromecast-device/","description":"從雲端開始熱門起來後，為了能能讓提供不同服務的伺服器能夠被自動的偵測，我們在許多雲端相關的工具都會看到 Service Discovery 這個名詞。\n不過，除了雲端上的服務能夠透過這樣的機制互相「發現」對方，我們也可以在區網中用類似的方法找到「提供服務」的裝置。\n這就要從 mDNS (Multicast DNS) 和 DNS-SD …\n","keywords":["Ruby","mDNS","DNS-SD","心得"],"image":"https://blog.frost.tw/images/2018-12-25-use-ruby-to-find-the-airplay-or-chromecast-device/thumbnail.jpg","author":{"@type":"Person","name":"蒼時弦也"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.frost.tw/"},"publisher":{"@type":"Organization","name":"弦而時習之","url":"https://blog.frost.tw/"}},{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://blog.frost.tw/","name":"弦而時習之","image":"http://blog.frost.tw/icon-512.png"}},{"@type":"ListItem","position":2,"item":{"@id":"https://blog.frost.tw/posts/2018/12/25/Use-Ruby-to-find-the-Airplay-or-Chromecast-device/","name":"用 Ruby 來尋找區網中的 Airplay、Chromecast","image":"https://blog.frost.tw/images/2018-12-25-use-ruby-to-find-the-airplay-or-chromecast-device/thumbnail.jpg"}}]}]</script><link rel=stylesheet href=/css/styls.css><script async src=/js/turbolinks.min.js></script></head><body><div id=fb-root data-turbolinks-permanent></div><h1 id=sitename><a href=/ class="hide-text logo--icon align-center">弦而時習之</a></h1><aside id=slogan class="slogan align-center text-center"><h2 class=slogan__title>Aotokitsuruya</h2><p class=slogan__description>The Web is attracting me, so I start learning PHP, HTML, CSS and JavaScript. When I know about Ruby, I fall in love with it. Now, I working with my friend to design games using C++ and still learning web about Golang, Ruby and JavaScript. In the other side, I also be a designer, the reason why the web is attracted me.</p></aside><div id=wrapper><article class="post article" role=article><header class=article__header><time datetime=2018-12-25T18:42:06+0000 class=article__time--header role=time>Feb.25</time><h1 class=article__title>用 Ruby 來尋找區網中的 Airplay、Chromecast</h1></header><div class=article__entry><nav class=translation></nav><p>從雲端開始熱門起來後，為了能能讓提供不同服務的伺服器能夠被自動的偵測，我們在許多雲端相關的工具都會看到 Service Discovery 這個名詞。</p><p>不過，除了雲端上的服務能夠透過這樣的機制互相「發現」對方，我們也可以在區網中用類似的方法找到「提供服務」的裝置。</p><p>這就要從 mDNS (Multicast DNS) 和 DNS-SD (DNS-based Service Discovery) 開始談起。</p><h2 id=概觀>概觀</h2><p>想要可以發現區網的裝置，我們需要先搞懂 mDNS 和 DNS-SD 這兩個東西在做些什麼。簡單來說 mDNS 就是對區網做「廣播」而廣播的內容則是我們熟悉的 DNS Query。當其他有在關注 mDNS 的裝置注意到之後，就會把回應廣播回區網上。也因為這樣的特性，我們不需要特別在區網架設一個 DNS 伺服器，因為我們會直接在這個區網中交換有興趣的訊息。</p><p>而 DNS-SD 其實是由 Apple 所提出的，如果看到 Bonjour 大致上他們可能是同一個東西。簡單來說就是基於 mDNS 在區網用特定的規則「查詢」和「回應」就能讓某個裝置辨識出另一個裝置有提供的服務，從而做到 Service Discovery 的功能。</p><blockquote><p>Bonjour 是不是相等 DNS-SD 資料不多，所以我不太敢直接斷定是同樣的東西，不過 DNS-SD 文件上是會出現 Bonjour 這個名詞的。</p></blockquote><h2 id=ruby-的-resolv-標準函式庫>Ruby 的 Resolv 標準函式庫</h2><p>基本上 <code>Resolv</code> 這個函式庫存在感低到我都懷疑他為什麼一直在 Ruby 原始碼中活得好好的，沒有被切割出來。不過如果我們想產生 DNS 查詢的封包，就得靠他來實現。</p><blockquote><p>原本我是看著這篇<a href=https://routley.io/tech/2017/12/28/hand-writing-dns-messages.html>文章</a>透過 Python 來實作產生和解析封包的功能，但是想起來我曾經對 Ruby 送過 PR 剛好就是 Resolv 相關的。</p></blockquote><p>先來一段 <code>Resolv::DNS</code> 的官方使用，讓我們快速了解一下怎麼送出 DNS 查詢。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-ruby data-lang=ruby><span class=nb>require</span> <span class=s1>&#39;resolv&#39;</span>

<span class=no>Resolv</span><span class=o>::</span><span class=no>DNS</span><span class=o>.</span><span class=n>new</span>
           <span class=o>.</span><span class=n>each_resource</span><span class=p>(</span><span class=s1>&#39;frost.tw&#39;</span><span class=p>,</span> <span class=no>Resolv</span><span class=o>::</span><span class=no>DNS</span><span class=o>::</span><span class=no>Resource</span><span class=o>::</span><span class=no>IN</span><span class=o>::</span><span class=n>A</span><span class=p>)</span> <span class=k>do</span> <span class=o>|</span><span class=n>record</span><span class=o>|</span>
             <span class=n>pp</span> <span class=n>record</span>
           <span class=k>end</span>
</code></pre></td></tr></table></div></div><p>如此一來就可以查詢到 <code>frost.tw</code> 的 A 紀錄有哪些，那麼從前面的介紹來看假設 mDNS 也是使用 DNS 封包來互動的話，是不是就表示 <code>Resolv::DNS</code> 已經提供了足夠我們實現 mDNS 和 DNS-SD 的必要實作了呢？</p><h2 id=監聽-mdns-封包>監聽 mDNS 封包</h2><p>跟我們平常使用的 <code>Socket</code> 功能比起來要正確的設定 <code>UDPSocket</code> 才能夠順利加入一個 <a href=https://en.wikipedia.org/wiki/Multicast>Multicast 群組</a>，然後接收裡面的訊息。</p><p>根據 <a href=https://en.wikipedia.org/wiki/Multicast_DNS>mDNS 定義</a>的 Multicast IPv4 位置，我們需要監聽 <code>224.0.0.251</code> 上的 <code>5353</code> 埠就可以收到 mDNS 的封包，剛開始我們可能會覺得像這樣實作應該就可以了。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-ruby data-lang=ruby><span class=nb>require</span> <span class=s1>&#39;socket&#39;</span>

<span class=n>socket</span> <span class=o>=</span> <span class=no>UDPSocket</span><span class=o>.</span><span class=n>new</span>
<span class=n>socket</span><span class=o>.</span><span class=n>bind</span><span class=p>(</span><span class=s1>&#39;224.0.0.251&#39;</span><span class=p>,</span> <span class=mi>5353</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><p>不過馬上就會得到 <code>Errno::EADDRINUSE (Address already in use - bind(2) for "224.0.0.251" port 5353)</code> 這樣的錯誤訊息，所以我們需要對這個 UDPSocket 做一些設定，讓他以「加入 Multicast 群組成員」的形式運作。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-ruby data-lang=ruby><span class=n>membership</span> <span class=o>=</span> <span class=no>IPAddr</span><span class=o>.</span><span class=n>new</span><span class=p>(</span><span class=s1>&#39;224.0.0.251&#39;</span><span class=p>)</span><span class=o>.</span><span class=n>hton</span> <span class=o>+</span> <span class=no>IPAddr</span><span class=o>.</span><span class=n>new</span><span class=p>(</span><span class=s1>&#39;0.0.0.0&#39;</span><span class=p>)</span><span class=o>.</span><span class=n>hton</span>
<span class=n>socket</span> <span class=o>=</span> <span class=no>UDPSocket</span><span class=o>.</span><span class=n>new</span>

<span class=n>socket</span><span class=o>.</span><span class=n>setsockopt</span><span class=p>(</span><span class=ss>:IPPROTO_IP</span><span class=p>,</span> <span class=ss>:IP_ADD_MEMBERSHIP</span><span class=p>,</span> <span class=n>membership</span><span class=p>)</span>
<span class=n>socket</span><span class=o>.</span><span class=n>setsockopt</span><span class=p>(</span><span class=ss>:SOL_SOCKET</span><span class=p>,</span> <span class=ss>:SO_REUSEPORT</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>

<span class=n>socket</span><span class=o>.</span><span class=n>bind</span><span class=p>(</span><span class=s1>&#39;0.0.0.0&#39;</span><span class=p>,</span> <span class=mi>5353</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><p>上述的程式碼簡單來說做了這幾件事情：</p><ol><li>設定 Socket 要加入 <code>224.0.0.251</code> 作為成員</li><li>設定 Socket 允許重複使用 5353 這個 Port</li></ol><p>設定 5353 Port 可以被重複使用是因為在這個裝置上可能還有其他服務存在，他也會需要關注 mDNS 或者做出廣播，所以我們可能會跟其他人共用這個 Port。</p><p>而加入 <code>224.0.0.251</code> 成員就相對不容易理解了，對沒學過網路相關知識的人來說還真的不太好好懂（所以特地查了一下資料）</p><p>我們先看 <code>setsockopt</code> 在 Ruby 原始碼做了什麼，才會知道上面這段的意思。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp># 略
</span><span class=cp></span><span class=k>if</span> <span class=p>(</span><span class=n>setsockopt</span><span class=p>(</span><span class=n>fptr</span><span class=o>-&gt;</span><span class=n>fd</span><span class=p>,</span> <span class=n>level</span><span class=p>,</span> <span class=n>option</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>vlen</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
        <span class=n>rsock_sys_fail_path</span><span class=p>(</span><span class=s>&#34;setsockopt(2)&#34;</span><span class=p>,</span> <span class=n>fptr</span><span class=o>-&gt;</span><span class=n>pathv</span><span class=p>);</span>

    <span class=k>return</span> <span class=nf>INT2FIX</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</code></pre></td></tr></table></div></div><p>在實作上 Ruby 會直接去呼叫 C API 來做這件事情，而 <code>level</code>, <code>option</code>, <code>v</code> 就是我們從 Ruby 傳入的數值。</p><p>接下來再看看我查到的 <code>IP_ADDD_MEMBERSHIP</code> 的 C API <a href=https://www.tldp.org/HOWTO/Multicast-HOWTO-6.html>使用說明</a>（嚴格上來說是 Multicast 的說明）</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=k>struct</span> <span class=n>ip_mreq</span>
<span class=p>{</span>
        <span class=k>struct</span> <span class=n>in_addr</span> <span class=n>imr_multiaddr</span><span class=p>;</span>   <span class=cm>/* IP multicast address of group */</span>
        <span class=k>struct</span> <span class=n>in_addr</span> <span class=n>imr_interface</span><span class=p>;</span>   <span class=cm>/* local IP address of interface */</span>
<span class=p>};</span>
</code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=n>setsockopt</span> <span class=p>(</span><span class=n>socket</span><span class=p>,</span> <span class=n>IPPROTO_IP</span><span class=p>,</span> <span class=n>IP_ADD_MEMBERSHIP</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>mreq</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>mreq</span><span class=p>));</span>
</code></pre></td></tr></table></div></div><p>實際上跟 Ruby 的版本幾乎沒有差別，最主要的是 <code>ip_mreq</code> 是一個資料結構，我們要怎樣才能夠正確的傳遞進去呢？</p><p>先看看 <code>IPAddr.new('224.0.0.251').hton</code> 執行後會得到什麼？</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>irb<span class=o>(</span>main<span class=o>)</span>:003:0&gt; IPAddr.new<span class=o>(</span><span class=s1>&#39;224.0.0.251&#39;</span><span class=o>)</span>.hton
<span class=o>=</span>&gt; <span class=s2>&#34;\xE0\x00\x00\xFB&#34;</span>
</code></pre></td></tr></table></div></div><p>那麼跟 <code>0.0.0.0</code> 的 <code>IPAddr#hton</code> 相加之後，因為是字串所以會變成像這樣</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>irb<span class=o>(</span>main<span class=o>)</span>:004:0&gt; IPAddr.new<span class=o>(</span><span class=s1>&#39;224.0.0.251&#39;</span><span class=o>)</span>.hton + IPAddr.new<span class=o>(</span><span class=s1>&#39;0.0.0.0&#39;</span><span class=o>)</span>.hton
<span class=o>=</span>&gt; <span class=s2>&#34;\xE0\x00\x00\xFB\x00\x00\x00\x00&#34;</span>
</code></pre></td></tr></table></div></div><p>我們再回去看 Ruby 在 <code>setsockopt</code> 實作中，遇到 <code>String</code> 時，會怎樣處理</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=kt>char</span> <span class=o>*</span><span class=n>v</span><span class=p>;</span>

<span class=cp># 略
</span><span class=cp></span>
    <span class=k>switch</span> <span class=p>(</span><span class=n>TYPE</span><span class=p>(</span><span class=n>val</span><span class=p>))</span> <span class=p>{</span>
      <span class=cp># 略
</span><span class=cp></span>      <span class=k>default</span><span class=o>:</span>
        <span class=n>StringValue</span><span class=p>(</span><span class=n>val</span><span class=p>);</span>
        <span class=n>v</span> <span class=o>=</span> <span class=n>RSTRING_PTR</span><span class=p>(</span><span class=n>val</span><span class=p>);</span>
        <span class=n>vlen</span> <span class=o>=</span> <span class=n>RSTRING_SOCKLEN</span><span class=p>(</span><span class=n>val</span><span class=p>);</span>
        <span class=k>break</span><span class=p>;</span>
    <span class=p>}</span>
    
<span class=cp># C API 呼叫處
</span></code></pre></td></tr></table></div></div><p>簡單說就是直接弄成一段 <code>char</code> 陣列，基本上我們在 C 裡面只要大小一樣直接對到結構上基本上是會運作的，於是我們就很自然的利用 Ruby 的字串變成一個在 C 裡面的 <code>ip_mreq</code> 資料結構，順利的傳遞進去了。</p><p>至於 <code>#hton</code> 是什麼呢？他是 <code>Host Byte Order to Network Byte Order</code> 的縮寫，簡單說在處理網路封包的時候需要知道 IP 位置，所以有一個特殊的格式，但是因為作業系統差異，存位置的規格可能有差異，所以送到網路上時會統一轉成網路用的位元順序。</p><p>總而言之，我們目前可以順利的接收到來自 mDNS 的廣播封包拉！</p><h2 id=解析封包>解析封包</h2><p>首先，我們先把上面的程式碼簡單重構成下面這樣的結構</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-ruby data-lang=ruby><span class=nb>require</span> <span class=s1>&#39;socket&#39;</span>
<span class=nb>require</span> <span class=s1>&#39;resolv&#39;</span>
<span class=nb>require</span> <span class=s1>&#39;awesome_print&#39;</span>

<span class=no>MDNS_PORT</span> <span class=o>=</span> <span class=mi>5353</span>
<span class=no>MDNS_ADDRESS</span> <span class=o>=</span> <span class=s1>&#39;224.0.0.251&#39;</span><span class=o>.</span><span class=n>freeze</span>
<span class=no>BIND_ADDRESS</span> <span class=o>=</span> <span class=s1>&#39;0.0.0.0&#39;</span><span class=o>.</span><span class=n>freeze</span>

<span class=no>M_MEMBERSHIP</span> <span class=o>=</span> <span class=no>IPAddr</span><span class=o>.</span><span class=n>new</span><span class=p>(</span><span class=no>MDNS_ADDRESS</span><span class=p>)</span><span class=o>.</span><span class=n>hton</span> <span class=o>+</span> <span class=no>IPAddr</span><span class=o>.</span><span class=n>new</span><span class=p>(</span><span class=no>BIND_ADDRESS</span><span class=p>)</span><span class=o>.</span><span class=n>hton</span>

<span class=c1># :nodoc:</span>
<span class=k>class</span> <span class=nc>MDNS</span>
  <span class=kp>include</span> <span class=no>Enumerable</span>

  <span class=k>def</span> <span class=nf>initialize</span>
    <span class=vi>@socket</span> <span class=o>=</span> <span class=no>UDPSocket</span><span class=o>.</span><span class=n>new</span>
    <span class=vi>@socket</span><span class=o>.</span><span class=n>setsockopt</span><span class=p>(</span><span class=ss>:IPPROTO_IP</span><span class=p>,</span> <span class=ss>:IP_ADD_MEMBERSHIP</span><span class=p>,</span> <span class=no>M_MEMBERSHIP</span><span class=p>)</span>
    <span class=vi>@socket</span><span class=o>.</span><span class=n>setsockopt</span><span class=p>(</span><span class=ss>:SOL_SOCKET</span><span class=p>,</span> <span class=ss>:SO_REUSEPORT</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
    <span class=vi>@socket</span><span class=o>.</span><span class=n>bind</span><span class=p>(</span><span class=no>BIND_ADDRESS</span><span class=p>,</span> <span class=no>MDNS_PORT</span><span class=p>)</span>
  <span class=k>end</span>

  <span class=k>def</span> <span class=nf>each</span><span class=p>(</span><span class=o>&amp;</span><span class=n>_block</span><span class=p>)</span>
    <span class=kp>loop</span> <span class=k>do</span>
      <span class=k>yield</span> <span class=vi>@socket</span><span class=o>.</span><span class=n>recvfrom</span><span class=p>(</span><span class=mi>4096</span><span class=p>)</span>
    <span class=k>end</span>
  <span class=k>end</span>
<span class=k>end</span>

<span class=n>mdns</span> <span class=o>=</span> <span class=no>MDNS</span><span class=o>.</span><span class=n>new</span>
<span class=n>mdns</span><span class=o>.</span><span class=n>each</span> <span class=k>do</span> <span class=o>|</span><span class=n>packet</span><span class=o>|</span>
  <span class=n>ap</span> <span class=n>packet</span>
<span class=k>end</span>
</code></pre></td></tr></table></div></div><p>執行之後，稍微等待一段時間就可以收到類似像這樣的封包資訊</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-ruby data-lang=ruby><span class=o>[</span>
    <span class=o>[</span><span class=mi>0</span><span class=o>]</span> <span class=s2>&#34;</span><span class=se>\x00\x00\x84\x00\x00\x00\x00\x02\x00\x00\x00\x01\a</span><span class=s2>Android</span><span class=se>\x05</span><span class=s2>local</span><span class=se>\x00\x00\x01\x80\x01\x00\x00\x00</span><span class=s2>x</span><span class=se>\x00\x04\xAC\x1F\x01\xC0\xC0\f\x00\x1C\x80\x01\x00\x00\x00</span><span class=s2>x</span><span class=se>\x00\x10\xFE\x80\x00\x00\x00\x00\x00\x00\xAE</span><span class=s2>c</span><span class=se>\xBE\xFF\xFE\xC2</span><span class=s2>1;</span><span class=se>\xC0\f\x00</span><span class=s2>/</span><span class=se>\x80\x01\x00\x00\x00</span><span class=s2>x</span><span class=se>\x00\b\xC0\f\x00\x04</span><span class=s2>@</span><span class=se>\x00\x00\b</span><span class=s2>&#34;</span><span class=p>,</span>
    <span class=o>[</span><span class=mi>1</span><span class=o>]</span> <span class=o>[</span>
        <span class=o>[</span><span class=mi>0</span><span class=o>]</span> <span class=s2>&#34;AF_INET&#34;</span><span class=p>,</span>
        <span class=o>[</span><span class=mi>1</span><span class=o>]</span> <span class=mi>5353</span><span class=p>,</span>
        <span class=o>[</span><span class=mi>2</span><span class=o>]</span> <span class=s2>&#34;172.31.1.192&#34;</span><span class=p>,</span>
        <span class=o>[</span><span class=mi>3</span><span class=o>]</span> <span class=s2>&#34;172.31.1.192&#34;</span>
    <span class=o>]</span>
<span class=o>]</span>
</code></pre></td></tr></table></div></div><p>那麼我們該如何解析呢？因為封包內容其實就是 DNS 查詢（或者回應）所以我們只需要透過 <code>Resolv::DNS::Message</code> 的 <code>#decode</code> 去解析就可以知道內容了！</p><blockquote><p>比較痛苦的大概是 <code>Resolv::DNS</code> 本身是 Class 所以無法用 <code>include</code> 進來使用，要打很長 Class Name XD</p></blockquote><p>我們稍微調整讀取封包的程式，改成這個樣子</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-ruby data-lang=ruby><span class=n>mdns</span> <span class=o>=</span> <span class=no>MDNS</span><span class=o>.</span><span class=n>new</span>
<span class=n>mdns</span><span class=o>.</span><span class=n>each</span> <span class=k>do</span> <span class=o>|</span><span class=n>packet</span><span class=p>,</span> <span class=n>_addr</span><span class=o>|</span>
  <span class=n>ap</span> <span class=no>Resolv</span><span class=o>::</span><span class=no>DNS</span><span class=o>::</span><span class=no>Message</span><span class=o>.</span><span class=n>decode</span><span class=p>(</span><span class=n>packet</span><span class=p>)</span>
<span class=k>end</span>
</code></pre></td></tr></table></div></div><p>執行後就可以看到 <code>Resolv::DNS::Message</code> 物件被產生，然後裡面包含了各種類型的 DNS 查詢。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-ruby data-lang=ruby><span class=c1>#&lt;Resolv::DNS::Message:0x00007ff3dc0b8420 @id=0, @qr=0, @opcode=0, @aa=0, @tc=0, @rd=0, @ra=0, @rcode=0, @question=[[#&lt;Resolv::DNS::Name: _airplay._tcp.local.&gt;, Resolv::DNS::Resource::Generic::Type12_Class32769]], @answer=[[#&lt;Resolv::DNS::Name: _airplay._tcp.local.&gt;, 4487, #&lt;Resolv::DNS::Resource::IN::PTR:0x00007ff3de822790 @name=#&lt;Resolv::DNS::Name: \xE8\x87\xA5\xE5\xAE\xA4._airplay._tcp.local.&gt;, @ttl=4487&gt;]], @authority=[], @additional=[]&gt;</span>
<span class=c1>#&lt;Resolv::DNS::Message:0x00007ff3de820ff8 @id=0, @qr=0, @opcode=0, @aa=0, @tc=0, @rd=0, @ra=0, @rcode=0, @question=[[#&lt;Resolv::DNS::Name: _airplay._tcp.local.&gt;, Resolv::DNS::Resource::IN::PTR]], @answer=[[#&lt;Resolv::DNS::Name: _airplay._tcp.local.&gt;, 4486, #&lt;Resolv::DNS::Resource::IN::PTR:0x00007ff3dc0e3198 @name=#&lt;Resolv::DNS::Name: \xE8\x87\xA5\xE5\xAE\xA4._airplay._tcp.local.&gt;, @ttl=4486&gt;]], @authority=[], @additional=[]&gt;</span>
</code></pre></td></tr></table></div></div><p>不過有些是查詢，有些則是回應，我們先把回應區分出來。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-ruby data-lang=ruby><span class=n>mdns</span> <span class=o>=</span> <span class=no>MDNS</span><span class=o>.</span><span class=n>new</span>
<span class=n>mdns</span><span class=o>.</span><span class=n>each</span> <span class=k>do</span> <span class=o>|</span><span class=n>packet</span><span class=p>,</span> <span class=n>_addr</span><span class=o>|</span>
  <span class=n>message</span> <span class=o>=</span> <span class=no>Resolv</span><span class=o>::</span><span class=no>DNS</span><span class=o>::</span><span class=no>Message</span><span class=o>.</span><span class=n>decode</span><span class=p>(</span><span class=n>packet</span><span class=p>)</span>
  <span class=k>next</span> <span class=k>if</span> <span class=n>message</span><span class=o>.</span><span class=n>qr</span><span class=o>.</span><span class=n>zero?</span>

  <span class=n>ap</span> <span class=n>message</span>
<span class=k>end</span>
</code></pre></td></tr></table></div></div><p>在 <code>Resolve::DNS::Message</code> 物件上有一個叫做 <code>qr</code> 的屬性，當他是 0 的時候表示這是一個「查詢」而 1 的時候，就是回應，所以只需要排除是 0 的訊息。</p><h2 id=根據-dns-sd-篩選出-airplay--chromecast-裝置>根據 DNS-SD 篩選出 Airplay / Chromecast 裝置</h2><p>首先我們要先搞懂幾個 DNS-SD 的規則，才能夠找到我們希望找到的資訊。</p><ol><li>DNS-SD 的 FQDN 結構</li><li>DNS-SD 會使用的 Record</li></ol><p>關於 FQDN 結構，我們會看到三種</p><ol><li>&lt; Service >.&lt; Domain ></li><li>&lt; Instance >.&lt; Service >.&lt; Domain ></li><li>&lt; Hostname ></li></ol><p>扣掉第三種不算，因為他就是 Host Name 之外，以 Airplay 裝置會這樣表示</p><pre><code>_airplay._tcp_.local
</code></pre><p>基本上在區網使用 <code>.local</code> 是必然的，然後 <code>_tcp</code> 暴露出了他是透過 TCP 連線，而 <code>_airplay</code> 就是這個服務的類型。</p><p>以我的房間為例，我有一台 Sonos One 音響叫做「臥室」那在 mDNS 中就可以查到 <code>臥室._airplay._tcp.local</code> 這個 DNS 紀錄。</p><p>至於會用到的 DNS Record 則有四種</p><ol><li>PTR (Pointer Record)</li><li>SRV (Service Record)</li><li>A (Address Record)</li><li>TXT (Text Record)</li></ol><p>簡單說 PTR 是一個指標，他會回應一個 Instance 給我們，讓我們知道該去問誰要這個 Service 的資訊，而 SRV / TXT 則提供了這個 Service 的 Port & Hostname 資訊，以及一些 Metadata 讓我們可以了解這個服務。</p><p>最後 A (or AAAA) 則會在我們詢問 Hostname 時回應區網的 IP 位置，讓我們知道該連到哪裡。</p><blockquote><p>這個機制看起來很聰明，有興趣的話可以參考 Spotify 的 <a href=https://labs.spotify.com/2017/03/31/spotifys-lovehate-relationship-with-dns/>DNS-SD</a> 文章，跟這個其實很像。</p></blockquote><p>所以整體流程會變成像這樣</p><ol><li>詢問 <code>PTR _airplay._tcp.local</code> 獲得 <code>_airplar._tcp.local PTR 臥室._airplay_.tcp.local</code> 的回答</li><li>詢問 <code>SRV 臥室._airplay_.tcp.local</code> 獲得 <code>臥室._airplay_.tcp.local SRV 0 0 7000 Sonos-0xAF.local</code> 的回答</li><li>詢問 <code>A Sonos-0xAF.local</code> 獲得 <code>Sonos-0xAF.local A 172.31.1.166</code> 的回答</li></ol><p>基於這些情報，我們可以彙整出：</p><ol><li>有一個裝置叫做「臥室」</li><li>IP 位置是 <code>172.31.1.166</code></li><li>使用 7000 Port 可以和他建立連線</li></ol><p>那麼，我們稍微調整一下程式碼讓我們可以拿到 PTR 來顯示詳細資訊。</p><blockquote><p>DNS-SD 的 <a href=https://tools.ietf.org/html/rfc6763>RFC6763</a> 提到回應 PTR 時要把 SRV / TXT / A 都一起回覆，理論上我們是不太需要重複詢問 SRV / TXT / A 的，不過因為除了 PTR 會把 TTL 設定的比較長，其他都會設定為短時間，好在一段時間後確認 IP 是否有變動之類的。</p></blockquote><p>我們先稍微重構一下，讓 <code>MDNS</code> 可以指篩選出我們有興趣的 PTR Record 回應給我們。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-ruby data-lang=ruby><span class=c1># :nodoc:</span>
<span class=k>class</span> <span class=nc>MDNS</span>
  <span class=kp>include</span> <span class=no>Enumerable</span>

  <span class=c1># 略</span>

  <span class=k>def</span> <span class=nf>listen</span>
    <span class=k>return</span> <span class=k>if</span> <span class=vi>@thread</span>

    <span class=vi>@thread</span> <span class=o>=</span> <span class=no>Thread</span><span class=o>.</span><span class=n>new</span> <span class=k>do</span>
      <span class=kp>loop</span> <span class=k>do</span>
        <span class=n>packet</span><span class=p>,</span> <span class=o>=</span> <span class=vi>@socket</span><span class=o>.</span><span class=n>recvfrom</span><span class=p>(</span><span class=mi>4096</span><span class=p>)</span>
        <span class=n>reply</span> <span class=o>=</span> <span class=no>Resolv</span><span class=o>::</span><span class=no>DNS</span><span class=o>::</span><span class=no>Message</span><span class=o>.</span><span class=n>decode</span><span class=p>(</span><span class=n>packet</span><span class=p>)</span>
        <span class=k>next</span> <span class=k>if</span> <span class=n>reply</span><span class=o>.</span><span class=n>qr</span><span class=o>.</span><span class=n>zero?</span>
        <span class=k>next</span> <span class=k>if</span> <span class=n>ptr?</span><span class=p>(</span><span class=n>reply</span><span class=p>)</span>

        <span class=vi>@replies</span> <span class=o>&lt;&lt;</span> <span class=n>reply</span>
      <span class=k>end</span>
    <span class=k>end</span>
  <span class=k>end</span>

  <span class=k>def</span> <span class=nf>each</span><span class=p>(</span><span class=o>&amp;</span><span class=n>_block</span><span class=p>)</span>
    <span class=kp>loop</span> <span class=k>do</span>
      <span class=k>yield</span> <span class=vi>@replies</span><span class=o>.</span><span class=n>shift</span> <span class=k>until</span> <span class=vi>@replies</span><span class=o>.</span><span class=n>empty?</span>
      <span class=nb>sleep</span> <span class=mi>1</span>
    <span class=k>end</span>
  <span class=k>end</span>

  <span class=kp>private</span>

  <span class=k>def</span> <span class=nf>ptr?</span><span class=p>(</span><span class=n>reply</span><span class=p>)</span>
    <span class=n>reply</span><span class=o>.</span><span class=n>answer</span><span class=o>.</span><span class=n>reduce</span><span class=p>(</span><span class=kp>true</span><span class=p>)</span> <span class=k>do</span> <span class=o>|</span><span class=n>prev</span><span class=p>,</span> <span class=p>(</span><span class=n>_</span><span class=p>,</span> <span class=n>_</span><span class=p>,</span> <span class=n>data</span><span class=p>)</span><span class=o>|</span>
      <span class=n>prev</span> <span class=o>&amp;</span> <span class=n>data</span><span class=o>.</span><span class=n>is_a?</span><span class=p>(</span><span class=no>Resolv</span><span class=o>::</span><span class=no>DNS</span><span class=o>::</span><span class=no>Resource</span><span class=o>::</span><span class=no>IN</span><span class=o>::</span><span class=no>PTR</span><span class=p>)</span>
    <span class=k>end</span>
  <span class=k>end</span>
<span class=k>end</span>

<span class=n>mdns</span> <span class=o>=</span> <span class=no>MDNS</span><span class=o>.</span><span class=n>new</span>
<span class=n>mdns</span><span class=o>.</span><span class=n>listen</span>
<span class=n>mdns</span><span class=o>.</span><span class=n>each</span> <span class=k>do</span> <span class=o>|</span><span class=n>reply</span><span class=o>|</span>
  <span class=n>reply</span><span class=o>.</span><span class=n>each_answer</span> <span class=k>do</span> <span class=o>|</span><span class=nb>name</span><span class=p>,</span> <span class=n>_</span><span class=p>,</span> <span class=n>_</span><span class=o>|</span>
    <span class=n>ap</span> <span class=nb>name</span>
  <span class=k>end</span>
<span class=k>end</span>
</code></pre></td></tr></table></div></div><p>執行後會獲得類似這樣的的訊息，因為 PTR 回應的是 Instance Name 所以是預期的結果。</p><pre><code>#&lt;Resolv::DNS::Name: 臥室._airplay._tcp.local.&gt;
#&lt;Resolv::DNS::Name: Sonos-7828CAC4542C.local.&gt;
#&lt;Resolv::DNS::Name: 7828CAC4542C@臥室._raop._tcp.local.&gt;
</code></pre><p>如此一來，我們只要稍加修改就可以篩選出是提供 Airplay / Chromecast 的裝置。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-ruby data-lang=ruby><span class=c1># Airplay 有兩種</span>
<span class=n>airplay</span> <span class=o>=</span> <span class=no>Resolv</span><span class=o>::</span><span class=no>DNS</span><span class=o>::</span><span class=no>Name</span><span class=o>.</span><span class=n>create</span><span class=p>(</span><span class=s1>&#39;_airplay._tcp.local.&#39;</span><span class=p>)</span>
<span class=n>raop</span> <span class=o>=</span> <span class=no>Resolv</span><span class=o>::</span><span class=no>DNS</span><span class=o>::</span><span class=no>Name</span><span class=o>.</span><span class=n>create</span><span class=p>(</span><span class=s1>&#39;_raop._tcp.local.&#39;</span><span class=p>)</span>
<span class=c1># Chromecast</span>
<span class=n>chromecast</span> <span class=o>=</span> <span class=no>Resolv</span><span class=o>::</span><span class=no>DNS</span><span class=o>::</span><span class=no>Name</span><span class=o>.</span><span class=n>create</span><span class=p>(</span><span class=err>&#39;</span><span class=n>_googlecast</span><span class=o>.</span><span class=n>_tcp</span><span class=o>.</span><span class=n>local</span><span class=o>.</span><span class=p>)</span>

<span class=n>mdns</span><span class=o>.</span><span class=n>each</span> <span class=k>do</span> <span class=o>|</span><span class=n>reply</span><span class=o>|</span>
  <span class=n>reply</span><span class=o>.</span><span class=n>each_answer</span> <span class=k>do</span> <span class=o>|</span><span class=nb>name</span><span class=p>,</span> <span class=n>_</span><span class=p>,</span> <span class=n>_</span><span class=o>|</span>
    <span class=k>next</span> <span class=k>unless</span> <span class=nb>name</span><span class=o>.</span><span class=n>subdomain_of?</span><span class=p>(</span><span class=n>airplay</span><span class=p>)</span>
    <span class=k>next</span> <span class=k>unless</span> <span class=nb>name</span><span class=o>.</span><span class=n>subdomain_of?</span><span class=p>(</span><span class=n>raop</span><span class=p>)</span>
    <span class=k>next</span> <span class=k>unless</span> <span class=nb>name</span><span class=o>.</span><span class=n>subdomain_of?</span><span class=p>(</span><span class=n>chromecast</span><span class=p>)</span>
    
    <span class=n>ap</span> <span class=nb>name</span>
  <span class=k>end</span>
<span class=k>end</span>
</code></pre></td></tr></table></div></div><blockquote><p>另外我們可以透過 <code>reply.each_addationial</code> 獲取更多資訊，不過可惜的是 <code>Resolv::DNS::Message</code> 在解析時可能因為某些關係只能知道他是 <code>PTR</code> 但是無法正確解析，就會獲得 <code>Generic::Type12_XXXX</code> 這種類型的物件，反而不好處理。</p></blockquote><h2 id=小結>小結</h2><p>在做這個技術測試的時候，發現蠻多情境下大家都是串 C API 然後去呼叫作業系統提供的 DNS-SD 機制來實作，不過在了解原理的狀況下，其實我們還是可以靠純 Ruby 的方式實現一定程度的 DNS-SD 機制。</p><p>那麼，這個技術有什麼用途嗎？在五倍的 IoT 專案 <a href=https://tamashii.io>Tamashii</a> 當時因為裝置很多的關係，我們就有研究過透過 DNS-SD 去找到區網內的裝置，然後讓他能夠一次性的套用或者修改設定，不過礙於各種因素就暫時沒有把他實作出來。</p><p>這次重新審視之後發現其實還是非常有用的，近期應該會更新一個在 Tamashii 專案下可以使用的 DNS-SD Gem 吧！</p><blockquote><p>礙於篇幅，其實還有下篇 - 偽裝成 Airplay 裝置的系列，不過就先到這裡告一段落吧！</p></blockquote><footer class=article__footer><div class=text-center><div class=fb-share-button data-href="<%- page.permalink %>" data-layout=button_count></div></div><div class="text-center mt-1"><style>.bmc-button img{width:27px!important;margin-bottom:1px!important;box-shadow:none!important;border:none!important;vertical-align:middle!important}.bmc-button{line-height:36px!important;height:37px!important;text-decoration:none!important;display:inline-flex!important;color:#fff!important;background-color:#000!important;border-radius:3px!important;border:1px solid transparent!important;padding:1px 9px!important;font-size:22px!important;letter-spacing:.6px!important;box-shadow:0 1px 2px rgba(190,190,190,.5)!important;-webkit-box-shadow:0 1px 2px 2px rgba(190,190,190,.5)!important;margin:0 auto!important;font-family:cookie,cursive!important;-webkit-box-sizing:border-box!important;box-sizing:border-box!important;-o-transition:.3s all linear!important;-webkit-transition:.3s all linear!important;-moz-transition:.3s all linear!important;-ms-transition:.3s all linear!important;transition:.3s all linear!important}.bmc-button:hover,.bmc-button:active,.bmc-button:focus{-webkit-box-shadow:0 1px 2px 2px rgba(190,190,190,.5)!important;text-decoration:none!important;box-shadow:0 1px 2px 2px rgba(190,190,190,.5)!important;opacity:.85!important;color:#fff!important}</style><link href="https://fonts.googleapis.com/css?family=Cookie" rel=stylesheet><a class=bmc-button target=_blank href=https://www.buymeacoffee.com/aotoki><img src=https://bmc-cdn.nyc3.digitaloceanspaces.com/BMC-button-images/BMC-btn-logo.svg alt="Buy me a Coffee"><span style=margin-left:5px>Buy me a Coffee</span></a></div><iframe scrolling=no frameborder=0 style="display:block;margin:0 auto;height:212px" src="https://button.like.co/in/embed/elct9620/button?referrer=<%- page.permalink %>"></iframe><ul class=article__tag-list><li class=article__tag-list-item><a class=article__tag-list-link href=https://blog.frost.tw/tags/Ruby/>Ruby</a></li><li class=article__tag-list-item><a class=article__tag-list-link href=https://blog.frost.tw/tags/mDNS/>mDNS</a></li><li class=article__tag-list-item><a class=article__tag-list-link href=https://blog.frost.tw/tags/DNS-SD/>DNS-SD</a></li><li class=article__tag-list-item><a class=article__tag-list-link href=https://blog.frost.tw/tags/%E5%BF%83%E5%BE%97/>心得</a></li></ul></footer><aside class=related><header class=related__header><h3 class=related__title>相關文章</h3></header><ul><li class=related__item><a class=related__link href=/posts/2018/11/06/Become-a-programmer-Find-your-own-value/>轉職工程師：尋找自己的價值</a></li><li class=related__item><a class=related__link href=/posts/2018/10/23/Become-a-programmer-Why-is-bottleneck-coming-very-soon/>轉職工程師：為什麼馬上就遇到瓶頸？</a></li><li class=related__item><a class=related__link href=/posts/2018/10/02/Become-a-programmer-how-to-start/>轉職工程師：要學什麼才好？</a></li><li class=related__item><a class=related__link href=/posts/2018/09/25/Become-a-programmer-lose-at-the-starting-line/>轉職工程師：輸在起跑點</a></li><li class=related__item><a class=related__link href=/posts/2018/09/10/How-to-choose-your-first-job/>怎麼選第一份工作？</a></li></ul></aside></div></article><div class=adv><script async src=//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-2844969736316510 data-ad-slot=5530952976 data-ad-format=auto></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div><section id=comment class=comment-box><h1 class=comment-box__title>留言</h1><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"revo-skill-frost"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></section></div><footer id=footer><div id=copyright>&copy;2020 <a href="https://plus.google.com/117236344655673213049?rel=author" target=_blank rel=noreferrer>蒼時弦也</a>. All right reversed.</div></footer><script src=/js/app.min.3b4fb51ff88af8769c725d45dc3d296b006596a8eb2118a56e7bbfacf4a08d34.js></script><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5TQLRN" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-5TQLRN');</script><script>window.fbAsyncInit=function(){FB.init({appId:'178355449110',xfbml:true,version:'v2.12'});FB.AppEvents.logPageView();};(function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(d.getElementById(id)){return;}
js=d.createElement(s);js.id=id;js.src="https://connect.facebook.net/zh_TW/sdk.js";js.async=true
js.defer=true
fjs.parentNode.insertBefore(js,fjs);}(document,'script','facebook-jssdk'));</script><div class=loading></div></body></html>