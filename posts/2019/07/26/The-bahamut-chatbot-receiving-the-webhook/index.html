<!DOCTYPE html><html lang="zh-TW"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><title>巴哈姆特 Chatbot 之亂：用 Ruby on Rails 接收 Webhook | 弦而時習之</title><meta name="theme-color" content="#EFEFEF"><meta name="author" content="蒼時弦也"><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name="description" content="六月底的時候發現巴哈姆特似乎想為他們推出的 Messaging APP （哈哈姆特）舉辦一個聊天機器人的比賽，看到之後想說還算蠻有趣的，所以我就跟朋友很隨意的組成一個團隊來開發。跟大多數我們熟悉串接 Chatbot 的機制是類似的，我們可以用 Webhook 的方式接收一個來自使用者發送的訊息，然後再透過程式處理後回傳訊息給使用者。"><meta name="keywords" content="Ruby,Ruby on Rails,聊天機器人,Chatbot,巴哈姆特"><meta property="og:type" content="article"><meta property="og:title" content="巴哈姆特 Chatbot 之亂：用 Ruby on Rails 接收 Webhook"><meta property="og:url" content="https://blog.frost.tw/posts/2019/07/26/The-bahamut-chatbot-receiving-the-webhook/"><meta property="og:site_name" content="弦而時習之"><meta property="og:description" content="六月底的時候發現巴哈姆特似乎想為他們推出的 Messaging APP （哈哈姆特）舉辦一個聊天機器人的比賽，看到之後想說還算蠻有趣的，所以我就跟朋友很隨意的組成一個團隊來開發。跟大多數我們熟悉串接 Chatbot 的機制是類似的，我們可以用 Webhook 的方式接收一個來自使用者發送的訊息，然後再透過程式處理後回傳訊息給使用者。"><meta property="og:locale" content="zh-TW"><meta property="og:image" content="https://blog.frost.tw/images/2019-07-26-the-bahamut-chatbot-receiving-the-webhook/thumbnail.png"><meta property="og:updated_time" content="2019-07-26T06:48:29.637Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="巴哈姆特 Chatbot 之亂：用 Ruby on Rails 接收 Webhook"><meta name="twitter:description" content="六月底的時候發現巴哈姆特似乎想為他們推出的 Messaging APP （哈哈姆特）舉辦一個聊天機器人的比賽，看到之後想說還算蠻有趣的，所以我就跟朋友很隨意的組成一個團隊來開發。跟大多數我們熟悉串接 Chatbot 的機制是類似的，我們可以用 Webhook 的方式接收一個來自使用者發送的訊息，然後再透過程式處理後回傳訊息給使用者。"><meta name="twitter:image" content="https://blog.frost.tw/images/2019-07-26-the-bahamut-chatbot-receiving-the-webhook/thumbnail.png"><link rel="publisher" href="https://plus.google.com/117236344655673213049"><meta property="fb:app_id" content="178355449110"><meta property="fb:pages" content="180666522388"><script type="application/ld+json">[
{
    "@context": "https://schema.org",
    "@type": "Blog",
    "name": "弦而時習之",
    "url": "https://blog.frost.tw",
    "image": "http://blog.frost.tw/icon-512.png",
    "description": "蒼時弦也的個人網誌，專注在前端、後端以及遊戲開發，大多使用 Ruby 和 Ruby on Rails 以及 Golang、JS 和 C 語言。",
    "sameAs": [
      "https://www.facebook.com/frost.tw/"
    ]
},
{
    "@context": "https://schema.org",
    "@type": "Person",
    "name": "蒼時弦也",
    "url": "https://blog.frost.tw",
    "sameAs": [
      "https://www.facebook.com/elct9620",
      "https://www.instagram.com/elct9620/",
      "https://twitter.com/elct9620",
      "https://plus.google.com/+%E8%92%BC%E6%99%82%E5%BC%A6%E4%B9%9F-plus",
      "https://www.linkedin.com/in/elct9620"
    ]
},
{
  "@context":"https://schema.org",
  "@type":"BlogPosting",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://blog.frost.tw/posts/2019/07/26/The-bahamut-chatbot-receiving-the-webhook/"
  },
  "headline":"巴哈姆特 Chatbot 之亂：用 Ruby on Rails 接收 Webhook",
  "image": [
    
    "https://blog.frost.tw/images/2019-07-26-the-bahamut-chatbot-receiving-the-webhook/thumbnail.png",
    
    "http://blog.frost.tw/icon-512.png"
  ],
  "thumbnailUrl": "https://blog.frost.tw/images/2019-07-26-the-bahamut-chatbot-receiving-the-webhook/thumbnail.png", 
  "datePublished": "2019-07-26T06:44:28.000Z",
  "dateModified": "2019-07-26T06:48:29.637Z",
  "description":"六月底的時候發現巴哈姆特似乎想為他們推出的 Messaging APP （哈哈姆特）舉辦一個聊天機器人的比賽，看到之後想說還算蠻有趣的，所以我就跟朋友很隨意的組成一個團隊來開發。跟大多數我們熟悉串接 Chatbot 的機制是類似的，我們可以用 Webhook 的方式接收一個來自使用者發送的訊息，然後再透過程式處理後回傳訊息給使用者。",
  "author": {
    "@type": "Person",
    "name": "蒼時弦也"
  },
  "publisher": {
    "@type": "Organization",
    "name": "蒼時弦也",
    "logo": "https://blog.frost.tw/icon-512.png"
  }
},
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
    "@type": "ListItem",
    "position": 1,
    "item": {
      "@id": "https://blog.frost.tw",
      "name": "弦而時習之 ",
      "image": "http://blog.frost.tw/icon-512.png"
    }
  },{
    "@type": "ListItem",
    "position": 2,
    "item": {
      "@id": "https://blog.frost.tw/posts/2019/07/26/The-bahamut-chatbot-receiving-the-webhook/",
      "name": "巴哈姆特 Chatbot 之亂：用 Ruby on Rails 接收 Webhook",
      "image": "https://blog.frost.tw/images/2019-07-26-the-bahamut-chatbot-receiving-the-webhook/thumbnail.png"
    }
  }]
}
,
{
"@context": "https://schema.org",
  "@type": "Organization",
  "name": "蒼時弦也",
  "url": "https://blog.frost.tw",
  "logo": "https://blog.frost.tw/icon-512.png"
}
]</script><link rel="canonical" href="https://blog.frost.tw/posts/2019/07/26/The-bahamut-chatbot-receiving-the-webhook/"><link href="/icon-512.png" rel="icon"><link rel="alternate" href="/feed.xml" title="弦而時習之" type="application/rss+xml"><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--><link rel="stylesheet" href="/css/style.css" media="screen" type="text/css"><script async src="/js/turbolinks.js"></script></head><body><div id="fb-root" data-turbolinks-permanent></div><header id="header"><h1 id="sitename"><a href="/" class="hide-text logo--icon align-center">弦而時習之</a></h1><aside id="slogan" class="slogan align-center text-center"><h2 class="slogan__title">Aotokitsuruya</h2><p class="slogan__description">The Web is attracting me, so I start learning PHP, HTML, CSS and JavaScript. When I know about Ruby, I fall in love with it. Now, I working with my friend to design games using C++ and still learning web about Golang, Ruby and JavaScript. In the other side, I also be a designer, the reason why the web is attracted me.</p></aside></header><div id="wrapper"><article class="post article"><header class="article__header"><time datetime="2019-07-26T06:44:28.000Z" class="article__time--header">Jul.26</time><h1 class="article__title">巴哈姆特 Chatbot 之亂：用 Ruby on Rails 接收 Webhook</h1></header><div class="article__entry"><p>六月底的時候發現巴哈姆特似乎想為他們推出的 Messaging APP （哈哈姆特）舉辦一個聊天機器人的比賽，看到之後想說還算蠻有趣的，所以我就跟朋友很隨意的組成一個團隊來開發。</p><p>跟大多數我們熟悉串接 Chatbot 的機制是類似的，我們可以用 Webhook 的方式接收一個來自使用者發送的訊息，然後再透過程式處理後回傳訊息給使用者。</p><a id="more"></a><h2 id="了解-Webhook-機制"><a href="#了解-Webhook-機制" class="headerlink" title="了解 Webhook 機制"></a>了解 Webhook 機制</h2><p>在程式設計中，我們常常會使用一種叫做「Hook（鉤子）」或者「Callback（回呼）」的機制，用比較好懂的角度去說明，他是一個在「程式執行中插入額外動作」</p><p>舉例來說，我們會有像這樣的程式</p><ul><li>接收訊息</li><li>顯示訊息</li></ul><p>假設我們要增加一個 Hook 就會變成像這樣</p><ul><li>接收訊息</li><li>Hooks （可能有多個）</li><li>顯示訊息</li></ul><p>而 Webhook 就是指這個 Hook 利用 Web（網站）的方式執行，所以當這些 Messaging APP 收到訊息後，會利用 Webhook 做一些事情（像是發送給我們自己的伺服器）然後再繼續動作。</p><h2 id="了解-Signature-機制"><a href="#了解-Signature-機制" class="headerlink" title="了解 Signature 機制"></a>了解 Signature 機制</h2><p>不過當我們收到一段訊息的時候，要怎麼知道這段訊息是來是正確的使用者？</p><p>這就要靠 Signature 機制來幫助我們，透過一個共用的密鑰（Token）來對訊息內容加密，當我們收到訊息的時候只要用同樣的密鑰對訊息加密，就會獲得一段驗證碼，當我們比對驗證碼跟發送者提供給我們相同時，就可以假設這是可信的訊息。</p><blockquote><p>有些網站提供檔案下載時會提供 MD5 校驗碼也是同樣的原理。</p></blockquote><p>以哈哈姆特的 Webhook 為例子，我們會從哈哈姆特收到一個 Webhook 請求，這個請求會包含類似下面的資訊。</p><ul><li>X-BAHA-DATA-SIGNATURE 標頭（Header）</li><li>內容（Ex. 某段訊息）</li></ul><p>巴哈使用的是 SHA1 演算法（MD5 是另外一種），所以我們就要把內容用 SHA1 計算，再比對巴哈給我們的 <code>X-BAHA-DATA-SIGNATURE</code> 來驗證是否是來自巴哈，因為加密的密碼理論上只會有我們自己跟巴哈知道。</p><h2 id="接收請求"><a href="#接收請求" class="headerlink" title="接收請求"></a>接收請求</h2><p>如果你還沒有用過 Ruby on Rails 的話，可以參考<a href="https://kaochenlong.com/" rel="external nofollow noopener noreferrer" target="_blank">龍哥</a>所寫的<a href="https://railsbook.tw/" rel="external nofollow noopener noreferrer" target="_blank">為你自己學 Ruby on Rails</a> 這本書，在網站上看到的部分就足夠你入門。</p><p>首先，我們希望有一個網址（Endpoint）可以接收請求，所以要在 <code>config/routes.rb</code> 定義一個控制器（Controller）來處理。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Rails.application.routes.draw <span class="keyword">do</span></span><br><span class="line"> <span class="comment"># ...</span></span><br><span class="line"> </span><br><span class="line"> post <span class="symbol">:bahamut</span>, <span class="symbol">to:</span> <span class="string">'webhook#bahamut'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>透過 Ruby 的 DSL 特性，我們就可以定義出一個叫做 <code>/bahamut</code> 的位址，用來接收巴哈姆特的 Webhook。然後在上面定義要使用 Webhook 控制器上面的 <code>#bahamut</code> 方法來處理這個位址的動作。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app/controllers/webhook_controller.rb</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebhookController</span> &lt; ActionController::API</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bahamut</span></span></span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> Implement Chatbot Handler</span></span><br><span class="line">    render <span class="symbol">plain:</span> <span class="string">'Hello World'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在這邊我們可能需要下一點指令才能測試，或者你可以使用 <a href="https://www.getpostman.com/" rel="external nofollow noopener noreferrer" target="_blank">Postman</a> 這套軟體來模擬 POST 請求。</p><blockquote><p>POST 請求一般是我們送出表單的操作，所以無法直接用打開網頁的方式開啟。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST http://localhost:3000/bahamut</span><br></pre></td></tr></table></figure><p>然後我們就能看到我們的終端機（Terminal）出現了 <code>Hello World</code> 字樣。</p><p>如果我們希望巴哈能發送訊息到我們自己的本機電腦（localhost）就必須讓我們的電腦能在網路上被找到，這可以利用 <a href="https://ngrok.com/" rel="external nofollow noopener noreferrer" target="_blank">Ngrok</a> 這套軟體達成，透過 Ngrok 我們可以得到一個暫時性的網址，如此一來就能將本機測試的網站被巴哈呼叫到。</p><blockquote><p>我想大家可能有疑問，就是是不是一定要用 Ruby on Rails 才能做到，實際上因為 Ruby on Rails 對初學者來說是最容易搭建出網站的選項，才會選擇使用。不然只要是任何能處理網的程式語言，都是可以直接用來寫 Chatbot 的，只不過像是 Ruby on Rails 這類網站開發框架，能幫我們省下學習這些基礎知識的時間。</p></blockquote><h2 id="驗證-Signature"><a href="#驗證-Signature" class="headerlink" title="驗證 Signature"></a>驗證 Signature</h2><p>因為處理簽章（Signature）的機制比較複雜，在物件導向類型的語言中，我們會設計一個 Class 來專門處理這件事情。</p><p>所以我們來製作一個服務物件（Service Object）叫做 Signature Verifer （簽章驗證器）來專們針對巴哈姆特傳入的簽章做驗證。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app/services/signature_verifer.rb</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SignatureVerifer</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(request)</span></span></span><br><span class="line">    @request = request</span><br><span class="line">    <span class="comment"># 讀取內容</span></span><br><span class="line">    @body = @request.body.read</span><br><span class="line">    <span class="comment"># 讀取 Signature Header</span></span><br><span class="line">    @signature = request.headers[<span class="string">'x-baha-data-signature'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 把內容退回開頭（避免其他人讀取不到資料）</span></span><br><span class="line">    @request.body.rewind</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>第一個步驟我們要設計驗證器的「初始化（Initialize）」階段要做什麼，我們預期會收到一個 HTTP 請求（<code>request</code>）然後將裡面的簽章（<code>x-baha-data-signature</code>）取出來，以及內容（對話訊息）取出來，這是我們在前面提到驗證是否是由巴哈發出的訊息所需要的資訊。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app/services/signature_verifer.rb</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SignatureVerifer</span></span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">  </span><br><span class="line">  private</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">verify_signature</span></span></span><br><span class="line">    @verify_signature <span class="params">||</span>=</span><br><span class="line">      <span class="string">"sha1=<span class="subst">#&#123;OpenSSL::HMAC.hexdigest(<span class="string">'SHA1'</span>, ENV[<span class="string">'BAHA_SECRET'</span>], @body)&#125;</span>"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>這個步驟是根據巴哈的<a href="https://sites.google.com/gamer.com.tw/hahamut-bot/%E6%8E%A5%E6%94%B6webhook%E4%BA%8B%E4%BB%B6?authuser=0" rel="external nofollow noopener noreferrer" target="_blank">文件</a>將剛剛抓到的訊息跟聊天機器人的 Secret（秘鑰）做 SHA1 運算產生出我們自己計算的簽章，如此一來跟巴哈提供的比對，就會知道內容是不是一樣沒有被人偷偷竄改。</p><blockquote><p>要特別注意的是 <code>ENV[&#39;BAHA_SECRET&#39;]</code> 這邊我是使用「環境變數」<code>來儲存密鑰，這樣只有安裝伺服器的人會知道，就可以避面將這類敏感資訊放到程式碼之中。 在 Rails 5 之後，我們可以用</code>rails credentials:edit` 這個指令編輯一個加密的檔案，並把密鑰放到裡面，使用方法可以參考 <a href="https://guides.rubyonrails.org/configuring.html" rel="external nofollow noopener noreferrer" target="_blank">Ruby on Rails 文件</a></p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SignatureVerifer</span></span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">valid?</span></span></span><br><span class="line">      @signature == verify_signature</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  private</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>最後再提供一個 <code>valid?</code> 方法，用來讓我們查詢是否正確就可以了！</p><p>我們修改一下 <code>WebhookController</code> 來做一個簡單的檢查。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebhookController</span> &lt; ActionController::API</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bahamut</span></span></span><br><span class="line">    <span class="keyword">return</span> unathorized_error <span class="keyword">unless</span> valid_signature?</span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> Implement Chatbot Handler</span></span><br><span class="line">    render <span class="symbol">plain:</span> <span class="string">'Hello World'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  private</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">valid_signature?</span></span></span><br><span class="line">    SignatureVerifer.new(request).valid?</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unauthorized_error</span></span></span><br><span class="line">    render <span class="symbol">json:</span> &#123; <span class="symbol">error:</span> <span class="string">'Unauthorized'</span> &#125;, <span class="symbol">status:</span> <span class="symbol">:unauthorized</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>假設我們透過 <code>SignatureVerifer</code> 驗證失敗的話，就回傳一個 JSON 資訊表示未驗證，並且設定 HTTP 的狀態碼為 401（未授權）的狀態。</p><blockquote><p>JSON 是一種資料格式，常常用在不同伺服器溝同時當作交歡資料的格式，我們從巴哈收到的訊息也是 JSON 格式。</p></blockquote><h2 id="發送回應"><a href="#發送回應" class="headerlink" title="發送回應"></a>發送回應</h2><p>既然我們已經可以接收訊息，如果使用者都沒有辦法收到任何回應的話肯定會覺得奇怪，所以下一步就是要能發送訊息給使用者。</p><p>哈哈姆特目前支援文字、圖片、貼圖跟事件幾種類型，其中事件是最容易做的，打好基底後也會變得更容易修改成支援其他類型的發送程式。</p><p>我們先來看一下從巴哈接收到的訊息會是怎樣的格式（JSON）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="attr">"botid"</span>:&lt;BOT_ID&gt;,</span><br><span class="line"> <span class="attr">"time"</span>:<span class="number">1512353744843</span>,</span><br><span class="line"> <span class="attr">"messaging"</span>:[</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="attr">"sender_id"</span>:&lt;SENDER_ID&gt;,</span><br><span class="line">     <span class="attr">"message"</span>:&#123;</span><br><span class="line">       <span class="attr">"text"</span>:<span class="string">"Hello~"</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我們需要關注的只有 <code>messaging</code> 區塊的部分，裡面描述了「多個訊息」而每個訊息都會有「發送者」和「內容」兩個資訊。在上面這從官方文件複製的訊息範例中，使用者發送的內容是一段「文字（text）」</p><p>在 Rails 接收到之後，會自動的做好 JSON 解析的處理，所以我們可以直接像這樣使用。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 照每一個訊息處理</span></span><br><span class="line">params[<span class="string">'messaging'</span>].each <span class="keyword">do</span> <span class="params">|message|</span></span><br><span class="line"> <span class="comment"># 解析訊息跟回覆</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在開始處理之前，我們需要先能夠發送訊息到哈哈姆特。因為步驟也是比較多的，所以我們需要製作一個 Sender （發送器）物件來處理。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'net/http'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># app/services/text_sender.rb</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextSender</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(recipient, message)</span></span></span><br><span class="line">    @receipient = receipient</span><br><span class="line">    @message = message</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>首先我們在初始化階段要把「接收者」跟想要發送出去的「訊息」記錄起來。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'net/http'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># app/services/text_sender.rb</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextSender</span></span></span><br><span class="line">  ENDPOINT = <span class="string">'https://us-central1-hahamut-8888.cloudfunctions.net/'</span> \</span><br><span class="line">             <span class="string">"messagePush?access_token=<span class="subst">#&#123;ENV[<span class="string">'BAHA_TOKEN'</span>]&#125;</span>"</span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">perform</span></span></span><br><span class="line">    <span class="comment"># 發送訊息</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">uri</span></span></span><br><span class="line">    @uri <span class="params">||</span>= URI(ENDPOINT)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">ssl?</span></span></span><br><span class="line">    uri.scheme == <span class="string">'https'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">  private</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">request</span></span></span><br><span class="line">    <span class="comment"># 製作一個 HTTP 請求</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>接下來我們將巴哈文件上所提供的位置，以及一些發送請求需要的一些資訊製作出來。</p><blockquote><p>像是 <code>URI</code> 這類轉換是用於 Ruby 處理發送 HTTP 請求所需要的，所以我們都先做好處理方便使用。而 <code>ENV[&#39;BAHA_TOKEN&#39;]</code> 跟前面的 <code>ENV[&#39;BAHA_SECRET&#39;]</code> 用途是一樣的，都是需要避免直接寫在程式內的數值。</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'net/http'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># app/services/text_sender.rb</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextSender</span></span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">  </span><br><span class="line">  private</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">request</span></span></span><br><span class="line">    <span class="keyword">return</span> @request <span class="keyword">if</span> @request.present?</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 產生一個 HTTP Post 請求</span></span><br><span class="line">    @request = Net::HTTP::Post.new(uri)</span><br><span class="line">    <span class="comment"># 使用 JSON 格式（指定內容類型）</span></span><br><span class="line">    @request[<span class="string">'Content-Type'</span>] = <span class="string">'application/json'</span></span><br><span class="line">    <span class="comment"># 把要傳輸的內容轉換成 JSON 格式的資料</span></span><br><span class="line">    @request.body = body.to_json</span><br><span class="line">    @request</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>因為我們要將訊息發給巴哈，巴哈再將訊息發給指定的使用者。</p><blockquote><p>如果是 LINE 或者 Facebook Messenger 我們想對同一個人發訊息，在不同的 Chatbot 有不同的編號（ID）這樣就可以保護使用者不會被沒有授權的 Chatbot 騷擾，所以不論是發送還是接收，都需要透過巴哈的伺服器。</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'net/http'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># app/services/text_sender.rb</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextSender</span></span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">perform</span></span></span><br><span class="line">    http = Net::HTTP.new(uri.host, uri.port)</span><br><span class="line">    http.use_ssl = ssl?</span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> 處理回應</span></span><br><span class="line">    <span class="comment"># 發送請求給巴哈</span></span><br><span class="line">    http.request(request)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">body</span></span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="symbol">recipient:</span> &#123;</span><br><span class="line">        <span class="symbol">id:</span> @recipient</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="symbol">message:</span> &#123;</span><br><span class="line">        <span class="symbol">text:</span> @message</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  private</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>最後我們只需要將請求的內容（文字訊息）定義好，然後讓他可以發送出去，我們就能對使用者發送回應。</p><blockquote><p>這邊的 <code>recipient</code> 通常會是我們收到的 <code>sender_id</code></p></blockquote><p>我們可以在 Rails Console 裡面像這樣簡單測試是否可以發送訊息</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TextSender.new(<span class="string">'巴哈帳號'</span>, <span class="string">'Hello!'</span>)</span><br></pre></td></tr></table></figure><h2 id="自動回應相同訊息"><a href="#自動回應相同訊息" class="headerlink" title="自動回應相同訊息"></a>自動回應相同訊息</h2><p>我們將前面的程式整合後，可以改寫 <code>WebhookController</code> 讓他可以自動回應跟使用者相同的訊息。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebhookController</span> &lt; ActionController::API</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bahamut</span></span></span><br><span class="line">    <span class="keyword">return</span> unathorized_error <span class="keyword">unless</span> valid_signature?</span><br><span class="line">    </span><br><span class="line">    process_messages</span><br><span class="line">    render <span class="symbol">json:</span> &#123; <span class="symbol">message:</span> <span class="string">'OK'</span> &#125;, <span class="symbol">status:</span> <span class="symbol">:ok</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  private</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">process_messages</span></span></span><br><span class="line">    params[<span class="string">'messaging'</span>].each <span class="keyword">do</span> <span class="params">|message|</span></span><br><span class="line">      TextSender.new(</span><br><span class="line">        message[<span class="string">'sender_id'</span>],</span><br><span class="line">        <span class="string">"PONG: <span class="subst">#&#123;message[<span class="string">'message'</span>][<span class="string">'text'</span>]&#125;</span>"</span></span><br><span class="line">      )</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我們透過將每一條訊息（<code>messaging</code>）取出來，然後將接收者設定為發送者（<code>sender_id</code>）並把訊息內容前面加上 <code>PONG:</code> 用來區別，確保確實是經過我們的 Chatbot 處理後才回應的。</p><blockquote><p>PING/PONG 跟 Hello World 都有點像是一個習慣，通常我們用來測試一個伺服器是否有正常運作，就會透過發送 PING 然後確認伺服器有回應 PONG 來當判斷，如果想換成任何想要的訊息都是沒問題的。</p></blockquote><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>其實這些步驟在大多數情況應該被製作成一個 Gem （Ruby 的套件，可以想像成 Mod 之類的東西）直接使用，不過最近比較忙就沒有時間好好設計並且封裝成 Gem。</p><p>不過這篇文章的概念在處理各種類型的 Chatbot 是很好用的，如果有興趣的話也蠻推薦大家詳細了解一下。</p><footer class="article__footer"><div class="text-center"><div class="fb-share-button" data-href="https://blog.frost.tw/posts/2019/07/26/The-bahamut-chatbot-receiving-the-webhook/" data-layout="button_count"></div></div><div class="text-center mt-1"><style>.bmc-button img{width:27px!important;margin-bottom:1px!important;box-shadow:none!important;border:none!important;vertical-align:middle!important}.bmc-button{line-height:36px!important;height:37px!important;text-decoration:none!important;display:inline-flex!important;color:#fff!important;background-color:#000!important;border-radius:3px!important;border:1px solid transparent!important;padding:1px 9px!important;font-size:22px!important;letter-spacing:.6px!important;box-shadow:0 1px 2px rgba(190,190,190,.5)!important;-webkit-box-shadow:0 1px 2px 2px rgba(190,190,190,.5)!important;margin:0 auto!important;font-family:Cookie,cursive!important;-webkit-box-sizing:border-box!important;box-sizing:border-box!important;-o-transition:.3s all linear!important;-webkit-transition:.3s all linear!important;-moz-transition:.3s all linear!important;-ms-transition:.3s all linear!important;transition:.3s all linear!important}.bmc-button:active,.bmc-button:focus,.bmc-button:hover{-webkit-box-shadow:0 1px 2px 2px rgba(190,190,190,.5)!important;text-decoration:none!important;box-shadow:0 1px 2px 2px rgba(190,190,190,.5)!important;opacity:.85!important;color:#fff!important}</style><link href="https://fonts.googleapis.com/css?family=Cookie" rel="stylesheet"><a class="bmc-button" target="_blank" href="https://www.buymeacoffee.com/aotoki" rel="external nofollow noopener noreferrer"><img src="https://bmc-cdn.nyc3.digitaloceanspaces.com/BMC-button-images/BMC-btn-logo.svg" alt="Buy me a Coffee"><span style="margin-left:5px">Buy me a Coffee</span></a></div><iframe scrolling="no" frameborder="0" style="display:block;margin:0 auto;height:212px" src="https://button.like.co/in/embed/elct9620/button?referrer=https://blog.frost.tw/posts/2019/07/26/The-bahamut-chatbot-receiving-the-webhook/"></iframe><ul class="article__tag-list"><li class="article__tag-list-item"><a class="article__tag-list-link" href="/tags/Chatbot/">Chatbot</a></li><li class="article__tag-list-item"><a class="article__tag-list-link" href="/tags/Ruby/">Ruby</a></li><li class="article__tag-list-item"><a class="article__tag-list-link" href="/tags/Ruby-on-Rails/">Ruby on Rails</a></li><li class="article__tag-list-item"><a class="article__tag-list-link" href="/tags/巴哈姆特/">巴哈姆特</a></li><li class="article__tag-list-item"><a class="article__tag-list-link" href="/tags/聊天機器人/">聊天機器人</a></li></ul></footer></div></article><div class="adv"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-2844969736316510" data-ad-slot="5530952976" data-ad-format="auto"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><section id="comment" class="comment-box"><h1 class="comment-box__title">留言</h1><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a rel="nofollow" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section></div><footer id="footer"><div id="copyright">&copy;2013 <a href="https://plus.google.com/117236344655673213049?rel=author" target="_blank" rel="external nofollow noopener noreferrer">蒼時弦也</a>. All right reversed.</div></footer><script type="text/javascript">window.disqus_shortname="revo-skill-frost",function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+window.disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5TQLRN" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><script>!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="//www.googletagmanager.com/gtm.js?id=GTM-5TQLRN",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer")</script><script>window.fbAsyncInit=function(){FB.init({appId:"178355449110",xfbml:!0,version:"v2.12"}),FB.AppEvents.logPageView()},function(e,n,t){var o,s=e.getElementsByTagName(n)[0];e.getElementById(t)||((o=e.createElement(n)).id=t,o.src="https://connect.facebook.net/zh_TW/sdk.js",o.async=!0,s.parentNode.insertBefore(o,s))}(document,"script","facebook-jssdk")</script><script src="/js/app.js"></script><div class="loading"></div></body></html>