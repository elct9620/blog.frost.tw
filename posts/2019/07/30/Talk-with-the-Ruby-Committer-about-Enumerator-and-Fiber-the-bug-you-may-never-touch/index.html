<!doctype html><html lang=zh-tw><head><title>你大概沒機會遇到的 Bug - 跟 Ruby Committer 聊 Enumerator 跟 Fiber - 弦而時習之</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=description content="今年 RubyConf Taiwan 嘗試辦了 After Hack 這個活動，也因此有機會可以跟 Ruby 語言的 Commiter 聊一些有趣的問題。
當天我的預定是把活動這幾天寫的 Gem 認真的補完測試，不過沒想到還剩下一個多小時就做完了，那就順便來思考一下 Tamashii 專案能怎樣去改進， …"><meta name=created content="2019-07-30T00:00:00+0000"><meta name=modified content="2019-07-30T14:11:31+0000"><meta name=author content="蒼時弦也"><meta property="og:site_name" content="弦而時習之"><meta property="og:title" content="你大概沒機會遇到的 Bug - 跟 Ruby Committer 聊 Enumerator 跟 Fiber"><meta property="og:url" content="https://blog.frost.tw/posts/2019/07/30/Talk-with-the-Ruby-Committer-about-Enumerator-and-Fiber-the-bug-you-may-never-touch/"><meta property="og:type" content="article"><meta property="og:image" content="https://blog.frost.tw/images/2019-07-30-talk-with-the-ruby-commiter-about-enumerator-and-fiber-the-bug-you-may-never-touch/thumbnail.jpg"><meta name=theme-color content="#EFEFEF"><link href=https://blog.frost.tw/icon-512.png rel=icon><link rel=canonical href=https://blog.frost.tw/posts/2019/07/30/Talk-with-the-Ruby-Committer-about-Enumerator-and-Fiber-the-bug-you-may-never-touch/><script type=application/ld+json>[{"@context":"https://schema.org","@type":"WebPage","headline":"你大概沒機會遇到的 Bug - 跟 Ruby Committer 聊 Enumerator 跟 Fiber","datePublished":"2019-07-30T00:00:00Z","dateModified":"2019-07-30T14:11:31Z","url":"https://blog.frost.tw/posts/2019/07/30/Talk-with-the-Ruby-Committer-about-Enumerator-and-Fiber-the-bug-you-may-never-touch/","description":"今年 RubyConf Taiwan 嘗試辦了 After Hack 這個活動，也因此有機會可以跟 Ruby 語言的 Commiter 聊一些有趣的問題。\n當天我的預定是把活動這幾天寫的 Gem 認真的補完測試，不過沒想到還剩下一個多小時就做完了，那就順便來思考一下 Tamashii 專案能怎樣去改進， …\n","keywords":["RubyConfTW","Bug","Ruby","Enumerator","Fiber"],"image":"https://blog.frost.tw/images/2019-07-30-talk-with-the-ruby-commiter-about-enumerator-and-fiber-the-bug-you-may-never-touch/thumbnail.jpg","author":{"@type":"Person","name":"蒼時弦也"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.frost.tw/"},"publisher":{"@type":"Organization","name":"弦而時習之","url":"https://blog.frost.tw/"}},{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/blog.frost.tw\/","name":"弦而時習之","image":"http:\/\/blog.frost.tw\/icon-512.png"}},{"@type":"ListItem","position":2,"item":{"@id":"https:\/\/blog.frost.tw\/posts\/2019\/07\/30\/Talk-with-the-Ruby-Committer-about-Enumerator-and-Fiber-the-bug-you-may-never-touch\/","name":"你大概沒機會遇到的 Bug - 跟 Ruby Committer 聊 Enumerator 跟 Fiber","image":"https:\/\/blog.frost.tw\/images\/2019-07-30-talk-with-the-ruby-commiter-about-enumerator-and-fiber-the-bug-you-may-never-touch\/thumbnail.jpg"}}]}]</script><link rel=stylesheet href=/css/styls.css><script async src=/js/turbolinks.min.js></script></head><body><div id=fb-root data-turbolinks-permanent></div><h1 id=sitename><a href=/ class="hide-text logo--icon align-center">弦而時習之</a></h1><aside id=slogan class="slogan align-center text-center"><h2 class=slogan__title>Aotokitsuruya</h2><p class=slogan__description>The Web is attracting me, so I start learning PHP, HTML, CSS and JavaScript. When I know about Ruby, I fall in love with it. Now, I working with my friend to design games using C++ and still learning web about Golang, Ruby and JavaScript. In the other side, I also be a designer, the reason why the web is attracted me.</p></aside><div id=wrapper><article class="post article"><header class=article__header><time datetime=2019-07-30T14:11:31+0000 class=article__time--header>Feb.30</time><h1 class=article__title>你大概沒機會遇到的 Bug - 跟 Ruby Committer 聊 Enumerator 跟 Fiber</h1></header><div class=article__entry><nav class=translation></nav><p>今年 <a href=https://2019.rubyconf.tw/>RubyConf Taiwan</a> 嘗試辦了 After Hack 這個活動，也因此有機會可以跟 Ruby 語言的 Commiter 聊一些有趣的問題。</p><p>當天我的預定是把活動這幾天寫的 Gem 認真的補完測試，不過沒想到還剩下一個多小時就做完了，那就順便來思考一下 <a href=https://tamashii.io>Tamashii</a> 專案能怎樣去改進，在今年的演講中大家應該都對 Fiber 有一個認識，而這個也許是一個不錯的選項。</p><p>所以就馬上去看了一下講者（Samuel）的 <a href=https://github.com/socketry/async>Async</a> 這個 Gem 做了些什麼事情，因為剛講完關於 Enumerator 的演講，所以自然地看到了一段引起我興趣的說明。</p><blockquote><p>Due to limitations within Ruby and the nature of this library, it is not possible to use to_enum on methods which invoke asynchronous behavior. We hope to fix this issue in the future.</p></blockquote><p>既然作者本人就在現場，而且 Issue 的內容也看不太出來發生什麼問題，那麼就直接問吧！</p><h2 id=關於-fiber>關於 Fiber</h2><p>詳細的部分可以參考之前寫過的 <a href=https://blog.frost.tw/posts/2018/06/26/Talk-about-ruby-s-fiber-Part-1/>Fiber 簡介</a> 以下只做簡單的介紹方便跟上這篇文章的內容，另外因為這幾年很多語言都在努力的更新，雖然 Ruby 是一個相容性非常好的語言，但是還是有不少變化是隱含的。</p><blockquote><p>以文章中的 4K 堆疊為例，今年另一位講者（<a href=https://github.com/dsh0416>Delton Ding</a>）在 <a href=https://twitter.com/DeltonDing/status/1155853101586214918>Twitter</a> 提醒我這個特性在 2010 年和 2017 年都修改過，在 Ruby 2.5 之後的版本是不會產生，而改用指標的方式來處理。</p></blockquote><p>Fiber 機制用很簡單的方式說明，就是我們可以在單一的 Thread 下面，再做一次切割來切換執行順序。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-ruby data-lang=ruby><span class=n>f</span> <span class=o>=</span> <span class=no>Fiber</span><span class=o>.</span><span class=n>new</span> <span class=k>do</span>
  <span class=c1># A: 做某些事情</span>
  <span class=no>Fiber</span><span class=o>.</span><span class=n>yield</span> <span class=c1># I/O Blocking 先跳出給其他人做事</span>
  <span class=c1># B: 繼續做事情</span>
<span class=k>end</span>

<span class=c1># 執行 Fiber (A 區塊）</span>
<span class=n>f</span><span class=o>.</span><span class=n>resume</span>
<span class=c1># 繼續執行（B 區塊）</span>
<span class=n>f</span><span class=o>.</span><span class=n>resume</span>
</code></pre></td></tr></table></div></div><p>以前我們會需要用切分 Thread 的方式來對應 I/O Blocking 的情況，現在我們可以用一些 Non-Blocking 的操作來判斷是否有賭塞現象，進而控制執行的流程。</p><h2 id=enumerator-中的-fiber>Enumerator 中的 Fiber</h2><p>今年我自己的演講主要是著重在 Enumerator 的生成與運作上，所以討論了 Ruby 能用哪些技巧去做到讓 <code>yield</code> 行為暫時不發生，以及讓某些動作能夠被「延遲（<code>#lazy</code>）」執行。</p><p>當我跟 Samuel 聊到這個 Enumerator 的 Bug 時候，我問了一句「Which ruby version this will happen?」得到的是「All versions」的解答，然後我馬上就知道這是我「沒有讀」的那一個部分，也就是關於 Enumerator 如何去迭代數值的部分。</p><blockquote><p>寫這篇文章的時候我再去看了一次 <code>enumerator.c</code> 裡面有出現 Fiber 的區段，基本上應該是有使用到 <code>#next</code> 的情況會發生，如果是一些 <code>#zip</code> 和 <code>#map</code> 的情況，因為不一定會去呼叫到 <code>#next</code> 就不會產生問題。</p></blockquote><p>那麼，到底是在哪裡產生了 Fiber 呢？</p><p><code>enumerator.c</code>（Ruby 2.6.2）裡面只有一個 <code>fiber_new</code> 我們照呼叫的順序去來追蹤，首先會看到 <code>enumerator_next</code> 這個實作。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=k>static</span> <span class=n>VALUE</span>
<span class=nf>enumerator_next</span><span class=p>(</span><span class=n>VALUE</span> <span class=n>obj</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>VALUE</span> <span class=n>vs</span> <span class=o>=</span> <span class=n>enumerator_next_values</span><span class=p>(</span><span class=n>obj</span><span class=p>)</span><span class=p>;</span>
    <span class=k>return</span> <span class=n>ary2sv</span><span class=p>(</span><span class=n>vs</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>這邊會把 <code>enumerator_next_values</code> 回傳的數值找出第一個（如果是陣列）或者直接回傳，基本上就是把下一個元素找出來。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=k>static</span> <span class=n>VALUE</span>
<span class=nf>enumerator_next_values</span><span class=p>(</span><span class=n>VALUE</span> <span class=n>obj</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>struct</span> <span class=n>enumerator</span> <span class=o>*</span><span class=n>e</span> <span class=o>=</span> <span class=n>enumerator_ptr</span><span class=p>(</span><span class=n>obj</span><span class=p>)</span><span class=p>;</span>
    <span class=n>VALUE</span> <span class=n>vs</span><span class=p>;</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>e</span><span class=o>-</span><span class=o>&gt;</span><span class=n>lookahead</span> <span class=o>!</span><span class=o>=</span> <span class=n>Qundef</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>vs</span> <span class=o>=</span> <span class=n>e</span><span class=o>-</span><span class=o>&gt;</span><span class=n>lookahead</span><span class=p>;</span>
        <span class=n>e</span><span class=o>-</span><span class=o>&gt;</span><span class=n>lookahead</span> <span class=o>=</span> <span class=n>Qundef</span><span class=p>;</span>
        <span class=k>return</span> <span class=n>vs</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>get_next_values</span><span class=p>(</span><span class=n>obj</span><span class=p>,</span> <span class=n>e</span><span class=p>)</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>然後這邊會拿當下作用的 Enumerator 來去找接下來會出現的數值，所以我們再繼續往下看到 <code>get_next_values</code> 這個方法。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=k>static</span> <span class=n>VALUE</span>
<span class=nf>get_next_values</span><span class=p>(</span><span class=n>VALUE</span> <span class=n>obj</span><span class=p>,</span> <span class=k>struct</span> <span class=n>enumerator</span> <span class=o>*</span><span class=n>e</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>VALUE</span> <span class=n>curr</span><span class=p>,</span> <span class=n>vs</span><span class=p>;</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>e</span><span class=o>-</span><span class=o>&gt;</span><span class=n>stop_exc</span><span class=p>)</span>
      <span class=n>rb_exc_raise</span><span class=p>(</span><span class=n>e</span><span class=o>-</span><span class=o>&gt;</span><span class=n>stop_exc</span><span class=p>)</span><span class=p>;</span>

    <span class=n>curr</span> <span class=o>=</span> <span class=n>rb_fiber_current</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>

    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>e</span><span class=o>-</span><span class=o>&gt;</span><span class=n>fib</span> <span class=o>|</span><span class=o>|</span> <span class=o>!</span><span class=n>rb_fiber_alive_p</span><span class=p>(</span><span class=n>e</span><span class=o>-</span><span class=o>&gt;</span><span class=n>fib</span><span class=p>)</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>next_init</span><span class=p>(</span><span class=n>obj</span><span class=p>,</span> <span class=n>e</span><span class=p>)</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=n>vs</span> <span class=o>=</span> <span class=n>rb_fiber_resume</span><span class=p>(</span><span class=n>e</span><span class=o>-</span><span class=o>&gt;</span><span class=n>fib</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>curr</span><span class=p>)</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>e</span><span class=o>-</span><span class=o>&gt;</span><span class=n>stop_exc</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>e</span><span class=o>-</span><span class=o>&gt;</span><span class=n>fib</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
      <span class=n>e</span><span class=o>-</span><span class=o>&gt;</span><span class=n>dst</span> <span class=o>=</span> <span class=n>Qnil</span><span class=p>;</span>
      <span class=n>e</span><span class=o>-</span><span class=o>&gt;</span><span class=n>lookahead</span> <span class=o>=</span> <span class=n>Qundef</span><span class=p>;</span>
      <span class=n>e</span><span class=o>-</span><span class=o>&gt;</span><span class=n>feedvalue</span> <span class=o>=</span> <span class=n>Qundef</span><span class=p>;</span>
      <span class=n>rb_exc_raise</span><span class=p>(</span><span class=n>e</span><span class=o>-</span><span class=o>&gt;</span><span class=n>stop_exc</span><span class=p>)</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=n>vs</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>到了這段，我們終於發現了 Fiber 的蹤跡，稍微來看一下發生了哪些事情。</p><ol><li>呼叫 <code>Fiber.current</code> 取得當下作用中的 Fiber</li><li><strong>如果 Enumerator 的 Fiber 不存在或者執行完畢</strong>，就做 <code>next_init</code> 這個動作</li><li>對 Enumerator 的 Fiber 呼叫 <code>#resume</code></li></ol><p>因為 <code>#resume</code> 的回傳值是 <code>Fiber.yield</code> 傳入的參數，所以我們只要再找到 Enumerator 的 Fiber 就能了解是怎樣運作的。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=k>static</span> <span class=kt>void</span>
<span class=nf>next_init</span><span class=p>(</span><span class=n>VALUE</span> <span class=n>obj</span><span class=p>,</span> <span class=k>struct</span> <span class=n>enumerator</span> <span class=o>*</span><span class=n>e</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>VALUE</span> <span class=n>curr</span> <span class=o>=</span> <span class=n>rb_fiber_current</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
    <span class=n>e</span><span class=o>-</span><span class=o>&gt;</span><span class=n>dst</span> <span class=o>=</span> <span class=n>curr</span><span class=p>;</span>
    <span class=n>e</span><span class=o>-</span><span class=o>&gt;</span><span class=n>fib</span> <span class=o>=</span> <span class=n>rb_fiber_new</span><span class=p>(</span><span class=n>next_i</span><span class=p>,</span> <span class=n>obj</span><span class=p>)</span><span class=p>;</span>
    <span class=n>e</span><span class=o>-</span><span class=o>&gt;</span><span class=n>lookahead</span> <span class=o>=</span> <span class=n>Qundef</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>回到 <code>next_init</code> 這段，我們會發現 Ruby 將 <code>next_i</code> 的方法當作是 Fiber 執行的區段來呼叫（就是我們 Fiber.new 給的 Block）</p><p>繼續往下追會看到 <code>next_i</code> 和 <code>next_ii</code> 兩個方法</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=k>static</span> <span class=n>VALUE</span>
<span class=nf>next_ii</span><span class=p>(</span><span class=n>RB_BLOCK_CALL_FUNC_ARGLIST</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>obj</span><span class=p>)</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>struct</span> <span class=n>enumerator</span> <span class=o>*</span><span class=n>e</span> <span class=o>=</span> <span class=n>enumerator_ptr</span><span class=p>(</span><span class=n>obj</span><span class=p>)</span><span class=p>;</span>
    <span class=n>VALUE</span> <span class=n>feedvalue</span> <span class=o>=</span> <span class=n>Qnil</span><span class=p>;</span>
    <span class=n>VALUE</span> <span class=n>args</span> <span class=o>=</span> <span class=n>rb_ary_new4</span><span class=p>(</span><span class=n>argc</span><span class=p>,</span> <span class=n>argv</span><span class=p>)</span><span class=p>;</span>
    <span class=n>rb_fiber_yield</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>args</span><span class=p>)</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>e</span><span class=o>-</span><span class=o>&gt;</span><span class=n>feedvalue</span> <span class=o>!</span><span class=o>=</span> <span class=n>Qundef</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>feedvalue</span> <span class=o>=</span> <span class=n>e</span><span class=o>-</span><span class=o>&gt;</span><span class=n>feedvalue</span><span class=p>;</span>
        <span class=n>e</span><span class=o>-</span><span class=o>&gt;</span><span class=n>feedvalue</span> <span class=o>=</span> <span class=n>Qundef</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=n>feedvalue</span><span class=p>;</span>
<span class=p>}</span>

<span class=k>static</span> <span class=n>VALUE</span>
<span class=nf>next_i</span><span class=p>(</span><span class=n>VALUE</span> <span class=n>curr</span><span class=p>,</span> <span class=n>VALUE</span> <span class=n>obj</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>struct</span> <span class=n>enumerator</span> <span class=o>*</span><span class=n>e</span> <span class=o>=</span> <span class=n>enumerator_ptr</span><span class=p>(</span><span class=n>obj</span><span class=p>)</span><span class=p>;</span>
    <span class=n>VALUE</span> <span class=n>nil</span> <span class=o>=</span> <span class=n>Qnil</span><span class=p>;</span>
    <span class=n>VALUE</span> <span class=n>result</span><span class=p>;</span>

    <span class=n>result</span> <span class=o>=</span> <span class=n>rb_block_call</span><span class=p>(</span><span class=n>obj</span><span class=p>,</span> <span class=n>id_each</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>next_ii</span><span class=p>,</span> <span class=n>obj</span><span class=p>)</span><span class=p>;</span>
    <span class=n>e</span><span class=o>-</span><span class=o>&gt;</span><span class=n>stop_exc</span> <span class=o>=</span> <span class=n>rb_exc_new2</span><span class=p>(</span><span class=n>rb_eStopIteration</span><span class=p>,</span> <span class=sa></span><span class=s>&#34;</span><span class=s>iteration reached an end</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
    <span class=n>rb_ivar_set</span><span class=p>(</span><span class=n>e</span><span class=o>-</span><span class=o>&gt;</span><span class=n>stop_exc</span><span class=p>,</span> <span class=n>id_result</span><span class=p>,</span> <span class=n>result</span><span class=p>)</span><span class=p>;</span>
    <span class=k>return</span> <span class=n>rb_fiber_yield</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>nil</span><span class=p>)</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>首先看 <code>next_i</code> 這個方法，他會去呼叫我們定義的 Enumerator 的 <code>#each</code> 方法來做迭代，跟我們對 Enumerator 的理解上是一致的，而迭代的行為（給 <code>#each</code> 的 Block）就是 <code>next_ii</code> 本身。
繼續看到 <code>next_ii</code> 這個方法，可以理解為他就是單純的呼叫 <code>Fiber.yield</code> 而已，所以我們可以把這段轉換成下面的 Ruby 來理解。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-ruby data-lang=ruby><span class=p>(</span><span class=mi>1</span><span class=o></span><span class=o>..</span><span class=mi>10</span><span class=o></span><span class=p>)</span><span class=o>.</span><span class=n>each</span> <span class=k>do</span> <span class=o>|</span><span class=n>item</span><span class=o>|</span>
  <span class=no>Fiber</span><span class=o>.</span><span class=n>yield</span> <span class=n>item</span>
<span class=k>end</span>
</code></pre></td></tr></table></div></div><p>也就是說，每次我們用 <code>#next</code> 的時候，Ruby 會產生一個 Fiber 然後每執行一次迭代就用 <code>Fiber.yield</code> 跳出來，直到都沒有任何元素可以被迭代後，再產生 <code>StopIteration</code> 的 Exception 同時做最後一次的 <code>Fiber.yield</code></p><p>我們可以用 Ruby簡單模擬這個行為</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-ruby data-lang=ruby><span class=c1># frozen_string_literal: true</span>

<span class=nb>require</span> <span class=s1>&#39;fiber&#39;</span>

<span class=c1># :nodoc:</span>
<span class=k>class</span> <span class=nc>FiberNext</span>
  <span class=k>def</span> <span class=nc></span><span class=o></span><span class=nf>initialize</span><span class=p>(</span><span class=n>items</span><span class=p>)</span>
    <span class=vi>@items</span> <span class=o>=</span> <span class=n>items</span>
    <span class=vi>@fiber</span> <span class=o>=</span> <span class=n>create_fiber</span>
  <span class=k>end</span>

  <span class=k>def</span> <span class=nc></span><span class=o></span><span class=nf>next</span>
    <span class=k>return</span> <span class=k>unless</span> <span class=vi>@fiber</span><span class=o>.</span><span class=n>alive?</span>

    <span class=vi>@fiber</span><span class=o>.</span><span class=n>resume</span>
  <span class=k>end</span>

  <span class=kp>private</span>

  <span class=k>def</span> <span class=nc></span><span class=o></span><span class=nf>create_fiber</span>
    <span class=no>Fiber</span><span class=o>.</span><span class=n>new</span> <span class=k>do</span>
      <span class=vi>@items</span><span class=o>.</span><span class=n>each</span> <span class=k>do</span> <span class=o>|</span><span class=n>item</span><span class=o>|</span>
        <span class=no>Fiber</span><span class=o>.</span><span class=n>yield</span> <span class=n>item</span>
      <span class=k>end</span>
      <span class=no>Fiber</span><span class=o>.</span><span class=n>yield</span>
    <span class=k>end</span>
  <span class=k>end</span>
<span class=k>end</span>

<span class=n>enum</span> <span class=o>=</span> <span class=no>FiberNext</span><span class=o>.</span><span class=n>new</span><span class=p>(</span><span class=o>%</span><span class=n>i</span><span class=o>[</span><span class=n>apple</span> <span class=n>water</span> <span class=n>flashlight</span><span class=o>]</span><span class=p>)</span>

<span class=mi>3</span><span class=o></span><span class=o>.</span><span class=n>times</span> <span class=k>do</span>
  <span class=nb>puts</span> <span class=s2>&#34;</span><span class=s2>Next: </span><span class=si>#{</span><span class=n>enum</span><span class=o>.</span><span class=n>next</span><span class=si>}</span><span class=s2>&#34;</span>
<span class=k>end</span>
</code></pre></td></tr></table></div></div><p>讀到這裡，不得不感嘆一下 Ruby Commiter 們用如此漂亮的方式設計了一個機能，我們都知道 Enumerator 對應的 <code>#each</code> 裡面只要給了 <code>yield</code> 基本上就是一個無法停止的狀態，他會不斷呼叫我們給的 Block 直到沒有 <code>yield</code> 再被呼叫，所以在 Ruby 裡面這算是一種「迭代」</p><p>但是想要控制迭代的進度，用步進的方式進行呢？如果採用一般的方式可能要做很多動作才能達成，此時 Fiber 這種可以暫停某個位置的執行跳去做其他任務，再跳回去的機制就變得非常實用。以應用案例來說，我想這大概也是非常漂亮的一個學習參考，以我過去對 Fiber 的理解是沒辦法想到這樣的使用方式的。</p><h2 id=被少考慮的情境>被少考慮的情境</h2><p>前情提要終於結束了，回到我們的主題，那個你不會遇到的 Bug 到底是什麼？</p><p>在 Samuel 對 Ruby 的 <a href=https://github.com/ruby/ruby/pull/2002#issuecomment-515749562>PR</a> 中你可以看到一段使用 <code>#to_enum</code> 和 <code>Fiber</code> 的程式碼，這段是當天再向我解釋時給的一個範例。</p><p>我稍微整理一下，讓大家比較好看到問題</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-ruby data-lang=ruby><span class=k>def</span> <span class=nc></span><span class=o></span><span class=nf>items</span><span class=p>(</span><span class=o>&amp;</span><span class=n>block</span><span class=p>)</span>
  <span class=k>yield</span> <span class=ss>:apple</span>
  <span class=no>Fiber</span><span class=o>.</span><span class=n>yield</span> <span class=c1># 我想在這跳出我的 Fiber</span>
  <span class=k>yield</span> <span class=ss>:water</span>
  <span class=k>yield</span> <span class=ss>:flashlight</span>
<span class=k>end</span>

<span class=n>enum</span> <span class=o>=</span> <span class=n>to_enum</span><span class=p>(</span><span class=ss>:items</span><span class=p>)</span>

<span class=n>f</span> <span class=o>=</span> <span class=no>Fiber</span><span class=o>.</span><span class=n>new</span> <span class=k>do</span>
  <span class=mi>3</span><span class=o></span><span class=o>.</span><span class=n>times</span> <span class=k>do</span>
    <span class=nb>puts</span> <span class=s2>&#34;</span><span class=s2>Next: </span><span class=si>#{</span><span class=n>enum</span><span class=o>.</span><span class=n>next</span><span class=si>}</span><span class=s2>&#34;</span>
  <span class=k>end</span>
<span class=k>end</span>

<span class=n>f</span><span class=o>.</span><span class=n>resume</span>
</code></pre></td></tr></table></div></div><p>執行的結果卻是這樣的</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=o>[</span>elct9620<span class=o>]</span> Desktop % ruby fiber.rb
Next: apple
Next:
Next: water
</code></pre></td></tr></table></div></div><p>照正常的迭代器運作，不應該是把 <code>:apple</code>, <code>:water</code> 和 <code>:flashlight</code> 印出來，為什麼多了一個 <code>nil</code> 的數值呢？</p><p>如果我們把 <code>Fiber.yield</code> 改成 <code>Fiber.yield :oops</code> 執行看看</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-ruby data-lang=ruby><span class=o>[</span><span class=n>elct9620</span><span class=o>]</span> <span class=no>Desktop</span> <span class=o>%</span> <span class=n>ruby</span> <span class=n>fiber</span><span class=o>.</span><span class=n>rb</span>
<span class=ss>Next</span><span class=p>:</span> <span class=n>apple</span>
<span class=ss>Next</span><span class=p>:</span> <span class=n>oops</span>
<span class=ss>Next</span><span class=p>:</span> <span class=n>water</span>
</code></pre></td></tr></table></div></div><p>問題就出在 <code>Fiber.yield</code> 竟然變得跟 <code>yield</code> 一樣，這是怎麼一回事？</p><p>回想一下前面介紹 Enumerator 在做 <code>#next</code> 的時候，是不是會產生一個新的 Fiber 然後用那個 Fiber 去做事情？</p><p>我們把前面那段產生 <code>#next</code> 的 Fiber 區段找出來，然後代入 <code>#items</code> 方法，會變成怎樣呢？</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-ruby data-lang=ruby><span class=c1># ...</span>
    <span class=no>Fiber</span><span class=o>.</span><span class=n>new</span> <span class=k>do</span>
      <span class=c1># @items.each do |item|</span>
        <span class=n>items</span> <span class=k>do</span> <span class=o>|</span><span class=n>item</span><span class=o>|</span>
          <span class=c1># 第一次 =&gt; item = (yield :apple)</span>
          <span class=c1># 第一次 =&gt; Fiber.yield :oops</span>
          <span class=c1># 第二次 =&gt; item = (yield :water)</span>
          <span class=c1># 第三次 =&gt; item = (yield :flashlight)</span>
          <span class=no>Fiber</span><span class=o>.</span><span class=n>yield</span> <span class=n>item</span>
        <span class=k>end</span>
      <span class=k>end</span>
      <span class=no>Fiber</span><span class=o>.</span><span class=n>yield</span>
    <span class=k>end</span>
<span class=c1># ...</span>
</code></pre></td></tr></table></div></div><p>大家有沒有發現，我們在第一次到第二次迭代的時候，被偷做了一次 <code>Fiber.yield</code> 然後他就跑回去變成 <code>#resume</code> 的回傳值，然後 <code>#next</code> 行為的次數就大亂了，歸咎原因在於他在執行的時候被 Ruby 判斷為「屬於 Enumerator 的 Fiber」</p><p>所以如果我們修改成像下面這樣執行，反而就不會出問題</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-ruby data-lang=ruby><span class=k>def</span> <span class=nc></span><span class=o></span><span class=nf>items</span><span class=p>(</span><span class=o>&amp;</span><span class=n>block</span><span class=p>)</span>
  <span class=k>yield</span> <span class=ss>:apple</span>
  <span class=no>Fiber</span><span class=o>.</span><span class=n>yield</span> <span class=c1># 我想在這跳出我的 Fiber</span>
  <span class=k>yield</span> <span class=ss>:water</span>
  <span class=k>yield</span> <span class=ss>:flashlight</span>
<span class=k>end</span>

<span class=n>enum</span> <span class=o>=</span> <span class=n>to_enum</span><span class=p>(</span><span class=ss>:items</span><span class=p>)</span>

<span class=n>f</span> <span class=o>=</span> <span class=no>Fiber</span><span class=o>.</span><span class=n>new</span> <span class=k>do</span>
  <span class=n>items</span> <span class=k>do</span> <span class=o>|</span><span class=n>item</span><span class=o>|</span>
    <span class=nb>puts</span> <span class=s2>&#34;</span><span class=s2>Next: </span><span class=si>#{</span><span class=n>item</span><span class=si>}</span><span class=s2>&#34;</span>
  <span class=k>end</span>
<span class=k>end</span>

<span class=n>f</span><span class=o>.</span><span class=n>resume</span>
<span class=n>f</span><span class=o>.</span><span class=n>resume</span> <span class=c1># 因為被正確 `Fiber.yield` 所以要再做一次讓他能繼續</span>
</code></pre></td></tr></table></div></div><p>因為沒有使用 <code>#next</code> 所以不會產生一個 Fiber 也就不會有被判斷錯誤的問題。</p><h2 id=解決方案與-fiber-的切換機制>解決方案與 Fiber 的切換機制</h2><p>目前我們看到的 PR 算是一個暫時性的解法，Samuel 告訴我這跟目前 Fiber 的設計有關係，所以只能先處理掉這個問題（大概會是 2.7 or 2.8 之類的會好）目前 PR 上已經是另一個版本，也就是最後展示給我會動的版本。中間也還有使用像是 <code>Fiber.transfer</code> 之類的方式做切換，就能指定應該要跳回哪一個 Fiber 上。</p><p>不過 Samuel 告訴我的想法我還不太清楚他想表達的是哪一個，不過只能說目前大致上有一個解決方法可以用。</p><ol><li>Enumerator 的 Fiber 要能跟普通的 Fiber 區分開來</li><li>Fiber 要加入一些類似 Call Stack 的機制，用來判斷要跳回去的 Fiber（以解釋來說比較像是多存一個指標）</li></ol><p>最後，我們來談談目前（Ruby 2.6.2）的 Fiber 切換機制是怎樣的。</p><p>目前已知 <code>Fiber.yield</code> <code>Fiber.transfer</code> 和 <code>#resume</code> 三個方法可以做切換，那麼來看一下這三個的實作</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=n>VALUE</span>
<span class=nf>rb_fiber_resume</span><span class=p>(</span><span class=n>VALUE</span> <span class=n>fibval</span><span class=p>,</span> <span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=k>const</span> <span class=n>VALUE</span> <span class=o>*</span><span class=n>argv</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>rb_fiber_t</span> <span class=o>*</span><span class=n>fib</span> <span class=o>=</span> <span class=n>fiber_ptr</span><span class=p>(</span><span class=n>fibval</span><span class=p>)</span><span class=p>;</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>fib</span><span class=o>-</span><span class=o>&gt;</span><span class=n>prev</span> <span class=o>!</span><span class=o>=</span> <span class=mi>0</span> <span class=o>|</span><span class=o>|</span> <span class=n>fiber_is_root_p</span><span class=p>(</span><span class=n>fib</span><span class=p>)</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>rb_raise</span><span class=p>(</span><span class=n>rb_eFiberError</span><span class=p>,</span> <span class=sa></span><span class=s>&#34;</span><span class=s>double resume</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>fib</span><span class=o>-</span><span class=o>&gt;</span><span class=n>transferred</span> <span class=o>!</span><span class=o>=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>rb_raise</span><span class=p>(</span><span class=n>rb_eFiberError</span><span class=p>,</span> <span class=sa></span><span class=s>&#34;</span><span class=s>cannot resume transferred Fiber</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>fiber_switch</span><span class=p>(</span><span class=n>fib</span><span class=p>,</span> <span class=n>argc</span><span class=p>,</span> <span class=n>argv</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span><span class=p>;</span>
<span class=p>}</span>

<span class=n>VALUE</span>
<span class=nf>rb_fiber_yield</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=k>const</span> <span class=n>VALUE</span> <span class=o>*</span><span class=n>argv</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>return</span> <span class=n>fiber_switch</span><span class=p>(</span><span class=n>return_fiber</span><span class=p>(</span><span class=p>)</span><span class=p>,</span> <span class=n>argc</span><span class=p>,</span> <span class=n>argv</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span><span class=p>;</span>
<span class=p>}</span>

<span class=n>VALUE</span>
<span class=nf>rb_fiber_transfer</span><span class=p>(</span><span class=n>VALUE</span> <span class=n>fibval</span><span class=p>,</span> <span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=k>const</span> <span class=n>VALUE</span> <span class=o>*</span><span class=n>argv</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>return</span> <span class=n>fiber_switch</span><span class=p>(</span><span class=n>fiber_ptr</span><span class=p>(</span><span class=n>fibval</span><span class=p>)</span><span class=p>,</span> <span class=n>argc</span><span class=p>,</span> <span class=n>argv</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>仔細一看，除了 <code>#resume</code> 有做一些檢查去避免重複執行之外，基本上都是做同樣的事情。（也就是文章前面提到的在新版的 Fiber 已經採用指標切換）</p><p>而 <code>Fiber.yield</code> 和 <code>Fiber.transfer</code> 的差異幾乎是只剩下「是否能指定 Fiber」這點，這也是 Samuel 有提到可能可以用 <code>Fiber.transfer</code> 去解決 Enumerator 裡面的 Fiber 問題的原因，因為我們可以利用這樣的方式「手動指定」而不是交由 Ruby 自己判斷，那麼就能讓我們指定正確的 Fiber 去繼續執行。</p><p>至於為什麼會選到錯誤的 Fiber 執行，我們看一下 <code>fiber_siwtch</code> 和 <code>return_fiber</code> 大概就可以猜到原因。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=k>static</span> <span class=kr>inline</span> <span class=n>VALUE</span>
<span class=nf>fiber_switch</span><span class=p>(</span><span class=n>rb_fiber_t</span> <span class=o>*</span><span class=n>fib</span><span class=p>,</span> <span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=k>const</span> <span class=n>VALUE</span> <span class=o>*</span><span class=n>argv</span><span class=p>,</span> <span class=kt>int</span> <span class=n>is_resume</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>VALUE</span> <span class=n>value</span><span class=p>;</span>
    <span class=n>rb_context_t</span> <span class=o>*</span><span class=n>cont</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>fib</span><span class=o>-</span><span class=o>&gt;</span><span class=n>cont</span><span class=p>;</span>
    <span class=n>rb_thread_t</span> <span class=o>*</span><span class=n>th</span> <span class=o>=</span> <span class=n>GET_THREAD</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>

    <span class=c1>// 略
</span><span class=c1></span>
    <span class=k>if</span> <span class=p>(</span><span class=n>is_resume</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>fib</span><span class=o>-</span><span class=o>&gt;</span><span class=n>prev</span> <span class=o>=</span> <span class=n>fiber_current</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=c1>// 略
</span><span class=c1></span>
    <span class=k>return</span> <span class=n>value</span><span class=p>;</span>
<span class=p>}</span>

<span class=k>static</span> <span class=kr>inline</span> <span class=n>rb_fiber_t</span><span class=o>*</span>
<span class=nf>return_fiber</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>rb_fiber_t</span> <span class=o>*</span><span class=n>fib</span> <span class=o>=</span> <span class=n>fiber_current</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
    <span class=n>rb_fiber_t</span> <span class=o>*</span><span class=n>prev</span> <span class=o>=</span> <span class=n>fib</span><span class=o>-</span><span class=o>&gt;</span><span class=n>prev</span><span class=p>;</span>

    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>prev</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>rb_thread_t</span> <span class=o>*</span><span class=n>th</span> <span class=o>=</span> <span class=n>GET_THREAD</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
      <span class=n>rb_fiber_t</span> <span class=o>*</span><span class=n>root_fiber</span> <span class=o>=</span> <span class=n>th</span><span class=o>-</span><span class=o>&gt;</span><span class=n>root_fiber</span><span class=p>;</span>

      <span class=n>VM_ASSERT</span><span class=p>(</span><span class=n>root_fiber</span> <span class=o>!</span><span class=o>=</span> <span class=nb>NULL</span><span class=p>)</span><span class=p>;</span>

      <span class=k>if</span> <span class=p>(</span><span class=n>root_fiber</span> <span class=o>=</span><span class=o>=</span> <span class=n>fib</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>rb_raise</span><span class=p>(</span><span class=n>rb_eFiberError</span><span class=p>,</span> <span class=sa></span><span class=s>&#34;</span><span class=s>can&#39;t yield from root fiber</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
    	<span class=p>}</span>
      <span class=k>return</span> <span class=n>root_fiber</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>else</span> <span class=p>{</span>
      <span class=n>fib</span><span class=o>-</span><span class=o>&gt;</span><span class=n>prev</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
      <span class=k>return</span> <span class=n>prev</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>簡單說當我們呼叫 <code>#resume</code> 的時候，會把當下的 Fiber 標記成前一個 Fiber，而做 <code>Fiber.yield</code> 的時候就會因為有紀錄，就把這個 Fiber 當作前一個目標做切換。</p><p>過程大概像是這樣：</p><ol><li>Fiber.new （我們的）</li><li>#resume （我們的）</li><li>#next （產生 Enumerator 的 Fiber）</li><li>Fiber.yield => 找到的是 Enumerator 的 Fiber</li></ol><p>所以在這中間，我們的 Fiber 已經不被我們自定義的迭代方法中的 <code>Fiber.yield</code> 認識。</p><h2 id=總結>總結</h2><p>在 After Hack 回到家之後，才發現原來是被 Commiter 直接一對一教學了一個多小時，算是很不錯的經驗。大概也是因為克服了這類心理上的障礙，所以即使聽得蠻吃力的但還是能夠繼續嘗試，我想之後的活動大概不會有不敢用英文對話的困擾了吧！</p><p>最大的收穫大概是有 Commiter 帶你看了一部分的原始碼，還有去理解這些國外的高手是怎樣思考問題的。至少以台灣人來說算是不錯的經驗，以比例來看台灣人不多的狀況下能遇到的高手是固定的但是如果有像是研討會這類活動，我們就有機會接觸到篩選出來的高手，把握機會跟這些人交流就能很快地學到新東西跟進步，畢竟算是短時間的讓台灣的高手比例上升吧 XD</p><p>雖然會覺得能早點突破心理障礙就能更快接觸到，不過有時候很多知識還沒準備齊全（像是嘗試過 Fiber 和了解基本原理等等）也蠻難能問對問題，可以的話真的蠻需要平常多準備一些問題或者寫下來，才不會遇到機會都沒辦法問。</p><blockquote><p>不過我自己也沒有這個習慣，但是看起來還是要準備一點會比較好呢 XD</p></blockquote><footer class=article__footer><div class=text-center><div class=fb-share-button data-href="<%- page.permalink %>" data-layout=button_count></div></div><div class="text-center mt-1"><style>.bmc-button img{width:27px!important;margin-bottom:1px!important;box-shadow:none!important;border:none!important;vertical-align:middle!important}.bmc-button{line-height:36px!important;height:37px!important;text-decoration:none!important;display:inline-flex!important;color:#fff!important;background-color:#000!important;border-radius:3px!important;border:1px solid transparent!important;padding:1px 9px!important;font-size:22px!important;letter-spacing:.6px!important;box-shadow:0 1px 2px rgba(190,190,190,.5)!important;-webkit-box-shadow:0 1px 2px 2px rgba(190,190,190,.5)!important;margin:0 auto!important;font-family:cookie,cursive!important;-webkit-box-sizing:border-box!important;box-sizing:border-box!important;-o-transition:.3s all linear!important;-webkit-transition:.3s all linear!important;-moz-transition:.3s all linear!important;-ms-transition:.3s all linear!important;transition:.3s all linear!important}.bmc-button:hover,.bmc-button:active,.bmc-button:focus{-webkit-box-shadow:0 1px 2px 2px rgba(190,190,190,.5)!important;text-decoration:none!important;box-shadow:0 1px 2px 2px rgba(190,190,190,.5)!important;opacity:.85!important;color:#fff!important}</style><link href="https://fonts.googleapis.com/css?family=Cookie" rel=stylesheet><a class=bmc-button target=_blank href=https://www.buymeacoffee.com/aotoki><img src=https://bmc-cdn.nyc3.digitaloceanspaces.com/BMC-button-images/BMC-btn-logo.svg alt="Buy me a Coffee"><span style=margin-left:5px>Buy me a Coffee</span></a></div><iframe scrolling=no frameborder=0 style="display:block;margin:0 auto;height:212px" src="https://button.like.co/in/embed/elct9620/button?referrer=<%- page.permalink %>"></iframe><ul class=article__tag-list><li class=article__tag-list-item><a class=article__tag-list-link href=https://blog.frost.tw/tags/RubyConfTW/>RubyConfTW</a></li><li class=article__tag-list-item><a class=article__tag-list-link href=https://blog.frost.tw/tags/Bug/>Bug</a></li><li class=article__tag-list-item><a class=article__tag-list-link href=https://blog.frost.tw/tags/Ruby/>Ruby</a></li><li class=article__tag-list-item><a class=article__tag-list-link href=https://blog.frost.tw/tags/Enumerator/>Enumerator</a></li><li class=article__tag-list-item><a class=article__tag-list-link href=https://blog.frost.tw/tags/Fiber/>Fiber</a></li></ul></footer></div></article><div class=adv><script async src=//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-2844969736316510 data-ad-slot=5530952976 data-ad-format=auto></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div><section id=comment class=comment-box><h1 class=comment-box__title>留言</h1><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"revo-skill-frost"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></section></div><footer id=footer><div id=copyright>&copy;2020 <a href="https://plus.google.com/117236344655673213049?rel=author" target=_blank rel=noreferrer>蒼時弦也</a>. All right reversed.</div></footer><script src=/js/app.min.e979702d4c2a76dd5e32acda7647b733e4959a8621df075338d00d2c6837e87a.js></script><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5TQLRN" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-5TQLRN');</script><script>window.fbAsyncInit=function(){FB.init({appId:'178355449110',xfbml:true,version:'v2.12'});FB.AppEvents.logPageView();};(function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(d.getElementById(id)){return;}
js=d.createElement(s);js.id=id;js.src="https://connect.facebook.net/zh_TW/sdk.js";js.async=true
js.defer=true
fjs.parentNode.insertBefore(js,fjs);}(document,'script','facebook-jssdk'));</script><div class=loading></div></body></html>