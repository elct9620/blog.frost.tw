<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Concurrency on 弦而時習之</title><link>https://blog.frost.tw/tags/Concurrency/</link><description>Recent content in Concurrency on 弦而時習之</description><generator>Hugo -- gohugo.io</generator><language>zh-TW</language><managingEditor>contact@frost.tw (蒼時弦也)</managingEditor><webMaster>contact@frost.tw (蒼時弦也)</webMaster><lastBuildDate>Wed, 05 Sep 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.frost.tw/tags/Concurrency/index.xml" rel="self" type="application/rss+xml"/><item><title>淺談 Ruby 的 Fiber（九）</title><link>https://blog.frost.tw/posts/2018/09/05/Talk-about-ruby-s-fiber-Part-9/</link><pubDate>Wed, 05 Sep 2018 00:00:00 +0000</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2018/09/05/Talk-about-ruby-s-fiber-Part-9/</guid><description>&lt;p>這篇文章我們會把 Broadcast （廣播）功能實作出來，如此一來我們就擁有了可以將訊息透過 Fiber 實作的伺服器廣播給其他使用者的功能。&lt;/p>
&lt;p>而這系列文章也就到此告一段落。&lt;/p></description></item><item><title>使用 Fiber 能給 Ruby 帶來好處嗎？</title><link>https://blog.frost.tw/posts/2018/08/21/Does-the-Fiber-have-any-benefit-for-Ruby/</link><pubDate>Tue, 21 Aug 2018 00:00:00 +0000</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2018/08/21/Does-the-Fiber-have-any-benefit-for-Ruby/</guid><description>&lt;p>關於 Fiber 的&lt;a href="https://blog.frost.tw/posts/2018/06/26/Talk-about-ruby-s-fiber-Part-1/">系列文&lt;/a>寫到現在也已經一個半月了，除了分享自己在使用 Fiber 的經驗之外，我也更加的熟悉 Fiber 的使用。&lt;/p>
&lt;p>不過，這真的是有益於現有的專案嗎？&lt;/p></description></item><item><title>淺談 Ruby 的 Fiber（八）</title><link>https://blog.frost.tw/posts/2018/08/14/Talk-about-ruby-s-fiber-Part-8/</link><pubDate>Tue, 14 Aug 2018 00:00:00 +0000</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2018/08/14/Talk-about-ruby-s-fiber-Part-8/</guid><description>&lt;p>到這篇為止，我們已經完成了將 Fiber 應用在程式中的基本雛型，現在只需要將上週未完成的錯誤處理，我們就能獲得一個可以正常發送訊息到伺服器的伺服器。&lt;/p></description></item><item><title>淺談 Ruby 的 Fiber（七）</title><link>https://blog.frost.tw/posts/2018/08/07/Talk-about-ruby-s-fiber-Part-7/</link><pubDate>Tue, 07 Aug 2018 00:00:00 +0000</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2018/08/07/Talk-about-ruby-s-fiber-Part-7/</guid><description>&lt;p>上週我們開始重構 Fiber 的結構，透過一個統一的 &lt;code>Selector&lt;/code> 物件來選取這個「當下」可以進行 I/O 操作的物件。&lt;/p>
&lt;p>不過，我們原本預期是因為使用 &lt;code>rescue&lt;/code> 來捕捉錯誤控制流程才讓他運行不正常，經過一週的思考後，卻發現事情跟預想的不太一樣。&lt;/p></description></item><item><title>淺談 Ruby 的 Fiber（六）</title><link>https://blog.frost.tw/posts/2018/07/29/Talk-about-ruby-s-fiber-Part-6/</link><pubDate>Sun, 29 Jul 2018 00:00:00 +0000</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2018/07/29/Talk-about-ruby-s-fiber-Part-6/</guid><description>&lt;p>經過前面幾篇文章的介紹，我們已經初步的了解 Fiber 的性質。這系列的文章目標是利用 Fiber 實現再不透過 Thread 或者 Process 的情境，來實現支援多人連線的 TCP 聊天伺服器。&lt;/p>
&lt;p>從這一篇開始，我們就要正式的來挑戰完整的實作了！&lt;/p></description></item><item><title>淺談 Ruby 的 Fiber（五）</title><link>https://blog.frost.tw/posts/2018/07/24/Talk-about-ruby-s-fiber-Part-5/</link><pubDate>Tue, 24 Jul 2018 00:00:00 +0000</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2018/07/24/Talk-about-ruby-s-fiber-Part-5/</guid><description>&lt;p>經過&lt;a href="https://blog.frost.tw/posts/2018/07/17/Talk-about-ruby-s-fiber-Part-4/">上次&lt;/a>的嘗試，我們已經開始對於 Fiber 的性質有一些了解，目前還需要解決已經結束的 Fiber 被呼叫，以及來不及處理的問題。&lt;/p></description></item><item><title>淺談 Ruby 的 Fiber（四）</title><link>https://blog.frost.tw/posts/2018/07/17/Talk-about-ruby-s-fiber-Part-4/</link><pubDate>Tue, 17 Jul 2018 00:00:00 +0000</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2018/07/17/Talk-about-ruby-s-fiber-Part-4/</guid><description>&lt;p>在上週的&lt;a href="https://blog.frost.tw/posts/2018/07/10/Talk-about-ruby-s-fiber-Part-3/">文章&lt;/a>我們注意到 Fiber 的使用並不是那麼容易的，因為我們需要自行管理每一個 Fiber 被恢復（&lt;code>#resume&lt;/code>）的時機，這週就繼續來挑戰吧！&lt;/p></description></item><item><title>淺談 Ruby 的 Fiber（三）</title><link>https://blog.frost.tw/posts/2018/07/10/Talk-about-ruby-s-fiber-Part-3/</link><pubDate>Tue, 10 Jul 2018 00:00:00 +0000</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2018/07/10/Talk-about-ruby-s-fiber-Part-3/</guid><description>&lt;p>延續&lt;a href="https://blog.frost.tw/posts/2018/07/03/Talk-about-ruby-s-fiber-Part-2/">上一篇&lt;/a>文章的實作，我們已經有一個簡易的 Thread 版本 TCP Socket 伺服器可以運作，那麼該怎麼用 Fiber 修改呢？&lt;/p></description></item><item><title>淺談 Ruby 的 Fiber（二）</title><link>https://blog.frost.tw/posts/2018/07/03/Talk-about-ruby-s-fiber-Part-2/</link><pubDate>Tue, 03 Jul 2018 00:00:00 +0000</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2018/07/03/Talk-about-ruby-s-fiber-Part-2/</guid><description>&lt;p>&lt;a href="https://blog.frost.tw/posts/2018/06/26/Talk-about-ruby-s-fiber-Part-1/">第一篇&lt;/a>我們已經大致上了解 Fiber 的運作原理，不過要能夠實際上的掌握跟應用，我認為是需要靠實作來熟悉的。&lt;/p>
&lt;p>所以，這一篇我們先來講學習 Socket 最常見的 TCP 伺服器實作吧！&lt;/p></description></item><item><title>淺談 Ruby 的 Fiber（ㄧ）</title><link>https://blog.frost.tw/posts/2018/06/26/Talk-about-ruby-s-fiber-Part-1/</link><pubDate>Tue, 26 Jun 2018 00:00:00 +0000</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2018/06/26/Talk-about-ruby-s-fiber-Part-1/</guid><description>&lt;p>前陣子再研究 Ruby 從 1.9.3 就開始提供的 Fiber 該怎麼使用，不過網路上的資料大多都只是簡單的討論。那麼 Fiber 到底是什麼呢？這系列的文章會詳細的介紹 Fiber 的基本概念，還有一些可以應用的方式。&lt;/p></description></item></channel></rss>