<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Ruby on 弦而時習之</title><link>https://blog.frost.tw/tags/Ruby/</link><description>Recent content in Ruby on 弦而時習之</description><generator>Hugo -- gohugo.io</generator><language>zh-TW</language><lastBuildDate>Thu, 20 Feb 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.frost.tw/tags/Ruby/index.xml" rel="self" type="application/rss+xml"/><item><title>撰寫一個合適的 RSpec 測試</title><link>https://blog.frost.tw/posts/2020/02/20/Write-a-suitable-RSpec-test/</link><pubDate>Thu, 20 Feb 2020 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2020/02/20/Write-a-suitable-RSpec-test/</guid><description>&lt;p>包括我自己在內，寫測試有時候是一個非常不想面對的工作。也有很多剛入門的工程師覺得很難去分辨該怎麼去寫測試，在今天跟同事說明完一些技巧後就決定來寫一下這篇分享一下我自己的經驗。&lt;/p></description></item><item><title>淺談在 Google Cloud Platform 讓 Ruby on Rails 實現簡單的 Immutable Infrastructure 部署</title><link>https://blog.frost.tw/posts/2020/01/07/An-overview-of-deploy-Ruby-on-Rails-to-Google-Cloud-Platform-uses-simple-immutable-infrastructure/</link><pubDate>Tue, 07 Jan 2020 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2020/01/07/An-overview-of-deploy-Ruby-on-Rails-to-Google-Cloud-Platform-uses-simple-immutable-infrastructure/</guid><description>&lt;p>去年雙十一活動的時候有一個算是比較急的專案是要做活動網站，當時評估了一下之後決定來嘗試透過 CI 自動生成 GCE 的自訂映像檔然後搭配 Auto Scale 來做部署。&lt;/p>
&lt;p>會選擇這樣的方式主要是因為 Rails 或者大多數開發框架的部署工具預設大多是不適合 Auto Scale 的，像是 Capistrano 大多數是手動填入伺服器位置（之前也有實作過透過 GCP API 自動填入）比較適合雲端服務的作法其實就是是製作成一個映像檔來處理，也因此像是 Docker Image 這類型容器化技術在這方面是相對容易做的。&lt;/p>
&lt;p>不過考量到容器化本身也還有一些調整問題才適合使用，再加上雲端服務的選擇是使用 GCP 來提供服務，並不像 AWS ECS 有專門針對容器的服務（可能是我不知道）而是提供 K8S 的方案，對一個短期活動來說在整個專案成員都沒有經驗的前提下學習成本還是偏高的。&lt;/p>
&lt;p>因此相對適合的做法是用之前我準備好的 &lt;a href="https://www.ansible.com/">Ansible&lt;/a> 腳本，搭配 &lt;a href="https://www.packer.io/">Packer&lt;/a> 這套工具直接在 GCP 上面生成一個自訂的映像檔然後直接更新 Instance Group 的設定讓他以新版本 Scale 起來，就能做到基本上網站不斷掉的更新（Health Check 和 Scale 規則需要調整好）&lt;/p>
&lt;p>我們大概花了約一天多的時間快速搭起來，這次的開發時間約兩週中間是透過放額外的人力去支援搭建這個部署流程。&lt;/p></description></item><item><title>如何透過 Service Account 來取得 Google API 的 OAuth2 Token</title><link>https://blog.frost.tw/posts/2019/12/29/How-to-use-Service-Account-to-exchange-Google-OAuth2-API-token/</link><pubDate>Sun, 29 Dec 2019 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2019/12/29/How-to-use-Service-Account-to-exchange-Google-OAuth2-API-token/</guid><description>&lt;p>前陣子在嘗試一些比較少見的 Google API 時發現，在 Google 提供的 Ruby Gem 裡面並不支援這個 API 的實作，這表示需要自己去想辦法解決如何去呼叫這個 API 的問題。&lt;/p>
&lt;p>不過呼叫 API 需要 Access Token 才能夠使用，以往我們都是依靠第三方套件或者 Google 官方提供的 Gem 直接呼叫，似乎很少去直接實作客戶端。另一方面我們對 OAuth2 的認識大多是做 SSO（Single Sign On）而非這種伺服器對伺服器的呼叫。&lt;/p>
&lt;p>以 Google 這種規模的公司，如果是直接使用一般 OAuth2 的伺服器對伺服器的作法似乎也不太適合，而 Google 提供的解決方案就是 Service Account 了！&lt;/p></description></item><item><title>Ruby World Conference 2019 見聞</title><link>https://blog.frost.tw/posts/2019/11/18/Ruby-World-Conference-2019-Experience/</link><pubDate>Mon, 18 Nov 2019 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2019/11/18/Ruby-World-Conference-2019-Experience/</guid><description>&lt;p>今年把在六月到八月做的一個小專案拿去投稿 &lt;a href="https://2019.rubyworld-conf.org/en/">Ruby World Conference&lt;/a> 意外的獲得了 15 分鐘的時間，於是又展開了一次日本出差之旅，剛好彌補一下今年因為客戶專案需要趕上線而無法參加 &lt;a href="https://rubykaigi.org/">RubyKaigi&lt;/a> 的遺憾。&lt;/p>
&lt;p>跟 RubyKaigi 不太一樣的地方是 Ruby World Conference 雖然叫做「World Conference」但是除了台上的講者之外，幾乎都是日本人（而且是稍微有年紀的大叔）去參加的。&lt;/p></description></item><item><title>COSCUP 2019 - 演講後談復活的頁遊 - Unlight （二）</title><link>https://blog.frost.tw/posts/2019/10/20/COSCUP-2019-Talk-about-the-browser-game-Unlight-which-I-revived-it-Part-2/</link><pubDate>Sun, 20 Oct 2019 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2019/10/20/COSCUP-2019-Talk-about-the-browser-game-Unlight-which-I-revived-it-Part-2/</guid><description>&lt;p>寫完&lt;a href="https://blog.frost.tw/posts/2019/09/03/COSCUP-2019-Talk-about-the-browser-game-Unlight-which-I-revived-it/">上篇&lt;/a>後就開始員工旅遊、鐵人賽（&lt;a href="https://ithelp.ithome.com.tw/users/20065771/ironman/2734">從讀遊戲原始碼學做連線遊戲&lt;/a>）反而一直都沒有時間把下篇寫完，離 COSCUP 都已經過了一個多月自己都忘記還剩什麼沒有寫在文章裡面。&lt;/p>
&lt;p>中間在鐵人賽的部分花了一些時間把目前理解到關於 Unlight 的一些基本設計整理出來，後面則是實作。至於近期也已經開始在搭建 HTML5 版本的底層設計，還有 mruby 的&lt;a href="https://github.com/elct9620/mruby.wasm">整合&lt;/a>（因為想提供 Mod 功能到遊戲中）等等東西都在進行中，十一月還要飛日本一趟參加 &lt;a href="https://2019.rubyworld-conf.org/en/">Ruby World Conference&lt;/a>，可以說是完全都閒不下來。&lt;/p>
&lt;p>總之，讓我們在來看看 COSCUP 這場演講的後續吧 XD&lt;/p></description></item><item><title>COSCUP 2019 - 演講後談復活的頁遊 - Unlight （一）</title><link>https://blog.frost.tw/posts/2019/09/03/COSCUP-2019-Talk-about-the-browser-game-Unlight-which-I-revived-it/</link><pubDate>Tue, 03 Sep 2019 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2019/09/03/COSCUP-2019-Talk-about-the-browser-game-Unlight-which-I-revived-it/</guid><description>&lt;p>在 &lt;a href="https://coscup.org/2019/">COSCUP&lt;/a> 分享了這兩週左右（8/3 ~ 8/17）把一款決定開放原始碼的網頁遊戲，從無法啟動到恢復伺服器開始運作的一些經驗跟大家分享。
不過看起來還是有很多人沒有機會來聽，雖然之後因為會把一部分重心放在這款遊戲上，所以應該還是有不少機會，但還是簡單的來彙整一下今天講的東西。&lt;/p>
&lt;p>上一篇&lt;a href="https://blog.frost.tw/posts/2019/08/04/Fast-review-the-Unlight-game-s-source-code/">快速閱讀 Unlight 原始碼&lt;/a>大致上有提到了我在當時看到原始碼的看法跟概觀。有興趣的話可以搭配&lt;a href="https://speakerdeck.com/elct9620/2019-coscup-fu-huo-ge-browser-game-unlight-kai-yuan-shi-jian">演講簡報&lt;/a>一起讀這篇文章。&lt;/p>
&lt;p>另外，這次整個遊戲運作起來除了我自己本身對 Ruby / ActionScript 有一定的了解外，也要感謝一下我們這個團隊（&lt;a href="https://unlight.app">Open Unlight&lt;/a>）的初期成員 Poka 和舞鶴，給我硬體上的支援跟對其他玩家的客服支援，不然有時候真的很難同時處理這些事情。&lt;/p></description></item><item><title>快速閱讀頁遊 Unlight 開源後的原始碼</title><link>https://blog.frost.tw/posts/2019/08/04/Fast-review-the-Unlight-game-s-source-code/</link><pubDate>Sun, 04 Aug 2019 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2019/08/04/Fast-review-the-Unlight-game-s-source-code/</guid><description>&lt;p>最近一款有點年紀的頁遊 &lt;a href="https://zh.wikipedia.org/zh-tw/Unlight">Unlight&lt;/a> 在停止營運後幾年，突然公佈說要開放原始碼跟圖片素材。&lt;/p>
&lt;p>這款遊戲嚴格說起來並沒有像我們熟悉的端遊、手遊之類的那樣華麗，但是非常有特色的人物設計跟對戰系統倒是讓很多玩家即使在好幾年後仍然在期待他能復活。&lt;/p>
&lt;p>作為一個曾經的玩家，其實也是非常期待的，不過這次的開放原始碼路線大概是復活無望。不過從這幾天公開的資料來看，圖片、音效到客戶端和伺服端都公開的狀況下，還是很有希望被熱血的玩家復活的。&lt;/p>
&lt;p>另一方面，既然伺服器是透過 Ruby 撰寫的，身為使用 Ruby 的開發者在遊戲類應用不常見的狀況下，能可以作為學習素材肯定是要看過一遍的。&lt;/p></description></item><item><title>你大概沒機會遇到的 Bug - 跟 Ruby Committer 聊 Enumerator 跟 Fiber</title><link>https://blog.frost.tw/posts/2019/07/30/Talk-with-the-Ruby-Committer-about-Enumerator-and-Fiber-the-bug-you-may-never-touch/</link><pubDate>Tue, 30 Jul 2019 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2019/07/30/Talk-with-the-Ruby-Committer-about-Enumerator-and-Fiber-the-bug-you-may-never-touch/</guid><description>&lt;p>今年 &lt;a href="https://2019.rubyconf.tw/">RubyConf Taiwan&lt;/a> 嘗試辦了 After Hack 這個活動，也因此有機會可以跟 Ruby 語言的 Commiter 聊一些有趣的問題。&lt;/p>
&lt;p>當天我的預定是把活動這幾天寫的 Gem 認真的補完測試，不過沒想到還剩下一個多小時就做完了，那就順便來思考一下 &lt;a href="https://tamashii.io">Tamashii&lt;/a> 專案能怎樣去改進，在今年的演講中大家應該都對 Fiber 有一個認識，而這個也許是一個不錯的選項。&lt;/p>
&lt;p>所以就馬上去看了一下講者（Samuel）的 &lt;a href="https://github.com/socketry/async">Async&lt;/a> 這個 Gem 做了些什麼事情，因為剛講完關於 Enumerator 的演講，所以自然地看到了一段引起我興趣的說明。&lt;/p>
&lt;blockquote>
&lt;p>Due to limitations within Ruby and the nature of this library, it is not possible to use to_enum on methods which invoke asynchronous behavior. We hope to fix this issue in the future.&lt;/p>
&lt;/blockquote>
&lt;p>既然作者本人就在現場，而且 Issue 的內容也看不太出來發生什麼問題，那麼就直接問吧！&lt;/p></description></item><item><title>RubyConf Taiwan 2019 會後感想、議程概覽</title><link>https://blog.frost.tw/posts/2019/07/29/My-experience-after-RubyConf-Taiwan-2019/</link><pubDate>Mon, 29 Jul 2019 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2019/07/29/My-experience-after-RubyConf-Taiwan-2019/</guid><description>&lt;p>跟前幾年一樣基本上就是工作人員，這幾年參加研討會也都比較沒有在仔細聽了，所以大多是邊顧邊寫點程式。&lt;/p>
&lt;p>比較不一樣的大概是今年更累了，從週四下午場佈到 Pre Party 然後兩天的活動、Official Party 最後到今年嘗試的 After Hack 幾乎是四天左右的連續接力，每天早上醒來都要先懷疑自己是否能撐過這一天。&lt;/p></description></item><item><title>巴哈姆特 Chatbot 之亂：用 Ruby on Rails 接收 Webhook</title><link>https://blog.frost.tw/posts/2019/07/26/The-bahamut-chatbot-receiving-the-webhook/</link><pubDate>Fri, 26 Jul 2019 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2019/07/26/The-bahamut-chatbot-receiving-the-webhook/</guid><description>&lt;p>六月底的時候發現巴哈姆特似乎想為他們推出的 Messaging APP （哈哈姆特）舉辦一個聊天機器人的比賽，看到之後想說還算蠻有趣的，所以我就跟朋友很隨意的組成一個團隊來開發。&lt;/p>
&lt;p>跟大多數我們熟悉串接 Chatbot 的機制是類似的，我們可以用 Webhook 的方式接收一個來自使用者發送的訊息，然後再透過程式處理後回傳訊息給使用者。&lt;/p></description></item><item><title>用 CloudFlare Workers 製作簡單的 Uptime Status 頁面</title><link>https://blog.frost.tw/posts/2019/07/09/Build-a-simple-uptime-status-page-use-CloudFlare-Workers/</link><pubDate>Tue, 09 Jul 2019 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2019/07/09/Build-a-simple-uptime-status-page-use-CloudFlare-Workers/</guid><description>&lt;p>最近跟朋友弄了一個透過 Chatbot 做出手遊效果的專案，沒出什麼意外的話大概能在九月看到一個雛形。不過既然是手遊類型的遊戲，更新資料跟維護其實就會遇到一些困難點。&lt;/p>
&lt;p>如果是線上遊戲或者手遊，大多數只要在公告後把玩家切斷連線然後升級過程中避免玩家連上就好。不過因為是 Chatbot 所以除非能做到不停機升級，不然是很困難的。
如此一來，讓玩家知道遊戲（機器人）正在更新，處於無法使用的狀態，就是一個重要的關鍵。&lt;/p></description></item><item><title>Ruby 中 Constant 和 Class 的關係</title><link>https://blog.frost.tw/posts/2019/06/18/The-relationship-between-constant-and-class-in-ruby/</link><pubDate>Tue, 18 Jun 2019 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2019/06/18/The-relationship-between-constant-and-class-in-ruby/</guid><description>&lt;p>下班前&lt;a href="https://kaochenlong.com/">龍哥&lt;/a>說在 Mailing List 看到了一段 Code 很有趣。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="n">a&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="no">Class&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">new&lt;/span>
&lt;span class="nb">p&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="c1">#=&amp;gt; #&amp;lt;Class:0x0000558d34f68b48&amp;gt;&lt;/span>
&lt;span class="nb">p&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">name&lt;/span> &lt;span class="c1">#=&amp;gt; nil&lt;/span>
&lt;span class="n">B&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">a&lt;/span>
&lt;span class="nb">p&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">name&lt;/span> &lt;span class="c1">#=&amp;gt; &amp;#39;B&amp;#39;&lt;/span>
&lt;span class="n">C&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">a&lt;/span>
&lt;span class="nb">p&lt;/span> &lt;span class="n">C&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">name&lt;/span> &lt;span class="c1">#=&amp;gt; &amp;#39;B&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>裡面 &lt;code>C = a&lt;/code> 到底發生了什麼事情，是很值得討論的，因為有了線索是 &lt;code>rb_const_set&lt;/code> 可以找到原因，所以就利用下班時間來讀看看這段。&lt;/p>
&lt;blockquote>
&lt;p>關於前面的用法可以參考之前寫過的&lt;a href="https://blog.frost.tw/posts/2017/10/22/The-ruby-s-class-is-free-Part-1/">自由的 Ruby 類別&lt;/a>來了解原因。&lt;/p>
&lt;/blockquote></description></item><item><title>關於 Rails 中的 Form Object / Presenter 這些物件該怎麼用（一）</title><link>https://blog.frost.tw/posts/2019/05/28/How-to-use-Form-Object-and-others-for-Rails/</link><pubDate>Tue, 28 May 2019 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2019/05/28/How-to-use-Form-Object-and-others-for-Rails/</guid><description>&lt;p>前陣子在 Review 新專案中同事的程式碼時，發現同事對像是 Service Object / Form Object 這類物件不太有概念。不過這個新專案因為是接手其他公司的專案，所以有不少地方要微調。至少那個值得吐槽的「因為 Controller 程式碼太長不知道放哪裡，就都丟去 Service Object 好了！」的神奇用法，完全沒有幫助改善程式碼。&lt;/p>
&lt;p>也因為這個機會，我用了一點時間跟專案的同事分享了一下我對這些物件的看法。畢竟當出我也是搞不太懂，不過隨著了解物件導向和 Ruby 的語言特性，從這些角度切入後，就比較能理解該怎麼使用。&lt;/p></description></item><item><title>利用 Ruby 的 Lambda 做條件判斷</title><link>https://blog.frost.tw/posts/2019/05/20/Use-Ruby-s-Lambda-as-case-when-condition/</link><pubDate>Mon, 20 May 2019 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2019/05/20/Use-Ruby-s-Lambda-as-case-when-condition/</guid><description>&lt;p>週末在思考一些 Ruby 特性可以應用的小技巧時，想到龍哥大概跟我講了三次以上的一個特性。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="n">fn&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">other&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">other&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="n">fn&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;span class="o">&lt;/span>&lt;span class="c1"># =&amp;gt; false&lt;/span>
&lt;span class="n">fn&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;span class="o">&lt;/span>&lt;span class="c1"># =&amp;gt; true&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>剛好最近工作的專案上有個問題，似乎挺適合用這個技巧。&lt;/p></description></item><item><title>如何在沒有任何設定下產生 Rails 的 Docker Image</title><link>https://blog.frost.tw/posts/2019/03/20/The-zero-configure-dockerfile-for-rails/</link><pubDate>Wed, 20 Mar 2019 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2019/03/20/The-zero-configure-dockerfile-for-rails/</guid><description>&lt;p>前陣子看到 &lt;a href="https://thoughtbot.com/">Throughbot&lt;/a> 這間在 Ruby 圈 算是蠻有名的公司做了一個叫做 &lt;a href="https://github.com/thoughtbot/suspenders">Suspenders&lt;/a> 的 Gem 主要是對 Rails 擴充，簡單說就是基於原本的 &lt;code>rails new&lt;/code> 做了一個替代品，而這個替代品會自動幫你先做好一些原本要手動做的事情。&lt;/p>
&lt;p>像是安裝好常用的 Gem、套版之類的，想了一下覺得&lt;a href="https://5xruby.tw">五倍&lt;/a>其實也很需要，不少新專案也都是從我這邊經手初始化的，有一個這樣的工具會省下不少時間。&lt;/p>
&lt;p>所以 &lt;a href="https://github.com/5xRuby/bankai">Bankai&lt;/a> （卍解） 這個 Gem 就樣做出來了，裡面基本上就是設置好在五倍大多數時候用的標配 Ex. GitLab CI 設定、RSpec 等等&lt;/p>
&lt;p>但是又發現好像不太夠用，有些時候有 Docker 會方便很多，但是 Bankai 現在做不到！&lt;/p></description></item><item><title>我在 Ruby 埋了一個陷阱 - Signal 的應用</title><link>https://blog.frost.tw/posts/2019/03/12/I-make-a-trap-in-the-Ruby-the-usage-of-Signal/</link><pubDate>Tue, 12 Mar 2019 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2019/03/12/I-make-a-trap-in-the-Ruby-the-usage-of-Signal/</guid><description>&lt;p>在 Ruby 之中，其實隱藏了很多非常實用的標準函式庫，而 Signal 就是其中一個。&lt;/p>
&lt;p>我們在寫 Ruby 大多數時候都是 Ruby on Rails 框架的應用，但是你們有想過當我們在一些 Gem 運行的時候，使用 Ctrl + C 為什麼不會出現錯誤嗎？&lt;/p>
&lt;p>例如我們常常用到的 &lt;code>irb&lt;/code> 和 &lt;code>pry&lt;/code> 為什麼按下 Ctrl + C 的時候不是直接中斷，卻還能繼續運作？&lt;/p></description></item><item><title>Rails 串接 ProxmoxVE API 自動化教學用虛擬機分配</title><link>https://blog.frost.tw/posts/2019/02/19/Automatic-VM-allocate-using-Proxmox-VE-and-Rails/</link><pubDate>Tue, 19 Feb 2019 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2019/02/19/Automatic-VM-allocate-using-Proxmox-VE-and-Rails/</guid><description>&lt;p>之前有一段時間因為用 KVM 手動管理&lt;a href="https://5xruby.tw">五倍&lt;/a>的虛擬機花上不少時間，評估之後我們就調整成 ProxmoxVE 來管理，至少在大多數的情況有 GUI 是很方便的。&lt;/p>
&lt;p>不過使用的權限還是限制在有權限管理機器的人身上，最近剛好有不少新同事加入，想讓他們練習部署伺服器。&lt;/p>
&lt;p>所以就有了這樣的問題：&lt;/p>
&lt;p>&lt;strong>可以讓同事自己申請虛擬機來練習嗎？&lt;/strong>&lt;/p></description></item><item><title>探索 Ruby 的 each 方法（一）</title><link>https://blog.frost.tw/posts/2019/02/13/Deep-into-ruby-s-each-method-Part-1/</link><pubDate>Wed, 13 Feb 2019 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2019/02/13/Deep-into-ruby-s-each-method-Part-1/</guid><description>&lt;p>原本是想討論 Enumerable 這個 Module 的機制跟運作原理，不過越寫越發現光是一篇文章很難講明白。&lt;/p>
&lt;p>所以就一邊查資料跟 Ruby 原始碼，慢慢的把 Enumerable / Enumerator 這兩個讓 &lt;code>#each&lt;/code> 運作起來的機制討論清楚。&lt;/p>
&lt;p>在 Ruby 裡面我們已經很熟悉使用 &lt;code>#each&lt;/code> 來對陣列相關的物件進行操作，不過在大部分的語言我們都需要透過迴圈的方式來取出陣列的元素，那麼 &lt;code>#each&lt;/code> 這個方法到底是怎麼讓我們用這麼方便的機制來操作陣列的呢？&lt;/p></description></item><item><title>你看懂五倍紅寶石粉專上的 Ruby 版台灣共識了嗎？</title><link>https://blog.frost.tw/posts/2019/01/14/Do-you-understand-the-Ruby-version-Taiwan-Consensus-on-5xruby-s-fanpage/</link><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2019/01/14/Do-you-understand-the-Ruby-version-Taiwan-Consensus-on-5xruby-s-fanpage/</guid><description>&lt;p>最近「台灣共識」很熱門，公司的粉專也分享了 Ruby 版的台灣共識。&lt;/p>
&lt;p>我們在公司內部的群組大家其實討論了蠻久，如果只是單純的去實作跟其他語言一樣的內容，不就沒有意義了嗎？&lt;/p>
&lt;p>我們之所以會選擇用 Ruby 來當作工作上的工具，就表示他有一些特別的地方吸引我們。&lt;/p>
&lt;p>所以，上面用了哪些 Ruby 技巧讓我們一起來分析看看！&lt;/p></description></item><item><title>用 Ruby 來尋找區網中的 Airplay、Chromecast</title><link>https://blog.frost.tw/posts/2018/12/25/Use-Ruby-to-find-the-Airplay-or-Chromecast-device/</link><pubDate>Tue, 25 Dec 2018 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2018/12/25/Use-Ruby-to-find-the-Airplay-or-Chromecast-device/</guid><description>&lt;p>從雲端開始熱門起來後，為了能能讓提供不同服務的伺服器能夠被自動的偵測，我們在許多雲端相關的工具都會看到 Service Discovery 這個名詞。&lt;/p>
&lt;p>不過，除了雲端上的服務能夠透過這樣的機制互相「發現」對方，我們也可以在區網中用類似的方法找到「提供服務」的裝置。&lt;/p>
&lt;p>這就要從 mDNS (Multicast DNS) 和 DNS-SD (DNS-based Service Discovery) 開始談起。&lt;/p></description></item><item><title>轉職工程師：尋找自己的價值</title><link>https://blog.frost.tw/posts/2018/11/06/Become-a-programmer-Find-your-own-value/</link><pubDate>Tue, 06 Nov 2018 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2018/11/06/Become-a-programmer-Find-your-own-value/</guid><description>&lt;p>這系列的文章已經稍微討論過我自己在學習寫程式過程中的&lt;a href="https://blog.frost.tw/posts/2018/09/25/Become-a-programmer-lose-at-the-starting-line/">心態&lt;/a>、&lt;a href="https://blog.frost.tw/posts/2018/10/02/Become-a-programmer-how-to-start/">方法&lt;/a>跟&lt;a href="https://blog.frost.tw/posts/2018/10/23/Become-a-programmer-Why-is-bottleneck-coming-very-soon/">困難&lt;/a>，最後就來討論最後一個我認為很重要的問題。&lt;/p>
&lt;p>不論學了什麼，或者有多麽厲害的技術，作為一個工程師我們的價值在哪裡？&lt;/p></description></item><item><title>轉職工程師：為什麼馬上就遇到瓶頸？</title><link>https://blog.frost.tw/posts/2018/10/23/Become-a-programmer-Why-is-bottleneck-coming-very-soon/</link><pubDate>Tue, 23 Oct 2018 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2018/10/23/Become-a-programmer-Why-is-bottleneck-coming-very-soon/</guid><description>&lt;p>前面已經討論了&lt;a href="https://blog.frost.tw/posts/2018/09/25/Become-a-programmer-lose-at-the-starting-line/">起步的心態&lt;/a>跟&lt;a href="https://blog.frost.tw/posts/2018/10/02/Become-a-programmer-how-to-start/">起步的方法&lt;/a>兩個問題，好不容易開始寫程式了，卻發現⋯⋯&lt;/p>
&lt;p>&lt;strong>照著教學做，但是沒有教學就完全不會&lt;/strong>&lt;/p>
&lt;p>不管是去上更多的課，還是看更多的教學，怎麼樣都無法擺脫這個問題。這到底是什麼原因呢？&lt;/p></description></item><item><title>客製化你樹莓派上運行的 Linux</title><link>https://blog.frost.tw/posts/2018/10/09/Customize-a-linux-for-your-raspberrypi/</link><pubDate>Tue, 09 Oct 2018 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2018/10/09/Customize-a-linux-for-your-raspberrypi/</guid><description>&lt;p>最近因為手邊有一個工作以外的專案需要搭配硬體做一些 IoT 類型的應用，雖然之前在五倍紅寶石開發的 Tamashii 系列應用已經足以應對在這個專案上開發所需的解決方案，但是依舊缺少了一些功能。&lt;/p>
&lt;p>也就是我們過去並沒有考慮到的，如果裝置是交給一般使用者的狀況下，如何在透過網路的前提將裝置更新。&lt;/p>
&lt;p>這是很多硬體都會有的功能，但是就目前而言 Tamashii 並不支援。&lt;/p></description></item><item><title>轉職工程師：要學什麼才好？</title><link>https://blog.frost.tw/posts/2018/10/02/Become-a-programmer-how-to-start/</link><pubDate>Tue, 02 Oct 2018 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2018/10/02/Become-a-programmer-how-to-start/</guid><description>&lt;p>上一篇文章&lt;a href="https://blog.frost.tw/posts/2018/09/25/Become-a-programmer-lose-at-the-starting-line/">輸在起跑點&lt;/a>已經稍微討論過心態上的問題，所以馬上就是要怎麼開始的問題。&lt;/p>
&lt;p>大部分的人不論之前有沒有經驗，一定會冒出「要學什麼語言？」「某某語言很熱門是不是應該去學？」之類的問題。&lt;/p>
&lt;p>很多時候，我認為這不是真正的問題。&lt;/p></description></item><item><title>轉職工程師：輸在起跑點</title><link>https://blog.frost.tw/posts/2018/09/25/Become-a-programmer-lose-at-the-starting-line/</link><pubDate>Tue, 25 Sep 2018 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2018/09/25/Become-a-programmer-lose-at-the-starting-line/</guid><description>&lt;p>工作到現在差不多兩年多，因為公司業務的關係偶爾也會跟同事討論在學習當工程師或者寫程式上的經驗。所以打算寫一個系列的文章，跟大家分享一下我從學程式到成為一個工程師的過程，是怎麼樣的。&lt;/p>
&lt;p>這是第一篇，我想用「輸在起跑點」來當開始。&lt;/p></description></item><item><title>怎麼選第一份工作？</title><link>https://blog.frost.tw/posts/2018/09/10/How-to-choose-your-first-job/</link><pubDate>Mon, 10 Sep 2018 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2018/09/10/How-to-choose-your-first-job/</guid><description>&lt;p>從退伍到工作差不多過了兩年，這段時間有不少經驗我想已經足夠跟大家分享。這篇算是一個前導的文章，想來跟大家分享「第一份工作」的重要性。&lt;/p>
&lt;blockquote>
&lt;p>重點是技能成長那段，討論薪水的地方太長可以跳過喔 XD&lt;/p>
&lt;/blockquote></description></item><item><title>淺談 Ruby 的 Fiber（九）</title><link>https://blog.frost.tw/posts/2018/09/05/Talk-about-ruby-s-fiber-Part-9/</link><pubDate>Wed, 05 Sep 2018 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2018/09/05/Talk-about-ruby-s-fiber-Part-9/</guid><description>&lt;p>這篇文章我們會把 Broadcast （廣播）功能實作出來，如此一來我們就擁有了可以將訊息透過 Fiber 實作的伺服器廣播給其他使用者的功能。&lt;/p>
&lt;p>而這系列文章也就到此告一段落。&lt;/p></description></item><item><title>使用 Fiber 能給 Ruby 帶來好處嗎？</title><link>https://blog.frost.tw/posts/2018/08/21/Does-the-Fiber-have-any-benefit-for-Ruby/</link><pubDate>Tue, 21 Aug 2018 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2018/08/21/Does-the-Fiber-have-any-benefit-for-Ruby/</guid><description>&lt;p>關於 Fiber 的&lt;a href="https://blog.frost.tw/posts/2018/06/26/Talk-about-ruby-s-fiber-Part-1/">系列文&lt;/a>寫到現在也已經一個半月了，除了分享自己在使用 Fiber 的經驗之外，我也更加的熟悉 Fiber 的使用。&lt;/p>
&lt;p>不過，這真的是有益於現有的專案嗎？&lt;/p></description></item><item><title>淺談 Ruby 的 Fiber（八）</title><link>https://blog.frost.tw/posts/2018/08/14/Talk-about-ruby-s-fiber-Part-8/</link><pubDate>Tue, 14 Aug 2018 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2018/08/14/Talk-about-ruby-s-fiber-Part-8/</guid><description>&lt;p>到這篇為止，我們已經完成了將 Fiber 應用在程式中的基本雛型，現在只需要將上週未完成的錯誤處理，我們就能獲得一個可以正常發送訊息到伺服器的伺服器。&lt;/p></description></item><item><title>淺談 Ruby 的 Fiber（七）</title><link>https://blog.frost.tw/posts/2018/08/07/Talk-about-ruby-s-fiber-Part-7/</link><pubDate>Tue, 07 Aug 2018 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2018/08/07/Talk-about-ruby-s-fiber-Part-7/</guid><description>&lt;p>上週我們開始重構 Fiber 的結構，透過一個統一的 &lt;code>Selector&lt;/code> 物件來選取這個「當下」可以進行 I/O 操作的物件。&lt;/p>
&lt;p>不過，我們原本預期是因為使用 &lt;code>rescue&lt;/code> 來捕捉錯誤控制流程才讓他運行不正常，經過一週的思考後，卻發現事情跟預想的不太一樣。&lt;/p></description></item><item><title>淺談 Ruby 的 Fiber（六）</title><link>https://blog.frost.tw/posts/2018/07/29/Talk-about-ruby-s-fiber-Part-6/</link><pubDate>Sun, 29 Jul 2018 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2018/07/29/Talk-about-ruby-s-fiber-Part-6/</guid><description>&lt;p>經過前面幾篇文章的介紹，我們已經初步的了解 Fiber 的性質。這系列的文章目標是利用 Fiber 實現再不透過 Thread 或者 Process 的情境，來實現支援多人連線的 TCP 聊天伺服器。&lt;/p>
&lt;p>從這一篇開始，我們就要正式的來挑戰完整的實作了！&lt;/p></description></item><item><title>淺談 Ruby 的 Fiber（五）</title><link>https://blog.frost.tw/posts/2018/07/24/Talk-about-ruby-s-fiber-Part-5/</link><pubDate>Tue, 24 Jul 2018 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2018/07/24/Talk-about-ruby-s-fiber-Part-5/</guid><description>&lt;p>經過&lt;a href="https://blog.frost.tw/posts/2018/07/17/Talk-about-ruby-s-fiber-Part-4/">上次&lt;/a>的嘗試，我們已經開始對於 Fiber 的性質有一些了解，目前還需要解決已經結束的 Fiber 被呼叫，以及來不及處理的問題。&lt;/p></description></item><item><title>淺談 Ruby 的 Fiber（四）</title><link>https://blog.frost.tw/posts/2018/07/17/Talk-about-ruby-s-fiber-Part-4/</link><pubDate>Tue, 17 Jul 2018 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2018/07/17/Talk-about-ruby-s-fiber-Part-4/</guid><description>&lt;p>在上週的&lt;a href="https://blog.frost.tw/posts/2018/07/10/Talk-about-ruby-s-fiber-Part-3/">文章&lt;/a>我們注意到 Fiber 的使用並不是那麼容易的，因為我們需要自行管理每一個 Fiber 被恢復（&lt;code>#resume&lt;/code>）的時機，這週就繼續來挑戰吧！&lt;/p></description></item><item><title>淺談 Ruby 的 Fiber（三）</title><link>https://blog.frost.tw/posts/2018/07/10/Talk-about-ruby-s-fiber-Part-3/</link><pubDate>Tue, 10 Jul 2018 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2018/07/10/Talk-about-ruby-s-fiber-Part-3/</guid><description>&lt;p>延續&lt;a href="https://blog.frost.tw/posts/2018/07/03/Talk-about-ruby-s-fiber-Part-2/">上一篇&lt;/a>文章的實作，我們已經有一個簡易的 Thread 版本 TCP Socket 伺服器可以運作，那麼該怎麼用 Fiber 修改呢？&lt;/p></description></item><item><title>淺談 Ruby 的 Fiber（二）</title><link>https://blog.frost.tw/posts/2018/07/03/Talk-about-ruby-s-fiber-Part-2/</link><pubDate>Tue, 03 Jul 2018 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2018/07/03/Talk-about-ruby-s-fiber-Part-2/</guid><description>&lt;p>&lt;a href="https://blog.frost.tw/posts/2018/06/26/Talk-about-ruby-s-fiber-Part-1/">第一篇&lt;/a>我們已經大致上了解 Fiber 的運作原理，不過要能夠實際上的掌握跟應用，我認為是需要靠實作來熟悉的。&lt;/p>
&lt;p>所以，這一篇我們先來講學習 Socket 最常見的 TCP 伺服器實作吧！&lt;/p></description></item><item><title>淺談 Ruby 的 Fiber（ㄧ）</title><link>https://blog.frost.tw/posts/2018/06/26/Talk-about-ruby-s-fiber-Part-1/</link><pubDate>Tue, 26 Jun 2018 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2018/06/26/Talk-about-ruby-s-fiber-Part-1/</guid><description>&lt;p>前陣子再研究 Ruby 從 1.9.3 就開始提供的 Fiber 該怎麼使用，不過網路上的資料大多都只是簡單的討論。那麼 Fiber 到底是什麼呢？這系列的文章會詳細的介紹 Fiber 的基本概念，還有一些可以應用的方式。&lt;/p></description></item><item><title>RubyKaigi 2018 會後心得</title><link>https://blog.frost.tw/posts/2018/06/12/The-RubyKaigi-2018-Experience/</link><pubDate>Tue, 12 Jun 2018 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2018/06/12/The-RubyKaigi-2018-Experience/</guid><description>&lt;p>今年的 RubyKaigi 比去年提早不少，作為 Ruby 開發者最大的盛會，今年也不意外的延續去年探討 Ruby 3 的可能性跟更多 Ruby 的深度應用。也因次，不意外的讓大家都聽的似懂非懂，而且還讓我感覺一年比一年的難度更高。&lt;/p>
&lt;p>總之，來看看今年的 RubyKaigi 吧！&lt;/p></description></item><item><title>RubyElixirConfTW 2018 會後感想</title><link>https://blog.frost.tw/posts/2018/05/01/The-RubyElixirConfTW-2018-Experience/</link><pubDate>Tue, 01 May 2018 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2018/05/01/The-RubyElixirConfTW-2018-Experience/</guid><description>&lt;p>Ruby Conference Taiwan 到今年已經是第七年了，印象中我大概是從 2013 年左右開始參加了，應該也有四五次。今年也加入了 Elixir 一起合辦，因為是&lt;a href="https://5xruby.tw">五倍紅寶石&lt;/a>的員工，所以也當了兩年的工作人員。&lt;/p>
&lt;p>那麼，就看看今年有什麼新鮮的事情吧！&lt;/p></description></item><item><title>自由的 Ruby 類別（二）</title><link>https://blog.frost.tw/posts/2018/03/23/The-ruby-s-object-is-free-Part-2/</link><pubDate>Fri, 23 Mar 2018 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2018/03/23/The-ruby-s-object-is-free-Part-2/</guid><description>&lt;p>&lt;a href="https://blog.frost.tw/posts/2017/10/22/The-ruby-s-class-is-free-Part-1/">上一篇文章&lt;/a>已經討論過關於 Ruby 中的類別是怎樣運作的，這篇文章則會來討論如何拓展 Ruby 類別。&lt;/p>
&lt;p>大部分的人寫 Ruby 有很大的原因是因為 Rails 但是上面像是 &lt;code>has_many&lt;/code> 跟 &lt;code>before_action&lt;/code> 這些可以直接在類別上做的事情，很明顯不是 Ruby 內建的，到底是怎麼運作的呢？&lt;/p></description></item><item><title>Ruby 中該如何 Raise 一個錯誤</title><link>https://blog.frost.tw/posts/2018/01/09/How-ruby-raise-an-error/</link><pubDate>Tue, 09 Jan 2018 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2018/01/09/How-ruby-raise-an-error/</guid><description>&lt;p>前幾天的晚上朋友在 Facebook 上問了一個問題。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="k">raise&lt;/span> &lt;span class="no">HTTPError&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;Not Found&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>和&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="k">raise&lt;/span> &lt;span class="no">HTTPError&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">new&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;Not Found&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>哪個比較快？也因為這樣，我們意外的發現 Ruby 對上面兩段程式碼的定義上其實是不太一樣的。&lt;/p></description></item><item><title>Stripe 的 Idempotency Key 設計機制</title><link>https://blog.frost.tw/posts/2017/10/30/The-design-of-Stripe-s-Idempotency-Keys/</link><pubDate>Mon, 30 Oct 2017 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2017/10/30/The-design-of-Stripe-s-Idempotency-Keys/</guid><description>&lt;p>週末看到一篇 Stripe 工程師所寫的文章，是一篇關於 Idempotency Key （幂等鍵）的設計機制。因為是一篇非常棒的文章，而且裡面的概念除了可以應用在 API 設計之外，很多程式設計上需要解決的問題都可以透過這個概念來處理。&lt;/p>
&lt;p>原文非常的長而且很詳細，這篇文章只會做簡單的重點整理。&lt;/p>
&lt;p>有興趣的話可以打開&lt;a href="https://brandur.org/idempotency-keys">原文&lt;/a>來讀，是一篇很有用的文章。&lt;/p>
&lt;blockquote>
&lt;p>作者是很厲害的工程師，部落格上的文章都是非常精實的技術文。&lt;/p>
&lt;/blockquote></description></item><item><title>自由的 Ruby 類別（一）</title><link>https://blog.frost.tw/posts/2017/10/22/The-ruby-s-class-is-free-Part-1/</link><pubDate>Sun, 22 Oct 2017 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2017/10/22/The-ruby-s-class-is-free-Part-1/</guid><description>&lt;p>以前還在讀書的時候，常常會思考所謂的「自由」是什麼，想著以後一定要過著自由的生活。不過現實就是到了社會，依舊還是有許多限制讓你無法自由自在。&lt;/p>
&lt;p>不過，在 Ruby 中的類別卻是非常自由的。&lt;/p>
&lt;p>有稍微接觸過 Ruby 的人應該都知道幾個特性：&lt;/p>
&lt;ul>
&lt;li>物件導向語言&lt;/li>
&lt;li>一切都是物件&lt;/li>
&lt;/ul></description></item><item><title>在 RubyKaigi 2017 年後的反思</title><link>https://blog.frost.tw/posts/2017/10/09/The-RubyKaigi-2017-let-me-reflection/</link><pubDate>Mon, 09 Oct 2017 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2017/10/09/The-RubyKaigi-2017-let-me-reflection/</guid><description>&lt;p>在這幾個月，感覺到自己好像快要突破這一階段的瓶頸，所以做了一些調整試試看能不能順利的突破，同時也到了每年公司參與 RubyKaigi 的時期。&lt;/p>
&lt;p>要說的話，今年的 RubyKaigi 整體的方向對我來說很不一樣，因為有不少關於 RubyKaigi 底層的議程被提出來，這在台灣舉辦研討會需要照顧到不同客群的人總會需要有一些取捨。&lt;/p>
&lt;p>不過，對日本——Ruby 的發源地來說，因為有不同類型的研討會互補，反而可以在不同的研討會上，著重不同的情境來討論。&lt;/p></description></item><item><title>在 RubyKaigi 2016 後的新視野</title><link>https://blog.frost.tw/posts/2016/09/17/the-new-vision-after-rubykaigi2016/</link><pubDate>Sat, 17 Sep 2016 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2016/09/17/the-new-vision-after-rubykaigi2016/</guid><description>&lt;p>八月份退伍後，馬上就加入了&lt;a href="https://5xruby.tw">五倍紅寶石&lt;/a>。而隨之而來的，剛好是在九月份為期九天的員工旅遊，一個非常充實的員工旅遊。&lt;/p>
&lt;p>實際上，我們只有三天左右在日本遊玩。原本的行程會穿插著與日本 Ruby 社群的交流，以及三天的 RubyKaigi 行程。&lt;/p>
&lt;p>這次的旅遊算是增長了不少見識，讓我想到高中快畢業時第一次知道了 COSCUP 之後瘋狂地參加各種語言的研討會，幾乎一年每個月都在跑研討會。印象沒錯的話，大概是 2013 年才參與到 RubyConf 也因為參加了 RubyConf 的活動，退伍前後蠻多工作機會都是來自 Ruby 圈的，算是整個程式經歷中給我幫助最多的社群了吧。&lt;/p></description></item><item><title>mRuby on Web</title><link>https://blog.frost.tw/posts/2015/04/10/mruby-on-web/</link><pubDate>Fri, 10 Apr 2015 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2015/04/10/mruby-on-web/</guid><description>&lt;p>忙裡偷閒玩了一下 Emscripten 將 mRuby 拉到 Web 上面運行。&lt;/p>
&lt;p>最初是看到 &lt;a href="https://Github.com/xxuejie/webruby">WebRuby&lt;/a> 這個專案的應用 &lt;a href="https://joshnuss.github.io/mruby-web-irb/">Webirb&lt;/a> 才決定要挑戰將 mruby 丟到 Web 上面跑。&lt;/p>
&lt;blockquote>
&lt;p>其實這個過程中 WebRuby 給我很多參考方向，才讓我得以順利完成 mruby on Web 的挑戰。&lt;/p>
&lt;/blockquote></description></item><item><title>MRuby in C# - 因 RPG Maker 的慘劇（二）</title><link>https://blog.frost.tw/posts/2014/09/28/mruby-in-csharp-the-tragedy-of-rpg-maker-2/</link><pubDate>Sun, 28 Sep 2014 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2014/09/28/mruby-in-csharp-the-tragedy-of-rpg-maker-2/</guid><description>&lt;p>前一篇文章討論了關於 C# 執行一段 Ruby 程式碼並且取得執行結果（字串）的做法。
不過，光是這樣在 C# 使用 MRuby 的意義並不大，我們需要結合 Ruby 的 DSL 特性，讓自製的 RPG Maker 可以更加簡單的被用於製作遊戲（最終目的）&lt;/p>
&lt;p>也因此，我們需要能夠讓 C# 中的一些 API 可以在 Ruby 中被呼叫以及使用。
那麼，能夠從 C# 定義 Ruby 的 Module / Class 和 Method 就非常的重要，因為如果無法這樣做，那麼就無法讓 Ruby 執行 C# 的程式碼。&lt;/p></description></item><item><title>MRuby in C# - 因 RPG Maker 的慘劇（一）</title><link>https://blog.frost.tw/posts/2014/09/04/mruby-in-csharp-the-tragedy-of-rpg-maker-1/</link><pubDate>Thu, 04 Sep 2014 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2014/09/04/mruby-in-csharp-the-tragedy-of-rpg-maker-1/</guid><description>&lt;p>最近看到朋友提起 RPG Maker 又勾起我在 Mac 上使用 RPG Maker 的野心，雖然之前用 Wine 順利跑了起來，不過既然能寫 Ruby 當然要用各種奇怪的方式去玩弄。&lt;/p>
&lt;p>結果，當我發現內建的 Library 要做到我想做的事情很困難的時候，腦抽的我決定自己做一個！&lt;/p>
&lt;p>不過，這年頭不跨平台其實還蠻空虛的，所以就從能夠跨平台來做選擇，至於為何會選 Mono 和 C# 大概就是受到 Unity3D 跟 Unreal Engine 4 兩個目前都是非常有名的遊戲引擎影響吧！
（上述兩個引擎都有使用 Mono 來協助實踐跨平台的功能）&lt;/p></description></item><item><title>Rails Girls 4 活動感想</title><link>https://blog.frost.tw/posts/2014/08/31/rails-girls-4-event-impressions/</link><pubDate>Sun, 31 Aug 2014 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2014/08/31/rails-girls-4-event-impressions/</guid><description>&lt;p>好久沒寫部落格了，一些技術類的文章都沒時間寫，草稿也越積越多⋯⋯
不過參加活動的不馬上寫完，很快就會忘記在做什麼事情啊 XDD&lt;/p>
&lt;p>這次 RG4 超幸運被選為教練，然後我又長知識了～&lt;/p>
&lt;p>雖然自己是讀設計學院，但是不管怎樣都不會有同學會朋友這麼認真的學這方面的知識。
其實某種意義上還蠻孤單的，不過對其他人來說畢竟不是必要的，所以也不能抱怨啊 XD&lt;/p>
&lt;p>那麼，就來說說 8/29 跟 8/30 這兩天做了什麼吧！&lt;/p></description></item><item><title>RubyConf TW 2014 會後心得</title><link>https://blog.frost.tw/posts/2014/04/26/rubyconf-tw-after-2014-will-experience/</link><pubDate>Sat, 26 Apr 2014 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2014/04/26/rubyconf-tw-after-2014-will-experience/</guid><description>&lt;p>接觸 Rails 快三年，今年終於有機會參加 RubyConf 了！
除了 PHP 之外，其實 Ruby 對我來說也算是一個有特別感情的語言，主要是國中時期的 RPG Maker 跟剛開始學習 PHP 的時候還分不出語言，也買了幾本 Ruby 跟 Rails 的書。&lt;/p>
&lt;p>今年的 RubyConf 似乎蠻多新的工作人員，所以第一天有點不順。
（不過對我來說是可以接受的範圍，議程品質非常高，不過我想這也會是許多 Conference 未來會碰到的問題。）&lt;/p>
&lt;p>然後不知道是不是錯覺，我整個覺得 RubyConf 給我一種蠻優雅的感覺 XD
（其他 Conference 各有特色，但是第一次有這種感覺真的蠻有趣的 XD）&lt;/p></description></item><item><title>Capistrano to Vagrant 自動部署心得</title><link>https://blog.frost.tw/posts/2014/03/24/capistrano-to-vagrant-automated-deployment-experience/</link><pubDate>Mon, 24 Mar 2014 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2014/03/24/capistrano-to-vagrant-automated-deployment-experience/</guid><description>&lt;p>之前寫過一篇關於 &lt;a href="https://blog.frost.tw/posts/2013/11/03/vagrant-integrated-gitlab-with-capistrano-create-staging-environment-automatically-deployed/">Vagrant + Capistrano + GitLab&lt;/a> 的自動化部署介紹。&lt;/p>
&lt;p>不過當時因為一些問題，卡著沒有繼續完成測試。
最近因為某些原因，需要一個 Nightly-like (不一定會每日更新，取決于 commit) 的環境，所以只好硬著頭皮把全部的問題解決了⋯⋯&lt;/p></description></item><item><title>用 Vagrant 整合 GitLab 與 Capistrano 做 Staging 環境自動部署</title><link>https://blog.frost.tw/posts/2013/11/03/vagrant-integrated-gitlab-with-capistrano-create-staging-environment-automatically-deployed/</link><pubDate>Sun, 03 Nov 2013 00:00:00 +0000</pubDate><guid>https://blog.frost.tw/posts/2013/11/03/vagrant-integrated-gitlab-with-capistrano-create-staging-environment-automatically-deployed/</guid><description>&lt;p>&lt;!-- raw HTML omitted -->這標題超級長的說（崩潰&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>最近因為有實習生要來，所以把老爸公司設定好 GitLab 和 Gitlba-CI 來作為內部的版本本控制和自動化測試環境。
不過原本規劃的 Staging 環境也是在這檯主機上（當初就很淡定把記憶體和處理器加高，因為我會狂開 VM XD）但是會有 SSH 權限上的問題，原本想利用 Git 的 Hook 之類的來處理，但是感覺似乎不太好。&lt;/p>
&lt;p>剛好這次看到 GitLab / GitLab-CI 的介紹文，我又再次嘗試安裝，過程上順利、簡單很多。
不過上次不順利肯定是我把整個環境裝在 NAS 裡面的關係 XDD&lt;/p>
&lt;p>從我建好 GitLab / GitLab-CI 到設定 Capistrano 到自動部署，其實花費不少時間，而且有很多「差點忘記」的部分，因此決定來寫一篇文章做筆記！&lt;/p></description></item></channel></rss>