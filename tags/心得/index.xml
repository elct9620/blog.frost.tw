<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>心得 on 弦而時習之</title><link>https://blog.frost.tw/tags/%E5%BF%83%E5%BE%97/</link><description>Recent content in 心得 on 弦而時習之</description><generator>Hugo -- gohugo.io</generator><language>zh-TW</language><managingEditor>contact@frost.tw (蒼時弦也)</managingEditor><webMaster>contact@frost.tw (蒼時弦也)</webMaster><lastBuildDate>Sat, 29 Feb 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.frost.tw/tags/%E5%BF%83%E5%BE%97/index.xml" rel="self" type="application/rss+xml"/><item><title>重複利用的 Ansible Role 難題</title><link>https://blog.frost.tw/posts/2020/02/29/The-Reusable-Ansible-Role-Problem/</link><pubDate>Sat, 29 Feb 2020 00:00:00 +0000</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2020/02/29/The-Reusable-Ansible-Role-Problem/</guid><description>&lt;p>大概一年前左右，我開始製作一個 &lt;a href="https://www.ansible.com/">Ansible&lt;/a> 的 Playbook 來幫&lt;a href="https://5xruby.tw">五倍紅寶石&lt;/a>的客戶安裝環境。&lt;/p>
&lt;p>不過當我們的客戶增加之後，其實開始有點變的很難透過 Fork 的機制來管理不同客戶的 Playbook。&lt;/p>
&lt;p>這表示我必須先更新主要的 Playbook 然後再同步到每一個客戶的版本上，也因此我決定去把這些通用的部分拆成單獨的 Role 專案。&lt;/p></description></item><item><title>TGONext: 規劃高併發服務</title><link>https://blog.frost.tw/posts/2020/02/23/TGONext-The-plan-for-high-concurrency/</link><pubDate>Sun, 23 Feb 2020 00:00:00 +0000</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2020/02/23/TGONext-The-plan-for-high-concurrency/</guid><description>&lt;p>昨天是 &lt;a href="https://next.tgonetworks.org/">TGONext&lt;/a> 的第一次聚會，在這個活動中我們會向台灣的一些高階主管學習。在開場結束後我們的導師 &lt;a href="https://blog.gcos.me/">Ant&lt;/a> 讓我們投票選出幾個想在這半年的時間內討論的題目。基本上我們預定討論四個主題，而「高併發」是我們的第一個主題。&lt;/p></description></item><item><title>撰寫一個合適的 RSpec 測試</title><link>https://blog.frost.tw/posts/2020/02/20/Write-a-suitable-RSpec-test/</link><pubDate>Thu, 20 Feb 2020 00:00:00 +0000</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2020/02/20/Write-a-suitable-RSpec-test/</guid><description>&lt;p>包括我自己在內，寫測試有時候是一個非常不想面對的工作。也有很多剛入門的工程師覺得很難去分辨該怎麼去寫測試，在今天跟同事說明完一些技巧後就決定來寫一下這篇分享一下我自己的經驗。&lt;/p></description></item><item><title>Ruby World Conference 2019 見聞</title><link>https://blog.frost.tw/posts/2019/11/18/Ruby-World-Conference-2019-Experience/</link><pubDate>Mon, 18 Nov 2019 00:00:00 +0000</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2019/11/18/Ruby-World-Conference-2019-Experience/</guid><description>&lt;p>今年把在六月到八月做的一個小專案拿去投稿 &lt;a href="https://2019.rubyworld-conf.org/en/">Ruby World Conference&lt;/a> 意外的獲得了 15 分鐘的時間，於是又展開了一次日本出差之旅，剛好彌補一下今年因為客戶專案需要趕上線而無法參加 &lt;a href="https://rubykaigi.org/">RubyKaigi&lt;/a> 的遺憾。&lt;/p>
&lt;p>跟 RubyKaigi 不太一樣的地方是 Ruby World Conference 雖然叫做「World Conference」但是除了台上的講者之外，幾乎都是日本人（而且是稍微有年紀的大叔）去參加的。&lt;/p></description></item><item><title>RubyConf Taiwan 2019 會後感想、議程概覽</title><link>https://blog.frost.tw/posts/2019/07/29/My-experience-after-RubyConf-Taiwan-2019/</link><pubDate>Mon, 29 Jul 2019 00:00:00 +0000</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2019/07/29/My-experience-after-RubyConf-Taiwan-2019/</guid><description>&lt;p>跟前幾年一樣基本上就是工作人員，這幾年參加研討會也都比較沒有在仔細聽了，所以大多是邊顧邊寫點程式。&lt;/p>
&lt;p>比較不一樣的大概是今年更累了，從週四下午場佈到 Pre Party 然後兩天的活動、Official Party 最後到今年嘗試的 After Hack 幾乎是四天左右的連續接力，每天早上醒來都要先懷疑自己是否能撐過這一天。&lt;/p></description></item><item><title>關於 Rails 中的 Form Object / Presenter 這些物件該怎麼用（一）</title><link>https://blog.frost.tw/posts/2019/05/28/How-to-use-Form-Object-and-others-for-Rails/</link><pubDate>Tue, 28 May 2019 00:00:00 +0000</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2019/05/28/How-to-use-Form-Object-and-others-for-Rails/</guid><description>&lt;p>前陣子在 Review 新專案中同事的程式碼時，發現同事對像是 Service Object / Form Object 這類物件不太有概念。不過這個新專案因為是接手其他公司的專案，所以有不少地方要微調。至少那個值得吐槽的「因為 Controller 程式碼太長不知道放哪裡，就都丟去 Service Object 好了！」的神奇用法，完全沒有幫助改善程式碼。&lt;/p>
&lt;p>也因為這個機會，我用了一點時間跟專案的同事分享了一下我對這些物件的看法。畢竟當出我也是搞不太懂，不過隨著了解物件導向和 Ruby 的語言特性，從這些角度切入後，就比較能理解該怎麼使用。&lt;/p></description></item><item><title>利用 Ruby 的 Lambda 做條件判斷</title><link>https://blog.frost.tw/posts/2019/05/20/Use-Ruby-s-Lambda-as-case-when-condition/</link><pubDate>Mon, 20 May 2019 00:00:00 +0000</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2019/05/20/Use-Ruby-s-Lambda-as-case-when-condition/</guid><description>&lt;p>週末在思考一些 Ruby 特性可以應用的小技巧時，想到龍哥大概跟我講了三次以上的一個特性。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="n">fn&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">other&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">other&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="n">fn&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;span class="c1"># =&amp;gt; false&lt;/span>
&lt;span class="n">fn&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;span class="c1"># =&amp;gt; true&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>剛好最近工作的專案上有個問題，似乎挺適合用這個技巧。&lt;/p></description></item><item><title>我在 Ruby 埋了一個陷阱 - Signal 的應用</title><link>https://blog.frost.tw/posts/2019/03/12/I-make-a-trap-in-the-Ruby-the-usage-of-Signal/</link><pubDate>Tue, 12 Mar 2019 00:00:00 +0000</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2019/03/12/I-make-a-trap-in-the-Ruby-the-usage-of-Signal/</guid><description>&lt;p>在 Ruby 之中，其實隱藏了很多非常實用的標準函式庫，而 Signal 就是其中一個。&lt;/p>
&lt;p>我們在寫 Ruby 大多數時候都是 Ruby on Rails 框架的應用，但是你們有想過當我們在一些 Gem 運行的時候，使用 Ctrl + C 為什麼不會出現錯誤嗎？&lt;/p>
&lt;p>例如我們常常用到的 &lt;code>irb&lt;/code> 和 &lt;code>pry&lt;/code> 為什麼按下 Ctrl + C 的時候不是直接中斷，卻還能繼續運作？&lt;/p></description></item><item><title>探索 Ruby 的 each 方法（一）</title><link>https://blog.frost.tw/posts/2019/02/13/Deep-into-ruby-s-each-method-Part-1/</link><pubDate>Wed, 13 Feb 2019 00:00:00 +0000</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2019/02/13/Deep-into-ruby-s-each-method-Part-1/</guid><description>&lt;p>原本是想討論 Enumerable 這個 Module 的機制跟運作原理，不過越寫越發現光是一篇文章很難講明白。&lt;/p>
&lt;p>所以就一邊查資料跟 Ruby 原始碼，慢慢的把 Enumerable / Enumerator 這兩個讓 &lt;code>#each&lt;/code> 運作起來的機制討論清楚。&lt;/p>
&lt;p>在 Ruby 裡面我們已經很熟悉使用 &lt;code>#each&lt;/code> 來對陣列相關的物件進行操作，不過在大部分的語言我們都需要透過迴圈的方式來取出陣列的元素，那麼 &lt;code>#each&lt;/code> 這個方法到底是怎麼讓我們用這麼方便的機制來操作陣列的呢？&lt;/p></description></item><item><title>用 Ruby 來尋找區網中的 Airplay、Chromecast</title><link>https://blog.frost.tw/posts/2018/12/25/Use-Ruby-to-find-the-Airplay-or-Chromecast-device/</link><pubDate>Tue, 25 Dec 2018 00:00:00 +0000</pubDate><author>contact@frost.tw (蒼時弦也)</author><guid>https://blog.frost.tw/posts/2018/12/25/Use-Ruby-to-find-the-Airplay-or-Chromecast-device/</guid><description>&lt;p>從雲端開始熱門起來後，為了能能讓提供不同服務的伺服器能夠被自動的偵測，我們在許多雲端相關的工具都會看到 Service Discovery 這個名詞。&lt;/p>
&lt;p>不過，除了雲端上的服務能夠透過這樣的機制互相「發現」對方，我們也可以在區網中用類似的方法找到「提供服務」的裝置。&lt;/p>
&lt;p>這就要從 mDNS (Multicast DNS) 和 DNS-SD (DNS-based Service Discovery) 開始談起。&lt;/p></description></item></channel></rss>